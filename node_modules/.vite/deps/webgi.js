import "./chunk-RSJERJUL.js";

// node_modules/webgi/dist/examples/runtime/bundle.m.js
var __webpackgi_modules__ = { 798: function(e, t, r) {
  var n = r(352), i = r.n(n)()(function(e2) {
    return e2[1];
  });
  i.push([e.id, "#assetManagerPopup{z-index:300;position:absolute;bottom:2rem;right:2rem;-webkit-backdrop-filter:blur(16px);backdrop-filter:blur(16px);color:#fff;background-blend-mode:luminosity;background-color:#28223CAA;padding:1.5rem;font-size:1rem;width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:80vw;max-height:80vh;overflow-y:scroll;border-radius:.5rem;height:-webkit-max-content;height:-moz-max-content;height:max-content}#assetManagerPopupClose{position:absolute;top:0;right:0;padding:.5rem;cursor:pointer}#assetManagerPopupContent{padding-top:.5rem}.processState{font-weight:bold}", ""]), t.Z = i;
}, 898: function(e, t, r) {
  var n = r(352), i = r.n(n)()(function(e2) {
    return e2[1];
  });
  i.push([e.id, ':root{--tp-blade-unit-size: 24px;--tp-element-border-radius: 0.25rem;--tp-base-background-color: #28223C;--tp-base-shadow-color: hsla(0, 0%, 0%, 0.2);--tp-button-background-color: hsla(230, 10%, 80%, 1.00);--tp-button-background-color-active: hsla(230, 10%, 95%, 1.00);--tp-button-background-color-focus: hsla(230, 10%, 90%, 1.00);--tp-button-background-color-hover: hsla(230, 10%, 85%, 1.00);--tp-button-foreground-color: hsla(230, 20%, 11%, 1.00);--tp-container-background-color: hsla(230, 25%, 16%, 0.65);--tp-container-background-color-active: hsla(230, 25%, 31%, 0.65);--tp-container-background-color-focus: hsla(230, 25%, 26%, 0.65);--tp-container-background-color-hover: hsla(230, 25%, 21%, 0.65);--tp-container-foreground-color: hsl(240, 10%, 92%);--tp-groove-foreground-color: hsla(230, 20%, 8%, 1.00);--tp-input-background-color: hsla(230, 20%, 8%, 1.00);--tp-input-background-color-active: hsla(230, 28%, 23%, 1.00);--tp-input-background-color-focus: hsla(230, 28%, 18%, 1.00);--tp-input-background-color-hover: hsla(230, 20%, 13%, 1.00);--tp-input-foreground-color: hsla(230, 10%, 80%, 1.00);--tp-monitor-background-color: hsla(230, 20%, 8%, 1.00);--tp-monitor-foreground-color: hsla(230, 12%, 48%, 1.00);--tp-label-foreground-color: #E4E2ED;--tp-font-family: "Inter"}.tp-fldv{margin-top:.25rem;margin-bottom:.25rem;background-blend-mode:luminosity;position:relative}.tp-fldv .tp-fldv{margin-top:.5rem;margin-bottom:.5rem}.tp-fldv .tp-brkv{background-color:rgba(32,32,50,.85)}.tp-fldv .tp-fldv .tp-brkv{background-color:rgba(32,32,50,.25) !important}.tp-fldv-expanded>.tp-fldv_b{background-color:rgba(32,32,50,.8) !important}.tp-fldv_b{height:calc(var(--bld-us)*1.5 + 4px) !important;font-size:.85rem !important}.tp-fldv_b+.tp-brkv .tp-fldv_b{height:calc(var(--bld-us)*1.1 + 4px) !important;font-size:.65rem !important}.tp-lblv_l{font-size:.7rem !important;font-weight:400 !important;flex-grow:1 !important;flex-basis:20% !important}.tp-lblv_v{flex-grow:1 !important;flex-basis:50% !important}.tp-txtv_i{font-size:.7rem !important;font-weight:400 !important}.tp-fldv_t{font-weight:400 !important;padding-left:1.5rem !important}.tp-fldv_m{right:auto !important;left:.75rem;opacity:1 !important}.pluginOptionsButton{position:absolute;right:0;top:.75rem;padding-left:.5rem;padding-right:.5rem;height:-webkit-min-content;height:-moz-min-content;height:min-content;background:transparent;color:#eee;border:none}', ""]), t.Z = i;
}, 513: function(e, t, r) {
  var n = r(352), i = r.n(n)()(function(e2) {
    return e2[1];
  });
  i.push([e.id, ".wwise-perspective{perspective:1000px;position:fixed;left:0;top:0;width:100vw;height:100vh}.wwise-wrapper{position:fixed;width:0;height:0;font-weight:400}.wwise-wrapper.v-center{top:50%}.wwise-wrapper.h-center{left:50%}.wwise-wrapper.left{left:0}.wwise-wrapper.right{right:0}.wwise-wrapper.top{top:0}.wwise-wrapper.bottom{bottom:0}.wwise *.preset{color:#fafafa}.wwise *.preset.ok{background:rgba(45,193,80,.95)}.wwise *.preset.error{background:rgba(190,17,51,.95)}.wwise *.preset.info{background:rgba(40,34,60,.95)}.wwise *.preset.caution{background:rgba(239,128,0,.95)}.wwise-no-scroll{position:relative;overflow:hidden}.wwise-overlay{position:fixed;left:0;top:0;width:100vw;height:100vh;background:rgba(50,50,50,.5)}.wwise{position:absolute;left:0;top:0;display:flex;flex-direction:column;border-radius:5px;box-shadow:1px 1px 10px rgba(150,150,150,.5);box-sizing:border-box}.wwise.no-radius{border-radius:0}.wwise *{box-sizing:border-box}.wwise .clear{clear:both}.wwise>.content{padding:0;margin:0;flex-grow:1;border-radius:0 0 4px 4px;background:#fff;color:#333;box-shadow:0 1px 3px rgba(200,200,200,.5) inset}.wwise>.content.no-topbar{border-radius:4px;box-shadow:none}.wwise.no-radius>.content,.wwise.no-radius>.content.no-topbar{border-radius:0}.wwise .modal>.main{width:90vw;max-width:400px;border-radius:4px 4px 0 0;text-align:center;padding-bottom:10px;color:#fff}.wwise .modal>.main .icon{display:block;margin:0 auto;fill:#fff;width:100px}.wwise .modal>.main .title{font-size:30px}.wwise .modal>.main .text{margin:10px 0;font-weight:300;font-size:16px}.wwise .modal>.main.no-op{border-radius:4px}.wwise .modal>.main.ok{background:#2dc150}.wwise .modal>.main.error{background:#be1133}.wwise .modal>.main.info{background:#28223c}.wwise .modal>.main.caution{background:#ef8000}.wwise .modal>.operation .button-wrapper{text-align:center;margin:30px 0 20px 0}.wwise .modal>.operation .button{display:inline-block;line-height:18px;padding:8px 10px;margin:0 15px;line-height:18px;width:100px;border-radius:4px;border:1px solid #eee;box-shadow:1px 1px 3px rgba(220,220,220,.8);color:#555;transition:all ease .2s}.wwise .modal>.operation .button:hover{background:#f5f5f5;cursor:pointer}.wwise .modal>.operation .button.main{color:#fff}.wwise .modal>.operation.ok .main{background:#2dc150}.wwise .modal>.operation.ok .main:hover{background:#23983f}.wwise .modal>.operation.error .main{background:#be1133}.wwise .modal>.operation.error .main:hover{background:#8f0d26}.wwise .modal>.operation.info .main{background:#28223c}.wwise .modal>.operation.info .main:hover{background:#12101b}.wwise .modal>.operation.caution .main{background:#ef8000}.wwise .modal>.operation.caution .main:hover{background:#bc6500}.wwise .input-wrapper{margin:15px auto -15px auto}.wwise .input-wrapper .input{display:block;margin:0 auto;width:95%;max-width:300px;outline:none;border:none;background:#f3f3f3;padding:15px;font-size:16px;border-radius:5px}.wwise .input-wrapper .error{width:95%;text-align:center;margin-top:10px;color:red}div:has(>.wwise-wrapper){position:absolute !important}.wwise-wrapper{position:absolute !important}.wwise .modal>.main{padding-top:10px}", ""]), t.Z = i;
}, 476: function(e) {
  var t;
  t = function() {
    return function(e2) {
      var t2 = {};
      function r(n) {
        if (t2[n])
          return t2[n].exports;
        var i = t2[n] = { i: n, l: false, exports: {} };
        return e2[n].call(i.exports, i, i.exports, r), i.l = true, i.exports;
      }
      return r.m = e2, r.c = t2, r.i = function(e3) {
        return e3;
      }, r.d = function(e3, t3, n) {
        r.o(e3, t3) || Object.defineProperty(e3, t3, { configurable: false, enumerable: true, get: n });
      }, r.n = function(e3) {
        var t3 = e3 && e3.__esModule ? function() {
          return e3.default;
        } : function() {
          return e3;
        };
        return r.d(t3, "a", t3), t3;
      }, r.o = function(e3, t3) {
        return Object.prototype.hasOwnProperty.call(e3, t3);
      }, r.p = "", r(r.s = 5);
    }([function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var n = { convertToObject: function(e3) {
        var t3 = e3.substring(e3.indexOf("{") + 1).trim().slice(0, -1), r2 = {};
        return t3.split(";").map(function(e4) {
          if (e4 = e4.trim()) {
            var t4 = e4.split(":");
            r2[t4[0].trim()] = t4[1].trim();
          }
        }), r2;
      }, getFromSheets: function(e3) {
        var t3 = document.styleSheets;
        for (var r2 in t3) {
          var i = null;
          try {
            i = t3[r2].rules || t3[r2].cssRules;
          } catch (e4) {
          }
          if (i) {
            for (var s in i)
              if (i[s].selectorText && -1 != i[s].selectorText.split(",").indexOf(e3))
                return i[s].cssText ? n.convertToObject(i[s].cssText) : n.convertToObject(i[s].style.cssText);
          }
        }
        return {};
      }, getPropertyDefault: function(e3) {
        return "timing-function" == e3 ? "ease" : "iteration-count" == e3 ? 1 : "direction" == e3 ? "normal" : "fill-mode" == e3 ? "none" : null;
      } };
      t2.default = n;
    }, function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var n = { generateId: function() {
        for (var e3 = "", t3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", r2 = 0; r2 < 8; ++r2)
          e3 += t3.charAt(Math.floor(Math.random() * t3.length));
        return e3;
      }, frameToString: function(e3) {
        var t3 = "";
        for (var r2 in e3)
          t3 += r2 + ":" + e3[r2] + ";";
        return t3;
      }, convertTimeToMs: function(e3) {
        if (!e3)
          return 0;
        if ("number" == typeof e3)
          return e3;
        var t3 = parseFloat(e3);
        return -1 != e3.indexOf("ms") ? t3 : 1e3 * t3;
      }, prefixes: ["", "-webkit-", "-moz-", "-o-"] };
      t2.default = n;
    }, function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var n, i = (n = r(0)) && n.__esModule ? n : { default: n };
      t2.default = function e3(t3, r2) {
        if (function(e4, t4) {
          if (!(e4 instanceof t4))
            throw new TypeError("Cannot call a class as a function");
        }(this, e3), this.styles = "string" == typeof t3 ? i.default.getFromSheets(t3) : t3, "string" == typeof r2) {
          var n2 = i.default.getFromSheets(r2);
          for (var s in this.options = {}, n2)
            this.options[s.replace("animation-", "")] = n2[s];
        } else
          this.options = "number" == typeof r2 ? { duration: r2 } : r2;
      };
    }, function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var n = function() {
        function e3(e4, t3) {
          for (var r2 = 0; r2 < t3.length; r2++) {
            var n2 = t3[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e4, n2.key, n2);
          }
        }
        return function(t3, r2, n2) {
          return r2 && e3(t3.prototype, r2), n2 && e3(t3, n2), t3;
        };
      }(), i = a(r(4)), s = a(r(1)), o = a(r(0));
      function a(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }
      var l = function() {
        function e3(t3, r2, n2, i2) {
          if (function(e4, t4) {
            if (!(e4 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), t3.constructor === Array ? this.doms = t3 : this.doms = [t3], r2.constructor === Array ? this.frames = r2 : this.frames = [r2], this.options = { startFrom: 0, pauseAt: [], prefix: false, count: 1, clear: true, applyOnEnd: false, instant: false }, null != n2 && null != n2)
            if ("boolean" == typeof n2)
              this.options.instant = n2;
            else if ("number" == typeof n2)
              this.options.count = n2, "boolean" == typeof i2 && (this.options.instant = i2);
            else
              for (var o2 in n2)
                "pauseAt" == o2 && n2.pauseAt.constructor !== Array ? this.options[o2] = [n2[o2]] : this.options[o2] = n2[o2];
          for (var a2 in this.promiseSupported = "undefined" != typeof Promise && -1 !== Promise.toString().indexOf("[native code]"), this.countRemainder = [], this.animations = [], this.styleDoms = [], this.superSets = [], this.eventHandler = [], this.options.prefix ? this.prefixes = s.default.prefixes : this.prefixes = [""], t3)
            this.countRemainder[a2] = this.options.count - 1;
          this.options.instant && this.play();
        }
        return n(e3, [{ key: "play", value: function() {
          var e4 = this;
          for (var t3 in this.clear(), this.promiseSupported && (this.promise = new Promise(function(t4) {
            e4.promiseResolve = t4;
          })), this.doms) {
            var r2 = this.makeAnimation(this.doms[t3]);
            this.animations[t3] = r2.names, this.styleDoms[t3] = r2.styleDom, this.superSets[t3] = this.makeSuperSet(this.doms[t3], this.animations[t3]), this.playAnimation(this.doms[t3], this.superSets[t3]), this.eventHandler[t3] = this.handleAnimationEnd.bind(this, t3), this.doms[t3].addEventListener("animationend", this.eventHandler[t3]);
          }
          if (this.promiseSupported)
            return this.promise;
        } }, { key: "clear", value: function(e4) {
          if (!e4) {
            for (var t3 in this.doms)
              this.clear(t3);
            return this.animationEnded = 0, this.promise = void 0, void (this.promiseResolve = void 0);
          }
          var r2 = this.styleDoms[e4];
          for (var n2 in r2 && r2.parentNode && r2.parentNode.removeChild(r2), this.superSets[e4])
            for (var i2 in this.prefixes)
              this.doms[e4].style[this.prefixes[i2] + "animation-" + n2] = null;
          for (var s2 in this.prefixes)
            this.doms[e4].style[this.prefixes[s2] + "animation-play-state"] = null;
          this.doms[e4].removeEventListener("animationend", this.eventHandler[e4]), this.countRemainder[e4] = this.options.count - 1;
        } }, { key: "replay", value: function(e4) {
          var t3 = this.doms[e4], r2 = t3.cloneNode(true);
          t3.parentNode.replaceChild(r2, t3), this.doms[e4].removeEventListener("animationend", this.eventHandler[e4]), this.doms[e4] = r2, this.doms[e4].addEventListener("animationend", this.eventHandler[e4]);
        } }, { key: "pause", value: function() {
          for (var e4 in this.doms)
            this.pauseDom(this.doms[e4]);
        } }, { key: "resume", value: function() {
          for (var e4 in this.doms)
            this.resumeDom(this.doms[e4]);
        } }, { key: "getPromise", value: function() {
          return this.promise;
        } }, { key: "handleAnimationEnd", value: function(e4, t3) {
          var r2 = t3.animationName, n2 = r2.substring(r2.lastIndexOf("-") + 1);
          this.options.pauseAt.includes(parseInt(n2)) && this.pauseDom(this.doms[e4]), n2 == this.frames.length && (-1 == this.countRemainder[e4] ? this.replay(e4) : this.countRemainder[e4] > 0 ? (this.countRemainder[e4]--, this.replay(e4)) : (this.options.applyOnEnd && this.applyOnEnd(e4), this.animationEnded++, this.animationEnded == this.doms.length && (this.promiseSupported && this.promiseResolve(), this.options.clear && this.clear())));
        } }, { key: "pauseDom", value: function(e4) {
          for (var t3 in this.prefixes)
            e4.style[this.prefixes[t3] + "animation-play-state"] = "paused";
        } }, { key: "resumeDom", value: function(e4) {
          for (var t3 in this.prefixes)
            e4.style[this.prefixes[t3] + "animation-play-state"] = "running";
        } }, { key: "applyOnEnd", value: function(e4) {
          var t3 = this.newFrames[this.frames.length];
          for (var r2 in t3)
            this.doms[e4].style[r2] = t3[r2];
        } }, { key: "makeAnimation", value: function(e4) {
          var t3 = {}, r2 = [], n2 = {};
          for (var s2 in this.frames)
            for (var o2 in r2.push(this.frames[s2].styles), r2[s2])
              n2[o2] = true;
          var a2 = window.getComputedStyle(e4);
          for (var l2 in n2)
            t3[l2] = a2[l2];
          r2.unshift(t3);
          for (var c = [r2[0]], u = 1; u < r2.length; ++u) {
            var h = JSON.parse(JSON.stringify(c[u - 1]));
            for (var p in r2[u])
              h[p] = r2[u][p];
            c.push(h);
          }
          return this.newFrames = c, i.default.make(c, this.prefixes);
        } }, { key: "makeSuperSet", value: function(e4, t3) {
          var r2 = 0, n2 = {};
          for (var i2 in this.frames)
            for (var a2 in this.frames[i2].options)
              n2[a2] = "";
          n2.name = "", n2.duration = "", n2.delay = "";
          for (var l2 = 0; l2 < this.frames.length; ++l2) {
            if (l2)
              for (var c in n2)
                n2[c] += ",";
            var u = s.default.convertTimeToMs(this.frames[l2].options.duration), h = s.default.convertTimeToMs(this.frames[l2].options.delay);
            for (var p in l2 < this.options.startFrom && (u = 0, h = 0), n2.name += t3[l2], n2.duration += u + "ms", n2.delay += r2 + h + "ms", n2)
              "name" != p && "duration" != p && "delay" != p && (n2[p] += this.frames[l2].options[p] ? this.frames[l2].options[p] : o.default.getPropertyDefault(p));
            var d = this.frames[l2].options["iteration-count"];
            r2 += u * parseInt(d || 1) + h;
          }
          return n2;
        } }, { key: "playAnimation", value: function(e4, t3) {
          for (var r2 in t3)
            for (var n2 in this.prefixes)
              e4.style[this.prefixes[n2] + "animation-" + r2] = t3[r2];
          this.options.pauseAt.includes(0) && this.pauseDom(e4);
        } }]), e3;
      }();
      t2.default = l;
    }, function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var n, i = (n = r(1)) && n.__esModule ? n : { default: n }, s = { make: function(e3, t3) {
        for (var r2 = [], n2 = "", o = "atr-" + i.default.generateId(), a = document.createElement("style"), l = 0; l < e3.length - 1; ++l)
          r2.push(o + "-" + (l + 1)), n2 += s.makeFromTwoFrames(e3[l], e3[l + 1], r2[l], t3);
        return a.innerHTML = n2, a.class = "foo", document.getElementsByTagName("head")[0].appendChild(a), { names: r2, styleDom: a };
      }, makeFromTwoFrames: function(e3, t3, r2, n2) {
        var s2 = "";
        for (var o in n2)
          s2 += "@" + n2[o] + "keyframes " + r2 + " {", s2 += "0%", s2 += "{" + i.default.frameToString(e3) + "}", s2 += "100%", s2 += "{" + i.default.frameToString(t3) + "}", s2 += "}";
        return s2;
      } };
      t2.default = s;
    }, function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Queue = t2.Frame = void 0;
      var n = s(r(2)), i = s(r(3));
      function s(e3) {
        return e3 && e3.__esModule ? e3 : { default: e3 };
      }
      t2.Frame = n.default, t2.Queue = i.default;
    }]);
  }, e.exports = t();
}, 352: function(e) {
  e.exports = function(e2) {
    var t = [];
    return t.toString = function() {
      return this.map(function(t2) {
        var r = e2(t2);
        return t2[2] ? "@media ".concat(t2[2], " {").concat(r, "}") : r;
      }).join("");
    }, t.i = function(e3, r, n) {
      "string" == typeof e3 && (e3 = [[null, e3, ""]]);
      var i = {};
      if (n)
        for (var s = 0; s < this.length; s++) {
          var o = this[s][0];
          null != o && (i[o] = true);
        }
      for (var a = 0; a < e3.length; a++) {
        var l = [].concat(e3[a]);
        n && i[l[0]] || (r && (l[2] ? l[2] = "".concat(r, " and ").concat(l[2]) : l[2] = r), t.push(l));
      }
    }, t;
  };
}, 388: function(e) {
  e.exports = function e2(t, r, n) {
    function i(o2, a) {
      if (!r[o2]) {
        if (!t[o2]) {
          if (s)
            return s(o2, true);
          throw new Error("Cannot find module '" + o2 + "'");
        }
        var l = r[o2] = { exports: {} };
        t[o2][0].call(l.exports, function(e3) {
          return i(t[o2][1][e3] || e3);
        }, l, l.exports, e2, t, r, n);
      }
      return r[o2].exports;
    }
    for (var s = void 0, o = 0; o < n.length; o++)
      i(n[o]);
    return i;
  }({ 1: [function(e2, t, r) {
    (function(n, i, s, o, a, l, c, u, h) {
      var p = e2("crypto");
      function d(e3, t2) {
        return function(e4, t3) {
          var r2;
          if (void 0 === (r2 = "passthrough" !== t3.algorithm ? p.createHash(t3.algorithm) : new A()).write && (r2.write = r2.update, r2.end = r2.update), v(t3, r2).dispatch(e4), r2.update || r2.end(""), r2.digest)
            return r2.digest("buffer" === t3.encoding ? void 0 : t3.encoding);
          var n2 = r2.read();
          return "buffer" !== t3.encoding ? n2.toString(t3.encoding) : n2;
        }(e3, t2 = _(e3, t2));
      }
      (r = t.exports = d).sha1 = function(e3) {
        return d(e3);
      }, r.keys = function(e3) {
        return d(e3, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
      }, r.MD5 = function(e3) {
        return d(e3, { algorithm: "md5", encoding: "hex" });
      }, r.keysMD5 = function(e3) {
        return d(e3, { algorithm: "md5", encoding: "hex", excludeValues: true });
      };
      var f = p.getHashes ? p.getHashes().slice() : ["sha1", "md5"];
      f.push("passthrough");
      var m = ["buffer", "hex", "binary", "base64"];
      function _(e3, t2) {
        t2 = t2 || {};
        var r2 = {};
        if (r2.algorithm = t2.algorithm || "sha1", r2.encoding = t2.encoding || "hex", r2.excludeValues = !!t2.excludeValues, r2.algorithm = r2.algorithm.toLowerCase(), r2.encoding = r2.encoding.toLowerCase(), r2.ignoreUnknown = true === t2.ignoreUnknown, r2.respectType = false !== t2.respectType, r2.respectFunctionNames = false !== t2.respectFunctionNames, r2.respectFunctionProperties = false !== t2.respectFunctionProperties, r2.unorderedArrays = true === t2.unorderedArrays, r2.unorderedSets = false !== t2.unorderedSets, r2.unorderedObjects = false !== t2.unorderedObjects, r2.replacer = t2.replacer || void 0, r2.excludeKeys = t2.excludeKeys || void 0, void 0 === e3)
          throw new Error("Object argument required.");
        for (var n2 = 0; n2 < f.length; ++n2)
          f[n2].toLowerCase() === r2.algorithm.toLowerCase() && (r2.algorithm = f[n2]);
        if (-1 === f.indexOf(r2.algorithm))
          throw new Error('Algorithm "' + r2.algorithm + '"  not supported. supported values: ' + f.join(", "));
        if (-1 === m.indexOf(r2.encoding) && "passthrough" !== r2.algorithm)
          throw new Error('Encoding "' + r2.encoding + '"  not supported. supported values: ' + m.join(", "));
        return r2;
      }
      function g(e3) {
        if ("function" == typeof e3)
          return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e3));
      }
      function v(e3, t2, r2) {
        function n2(e4) {
          return t2.update ? t2.update(e4, "utf8") : t2.write(e4, "utf8");
        }
        return r2 = r2 || [], { dispatch: function(t3) {
          return e3.replacer && (t3 = e3.replacer(t3)), this["_" + (null === t3 ? "null" : typeof t3)](t3);
        }, _object: function(t3) {
          var i2, o2 = Object.prototype.toString.call(t3), a2 = /\[object (.*)\]/i.exec(o2);
          if (a2 = (a2 = a2 ? a2[1] : "unknown:[" + o2 + "]").toLowerCase(), 0 <= (i2 = r2.indexOf(t3)))
            return this.dispatch("[CIRCULAR:" + i2 + "]");
          if (r2.push(t3), void 0 !== s && s.isBuffer && s.isBuffer(t3))
            return n2("buffer:"), n2(t3);
          if ("object" === a2 || "function" === a2 || "asyncfunction" === a2) {
            var l2 = Object.keys(t3);
            e3.unorderedObjects && (l2 = l2.sort()), false === e3.respectType || g(t3) || l2.splice(0, 0, "prototype", "__proto__", "constructor"), e3.excludeKeys && (l2 = l2.filter(function(t4) {
              return !e3.excludeKeys(t4);
            })), n2("object:" + l2.length + ":");
            var c2 = this;
            return l2.forEach(function(r3) {
              c2.dispatch(r3), n2(":"), e3.excludeValues || c2.dispatch(t3[r3]), n2(",");
            });
          }
          if (!this["_" + a2]) {
            if (e3.ignoreUnknown)
              return n2("[" + a2 + "]");
            throw new Error('Unknown object type "' + a2 + '"');
          }
          this["_" + a2](t3);
        }, _array: function(t3, i2) {
          i2 = void 0 !== i2 ? i2 : false !== e3.unorderedArrays;
          var s2 = this;
          if (n2("array:" + t3.length + ":"), !i2 || t3.length <= 1)
            return t3.forEach(function(e4) {
              return s2.dispatch(e4);
            });
          var o2 = [], a2 = t3.map(function(t4) {
            var n3 = new A(), i3 = r2.slice();
            return v(e3, n3, i3).dispatch(t4), o2 = o2.concat(i3.slice(r2.length)), n3.read().toString();
          });
          return r2 = r2.concat(o2), a2.sort(), this._array(a2, false);
        }, _date: function(e4) {
          return n2("date:" + e4.toJSON());
        }, _symbol: function(e4) {
          return n2("symbol:" + e4.toString());
        }, _error: function(e4) {
          return n2("error:" + e4.toString());
        }, _boolean: function(e4) {
          return n2("bool:" + e4.toString());
        }, _string: function(e4) {
          n2("string:" + e4.length + ":"), n2(e4.toString());
        }, _function: function(t3) {
          n2("fn:"), g(t3) ? this.dispatch("[native]") : this.dispatch(t3.toString()), false !== e3.respectFunctionNames && this.dispatch("function-name:" + String(t3.name)), e3.respectFunctionProperties && this._object(t3);
        }, _number: function(e4) {
          return n2("number:" + e4.toString());
        }, _xml: function(e4) {
          return n2("xml:" + e4.toString());
        }, _null: function() {
          return n2("Null");
        }, _undefined: function() {
          return n2("Undefined");
        }, _regexp: function(e4) {
          return n2("regex:" + e4.toString());
        }, _uint8array: function(e4) {
          return n2("uint8array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _uint8clampedarray: function(e4) {
          return n2("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _int8array: function(e4) {
          return n2("uint8array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _uint16array: function(e4) {
          return n2("uint16array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _int16array: function(e4) {
          return n2("uint16array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _uint32array: function(e4) {
          return n2("uint32array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _int32array: function(e4) {
          return n2("uint32array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _float32array: function(e4) {
          return n2("float32array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _float64array: function(e4) {
          return n2("float64array:"), this.dispatch(Array.prototype.slice.call(e4));
        }, _arraybuffer: function(e4) {
          return n2("arraybuffer:"), this.dispatch(new Uint8Array(e4));
        }, _url: function(e4) {
          return n2("url:" + e4.toString());
        }, _map: function(t3) {
          n2("map:");
          var r3 = Array.from(t3);
          return this._array(r3, false !== e3.unorderedSets);
        }, _set: function(t3) {
          n2("set:");
          var r3 = Array.from(t3);
          return this._array(r3, false !== e3.unorderedSets);
        }, _file: function(e4) {
          return n2("file:"), this.dispatch([e4.name, e4.size, e4.type, e4.lastModfied]);
        }, _blob: function() {
          if (e3.ignoreUnknown)
            return n2("[blob]");
          throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
        }, _domwindow: function() {
          return n2("domwindow");
        }, _bigint: function(e4) {
          return n2("bigint:" + e4.toString());
        }, _process: function() {
          return n2("process");
        }, _timer: function() {
          return n2("timer");
        }, _pipe: function() {
          return n2("pipe");
        }, _tcp: function() {
          return n2("tcp");
        }, _udp: function() {
          return n2("udp");
        }, _tty: function() {
          return n2("tty");
        }, _statwatcher: function() {
          return n2("statwatcher");
        }, _securecontext: function() {
          return n2("securecontext");
        }, _connection: function() {
          return n2("connection");
        }, _zlib: function() {
          return n2("zlib");
        }, _context: function() {
          return n2("context");
        }, _nodescript: function() {
          return n2("nodescript");
        }, _httpparser: function() {
          return n2("httpparser");
        }, _dataview: function() {
          return n2("dataview");
        }, _signal: function() {
          return n2("signal");
        }, _fsevent: function() {
          return n2("fsevent");
        }, _tlswrap: function() {
          return n2("tlswrap");
        } };
      }
      function A() {
        return { buf: "", write: function(e3) {
          this.buf += e3;
        }, end: function(e3) {
          this.buf += e3;
        }, read: function() {
          return this.buf;
        } };
      }
      r.writeToStream = function(e3, t2, r2) {
        return void 0 === r2 && (r2 = t2, t2 = {}), v(t2 = _(e3, t2), r2).dispatch(e3);
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_7eac155c.js", "/");
  }, { buffer: 3, crypto: 5, lYpoI2: 10 }], 2: [function(e2, t, r) {
    (function(e3, t2, n, i, s, o, a, l, c) {
      !function(e4) {
        var t3 = "undefined" != typeof Uint8Array ? Uint8Array : Array, r2 = "+".charCodeAt(0), n2 = "/".charCodeAt(0), i2 = "0".charCodeAt(0), s2 = "a".charCodeAt(0), o2 = "A".charCodeAt(0), a2 = "-".charCodeAt(0), l2 = "_".charCodeAt(0);
        function c2(e5) {
          var t4 = e5.charCodeAt(0);
          return t4 === r2 || t4 === a2 ? 62 : t4 === n2 || t4 === l2 ? 63 : t4 < i2 ? -1 : t4 < i2 + 10 ? t4 - i2 + 26 + 26 : t4 < o2 + 26 ? t4 - o2 : t4 < s2 + 26 ? t4 - s2 + 26 : void 0;
        }
        e4.toByteArray = function(e5) {
          var r3, n3;
          if (0 < e5.length % 4)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var i3 = e5.length, s3 = "=" === e5.charAt(i3 - 2) ? 2 : "=" === e5.charAt(i3 - 1) ? 1 : 0, o3 = new t3(3 * e5.length / 4 - s3), a3 = 0 < s3 ? e5.length - 4 : e5.length, l3 = 0;
          function u(e6) {
            o3[l3++] = e6;
          }
          for (r3 = 0; r3 < a3; r3 += 4, 0)
            u((16711680 & (n3 = c2(e5.charAt(r3)) << 18 | c2(e5.charAt(r3 + 1)) << 12 | c2(e5.charAt(r3 + 2)) << 6 | c2(e5.charAt(r3 + 3)))) >> 16), u((65280 & n3) >> 8), u(255 & n3);
          return 2 == s3 ? u(255 & (n3 = c2(e5.charAt(r3)) << 2 | c2(e5.charAt(r3 + 1)) >> 4)) : 1 == s3 && (u((n3 = c2(e5.charAt(r3)) << 10 | c2(e5.charAt(r3 + 1)) << 4 | c2(e5.charAt(r3 + 2)) >> 2) >> 8 & 255), u(255 & n3)), o3;
        }, e4.fromByteArray = function(e5) {
          var t4, r3, n3, i3, s3 = e5.length % 3, o3 = "";
          function a3(e6) {
            return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e6);
          }
          for (t4 = 0, n3 = e5.length - s3; t4 < n3; t4 += 3)
            o3 += a3((i3 = r3 = (e5[t4] << 16) + (e5[t4 + 1] << 8) + e5[t4 + 2]) >> 18 & 63) + a3(i3 >> 12 & 63) + a3(i3 >> 6 & 63) + a3(63 & i3);
          switch (s3) {
            case 1:
              o3 += a3((r3 = e5[e5.length - 1]) >> 2), o3 += a3(r3 << 4 & 63), o3 += "==";
              break;
            case 2:
              o3 += a3((r3 = (e5[e5.length - 2] << 8) + e5[e5.length - 1]) >> 10), o3 += a3(r3 >> 4 & 63), o3 += a3(r3 << 2 & 63), o3 += "=";
          }
          return o3;
        };
      }(void 0 === r ? this.base64js = {} : r);
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
  }, { buffer: 3, lYpoI2: 10 }], 3: [function(e2, t, r) {
    (function(t2, n, i, s, o, a, l, c, u) {
      var h = e2("base64-js"), p = e2("ieee754");
      function i(e3, t3, r2) {
        if (!(this instanceof i))
          return new i(e3, t3, r2);
        var n2, s2, o2, a2, l2, c2 = typeof e3;
        if ("base64" === t3 && "string" == c2)
          for (e3 = (n2 = e3).trim ? n2.trim() : n2.replace(/^\s+|\s+$/g, ""); e3.length % 4 != 0; )
            e3 += "=";
        if ("number" == c2)
          s2 = M(e3);
        else if ("string" == c2)
          s2 = i.byteLength(e3, t3);
        else {
          if ("object" != c2)
            throw new Error("First argument needs to be a number, array or string.");
          s2 = M(e3.length);
        }
        if (i._useTypedArrays ? o2 = i._augment(new Uint8Array(s2)) : ((o2 = this).length = s2, o2._isBuffer = true), i._useTypedArrays && "number" == typeof e3.byteLength)
          o2._set(e3);
        else if (T(l2 = e3) || i.isBuffer(l2) || l2 && "object" == typeof l2 && "number" == typeof l2.length)
          for (a2 = 0; a2 < s2; a2++)
            i.isBuffer(e3) ? o2[a2] = e3.readUInt8(a2) : o2[a2] = e3[a2];
        else if ("string" == c2)
          o2.write(e3, 0, t3);
        else if ("number" == c2 && !i._useTypedArrays && !r2)
          for (a2 = 0; a2 < s2; a2++)
            o2[a2] = 0;
        return o2;
      }
      function d(e3, t3, r2, n2) {
        n2 || (F("boolean" == typeof r2, "missing or invalid endian"), F(null != t3, "missing offset"), F(t3 + 1 < e3.length, "Trying to read beyond buffer length"));
        var i2, s2 = e3.length;
        if (!(s2 <= t3))
          return r2 ? (i2 = e3[t3], t3 + 1 < s2 && (i2 |= e3[t3 + 1] << 8)) : (i2 = e3[t3] << 8, t3 + 1 < s2 && (i2 |= e3[t3 + 1])), i2;
      }
      function f(e3, t3, r2, n2) {
        n2 || (F("boolean" == typeof r2, "missing or invalid endian"), F(null != t3, "missing offset"), F(t3 + 3 < e3.length, "Trying to read beyond buffer length"));
        var i2, s2 = e3.length;
        if (!(s2 <= t3))
          return r2 ? (t3 + 2 < s2 && (i2 = e3[t3 + 2] << 16), t3 + 1 < s2 && (i2 |= e3[t3 + 1] << 8), i2 |= e3[t3], t3 + 3 < s2 && (i2 += e3[t3 + 3] << 24 >>> 0)) : (t3 + 1 < s2 && (i2 = e3[t3 + 1] << 16), t3 + 2 < s2 && (i2 |= e3[t3 + 2] << 8), t3 + 3 < s2 && (i2 |= e3[t3 + 3]), i2 += e3[t3] << 24 >>> 0), i2;
      }
      function m(e3, t3, r2, n2) {
        if (n2 || (F("boolean" == typeof r2, "missing or invalid endian"), F(null != t3, "missing offset"), F(t3 + 1 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t3)) {
          var i2 = d(e3, t3, r2, true);
          return 32768 & i2 ? -1 * (65535 - i2 + 1) : i2;
        }
      }
      function _(e3, t3, r2, n2) {
        if (n2 || (F("boolean" == typeof r2, "missing or invalid endian"), F(null != t3, "missing offset"), F(t3 + 3 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t3)) {
          var i2 = f(e3, t3, r2, true);
          return 2147483648 & i2 ? -1 * (4294967295 - i2 + 1) : i2;
        }
      }
      function g(e3, t3, r2, n2) {
        return n2 || (F("boolean" == typeof r2, "missing or invalid endian"), F(t3 + 3 < e3.length, "Trying to read beyond buffer length")), p.read(e3, t3, r2, 23, 4);
      }
      function v(e3, t3, r2, n2) {
        return n2 || (F("boolean" == typeof r2, "missing or invalid endian"), F(t3 + 7 < e3.length, "Trying to read beyond buffer length")), p.read(e3, t3, r2, 52, 8);
      }
      function A(e3, t3, r2, n2, i2) {
        i2 || (F(null != t3, "missing value"), F("boolean" == typeof n2, "missing or invalid endian"), F(null != r2, "missing offset"), F(r2 + 1 < e3.length, "trying to write beyond buffer length"), R(t3, 65535));
        var s2 = e3.length;
        if (!(s2 <= r2))
          for (var o2 = 0, a2 = Math.min(s2 - r2, 2); o2 < a2; o2++)
            e3[r2 + o2] = (t3 & 255 << 8 * (n2 ? o2 : 1 - o2)) >>> 8 * (n2 ? o2 : 1 - o2);
      }
      function b(e3, t3, r2, n2, i2) {
        i2 || (F(null != t3, "missing value"), F("boolean" == typeof n2, "missing or invalid endian"), F(null != r2, "missing offset"), F(r2 + 3 < e3.length, "trying to write beyond buffer length"), R(t3, 4294967295));
        var s2 = e3.length;
        if (!(s2 <= r2))
          for (var o2 = 0, a2 = Math.min(s2 - r2, 4); o2 < a2; o2++)
            e3[r2 + o2] = t3 >>> 8 * (n2 ? o2 : 3 - o2) & 255;
      }
      function y(e3, t3, r2, n2, i2) {
        i2 || (F(null != t3, "missing value"), F("boolean" == typeof n2, "missing or invalid endian"), F(null != r2, "missing offset"), F(r2 + 1 < e3.length, "Trying to write beyond buffer length"), L(t3, 32767, -32768)), e3.length <= r2 || A(e3, 0 <= t3 ? t3 : 65535 + t3 + 1, r2, n2, i2);
      }
      function x(e3, t3, r2, n2, i2) {
        i2 || (F(null != t3, "missing value"), F("boolean" == typeof n2, "missing or invalid endian"), F(null != r2, "missing offset"), F(r2 + 3 < e3.length, "Trying to write beyond buffer length"), L(t3, 2147483647, -2147483648)), e3.length <= r2 || b(e3, 0 <= t3 ? t3 : 4294967295 + t3 + 1, r2, n2, i2);
      }
      function w(e3, t3, r2, n2, i2) {
        i2 || (F(null != t3, "missing value"), F("boolean" == typeof n2, "missing or invalid endian"), F(null != r2, "missing offset"), F(r2 + 3 < e3.length, "Trying to write beyond buffer length"), O(t3, 34028234663852886e22, -34028234663852886e22)), e3.length <= r2 || p.write(e3, t3, r2, n2, 23, 4);
      }
      function E(e3, t3, r2, n2, i2) {
        i2 || (F(null != t3, "missing value"), F("boolean" == typeof n2, "missing or invalid endian"), F(null != r2, "missing offset"), F(r2 + 7 < e3.length, "Trying to write beyond buffer length"), O(t3, 17976931348623157e292, -17976931348623157e292)), e3.length <= r2 || p.write(e3, t3, r2, n2, 52, 8);
      }
      r.Buffer = i, r.SlowBuffer = i, r.INSPECT_MAX_BYTES = 50, i.poolSize = 8192, i._useTypedArrays = function() {
        try {
          var e3 = new ArrayBuffer(0), t3 = new Uint8Array(e3);
          return t3.foo = function() {
            return 42;
          }, 42 === t3.foo() && "function" == typeof t3.subarray;
        } catch (e4) {
          return false;
        }
      }(), i.isEncoding = function(e3) {
        switch (String(e3).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "raw":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, i.isBuffer = function(e3) {
        return !(null == e3 || !e3._isBuffer);
      }, i.byteLength = function(e3, t3) {
        var r2;
        switch (e3 += "", t3 || "utf8") {
          case "hex":
            r2 = e3.length / 2;
            break;
          case "utf8":
          case "utf-8":
            r2 = k(e3).length;
            break;
          case "ascii":
          case "binary":
          case "raw":
            r2 = e3.length;
            break;
          case "base64":
            r2 = D(e3).length;
            break;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            r2 = 2 * e3.length;
            break;
          default:
            throw new Error("Unknown encoding");
        }
        return r2;
      }, i.concat = function(e3, t3) {
        if (F(T(e3), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e3.length)
          return new i(0);
        if (1 === e3.length)
          return e3[0];
        if ("number" != typeof t3)
          for (s2 = t3 = 0; s2 < e3.length; s2++)
            t3 += e3[s2].length;
        for (var r2 = new i(t3), n2 = 0, s2 = 0; s2 < e3.length; s2++) {
          var o2 = e3[s2];
          o2.copy(r2, n2), n2 += o2.length;
        }
        return r2;
      }, i.prototype.write = function(e3, t3, r2, n2) {
        var s2;
        isFinite(t3) ? isFinite(r2) || (n2 = r2, r2 = void 0) : (s2 = n2, n2 = t3, t3 = r2, r2 = s2), t3 = Number(t3) || 0;
        var o2, a2, l2, c2, u2, h2, p2, d2 = this.length - t3;
        switch ((!r2 || d2 < (r2 = Number(r2))) && (r2 = d2), n2 = String(n2 || "utf8").toLowerCase()) {
          case "hex":
            o2 = function(e4, t4, r3, n3) {
              r3 = Number(r3) || 0;
              var s3 = e4.length - r3;
              (!n3 || s3 < (n3 = Number(n3))) && (n3 = s3);
              var o3 = t4.length;
              F(o3 % 2 == 0, "Invalid hex string"), o3 / 2 < n3 && (n3 = o3 / 2);
              for (var a3 = 0; a3 < n3; a3++) {
                var l3 = parseInt(t4.substr(2 * a3, 2), 16);
                F(!isNaN(l3), "Invalid hex string"), e4[r3 + a3] = l3;
              }
              return i._charsWritten = 2 * a3, a3;
            }(this, e3, t3, r2);
            break;
          case "utf8":
          case "utf-8":
            this, u2 = e3, h2 = t3, p2 = r2, o2 = i._charsWritten = P(k(u2), this, h2, p2);
            break;
          case "ascii":
          case "binary":
            o2 = function(e4, t4, r3, n3) {
              return i._charsWritten = P(function(e5) {
                for (var t5 = [], r4 = 0; r4 < e5.length; r4++)
                  t5.push(255 & e5.charCodeAt(r4));
                return t5;
              }(t4), e4, r3, n3);
            }(this, e3, t3, r2);
            break;
          case "base64":
            this, a2 = e3, l2 = t3, c2 = r2, o2 = i._charsWritten = P(D(a2), this, l2, c2);
            break;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            o2 = function(e4, t4, r3, n3) {
              return i._charsWritten = P(function(e5) {
                for (var t5, r4, n4, i2 = [], s3 = 0; s3 < e5.length; s3++)
                  r4 = (t5 = e5.charCodeAt(s3)) >> 8, n4 = t5 % 256, i2.push(n4), i2.push(r4);
                return i2;
              }(t4), e4, r3, n3);
            }(this, e3, t3, r2);
            break;
          default:
            throw new Error("Unknown encoding");
        }
        return o2;
      }, i.prototype.toString = function(e3, t3, r2) {
        var n2, i2, s2, o2, a2 = this;
        if (e3 = String(e3 || "utf8").toLowerCase(), t3 = Number(t3) || 0, (r2 = void 0 !== r2 ? Number(r2) : r2 = a2.length) === t3)
          return "";
        switch (e3) {
          case "hex":
            n2 = function(e4, t4, r3) {
              var n3 = e4.length;
              (!t4 || t4 < 0) && (t4 = 0), (!r3 || r3 < 0 || n3 < r3) && (r3 = n3);
              for (var i3 = "", s3 = t4; s3 < r3; s3++)
                i3 += I(e4[s3]);
              return i3;
            }(a2, t3, r2);
            break;
          case "utf8":
          case "utf-8":
            n2 = function(e4, t4, r3) {
              var n3 = "", i3 = "";
              r3 = Math.min(e4.length, r3);
              for (var s3 = t4; s3 < r3; s3++)
                e4[s3] <= 127 ? (n3 += B(i3) + String.fromCharCode(e4[s3]), i3 = "") : i3 += "%" + e4[s3].toString(16);
              return n3 + B(i3);
            }(a2, t3, r2);
            break;
          case "ascii":
          case "binary":
            n2 = function(e4, t4, r3) {
              var n3 = "";
              r3 = Math.min(e4.length, r3);
              for (var i3 = t4; i3 < r3; i3++)
                n3 += String.fromCharCode(e4[i3]);
              return n3;
            }(a2, t3, r2);
            break;
          case "base64":
            i2 = a2, o2 = r2, n2 = 0 === (s2 = t3) && o2 === i2.length ? h.fromByteArray(i2) : h.fromByteArray(i2.slice(s2, o2));
            break;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            n2 = function(e4, t4, r3) {
              for (var n3 = e4.slice(t4, r3), i3 = "", s3 = 0; s3 < n3.length; s3 += 2)
                i3 += String.fromCharCode(n3[s3] + 256 * n3[s3 + 1]);
              return i3;
            }(a2, t3, r2);
            break;
          default:
            throw new Error("Unknown encoding");
        }
        return n2;
      }, i.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      }, i.prototype.copy = function(e3, t3, r2, n2) {
        if (r2 = r2 || 0, n2 || 0 === n2 || (n2 = this.length), t3 = t3 || 0, n2 !== r2 && 0 !== e3.length && 0 !== this.length) {
          F(r2 <= n2, "sourceEnd < sourceStart"), F(0 <= t3 && t3 < e3.length, "targetStart out of bounds"), F(0 <= r2 && r2 < this.length, "sourceStart out of bounds"), F(0 <= n2 && n2 <= this.length, "sourceEnd out of bounds"), n2 > this.length && (n2 = this.length), e3.length - t3 < n2 - r2 && (n2 = e3.length - t3 + r2);
          var s2 = n2 - r2;
          if (s2 < 100 || !i._useTypedArrays)
            for (var o2 = 0; o2 < s2; o2++)
              e3[o2 + t3] = this[o2 + r2];
          else
            e3._set(this.subarray(r2, r2 + s2), t3);
        }
      }, i.prototype.slice = function(e3, t3) {
        var r2 = this.length;
        if (e3 = C(e3, r2, 0), t3 = C(t3, r2, r2), i._useTypedArrays)
          return i._augment(this.subarray(e3, t3));
        for (var n2 = t3 - e3, s2 = new i(n2, void 0, true), o2 = 0; o2 < n2; o2++)
          s2[o2] = this[o2 + e3];
        return s2;
      }, i.prototype.get = function(e3) {
        return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e3);
      }, i.prototype.set = function(e3, t3) {
        return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e3, t3);
      }, i.prototype.readUInt8 = function(e3, t3) {
        if (t3 || (F(null != e3, "missing offset"), F(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length))
          return this[e3];
      }, i.prototype.readUInt16LE = function(e3, t3) {
        return d(this, e3, true, t3);
      }, i.prototype.readUInt16BE = function(e3, t3) {
        return d(this, e3, false, t3);
      }, i.prototype.readUInt32LE = function(e3, t3) {
        return f(this, e3, true, t3);
      }, i.prototype.readUInt32BE = function(e3, t3) {
        return f(this, e3, false, t3);
      }, i.prototype.readInt8 = function(e3, t3) {
        if (t3 || (F(null != e3, "missing offset"), F(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length))
          return 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
      }, i.prototype.readInt16LE = function(e3, t3) {
        return m(this, e3, true, t3);
      }, i.prototype.readInt16BE = function(e3, t3) {
        return m(this, e3, false, t3);
      }, i.prototype.readInt32LE = function(e3, t3) {
        return _(this, e3, true, t3);
      }, i.prototype.readInt32BE = function(e3, t3) {
        return _(this, e3, false, t3);
      }, i.prototype.readFloatLE = function(e3, t3) {
        return g(this, e3, true, t3);
      }, i.prototype.readFloatBE = function(e3, t3) {
        return g(this, e3, false, t3);
      }, i.prototype.readDoubleLE = function(e3, t3) {
        return v(this, e3, true, t3);
      }, i.prototype.readDoubleBE = function(e3, t3) {
        return v(this, e3, false, t3);
      }, i.prototype.writeUInt8 = function(e3, t3, r2) {
        r2 || (F(null != e3, "missing value"), F(null != t3, "missing offset"), F(t3 < this.length, "trying to write beyond buffer length"), R(e3, 255)), t3 >= this.length || (this[t3] = e3);
      }, i.prototype.writeUInt16LE = function(e3, t3, r2) {
        A(this, e3, t3, true, r2);
      }, i.prototype.writeUInt16BE = function(e3, t3, r2) {
        A(this, e3, t3, false, r2);
      }, i.prototype.writeUInt32LE = function(e3, t3, r2) {
        b(this, e3, t3, true, r2);
      }, i.prototype.writeUInt32BE = function(e3, t3, r2) {
        b(this, e3, t3, false, r2);
      }, i.prototype.writeInt8 = function(e3, t3, r2) {
        r2 || (F(null != e3, "missing value"), F(null != t3, "missing offset"), F(t3 < this.length, "Trying to write beyond buffer length"), L(e3, 127, -128)), t3 >= this.length || (0 <= e3 ? this.writeUInt8(e3, t3, r2) : this.writeUInt8(255 + e3 + 1, t3, r2));
      }, i.prototype.writeInt16LE = function(e3, t3, r2) {
        y(this, e3, t3, true, r2);
      }, i.prototype.writeInt16BE = function(e3, t3, r2) {
        y(this, e3, t3, false, r2);
      }, i.prototype.writeInt32LE = function(e3, t3, r2) {
        x(this, e3, t3, true, r2);
      }, i.prototype.writeInt32BE = function(e3, t3, r2) {
        x(this, e3, t3, false, r2);
      }, i.prototype.writeFloatLE = function(e3, t3, r2) {
        w(this, e3, t3, true, r2);
      }, i.prototype.writeFloatBE = function(e3, t3, r2) {
        w(this, e3, t3, false, r2);
      }, i.prototype.writeDoubleLE = function(e3, t3, r2) {
        E(this, e3, t3, true, r2);
      }, i.prototype.writeDoubleBE = function(e3, t3, r2) {
        E(this, e3, t3, false, r2);
      }, i.prototype.fill = function(e3, t3, r2) {
        if (e3 = e3 || 0, t3 = t3 || 0, r2 = r2 || this.length, "string" == typeof e3 && (e3 = e3.charCodeAt(0)), F("number" == typeof e3 && !isNaN(e3), "value is not a number"), F(t3 <= r2, "end < start"), r2 !== t3 && 0 !== this.length) {
          F(0 <= t3 && t3 < this.length, "start out of bounds"), F(0 <= r2 && r2 <= this.length, "end out of bounds");
          for (var n2 = t3; n2 < r2; n2++)
            this[n2] = e3;
        }
      }, i.prototype.inspect = function() {
        for (var e3 = [], t3 = this.length, n2 = 0; n2 < t3; n2++)
          if (e3[n2] = I(this[n2]), n2 === r.INSPECT_MAX_BYTES) {
            e3[n2 + 1] = "...";
            break;
          }
        return "<Buffer " + e3.join(" ") + ">";
      }, i.prototype.toArrayBuffer = function() {
        if ("undefined" == typeof Uint8Array)
          throw new Error("Buffer.toArrayBuffer not supported in this browser");
        if (i._useTypedArrays)
          return new i(this).buffer;
        for (var e3 = new Uint8Array(this.length), t3 = 0, r2 = e3.length; t3 < r2; t3 += 1)
          e3[t3] = this[t3];
        return e3.buffer;
      };
      var S = i.prototype;
      function C(e3, t3, r2) {
        return "number" != typeof e3 ? r2 : t3 <= (e3 = ~~e3) ? t3 : 0 <= e3 || 0 <= (e3 += t3) ? e3 : 0;
      }
      function M(e3) {
        return (e3 = ~~Math.ceil(+e3)) < 0 ? 0 : e3;
      }
      function T(e3) {
        return (Array.isArray || function(e4) {
          return "[object Array]" === Object.prototype.toString.call(e4);
        })(e3);
      }
      function I(e3) {
        return e3 < 16 ? "0" + e3.toString(16) : e3.toString(16);
      }
      function k(e3) {
        for (var t3 = [], r2 = 0; r2 < e3.length; r2++) {
          var n2 = e3.charCodeAt(r2);
          if (n2 <= 127)
            t3.push(e3.charCodeAt(r2));
          else {
            var i2 = r2;
            55296 <= n2 && n2 <= 57343 && r2++;
            for (var s2 = encodeURIComponent(e3.slice(i2, r2 + 1)).substr(1).split("%"), o2 = 0; o2 < s2.length; o2++)
              t3.push(parseInt(s2[o2], 16));
          }
        }
        return t3;
      }
      function D(e3) {
        return h.toByteArray(e3);
      }
      function P(e3, t3, r2, n2) {
        for (var i2 = 0; i2 < n2 && !(i2 + r2 >= t3.length || i2 >= e3.length); i2++)
          t3[i2 + r2] = e3[i2];
        return i2;
      }
      function B(e3) {
        try {
          return decodeURIComponent(e3);
        } catch (e4) {
          return String.fromCharCode(65533);
        }
      }
      function R(e3, t3) {
        F("number" == typeof e3, "cannot write a non-number as a number"), F(0 <= e3, "specified a negative value for writing an unsigned value"), F(e3 <= t3, "value is larger than maximum value for type"), F(Math.floor(e3) === e3, "value has a fractional component");
      }
      function L(e3, t3, r2) {
        F("number" == typeof e3, "cannot write a non-number as a number"), F(e3 <= t3, "value larger than maximum allowed value"), F(r2 <= e3, "value smaller than minimum allowed value"), F(Math.floor(e3) === e3, "value has a fractional component");
      }
      function O(e3, t3, r2) {
        F("number" == typeof e3, "cannot write a non-number as a number"), F(e3 <= t3, "value larger than maximum allowed value"), F(r2 <= e3, "value smaller than minimum allowed value");
      }
      function F(e3, t3) {
        if (!e3)
          throw new Error(t3 || "Failed assertion");
      }
      i._augment = function(e3) {
        return e3._isBuffer = true, e3._get = e3.get, e3._set = e3.set, e3.get = S.get, e3.set = S.set, e3.write = S.write, e3.toString = S.toString, e3.toLocaleString = S.toString, e3.toJSON = S.toJSON, e3.copy = S.copy, e3.slice = S.slice, e3.readUInt8 = S.readUInt8, e3.readUInt16LE = S.readUInt16LE, e3.readUInt16BE = S.readUInt16BE, e3.readUInt32LE = S.readUInt32LE, e3.readUInt32BE = S.readUInt32BE, e3.readInt8 = S.readInt8, e3.readInt16LE = S.readInt16LE, e3.readInt16BE = S.readInt16BE, e3.readInt32LE = S.readInt32LE, e3.readInt32BE = S.readInt32BE, e3.readFloatLE = S.readFloatLE, e3.readFloatBE = S.readFloatBE, e3.readDoubleLE = S.readDoubleLE, e3.readDoubleBE = S.readDoubleBE, e3.writeUInt8 = S.writeUInt8, e3.writeUInt16LE = S.writeUInt16LE, e3.writeUInt16BE = S.writeUInt16BE, e3.writeUInt32LE = S.writeUInt32LE, e3.writeUInt32BE = S.writeUInt32BE, e3.writeInt8 = S.writeInt8, e3.writeInt16LE = S.writeInt16LE, e3.writeInt16BE = S.writeInt16BE, e3.writeInt32LE = S.writeInt32LE, e3.writeInt32BE = S.writeInt32BE, e3.writeFloatLE = S.writeFloatLE, e3.writeFloatBE = S.writeFloatBE, e3.writeDoubleLE = S.writeDoubleLE, e3.writeDoubleBE = S.writeDoubleBE, e3.fill = S.fill, e3.inspect = S.inspect, e3.toArrayBuffer = S.toArrayBuffer, e3;
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
  }, { "base64-js": 2, buffer: 3, ieee754: 11, lYpoI2: 10 }], 4: [function(e2, t, r) {
    (function(r2, n, i, s, o, a, l, c, u) {
      i = e2("buffer").Buffer;
      var h = new i(4);
      h.fill(0), t.exports = { hash: function(e3, t2, r3, n2) {
        return i.isBuffer(e3) || (e3 = new i(e3)), function(e4, t3, r4) {
          for (var n3 = new i(t3), s2 = r4 ? n3.writeInt32BE : n3.writeInt32LE, o2 = 0; o2 < e4.length; o2++)
            s2.call(n3, e4[o2], 4 * o2, true);
          return n3;
        }(t2(function(e4, t3) {
          var r4;
          e4.length % 4 != 0 && (r4 = e4.length + (4 - e4.length % 4), e4 = i.concat([e4, h], r4));
          for (var n3 = [], s2 = t3 ? e4.readInt32BE : e4.readInt32LE, o2 = 0; o2 < e4.length; o2 += 4)
            n3.push(s2.call(e4, o2));
          return n3;
        }(e3, n2), 8 * e3.length), r3, n2);
      } };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { buffer: 3, lYpoI2: 10 }], 5: [function(e2, t, r) {
    (function(t2, n, i, s, o, a, l, c, u) {
      i = e2("buffer").Buffer;
      var h = e2("./sha"), p = e2("./sha256"), d = e2("./rng"), f = { sha1: h, sha256: p, md5: e2("./md5") }, m = 64, _ = new i(m);
      function g(e3, t3) {
        var r2 = f[e3 = e3 || "sha1"], n2 = [];
        return r2 || v("algorithm:", e3, "is not yet supported"), { update: function(e4) {
          return i.isBuffer(e4) || (e4 = new i(e4)), n2.push(e4), e4.length, this;
        }, digest: function(e4) {
          var s2 = i.concat(n2), o2 = t3 ? function(e5, t4, r3) {
            i.isBuffer(t4) || (t4 = new i(t4)), i.isBuffer(r3) || (r3 = new i(r3)), t4.length > m ? t4 = e5(t4) : t4.length < m && (t4 = i.concat([t4, _], m));
            for (var n3 = new i(m), s3 = new i(m), o3 = 0; o3 < m; o3++)
              n3[o3] = 54 ^ t4[o3], s3[o3] = 92 ^ t4[o3];
            var a2 = e5(i.concat([n3, r3]));
            return e5(i.concat([s3, a2]));
          }(r2, t3, s2) : r2(s2);
          return n2 = null, e4 ? o2.toString(e4) : o2;
        } };
      }
      function v() {
        var e3 = [].slice.call(arguments).join(" ");
        throw new Error([e3, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
      }
      _.fill(0), r.createHash = function(e3) {
        return g(e3);
      }, r.createHmac = g, r.randomBytes = function(e3, t3) {
        if (!t3 || !t3.call)
          return new i(d(e3));
        try {
          t3.call(this, void 0, new i(d(e3)));
        } catch (e4) {
          t3(e4);
        }
      }, function(e3, t3) {
        for (var r2 in e3)
          t3(e3[r2]);
      }(["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], function(e3) {
        r[e3] = function() {
          v("sorry,", e3, "is not implemented yet");
        };
      });
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 10 }], 6: [function(e2, t, r) {
    (function(r2, n, i, s, o, a, l, c, u) {
      var h = e2("./helpers");
      function p(e3, t2) {
        e3[t2 >> 5] |= 128 << t2 % 32, e3[14 + (t2 + 64 >>> 9 << 4)] = t2;
        for (var r3 = 1732584193, n2 = -271733879, i2 = -1732584194, s2 = 271733878, o2 = 0; o2 < e3.length; o2 += 16) {
          var a2 = r3, l2 = n2, c2 = i2, u2 = s2;
          r3 = f(r3, n2, i2, s2, e3[o2 + 0], 7, -680876936), s2 = f(s2, r3, n2, i2, e3[o2 + 1], 12, -389564586), i2 = f(i2, s2, r3, n2, e3[o2 + 2], 17, 606105819), n2 = f(n2, i2, s2, r3, e3[o2 + 3], 22, -1044525330), r3 = f(r3, n2, i2, s2, e3[o2 + 4], 7, -176418897), s2 = f(s2, r3, n2, i2, e3[o2 + 5], 12, 1200080426), i2 = f(i2, s2, r3, n2, e3[o2 + 6], 17, -1473231341), n2 = f(n2, i2, s2, r3, e3[o2 + 7], 22, -45705983), r3 = f(r3, n2, i2, s2, e3[o2 + 8], 7, 1770035416), s2 = f(s2, r3, n2, i2, e3[o2 + 9], 12, -1958414417), i2 = f(i2, s2, r3, n2, e3[o2 + 10], 17, -42063), n2 = f(n2, i2, s2, r3, e3[o2 + 11], 22, -1990404162), r3 = f(r3, n2, i2, s2, e3[o2 + 12], 7, 1804603682), s2 = f(s2, r3, n2, i2, e3[o2 + 13], 12, -40341101), i2 = f(i2, s2, r3, n2, e3[o2 + 14], 17, -1502002290), r3 = m(r3, n2 = f(n2, i2, s2, r3, e3[o2 + 15], 22, 1236535329), i2, s2, e3[o2 + 1], 5, -165796510), s2 = m(s2, r3, n2, i2, e3[o2 + 6], 9, -1069501632), i2 = m(i2, s2, r3, n2, e3[o2 + 11], 14, 643717713), n2 = m(n2, i2, s2, r3, e3[o2 + 0], 20, -373897302), r3 = m(r3, n2, i2, s2, e3[o2 + 5], 5, -701558691), s2 = m(s2, r3, n2, i2, e3[o2 + 10], 9, 38016083), i2 = m(i2, s2, r3, n2, e3[o2 + 15], 14, -660478335), n2 = m(n2, i2, s2, r3, e3[o2 + 4], 20, -405537848), r3 = m(r3, n2, i2, s2, e3[o2 + 9], 5, 568446438), s2 = m(s2, r3, n2, i2, e3[o2 + 14], 9, -1019803690), i2 = m(i2, s2, r3, n2, e3[o2 + 3], 14, -187363961), n2 = m(n2, i2, s2, r3, e3[o2 + 8], 20, 1163531501), r3 = m(r3, n2, i2, s2, e3[o2 + 13], 5, -1444681467), s2 = m(s2, r3, n2, i2, e3[o2 + 2], 9, -51403784), i2 = m(i2, s2, r3, n2, e3[o2 + 7], 14, 1735328473), r3 = _(r3, n2 = m(n2, i2, s2, r3, e3[o2 + 12], 20, -1926607734), i2, s2, e3[o2 + 5], 4, -378558), s2 = _(s2, r3, n2, i2, e3[o2 + 8], 11, -2022574463), i2 = _(i2, s2, r3, n2, e3[o2 + 11], 16, 1839030562), n2 = _(n2, i2, s2, r3, e3[o2 + 14], 23, -35309556), r3 = _(r3, n2, i2, s2, e3[o2 + 1], 4, -1530992060), s2 = _(s2, r3, n2, i2, e3[o2 + 4], 11, 1272893353), i2 = _(i2, s2, r3, n2, e3[o2 + 7], 16, -155497632), n2 = _(n2, i2, s2, r3, e3[o2 + 10], 23, -1094730640), r3 = _(r3, n2, i2, s2, e3[o2 + 13], 4, 681279174), s2 = _(s2, r3, n2, i2, e3[o2 + 0], 11, -358537222), i2 = _(i2, s2, r3, n2, e3[o2 + 3], 16, -722521979), n2 = _(n2, i2, s2, r3, e3[o2 + 6], 23, 76029189), r3 = _(r3, n2, i2, s2, e3[o2 + 9], 4, -640364487), s2 = _(s2, r3, n2, i2, e3[o2 + 12], 11, -421815835), i2 = _(i2, s2, r3, n2, e3[o2 + 15], 16, 530742520), r3 = g(r3, n2 = _(n2, i2, s2, r3, e3[o2 + 2], 23, -995338651), i2, s2, e3[o2 + 0], 6, -198630844), s2 = g(s2, r3, n2, i2, e3[o2 + 7], 10, 1126891415), i2 = g(i2, s2, r3, n2, e3[o2 + 14], 15, -1416354905), n2 = g(n2, i2, s2, r3, e3[o2 + 5], 21, -57434055), r3 = g(r3, n2, i2, s2, e3[o2 + 12], 6, 1700485571), s2 = g(s2, r3, n2, i2, e3[o2 + 3], 10, -1894986606), i2 = g(i2, s2, r3, n2, e3[o2 + 10], 15, -1051523), n2 = g(n2, i2, s2, r3, e3[o2 + 1], 21, -2054922799), r3 = g(r3, n2, i2, s2, e3[o2 + 8], 6, 1873313359), s2 = g(s2, r3, n2, i2, e3[o2 + 15], 10, -30611744), i2 = g(i2, s2, r3, n2, e3[o2 + 6], 15, -1560198380), n2 = g(n2, i2, s2, r3, e3[o2 + 13], 21, 1309151649), r3 = g(r3, n2, i2, s2, e3[o2 + 4], 6, -145523070), s2 = g(s2, r3, n2, i2, e3[o2 + 11], 10, -1120210379), i2 = g(i2, s2, r3, n2, e3[o2 + 2], 15, 718787259), n2 = g(n2, i2, s2, r3, e3[o2 + 9], 21, -343485551), r3 = v(r3, a2), n2 = v(n2, l2), i2 = v(i2, c2), s2 = v(s2, u2);
        }
        return Array(r3, n2, i2, s2);
      }
      function d(e3, t2, r3, n2, i2, s2) {
        return v((o2 = v(v(t2, e3), v(n2, s2))) << (a2 = i2) | o2 >>> 32 - a2, r3);
        var o2, a2;
      }
      function f(e3, t2, r3, n2, i2, s2, o2) {
        return d(t2 & r3 | ~t2 & n2, e3, t2, i2, s2, o2);
      }
      function m(e3, t2, r3, n2, i2, s2, o2) {
        return d(t2 & n2 | r3 & ~n2, e3, t2, i2, s2, o2);
      }
      function _(e3, t2, r3, n2, i2, s2, o2) {
        return d(t2 ^ r3 ^ n2, e3, t2, i2, s2, o2);
      }
      function g(e3, t2, r3, n2, i2, s2, o2) {
        return d(r3 ^ (t2 | ~n2), e3, t2, i2, s2, o2);
      }
      function v(e3, t2) {
        var r3 = (65535 & e3) + (65535 & t2);
        return (e3 >> 16) + (t2 >> 16) + (r3 >> 16) << 16 | 65535 & r3;
      }
      t.exports = function(e3) {
        return h.hash(e3, p, 16);
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 7: [function(e2, t, r) {
    (function(e3, r2, n, i, s, o, a, l, c) {
      var u;
      u = function(e4) {
        for (var t2, r3 = new Array(e4), n2 = 0; n2 < e4; n2++)
          0 == (3 & n2) && (t2 = 4294967296 * Math.random()), r3[n2] = t2 >>> ((3 & n2) << 3) & 255;
        return r3;
      }, t.exports = u;
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { buffer: 3, lYpoI2: 10 }], 8: [function(e2, t, r) {
    (function(r2, n, i, s, o, a, l, c, u) {
      var h = e2("./helpers");
      function p(e3, t2) {
        e3[t2 >> 5] |= 128 << 24 - t2 % 32, e3[15 + (t2 + 64 >> 9 << 4)] = t2;
        for (var r3, n2, i2, s2, o2, a2 = Array(80), l2 = 1732584193, c2 = -271733879, u2 = -1732584194, h2 = 271733878, p2 = -1009589776, m = 0; m < e3.length; m += 16) {
          for (var _ = l2, g = c2, v = u2, A = h2, b = p2, y = 0; y < 80; y++) {
            a2[y] = y < 16 ? e3[m + y] : f(a2[y - 3] ^ a2[y - 8] ^ a2[y - 14] ^ a2[y - 16], 1);
            var x = d(d(f(l2, 5), (i2 = c2, s2 = u2, o2 = h2, (n2 = y) < 20 ? i2 & s2 | ~i2 & o2 : !(n2 < 40) && n2 < 60 ? i2 & s2 | i2 & o2 | s2 & o2 : i2 ^ s2 ^ o2)), d(d(p2, a2[y]), (r3 = y) < 20 ? 1518500249 : r3 < 40 ? 1859775393 : r3 < 60 ? -1894007588 : -899497514));
            p2 = h2, h2 = u2, u2 = f(c2, 30), c2 = l2, l2 = x;
          }
          l2 = d(l2, _), c2 = d(c2, g), u2 = d(u2, v), h2 = d(h2, A), p2 = d(p2, b);
        }
        return Array(l2, c2, u2, h2, p2);
      }
      function d(e3, t2) {
        var r3 = (65535 & e3) + (65535 & t2);
        return (e3 >> 16) + (t2 >> 16) + (r3 >> 16) << 16 | 65535 & r3;
      }
      function f(e3, t2) {
        return e3 << t2 | e3 >>> 32 - t2;
      }
      t.exports = function(e3) {
        return h.hash(e3, p, 20, true);
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 9: [function(e2, t, r) {
    (function(r2, n, i, s, o, a, l, c, u) {
      function h(e3, t2) {
        var r3 = (65535 & e3) + (65535 & t2);
        return (e3 >> 16) + (t2 >> 16) + (r3 >> 16) << 16 | 65535 & r3;
      }
      function p(e3, t2) {
        return e3 >>> t2 | e3 << 32 - t2;
      }
      function d(e3, t2) {
        var r3, n2, i2, s2, o2, a2, l2, c2, u2, d2, f2 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), m = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), _ = new Array(64);
        e3[t2 >> 5] |= 128 << 24 - t2 % 32, e3[15 + (t2 + 64 >> 9 << 4)] = t2;
        for (var g, v, A, b, y, x, w, E, S = 0; S < e3.length; S += 16) {
          r3 = m[0], n2 = m[1], i2 = m[2], s2 = m[3], o2 = m[4], a2 = m[5], l2 = m[6], c2 = m[7];
          for (var C = 0; C < 64; C++)
            _[C] = C < 16 ? e3[C + S] : h(h(h(p(E = _[C - 2], 17) ^ p(E, 19) ^ E >>> 10, _[C - 7]), p(w = _[C - 15], 7) ^ p(w, 18) ^ w >>> 3), _[C - 16]), u2 = h(h(h(h(c2, p(x = o2, 6) ^ p(x, 11) ^ p(x, 25)), (y = o2) & a2 ^ ~y & l2), f2[C]), _[C]), d2 = h(p(b = r3, 2) ^ p(b, 13) ^ p(b, 22), (g = r3) & (v = n2) ^ g & (A = i2) ^ v & A), c2 = l2, l2 = a2, a2 = o2, o2 = h(s2, u2), s2 = i2, i2 = n2, n2 = r3, r3 = h(u2, d2);
          m[0] = h(r3, m[0]), m[1] = h(n2, m[1]), m[2] = h(i2, m[2]), m[3] = h(s2, m[3]), m[4] = h(o2, m[4]), m[5] = h(a2, m[5]), m[6] = h(l2, m[6]), m[7] = h(c2, m[7]);
        }
        return m;
      }
      var f = e2("./helpers");
      t.exports = function(e3) {
        return f.hash(e3, d, 32, true);
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
  }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 10: [function(e2, t, r) {
    (function(e3, r2, n, i, s, o, a, l, c) {
      function u() {
      }
      (e3 = t.exports = {}).nextTick = function() {
        var e4 = "undefined" != typeof window && window.setImmediate, t2 = "undefined" != typeof window && window.postMessage && window.addEventListener;
        if (e4)
          return function(e5) {
            return window.setImmediate(e5);
          };
        if (t2) {
          var r3 = [];
          return window.addEventListener("message", function(e5) {
            var t3 = e5.source;
            t3 !== window && null !== t3 || "process-tick" !== e5.data || (e5.stopPropagation(), 0 < r3.length && r3.shift()());
          }, true), function(e5) {
            r3.push(e5), window.postMessage("process-tick", "*");
          };
        }
        return function(e5) {
          setTimeout(e5, 0);
        };
      }(), e3.title = "browser", e3.browser = true, e3.env = {}, e3.argv = [], e3.on = u, e3.addListener = u, e3.once = u, e3.off = u, e3.removeListener = u, e3.removeAllListeners = u, e3.emit = u, e3.binding = function(e4) {
        throw new Error("process.binding is not supported");
      }, e3.cwd = function() {
        return "/";
      }, e3.chdir = function(e4) {
        throw new Error("process.chdir is not supported");
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
  }, { buffer: 3, lYpoI2: 10 }], 11: [function(e2, t, r) {
    (function(e3, t2, n, i, s, o, a, l, c) {
      r.read = function(e4, t3, r2, n2, i2) {
        var s2, o2, a2 = 8 * i2 - n2 - 1, l2 = (1 << a2) - 1, c2 = l2 >> 1, u = -7, h = r2 ? i2 - 1 : 0, p = r2 ? -1 : 1, d = e4[t3 + h];
        for (h += p, s2 = d & (1 << -u) - 1, d >>= -u, u += a2; 0 < u; s2 = 256 * s2 + e4[t3 + h], h += p, u -= 8)
          ;
        for (o2 = s2 & (1 << -u) - 1, s2 >>= -u, u += n2; 0 < u; o2 = 256 * o2 + e4[t3 + h], h += p, u -= 8)
          ;
        if (0 === s2)
          s2 = 1 - c2;
        else {
          if (s2 === l2)
            return o2 ? NaN : 1 / 0 * (d ? -1 : 1);
          o2 += Math.pow(2, n2), s2 -= c2;
        }
        return (d ? -1 : 1) * o2 * Math.pow(2, s2 - n2);
      }, r.write = function(e4, t3, r2, n2, i2, s2) {
        var o2, a2, l2, c2 = 8 * s2 - i2 - 1, u = (1 << c2) - 1, h = u >> 1, p = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = n2 ? 0 : s2 - 1, f = n2 ? 1 : -1, m = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
        for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a2 = isNaN(t3) ? 1 : 0, o2 = u) : (o2 = Math.floor(Math.log(t3) / Math.LN2), t3 * (l2 = Math.pow(2, -o2)) < 1 && (o2--, l2 *= 2), 2 <= (t3 += 1 <= o2 + h ? p / l2 : p * Math.pow(2, 1 - h)) * l2 && (o2++, l2 /= 2), u <= o2 + h ? (a2 = 0, o2 = u) : 1 <= o2 + h ? (a2 = (t3 * l2 - 1) * Math.pow(2, i2), o2 += h) : (a2 = t3 * Math.pow(2, h - 1) * Math.pow(2, i2), o2 = 0)); 8 <= i2; e4[r2 + d] = 255 & a2, d += f, a2 /= 256, i2 -= 8)
          ;
        for (o2 = o2 << i2 | a2, c2 += i2; 0 < c2; e4[r2 + d] = 255 & o2, d += f, o2 /= 256, c2 -= 8)
          ;
        e4[r2 + d - f] |= 128 * m;
      };
    }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/ieee754/index.js", "/node_modules/ieee754");
  }, { buffer: 3, lYpoI2: 10 }] }, {}, [1])(1);
}, 654: function(e) {
  var t = function() {
    function e2(e3) {
      return l(e3, c(a(u(e3.length), e3), 1 / e3.length));
    }
    function t2(e3) {
      return a(h(e3), e3);
    }
    function r(e3, t3) {
      return c(e3, t3 ? 1 / (e3.length - 1) : 1 / e3.length);
    }
    function n(e3) {
      var t3 = function(e4) {
        var t4, r3 = Math.pow(2, -52), n2 = 1e-64 / r3, i2 = 0, s2 = 0, o2 = 0, a2 = 0, l2 = 0, c2 = p(e4), u2 = c2.length, h2 = c2[0].length;
        if (u2 < h2)
          throw "Need more rows than columns";
        var d = new Array(h2), f = new Array(h2);
        for (s2 = 0; s2 < h2; s2++)
          d[s2] = f[s2] = 0;
        var m = function e5(t5, r4, n3) {
          void 0 === n3 && (n3 = 0);
          var i3, s3 = t5[n3], o3 = Array(s3);
          if (n3 === t5.length - 1) {
            for (i3 = s3 - 2; i3 >= 0; i3 -= 2)
              o3[i3 + 1] = r4, o3[i3] = r4;
            return -1 === i3 && (o3[0] = r4), o3;
          }
          for (i3 = s3 - 1; i3 >= 0; i3--)
            o3[i3] = e5(t5, r4, n3 + 1);
          return o3;
        }([h2, h2], 0);
        function _(e5, t5) {
          return (e5 = Math.abs(e5)) > (t5 = Math.abs(t5)) ? e5 * Math.sqrt(1 + t5 * t5 / e5 / e5) : 0 == t5 ? e5 : t5 * Math.sqrt(1 + e5 * e5 / t5 / t5);
        }
        var g = 0, v = 0, A = 0, b = 0, y = 0, x = 0, w = 0;
        for (s2 = 0; s2 < h2; s2++) {
          for (d[s2] = v, w = 0, l2 = s2 + 1, o2 = s2; o2 < u2; o2++)
            w += c2[o2][s2] * c2[o2][s2];
          if (w <= n2)
            v = 0;
          else
            for (g = c2[s2][s2], v = Math.sqrt(w), g >= 0 && (v = -v), A = g * v - w, c2[s2][s2] = g - v, o2 = l2; o2 < h2; o2++) {
              for (w = 0, a2 = s2; a2 < u2; a2++)
                w += c2[a2][s2] * c2[a2][o2];
              for (g = w / A, a2 = s2; a2 < u2; a2++)
                c2[a2][o2] += g * c2[a2][s2];
            }
          for (f[s2] = v, w = 0, o2 = l2; o2 < h2; o2++)
            w += c2[s2][o2] * c2[s2][o2];
          if (w <= n2)
            v = 0;
          else {
            for (g = c2[s2][s2 + 1], v = Math.sqrt(w), g >= 0 && (v = -v), A = g * v - w, c2[s2][s2 + 1] = g - v, o2 = l2; o2 < h2; o2++)
              d[o2] = c2[s2][o2] / A;
            for (o2 = l2; o2 < u2; o2++) {
              for (w = 0, a2 = l2; a2 < h2; a2++)
                w += c2[o2][a2] * c2[s2][a2];
              for (a2 = l2; a2 < h2; a2++)
                c2[o2][a2] += w * d[a2];
            }
          }
          (y = Math.abs(f[s2]) + Math.abs(d[s2])) > b && (b = y);
        }
        for (s2 = h2 - 1; -1 != s2; s2 += -1) {
          if (0 != v) {
            for (A = v * c2[s2][s2 + 1], o2 = l2; o2 < h2; o2++)
              m[o2][s2] = c2[s2][o2] / A;
            for (o2 = l2; o2 < h2; o2++) {
              for (w = 0, a2 = l2; a2 < h2; a2++)
                w += c2[s2][a2] * m[a2][o2];
              for (a2 = l2; a2 < h2; a2++)
                m[a2][o2] += w * m[a2][s2];
            }
          }
          for (o2 = l2; o2 < h2; o2++)
            m[s2][o2] = 0, m[o2][s2] = 0;
          m[s2][s2] = 1, v = d[s2], l2 = s2;
        }
        for (s2 = h2 - 1; -1 != s2; s2 += -1) {
          for (l2 = s2 + 1, v = f[s2], o2 = l2; o2 < h2; o2++)
            c2[s2][o2] = 0;
          if (0 != v) {
            for (A = c2[s2][s2] * v, o2 = l2; o2 < h2; o2++) {
              for (w = 0, a2 = l2; a2 < u2; a2++)
                w += c2[a2][s2] * c2[a2][o2];
              for (g = w / A, a2 = s2; a2 < u2; a2++)
                c2[a2][o2] += g * c2[a2][s2];
            }
            for (o2 = s2; o2 < u2; o2++)
              c2[o2][s2] = c2[o2][s2] / v;
          } else
            for (o2 = s2; o2 < u2; o2++)
              c2[o2][s2] = 0;
          c2[s2][s2] += 1;
        }
        for (r3 *= b, a2 = h2 - 1; -1 != a2; a2 += -1)
          for (var E = 0; E < 50; E++) {
            var S = false;
            for (l2 = a2; -1 != l2; l2 += -1) {
              if (Math.abs(d[l2]) <= r3) {
                S = true;
                break;
              }
              if (Math.abs(f[l2 - 1]) <= r3)
                break;
            }
            if (!S) {
              i2 = 0, w = 1;
              var C = l2 - 1;
              for (s2 = l2; s2 < a2 + 1 && (g = w * d[s2], d[s2] = i2 * d[s2], !(Math.abs(g) <= r3)); s2++)
                for (A = _(g, v = f[s2]), f[s2] = A, i2 = v / A, w = -g / A, o2 = 0; o2 < u2; o2++)
                  y = c2[o2][C], x = c2[o2][s2], c2[o2][C] = y * i2 + x * w, c2[o2][s2] = -y * w + x * i2;
            }
            if (x = f[a2], l2 == a2) {
              if (x < 0)
                for (f[a2] = -x, o2 = 0; o2 < h2; o2++)
                  m[o2][a2] = -m[o2][a2];
              break;
            }
            if (E >= 49)
              throw "Error: no convergence.";
            for (b = f[l2], v = _(g = (((y = f[a2 - 1]) - x) * (y + x) + ((v = d[a2 - 1]) - (A = d[a2])) * (v + A)) / (2 * A * y), 1), g = g < 0 ? ((b - x) * (b + x) + A * (y / (g - v) - A)) / b : ((b - x) * (b + x) + A * (y / (g + v) - A)) / b, i2 = 1, w = 1, s2 = l2 + 1; s2 < a2 + 1; s2++) {
              for (v = d[s2], y = f[s2], A = w * v, v *= i2, x = _(g, A), d[s2 - 1] = x, g = b * (i2 = g / x) + v * (w = A / x), v = -b * w + v * i2, A = y * w, y *= i2, o2 = 0; o2 < h2; o2++)
                b = m[o2][s2 - 1], x = m[o2][s2], m[o2][s2 - 1] = b * i2 + x * w, m[o2][s2] = -b * w + x * i2;
              for (x = _(g, A), f[s2 - 1] = x, g = (i2 = g / x) * v + (w = A / x) * y, b = -w * v + i2 * y, o2 = 0; o2 < u2; o2++)
                y = c2[o2][s2 - 1], x = c2[o2][s2], c2[o2][s2 - 1] = y * i2 + x * w, c2[o2][s2] = -y * w + x * i2;
            }
            d[l2] = 0, d[a2] = g, f[a2] = b;
          }
        for (s2 = 0; s2 < f.length; s2++)
          f[s2] < r3 && (f[s2] = 0);
        for (s2 = 0; s2 < h2; s2++)
          for (o2 = s2 - 1; o2 >= 0; o2--)
            if (f[o2] < f[s2]) {
              for (i2 = f[o2], f[o2] = f[s2], f[s2] = i2, a2 = 0; a2 < c2.length; a2++)
                t4 = c2[a2][s2], c2[a2][s2] = c2[a2][o2], c2[a2][o2] = t4;
              for (a2 = 0; a2 < m.length; a2++)
                t4 = m[a2][s2], m[a2][s2] = m[a2][o2], m[a2][o2] = t4;
              s2 = o2;
            }
        return { U: c2, S: f, V: m };
      }(e3);
      console.log(t3);
      var r2 = t3.U;
      return t3.S.map(function(e4, t4) {
        var n2 = {};
        return n2.eigenvalue = e4, n2.vector = r2.map(function(e5, r3) {
          return -1 * e5[t4];
        }), n2;
      });
    }
    function i(t3, ...r2) {
      var n2 = r2.map(function(e3) {
        return e3.vector;
      }), i2 = a(n2, h(e2(t3))), s2 = c(a(u(t3.length), t3), -1 / t3.length);
      return { adjustedData: i2, formattedAdjustedData: o(i2, 2), avgData: s2, selectedVectors: n2 };
    }
    function s(i2) {
      return n(r(t2(e2(i2)), false));
    }
    function o(e3, t3) {
      var r2 = Math.pow(10, t3 || 2);
      return e3.map(function(e4, t4) {
        return e4.map(function(e5) {
          return Math.round(e5 * r2) / r2;
        });
      });
    }
    function a(e3, t3) {
      if (!(e3[0] && t3[0] && e3.length && t3.length))
        throw new Error("Both A and B should be matrices");
      if (t3.length !== e3[0].length)
        throw new Error("Columns in A should be the same as the number of rows in B");
      for (var r2 = [], n2 = 0; n2 < e3.length; n2++) {
        r2[n2] = [];
        for (var i2 = 0; i2 < t3[0].length; i2++)
          for (var s2 = 0; s2 < e3[0].length; s2++)
            r2[n2][i2] = r2[n2][i2] ? r2[n2][i2] + e3[n2][s2] * t3[s2][i2] : e3[n2][s2] * t3[s2][i2];
      }
      return r2;
    }
    function l(e3, t3) {
      if (e3.length !== t3.length || e3[0].length !== t3[0].length)
        throw new Error("Both A and B should have the same dimensions");
      for (var r2 = [], n2 = 0; n2 < e3.length; n2++) {
        r2[n2] = [];
        for (var i2 = 0; i2 < t3[0].length; i2++)
          r2[n2][i2] = e3[n2][i2] - t3[n2][i2];
      }
      return r2;
    }
    function c(e3, t3) {
      for (var r2 = [], n2 = 0; n2 < e3.length; n2++) {
        r2[n2] = [];
        for (var i2 = 0; i2 < e3[0].length; i2++)
          r2[n2][i2] = e3[n2][i2] * t3;
      }
      return r2;
    }
    function u(e3) {
      for (var t3 = [], r2 = 0; r2 < e3; r2++) {
        t3[r2] = [];
        for (var n2 = 0; n2 < e3; n2++)
          t3[r2][n2] = 1;
      }
      return t3;
    }
    function h(e3) {
      return p(e3)[0].map(function(t3, r2) {
        return e3.map(function(e4) {
          return e4[r2];
        });
      });
    }
    function p(e3) {
      var t3 = JSON.stringify(e3);
      return JSON.parse(t3);
    }
    return { computeDeviationScores: t2, computeDeviationMatrix: e2, computeSVD: n, computePercentageExplained: function(e3, ...t3) {
      var r2 = e3.map(function(e4) {
        return e4.eigenvalue;
      }).reduce(function(e4, t4) {
        return e4 + t4;
      });
      return t3.map(function(e4) {
        return e4.eigenvalue;
      }).reduce(function(e4, t4) {
        return e4 + t4;
      }) / r2;
    }, computeOriginalData: function(e3, t3, r2) {
      var n2 = l(h(a(h(t3), e3)), r2);
      return { originalData: n2, formattedOriginalData: o(n2, 2) };
    }, computeVarianceCovariance: r, computeAdjustedData: i, getEigenVectors: s, analyseTopResult: function(e3) {
      var t3 = s(e3).sort(function(e4, t4) {
        return t4.eigenvalue - e4.eigenvalue;
      });
      return console.log("Sorted Vectors", t3), i(e3, t3[0].vector);
    }, transpose: h, multiply: a, clone: p, scale: c };
  }();
  e.exports = t;
}, 701: function(e) {
  var t = [];
  function r(e2) {
    for (var r2 = -1, n2 = 0; n2 < t.length; n2++)
      if (t[n2].identifier === e2) {
        r2 = n2;
        break;
      }
    return r2;
  }
  function n(e2, n2) {
    for (var s = {}, o = [], a = 0; a < e2.length; a++) {
      var l = e2[a], c = n2.base ? l[0] + n2.base : l[0], u = s[c] || 0, h = "".concat(c, " ").concat(u);
      s[c] = u + 1;
      var p = r(h), d = { css: l[1], media: l[2], sourceMap: l[3], supports: l[4], layer: l[5] };
      if (-1 !== p)
        t[p].references++, t[p].updater(d);
      else {
        var f = i(d, n2);
        n2.byIndex = a, t.splice(a, 0, { identifier: h, updater: f, references: 1 });
      }
      o.push(h);
    }
    return o;
  }
  function i(e2, t2) {
    var r2 = t2.domAPI(t2);
    return r2.update(e2), function(t3) {
      if (t3) {
        if (t3.css === e2.css && t3.media === e2.media && t3.sourceMap === e2.sourceMap && t3.supports === e2.supports && t3.layer === e2.layer)
          return;
        r2.update(e2 = t3);
      } else
        r2.remove();
    };
  }
  e.exports = function(e2, i2) {
    var s = n(e2 = e2 || [], i2 = i2 || {});
    return function(e3) {
      e3 = e3 || [];
      for (var o = 0; o < s.length; o++) {
        var a = r(s[o]);
        t[a].references--;
      }
      for (var l = n(e3, i2), c = 0; c < s.length; c++) {
        var u = r(s[c]);
        0 === t[u].references && (t[u].updater(), t.splice(u, 1));
      }
      s = l;
    };
  };
}, 182: function(e) {
  e.exports = function(e2) {
    var t = document.createElement("style");
    return e2.setAttributes(t, e2.attributes), e2.insert(t, e2.options), t;
  };
}, 850: function(e, t, r) {
  e.exports = function(e2) {
    var t2 = r.nc;
    t2 && e2.setAttribute("nonce", t2);
  };
}, 236: function(e) {
  e.exports = function(e2) {
    var t = e2.insertStyleElement(e2);
    return { update: function(r) {
      !function(e3, t2, r2) {
        var n = "";
        r2.supports && (n += "@supports (".concat(r2.supports, ") {")), r2.media && (n += "@media ".concat(r2.media, " {"));
        var i = void 0 !== r2.layer;
        i && (n += "@layer".concat(r2.layer.length > 0 ? " ".concat(r2.layer) : "", " {")), n += r2.css, i && (n += "}"), r2.media && (n += "}"), r2.supports && (n += "}");
        var s = r2.sourceMap;
        s && "undefined" != typeof btoa && (n += "\n/", n += "*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s)))), " *"), n += "/"), t2.styleTagTransform(n, e3, t2.options);
      }(t, e2, r);
    }, remove: function() {
      !function(e3) {
        if (null === e3.parentNode)
          return false;
        e3.parentNode.removeChild(e3);
      }(t);
    } };
  };
}, 213: function(e) {
  e.exports = function(e2, t) {
    if (t.styleSheet)
      t.styleSheet.cssText = e2;
    else {
      for (; t.firstChild; )
        t.removeChild(t.firstChild);
      t.appendChild(document.createTextNode(e2));
    }
  };
}, 1: function(e) {
  self, e.exports = function() {
    var e2 = { 820: function(e3, t2, r2) {
      var n2 = r2(537), i = r2.n(n2), s = r2(645), o = r2.n(s)()(i());
      o.push([e3.id, ".treejs {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  font-size: 14px;\n  margin-left: -18px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.treejs *:after,\n.treejs *:before {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.treejs > .treejs-node {\n  padding-left: 0;\n}\n.treejs .treejs-nodes {\n  list-style: none;\n  padding-left: 18px;\n  margin: 0;\n  overflow: hidden;\n  -webkit-transition: height 150ms ease-out, opacity 150ms ease-out;\n  -o-transition: height 150ms ease-out, opacity 150ms ease-out;\n  transition: height 150ms ease-out, opacity 150ms ease-out;\n}\n.treejs .treejs-node {\n  cursor: pointer;\n  overflow: hidden;\n}\n.treejs .treejs-node.treejs-placeholder {\n  padding-left: 18px;\n}\n.treejs .treejs-switcher {\n  display: inline-block;\n  vertical-align: middle;\n  width: 20px;\n  height: 20px;\n  cursor: pointer;\n  position: relative;\n  -webkit-transition: -webkit-transform 150ms ease-out;\n  transition: -webkit-transform 150ms ease-out;\n  -o-transition: transform 150ms ease-out;\n  transition: transform 150ms ease-out;\n  transition: transform 150ms ease-out, -webkit-transform 150ms ease-out;\n}\n.treejs .treejs-switcher:before {\n  position: absolute;\n  top: 8px;\n  left: 6px;\n  display: block;\n  content: ' ';\n  border: 4px solid transparent;\n  border-top: 4px solid rgba(245, 245, 245, 0.7);\n  -webkit-transition: border-color 150ms;\n  -o-transition: border-color 150ms;\n  transition: border-color 150ms;\n}\n.treejs .treejs-switcher:hover:before {\n  border-top: 4px solid rgba(245, 245, 245, 0.96);\n}\n.treejs .treejs-node__close > .treejs-switcher {\n  -webkit-transform: rotate(-90deg);\n      -ms-transform: rotate(-90deg);\n          transform: rotate(-90deg);\n}\n.treejs .treejs-node__close > .treejs-nodes {\n  height: 0;\n}\n.treejs .treejs-checkbox {\n  display: inline-block;\n  vertical-align: middle;\n  width: 20px;\n  height: 20px;\n  cursor: pointer;\n  position: relative;\n}\n.treejs .treejs-checkbox:before {\n  -webkit-transition: all 0.3s;\n  -o-transition: all 0.3s;\n  transition: all 0.3s;\n  cursor: pointer;\n  position: absolute;\n  top: 2px;\n  content: ' ';\n  display: block;\n  width: 16px;\n  height: 16px;\n  border: 1px solid #d9d9d9;\n  border-radius: 2px;\n}\n.treejs .treejs-checkbox:hover:before {\n  -webkit-box-shadow: 0 0 2px 1px #1890ff;\n          box-shadow: 0 0 2px 1px #1890ff;\n}\n.treejs .treejs-node__checked > .treejs-checkbox:before {\n  background-color: #1890ff;\n  border-color: #1890ff;\n}\n.treejs .treejs-node__checked > .treejs-checkbox:after {\n  position: absolute;\n  content: ' ';\n  display: block;\n  top: 4px;\n  left: 5px;\n  width: 5px;\n  height: 9px;\n  border: 2px solid #fff;\n  border-top: none;\n  border-left: none;\n  -webkit-transform: rotate(45deg);\n      -ms-transform: rotate(45deg);\n          transform: rotate(45deg);\n}\n.treejs .treejs-node__halfchecked > .treejs-checkbox:before {\n  background-color: #1890ff;\n  border-color: #1890ff;\n}\n.treejs .treejs-node__halfchecked > .treejs-checkbox:after {\n  position: absolute;\n  content: ' ';\n  display: block;\n  top: 9px;\n  left: 3px;\n  width: 10px;\n  height: 2px;\n  background-color: #fff;\n}\n.treejs .treejs-node__disabled {\n  cursor: not-allowed;\n  color: rgba(255, 255, 255, 0.25);\n}\n.treejs .treejs-node__disabled .treejs-checkbox {\n  cursor: not-allowed;\n}\n.treejs .treejs-node__disabled .treejs-checkbox:before {\n  cursor: not-allowed;\n  border-color: #d9d9d9 !important;\n  background-color: #f5f5f5 !important;\n}\n.treejs .treejs-node__disabled .treejs-checkbox:hover:before {\n  -webkit-box-shadow: none !important;\n          box-shadow: none !important;\n}\n.treejs .treejs-node__disabled .treejs-node__checked > .treejs-checkbox:after {\n  border-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled .treejs-node__halfchecked > .treejs-checkbox:after {\n  background-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled.treejs-node__checked > .treejs-checkbox:after {\n  border-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled.treejs-node__halfchecked > .treejs-checkbox:after {\n  background-color: #d9d9d9;\n}\n.treejs .treejs-label {\n  vertical-align: middle;\n}\n", "", { version: 3, sources: ["webpack://./src/index.less"], names: [], mappings: "AAKA;EACE,8BAAA;UAAA,sBAAA;EACA,eAAA;EACA,kBAAA;EACA,yBAAA;KAAA,sBAAA;MAAA,qBAAA;UAAA,iBAAA;AAJF;AAAA;;EAQI,8BAAA;UAAA,sBAAA;AAJJ;AAOE;EACE,eAAA;AALJ;AAPA;EAgBI,gBAAA;EACA,kBAAA;EACA,SAAA;EACA,gBAAA;EACA,iEAAA;EAAA,4DAAA;EAAA,yDAAA;AANJ;AAdA;EAwBI,eAAA;EACA,gBAAA;AAPJ;AASI;EACE,kBAAA;AAPN;AArBA;EAiCI,qBAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,kBAAA;EACA,oDAAA;EAAA,4CAAA;EAAA,uCAAA;EAAA,oCAAA;EAAA,sEAAA;AATJ;AAWI;EACE,kBAAA;EACA,QAAA;EACA,SAAA;EACA,cAAA;EACA,YAAA;EACA,6BAAA;EACA,8CAAA;EACA,sCAAA;EAAA,iCAAA;EAAA,8BAAA;AATN;AAWI;EACE,+CAAA;AATN;AA3CA;EAwDI,iCAAA;MAAA,6BAAA;UAAA,yBAAA;AAVJ;AA9CA;EA2DI,SAAA;AAVJ;AAjDA;EA+DI,qBAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,kBAAA;AAXJ;AAaI;EACE,4BAAA;EAAA,uBAAA;EAAA,oBAAA;EACA,eAAA;EACA,kBAAA;EACA,QAAA;EACA,YAAA;EACA,cAAA;EACA,WAAA;EACA,YAAA;EACA,yBAAA;EACA,kBAAA;AAXN;AAaI;EACE,uCAAA;UAAA,+BAAA;AAXN;AAgBM;EACE,yBAAA;EACA,qBAAA;AAdR;AAgBM;EACE,kBAAA;EACA,YAAA;EACA,cAAA;EACA,QAAA;EACA,SAAA;EACA,UAAA;EACA,WAAA;EACA,sBAAA;EACA,gBAAA;EACA,iBAAA;EACA,gCAAA;MAAA,4BAAA;UAAA,wBAAA;AAdR;AAoBM;EACE,yBAAA;EACA,qBAAA;AAlBR;AAoBM;EACE,kBAAA;EACA,YAAA;EACA,cAAA;EACA,QAAA;EACA,SAAA;EACA,WAAA;EACA,WAAA;EACA,sBAAA;AAlBR;AAvGA;EA+HI,mBAAA;EACA,gCAAA;AArBJ;AA3GA;EAkIM,mBAAA;AApBN;AAqBM;EACE,mBAAA;EACA,gCAAA;EACA,oCAAA;AAnBR;AAqBM;EACE,mCAAA;UAAA,2BAAA;AAnBR;AAwBQ;EACE,qBAAA;AAtBV;AA4BQ;EACE,yBAAA;AA1BV;AAiCM;EACE,qBAAA;AA/BR;AAqCM;EACE,yBAAA;AAnCR;AAlIA;EA2KI,sBAAA;AAtCJ", sourcesContent: ["@color-disable: #d4d4d4;\n@bgcolor-disable: #f5f5f5;\n@greyborder: #d9d9d9;\n@bluebg: #1890ff;\n\n.treejs {\n  box-sizing: border-box;\n  font-size: 14px;\n  margin-left: -18px;\n  user-select: none;\n\n  *:after,\n  *:before {\n    box-sizing: border-box;\n  }\n\n  & > .treejs-node {\n    padding-left: 0;\n  }\n\n  .treejs-nodes {\n    list-style: none;\n    padding-left: 18px;\n    margin: 0; //  for default ul...\n    overflow: hidden;\n    transition: height 150ms ease-out, opacity 150ms ease-out;\n  }\n\n  .treejs-node {\n    cursor: pointer;\n    overflow: hidden;\n\n    &.treejs-placeholder {\n      padding-left: 18px;\n    }\n  }\n\n  .treejs-switcher {\n    display: inline-block;\n    vertical-align: middle;\n    width: 20px;\n    height: 20px;\n    cursor: pointer;\n    position: relative;\n    transition: transform 150ms ease-out;\n\n    &:before {\n      position: absolute;\n      top: 8px;\n      left: 6px;\n      display: block;\n      content: ' ';\n      border: 4px solid transparent;\n      border-top: 4px solid rgba(245, 245, 245, 0.7);\n      transition: border-color 150ms;\n    }\n    &:hover:before {\n      border-top: 4px solid rgba(245, 245, 245, 0.96);\n    }\n  }\n  .treejs-node__close > .treejs-switcher {\n    transform: rotate(-90deg);\n  }\n  .treejs-node__close > .treejs-nodes {\n    height: 0;\n  }\n\n  .treejs-checkbox {\n    display: inline-block;\n    vertical-align: middle;\n    width: 20px;\n    height: 20px;\n    cursor: pointer;\n    position: relative;\n\n    &:before {\n      transition: all 0.3s;\n      cursor: pointer;\n      position: absolute;\n      top: 2px;\n      content: ' ';\n      display: block;\n      width: 16px;\n      height: 16px;\n      border: 1px solid @greyborder;\n      border-radius: 2px;\n    }\n    &:hover:before {\n      box-shadow: 0 0 2px 1px @bluebg;\n    }\n  }\n  .treejs-node__checked {\n    & > .treejs-checkbox {\n      &:before {\n        background-color: @bluebg;\n        border-color: @bluebg;\n      }\n      &:after {\n        position: absolute;\n        content: ' ';\n        display: block;\n        top: 4px;\n        left: 5px;\n        width: 5px;\n        height: 9px;\n        border: 2px solid #fff;\n        border-top: none;\n        border-left: none;\n        transform: rotate(45deg);\n      }\n    }\n  }\n  .treejs-node__halfchecked {\n    & > .treejs-checkbox {\n      &:before {\n        background-color: @bluebg;\n        border-color: @bluebg;\n      }\n      &:after {\n        position: absolute;\n        content: ' ';\n        display: block;\n        top: 9px;\n        left: 3px;\n        width: 10px;\n        height: 2px;\n        background-color: #fff;\n      }\n    }\n  }\n\n  .treejs-node__disabled {\n    cursor: not-allowed;\n    color: rgba(255, 255, 255, 0.25);\n    .treejs-checkbox {\n      cursor: not-allowed;\n      &:before {\n        cursor: not-allowed;\n        border-color: @greyborder !important;\n        background-color: @bgcolor-disable !important;\n      }\n      &:hover:before {\n        box-shadow: none !important;\n      }\n    }\n    .treejs-node__checked {\n      & > .treejs-checkbox {\n        &:after {\n          border-color: @greyborder;\n        }\n      }\n    }\n    .treejs-node__halfchecked {\n      & > .treejs-checkbox {\n        &:after {\n          background-color: @greyborder;\n        }\n      }\n    }\n  }\n  .treejs-node__disabled.treejs-node__checked {\n    & > .treejs-checkbox {\n      &:after {\n        border-color: @greyborder;\n      }\n    }\n  }\n  .treejs-node__disabled.treejs-node__halfchecked {\n    & > .treejs-checkbox {\n      &:after {\n        background-color: @greyborder;\n      }\n    }\n  }\n\n  .treejs-label {\n    vertical-align: middle;\n  }\n}\n"], sourceRoot: "" }]), t2.Z = o;
    }, 645: function(e3) {
      e3.exports = function(e4) {
        var t2 = [];
        return t2.toString = function() {
          return this.map(function(t3) {
            var r2 = "", n2 = void 0 !== t3[5];
            return t3[4] && (r2 += "@supports (".concat(t3[4], ") {")), t3[2] && (r2 += "@media ".concat(t3[2], " {")), n2 && (r2 += "@layer".concat(t3[5].length > 0 ? " ".concat(t3[5]) : "", " {")), r2 += e4(t3), n2 && (r2 += "}"), t3[2] && (r2 += "}"), t3[4] && (r2 += "}"), r2;
          }).join("");
        }, t2.i = function(e5, r2, n2, i, s) {
          "string" == typeof e5 && (e5 = [[null, e5, void 0]]);
          var o = {};
          if (n2)
            for (var a = 0; a < this.length; a++) {
              var l = this[a][0];
              null != l && (o[l] = true);
            }
          for (var c = 0; c < e5.length; c++) {
            var u = [].concat(e5[c]);
            n2 && o[u[0]] || (void 0 !== s && (void 0 === u[5] || (u[1] = "@layer".concat(u[5].length > 0 ? " ".concat(u[5]) : "", " {").concat(u[1], "}")), u[5] = s), r2 && (u[2] ? (u[1] = "@media ".concat(u[2], " {").concat(u[1], "}"), u[2] = r2) : u[2] = r2), i && (u[4] ? (u[1] = "@supports (".concat(u[4], ") {").concat(u[1], "}"), u[4] = i) : u[4] = "".concat(i)), t2.push(u));
          }
        }, t2;
      };
    }, 537: function(e3) {
      e3.exports = function(e4) {
        var t2 = e4[1], r2 = e4[3];
        if (!r2)
          return t2;
        if ("function" == typeof btoa) {
          var n2 = btoa(unescape(encodeURIComponent(JSON.stringify(r2)))), i = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(n2), s = "/*# ".concat(i, " */"), o = r2.sources.map(function(e5) {
            return "/*# sourceURL=".concat(r2.sourceRoot || "").concat(e5, " */");
          });
          return [t2].concat(o).concat([s]).join("\n");
        }
        return [t2].join("\n");
      };
    }, 379: function(e3) {
      var t2 = [];
      function r2(e4) {
        for (var r3 = -1, n3 = 0; n3 < t2.length; n3++)
          if (t2[n3].identifier === e4) {
            r3 = n3;
            break;
          }
        return r3;
      }
      function n2(e4, n3) {
        for (var s = {}, o = [], a = 0; a < e4.length; a++) {
          var l = e4[a], c = n3.base ? l[0] + n3.base : l[0], u = s[c] || 0, h = "".concat(c, " ").concat(u);
          s[c] = u + 1;
          var p = r2(h), d = { css: l[1], media: l[2], sourceMap: l[3], supports: l[4], layer: l[5] };
          if (-1 !== p)
            t2[p].references++, t2[p].updater(d);
          else {
            var f = i(d, n3);
            n3.byIndex = a, t2.splice(a, 0, { identifier: h, updater: f, references: 1 });
          }
          o.push(h);
        }
        return o;
      }
      function i(e4, t3) {
        var r3 = t3.domAPI(t3);
        return r3.update(e4), function(t4) {
          if (t4) {
            if (t4.css === e4.css && t4.media === e4.media && t4.sourceMap === e4.sourceMap && t4.supports === e4.supports && t4.layer === e4.layer)
              return;
            r3.update(e4 = t4);
          } else
            r3.remove();
        };
      }
      e3.exports = function(e4, i2) {
        var s = n2(e4 = e4 || [], i2 = i2 || {});
        return function(e5) {
          e5 = e5 || [];
          for (var o = 0; o < s.length; o++) {
            var a = r2(s[o]);
            t2[a].references--;
          }
          for (var l = n2(e5, i2), c = 0; c < s.length; c++) {
            var u = r2(s[c]);
            0 === t2[u].references && (t2[u].updater(), t2.splice(u, 1));
          }
          s = l;
        };
      };
    }, 216: function(e3) {
      e3.exports = function(e4) {
        var t2 = document.createElement("style");
        return e4.setAttributes(t2, e4.attributes), e4.insert(t2, e4.options), t2;
      };
    }, 636: function(e3, t2, r2) {
      e3.exports = function(e4) {
        var t3 = r2.nc;
        t3 && e4.setAttribute("nonce", t3);
      };
    }, 795: function(e3) {
      e3.exports = function(e4) {
        var t2 = e4.insertStyleElement(e4);
        return { update: function(r2) {
          !function(e5, t3, r3) {
            var n2 = "";
            r3.supports && (n2 += "@supports (".concat(r3.supports, ") {")), r3.media && (n2 += "@media ".concat(r3.media, " {"));
            var i = void 0 !== r3.layer;
            i && (n2 += "@layer".concat(r3.layer.length > 0 ? " ".concat(r3.layer) : "", " {")), n2 += r3.css, i && (n2 += "}"), r3.media && (n2 += "}"), r3.supports && (n2 += "}");
            var s = r3.sourceMap;
            s && "undefined" != typeof btoa && (n2 += "\n/", n2 += "*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s)))), " *"), n2 += "/"), t3.styleTagTransform(n2, e5, t3.options);
          }(t2, e4, r2);
        }, remove: function() {
          !function(e5) {
            if (null === e5.parentNode)
              return false;
            e5.parentNode.removeChild(e5);
          }(t2);
        } };
      };
    }, 589: function(e3) {
      e3.exports = function(e4, t2) {
        if (t2.styleSheet)
          t2.styleSheet.cssText = e4;
        else {
          for (; t2.firstChild; )
            t2.removeChild(t2.firstChild);
          t2.appendChild(document.createTextNode(e4));
        }
      };
    } }, t = {};
    function r(n2) {
      var i = t[n2];
      if (void 0 !== i)
        return i.exports;
      var s = t[n2] = { id: n2, exports: {} };
      return e2[n2](s, s.exports, r), s.exports;
    }
    r.n = function(e3) {
      var t2 = e3 && e3.__esModule ? function() {
        return e3.default;
      } : function() {
        return e3;
      };
      return r.d(t2, { a: t2 }), t2;
    }, r.d = function(e3, t2) {
      for (var n2 in t2)
        r.o(t2, n2) && !r.o(e3, n2) && Object.defineProperty(e3, n2, { enumerable: true, get: t2[n2] });
    }, r.o = function(e3, t2) {
      return Object.prototype.hasOwnProperty.call(e3, t2);
    }, r.nc = void 0;
    var n = {};
    return function() {
      r.d(n, { default: function() {
        return T;
      } });
      var e3 = r(379), t2 = r.n(e3), i = r(795), s = r.n(i), o = r(636), a = r.n(o), l = r(216), c = r.n(l), u = r(589), h = r.n(u), p = r(820), d = {};
      p.Z && p.Z.locals && (d.locals = p.Z.locals);
      var f, m = 0, _ = {};
      _.styleTagTransform = h(), _.setAttributes = a(), _.insert = function(e4, t3) {
        (t3.target || document.head).appendChild(e4);
      }, _.domAPI = s(), _.insertStyleElement = c(), d.use = function(e4) {
        return _.options = e4 || {}, m++ || (f = t2()(p.Z, _)), d;
      }, d.unuse = function() {
        m > 0 && !--m && (f(), f = null);
      };
      var g = d;
      function v(e4, t3) {
        return function(e5) {
          if (Array.isArray(e5))
            return e5;
        }(e4) || function(e5, t4) {
          var r2 = null == e5 ? null : "undefined" != typeof Symbol && e5[Symbol.iterator] || e5["@@iterator"];
          if (null != r2) {
            var n2, i2, s2 = [], o2 = true, a2 = false;
            try {
              for (r2 = r2.call(e5); !(o2 = (n2 = r2.next()).done) && (s2.push(n2.value), !t4 || s2.length !== t4); o2 = true)
                ;
            } catch (e6) {
              a2 = true, i2 = e6;
            } finally {
              try {
                o2 || null == r2.return || r2.return();
              } finally {
                if (a2)
                  throw i2;
              }
            }
            return s2;
          }
        }(e4, t3) || function(e5, t4) {
          if (e5) {
            if ("string" == typeof e5)
              return A(e5, t4);
            var r2 = Object.prototype.toString.call(e5).slice(8, -1);
            return "Object" === r2 && e5.constructor && (r2 = e5.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(e5) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? A(e5, t4) : void 0;
          }
        }(e4, t3) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function A(e4, t3) {
        (null == t3 || t3 > e4.length) && (t3 = e4.length);
        for (var r2 = 0, n2 = new Array(t3); r2 < t3; r2++)
          n2[r2] = e4[r2];
        return n2;
      }
      function b(e4, t3) {
        var r2 = Object.keys(e4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e4);
          t3 && (n2 = n2.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e4, t4).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function y(e4) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var r2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? b(Object(r2), true).forEach(function(t4) {
            x(e4, t4, r2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(r2)) : b(Object(r2)).forEach(function(t4) {
            Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(r2, t4));
          });
        }
        return e4;
      }
      function x(e4, t3, r2) {
        return t3 in e4 ? Object.defineProperty(e4, t3, { value: r2, enumerable: true, configurable: true, writable: true }) : e4[t3] = r2, e4;
      }
      function w(e4, t3) {
        for (var r2 = 0; r2 < t3.length; r2++) {
          var n2 = t3[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e4, n2.key, n2);
        }
      }
      function E(e4) {
        var t3 = {};
        return e4.reduce(function(e5, r2) {
          return t3[r2] || (t3[r2] = true, e5.push(r2)), e5;
        }, []);
      }
      function S(e4, t3) {
        requestAnimationFrame(function() {
          t3.enter(), requestAnimationFrame(function() {
            t3.active(), setTimeout(function() {
              t3.leave();
            }, e4);
          });
        });
      }
      function C(e4, t3) {
        try {
          var r2 = e4.liElementsById[t3.parent.id];
          r2.classList.contains("treejs-node__close") || r2.getElementsByClassName("treejs-switcher")[0].click();
        } catch (e5) {
          return;
        }
        Object.prototype.hasOwnProperty.call(t3, "parent") && C(e4, t3.parent);
      }
      function M(e4, t3) {
        var r2 = e4.liElementsById[t3.id];
        r2.classList.contains("treejs-node__close") && r2.getElementsByClassName("treejs-switcher")[0].click(), Object.prototype.hasOwnProperty.call(t3, "children") && t3.children.forEach(function(t4) {
          return M(e4, t4);
        });
      }
      var T = function() {
        function e4(t4, r3) {
          !function(e5, t5) {
            if (!(e5 instanceof t5))
              throw new TypeError("Cannot call a class as a function");
          }(this, e4), g.use({ target: "string" == typeof this.container ? document.querySelector(this.container) : this.container }), this.treeNodes = [], this.nodesById = {}, this.leafNodesById = {}, this.liElementsById = {}, this.willUpdateNodesById = {}, this.container = t4, this.options = Object.assign({ values: [], disables: [], loaded: null, closeDepth: null }, r3), Object.defineProperties(this, { values: { get: function() {
            return this.getValues();
          }, set: function(e5) {
            this.setValues(E(e5));
          } }, disables: { get: function() {
            return this.getDisables();
          }, set: function(e5) {
            this.setDisables(E(e5));
          } }, selectedNodes: { get: function() {
            var e5 = [], t5 = this.nodesById;
            return Object.keys(t5).forEach(function(r4) {
              if (Object.prototype.hasOwnProperty.call(t5, r4) && (1 === t5[r4].status || 2 === t5[r4].status)) {
                var n3 = y({}, t5[r4]);
                delete n3.parent, delete n3.children, e5.push(n3);
              }
            }), e5;
          } }, disabledNodes: { get: function() {
            var e5 = [], t5 = this.nodesById;
            return Object.keys(t5).forEach(function(r4) {
              if (Object.prototype.hasOwnProperty.call(t5, r4) && t5[r4].disabled) {
                var n3 = y({}, t5[r4]);
                delete n3.parent, e5.push(n3);
              }
            }), e5;
          } } }), this.init(this.options.data);
        }
        var t3, r2, n2;
        return t3 = e4, n2 = [{ key: "onSwitcherClick", value: function(e5) {
          var t4 = e5.parentNode, r3 = t4.lastChild, n3 = r3.scrollHeight;
          t4.classList.contains("treejs-node__close") ? S(150, { enter: function() {
            r3.style.height = 0, r3.style.opacity = 0;
          }, active: function() {
            r3.style.height = "".concat(n3, "px"), r3.style.opacity = 1;
          }, leave: function() {
            r3.style.height = "", r3.style.opacity = "", t4.classList.remove("treejs-node__close");
          } }) : S(150, { enter: function() {
            r3.style.height = "".concat(n3, "px"), r3.style.opacity = 1;
          }, active: function() {
            r3.style.height = 0, r3.style.opacity = 0;
          }, leave: function() {
            r3.style.height = "", r3.style.opacity = "", t4.classList.add("treejs-node__close");
          } });
        } }, { key: "parseTreeData", value: function(e5) {
          var t4, r3 = (t4 = e5, JSON.parse(JSON.stringify(t4))), n3 = {}, i2 = {}, s2 = [], o2 = [];
          return function e6(t5, r4) {
            t5.forEach(function(t6) {
              n3[t6.id] = t6, t6.checked && s2.push(t6.id), t6.disabled && o2.push(t6.id), r4 && (t6.parent = r4), t6.children && t6.children.length ? e6(t6.children, t6) : i2[t6.id] = t6;
            });
          }(r3), { treeNodes: r3, nodesById: n3, leafNodesById: i2, defaultValues: s2, defaultDisables: o2 };
        } }, { key: "createRootEle", value: function() {
          var e5 = document.createElement("div");
          return e5.classList.add("treejs"), e5;
        } }, { key: "createUlEle", value: function() {
          var e5 = document.createElement("ul");
          return e5.classList.add("treejs-nodes"), e5;
        } }, { key: "createLiEle", value: function(e5, t4) {
          var r3 = document.createElement("li");
          if (r3.classList.add("treejs-node"), t4 && r3.classList.add("treejs-node__close"), e5.children && e5.children.length) {
            var n3 = document.createElement("span");
            n3.classList.add("treejs-switcher"), r3.appendChild(n3);
          } else
            r3.classList.add("treejs-placeholder");
          var i2 = document.createElement("span");
          i2.classList.add("treejs-checkbox"), r3.appendChild(i2);
          var s2 = document.createElement("span");
          s2.classList.add("treejs-label");
          var o2 = document.createTextNode(e5.text);
          return s2.appendChild(o2), r3.appendChild(s2), r3.nodeId = e5.id, r3;
        } }], (r2 = [{ key: "init", value: function(t4) {
          var r3 = e4.parseTreeData(t4), n3 = r3.treeNodes, i2 = r3.nodesById, s2 = r3.leafNodesById, o2 = r3.defaultValues, a2 = r3.defaultDisables;
          this.treeNodes = n3, this.nodesById = i2, this.leafNodesById = s2, this.render(this.treeNodes);
          var l2 = this.options, c2 = l2.values, u2 = l2.disables, h2 = l2.loaded;
          c2 && c2.length ? this.setValues(c2) : o2 && o2.length && this.setValues(o2), u2 && u2.length ? this.setDisables(u2) : a2 && a2.length && this.setDisables(a2), "function" == typeof h2 && h2.call(this);
        } }, { key: "render", value: function(t4) {
          var r3 = e4.createRootEle();
          r3.appendChild(this.buildTree(t4, 0)), this.bindEvent(r3);
          var n3 = "string" == typeof this.container ? document.querySelector(this.container) : this.container;
          !function(e5) {
            for (; e5.firstChild; )
              e5.removeChild(e5.firstChild);
          }(n3), n3.appendChild(r3);
        } }, { key: "buildTree", value: function(t4, r3) {
          var n3 = this, i2 = e4.createUlEle();
          return t4 && t4.length && t4.forEach(function(t5) {
            var s2 = e4.createLiEle(t5, r3 === n3.options.closeDepth - 1);
            n3.liElementsById[t5.id] = s2;
            var o2 = null;
            t5.children && t5.children.length && (o2 = n3.buildTree(t5.children, r3 + 1)), o2 && s2.appendChild(o2), i2.appendChild(s2);
          }), i2;
        } }, { key: "bindEvent", value: function(t4) {
          var r3 = this;
          t4.addEventListener("click", function(t5) {
            var n3 = t5.target;
            "SPAN" === n3.nodeName && n3.classList.contains("treejs-checkbox") ? r3.onItemClick(n3.parentNode.nodeId) : "SPAN" === n3.nodeName && n3.classList.contains("treejs-label") ? r3.onItemLabelClick(n3.parentNode.nodeId) : "LI" === n3.nodeName && n3.classList.contains("treejs-node") ? r3.onItemClick(n3.nodeId) : "SPAN" === n3.nodeName && n3.classList.contains("treejs-switcher") && e4.onSwitcherClick(n3);
          }, false);
        } }, { key: "onItemClick", value: function(e5) {
          var t4 = this.nodesById[e5], r3 = this.options.onChange;
          t4.disabled || (this.setValue(e5), this.updateLiElements()), r3 && r3.call(this);
        } }, { key: "onItemLabelClick", value: function(e5) {
          var t4 = this.options.onItemLabelClick;
          t4 && t4.call(this, e5);
        } }, { key: "setValue", value: function(e5) {
          var t4 = this.nodesById[e5];
          if (t4) {
            var r3 = t4.status, n3 = 1 === r3 || 2 === r3 ? 0 : 2;
            t4.status = n3, this.markWillUpdateNode(t4), this.walkUp(t4, "status"), this.walkDown(t4, "status");
          }
        } }, { key: "getValues", value: function() {
          var e5 = this, t4 = [];
          return Object.keys(this.leafNodesById).forEach(function(r3) {
            Object.prototype.hasOwnProperty.call(e5.leafNodesById, r3) && (1 !== e5.leafNodesById[r3].status && 2 !== e5.leafNodesById[r3].status || t4.push(r3));
          }), t4;
        } }, { key: "setValues", value: function(e5) {
          var t4 = this;
          this.emptyNodesCheckStatus(), e5.forEach(function(e6) {
            t4.setValue(e6);
          }), this.updateLiElements();
          var r3 = this.options.onChange;
          r3 && r3.call(this);
        } }, { key: "setDisable", value: function(e5) {
          var t4 = this.nodesById[e5];
          t4 && (t4.disabled || (t4.disabled = true, this.markWillUpdateNode(t4), this.walkUp(t4, "disabled"), this.walkDown(t4, "disabled")));
        } }, { key: "getDisables", value: function() {
          var e5 = this, t4 = [];
          return Object.keys(this.leafNodesById).forEach(function(r3) {
            Object.prototype.hasOwnProperty.call(e5.leafNodesById, r3) && e5.leafNodesById[r3].disabled && t4.push(r3);
          }), t4;
        } }, { key: "setDisables", value: function(e5) {
          var t4 = this;
          this.emptyNodesDisable(), e5.forEach(function(e6) {
            t4.setDisable(e6);
          }), this.updateLiElements();
        } }, { key: "emptyNodesCheckStatus", value: function() {
          this.willUpdateNodesById = this.getSelectedNodesById(), Object.values(this.willUpdateNodesById).forEach(function(e5) {
            e5.disabled || (e5.status = 0);
          });
        } }, { key: "emptyNodesDisable", value: function() {
          this.willUpdateNodesById = this.getDisabledNodesById(), Object.values(this.willUpdateNodesById).forEach(function(e5) {
            e5.disabled = false;
          });
        } }, { key: "getSelectedNodesById", value: function() {
          return Object.entries(this.nodesById).reduce(function(e5, t4) {
            var r3 = v(t4, 2), n3 = r3[0], i2 = r3[1];
            return 1 !== i2.status && 2 !== i2.status || (e5[n3] = i2), e5;
          }, {});
        } }, { key: "getDisabledNodesById", value: function() {
          return Object.entries(this.nodesById).reduce(function(e5, t4) {
            var r3 = v(t4, 2), n3 = r3[0], i2 = r3[1];
            return i2.disabled && (e5[n3] = i2), e5;
          }, {});
        } }, { key: "updateLiElements", value: function() {
          var e5 = this;
          Object.values(this.willUpdateNodesById).forEach(function(t4) {
            e5.updateLiElement(t4);
          }), this.willUpdateNodesById = {};
        } }, { key: "markWillUpdateNode", value: function(e5) {
          this.willUpdateNodesById[e5.id] = e5;
        } }, { key: "walkUp", value: function(e5, t4) {
          var r3 = e5.parent;
          if (r3) {
            if ("status" === t4) {
              var n3, i2 = r3.children.reduce(function(e6, t5) {
                return Number.isNaN(t5.status) ? e6 : e6 + t5.status;
              }, 0);
              if (n3 = i2 ? i2 === 2 * r3.children.length ? 2 : 1 : 0, r3.status === n3)
                return;
              r3.status = n3;
            } else {
              var s2 = r3.children.reduce(function(e6, t5) {
                return e6 && t5.disabled;
              }, true);
              if (r3.disabled === s2)
                return;
              r3.disabled = s2;
            }
            this.markWillUpdateNode(r3), this.walkUp(r3, t4);
          }
        } }, { key: "walkDown", value: function(e5, t4) {
          var r3 = this;
          e5.children && e5.children.length && e5.children.forEach(function(n3) {
            "status" === t4 && n3.disabled || (n3[t4] = e5[t4], r3.markWillUpdateNode(n3), r3.walkDown(n3, t4));
          });
        } }, { key: "updateLiElement", value: function(e5) {
          var t4 = this.liElementsById[e5.id].classList;
          switch (e5.status) {
            case 0:
              t4.remove("treejs-node__halfchecked", "treejs-node__checked");
              break;
            case 1:
              t4.remove("treejs-node__checked"), t4.add("treejs-node__halfchecked");
              break;
            case 2:
              t4.remove("treejs-node__halfchecked"), t4.add("treejs-node__checked");
          }
          switch (e5.disabled) {
            case true:
              t4.contains("treejs-node__disabled") || t4.add("treejs-node__disabled");
              break;
            case false:
              t4.contains("treejs-node__disabled") && t4.remove("treejs-node__disabled");
          }
        } }, { key: "collapseAll", value: function() {
          var e5 = this;
          Object.keys(this.leafNodesById).forEach(function(t4) {
            var r3 = e5.leafNodesById[t4];
            C(e5, r3);
          });
        } }, { key: "expandAll", value: function() {
          M(this, this.treeNodes[0]);
        } }]) && w(t3.prototype, r2), n2 && w(t3, n2), Object.defineProperty(t3, "prototype", { writable: false }), e4;
      }();
    }(), n.default;
  }();
}, 819: function(e, t) {
  !function(e2) {
    const t2 = "tp";
    function r(e3) {
      return (t3) => (r2) => {
        if (!t3 && void 0 === r2)
          return { succeeded: false, value: void 0 };
        if (t3 && void 0 === r2)
          return { succeeded: true, value: void 0 };
        const n2 = e3(r2);
        return void 0 !== n2 ? { succeeded: true, value: n2 } : { succeeded: false, value: void 0 };
      };
    }
    function n(e3) {
      return { custom: (t3) => r(t3)(e3), boolean: r((e4) => "boolean" == typeof e4 ? e4 : void 0)(e3), number: r((e4) => "number" == typeof e4 ? e4 : void 0)(e3), string: r((e4) => "string" == typeof e4 ? e4 : void 0)(e3), function: r((e4) => "function" == typeof e4 ? e4 : void 0)(e3), constant: (t3) => r((e4) => e4 === t3 ? t3 : void 0)(e3), raw: r((e4) => e4)(e3), object: (t3) => r((e4) => {
        if (null !== (r2 = e4) && "object" == typeof r2)
          return function(e5, t4) {
            return Object.keys(t4).reduce((r3, n2) => {
              if (void 0 === r3)
                return;
              const i2 = (0, t4[n2])(e5[n2]);
              return i2.succeeded ? Object.assign(Object.assign({}, r3), { [n2]: i2.value }) : void 0;
            }, {});
          }(e4, t3);
        var r2;
      })(e3), array: (t3) => r((e4) => {
        if (Array.isArray(e4))
          return r2 = t3, e4.reduce((e5, t4) => {
            if (void 0 === e5)
              return;
            const n2 = r2(t4);
            return n2.succeeded && void 0 !== n2.value ? [...e5, n2.value] : void 0;
          }, []);
        var r2;
      })(e3) };
    }
    const i = { optional: n(true), required: n(false) };
    function s(e3, t3, r2, n2) {
      return new (r2 || (r2 = Promise))(function(i2, s2) {
        function o2(e4) {
          try {
            l2(n2.next(e4));
          } catch (e5) {
            s2(e5);
          }
        }
        function a2(e4) {
          try {
            l2(n2.throw(e4));
          } catch (e5) {
            s2(e5);
          }
        }
        function l2(e4) {
          var t4;
          e4.done ? i2(e4.value) : (t4 = e4.value, t4 instanceof r2 ? t4 : new r2(function(e5) {
            e5(t4);
          })).then(o2, a2);
        }
        l2((n2 = n2.apply(e3, t3 || [])).next());
      });
    }
    function o(e3) {
      return s(this, void 0, void 0, function* () {
        const t3 = new Image();
        return t3.crossOrigin = "anonymous", new Promise((r2, n2) => {
          t3.src = e3, t3.onload = () => {
            r2(t3);
          }, t3.onerror = n2;
        });
      });
    }
    const a = (l = "img", (e3, r2) => [t2, "-", l, "v", e3 ? `_${e3}` : "", r2 ? `-${r2}` : ""].join(""));
    var l;
    class c {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(a()), t3.viewProps.bindClassModifiers(this.element), this.input = e3.createElement("input"), this.input.classList.add(a("input")), this.input.setAttribute("type", "file"), this.input.setAttribute("accept", t3.extensions.join(",")), this.image_ = e3.createElement("img"), this.image_.classList.add(a("image")), this.image_.classList.add(a(`image_${t3.imageFit}`)), this.image_.crossOrigin = "anonymous", this.image_.onclick = (e4) => {
          t3.clickCallback ? t3.clickCallback(e4, this.input) : this.input.click();
        }, this.element.classList.add(a("area_root")), this.element.appendChild(this.image_), this.element.appendChild(this.input);
      }
      changeImage(e3) {
        this.image_.src = e3;
      }
      changeDraggingState(e3) {
        const t3 = this.element;
        e3 ? null == t3 || t3.classList.add(a("area_dragging")) : null == t3 || t3.classList.remove(a("area_dragging"));
      }
    }
    let u = null;
    class h {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.view = new c(e3, { viewProps: this.viewProps, extensions: t3.extensions, imageFit: t3.imageFit, clickCallback: t3.clickCallback }), this.onFile = this.onFile.bind(this), this.onDrop = this.onDrop.bind(this), this.onDragOver = this.onDragOver.bind(this), this.onDragLeave = this.onDragLeave.bind(this), this.view.input.addEventListener("change", this.onFile), this.view.element.addEventListener("drop", this.onDrop), this.view.element.addEventListener("dragover", this.onDragOver), this.view.element.addEventListener("dragleave", this.onDragLeave), this.viewProps.handleDispose(() => {
          this.view.input.removeEventListener("change", this.onFile), this.view.input.removeEventListener("drop", this.onDrop), this.view.input.removeEventListener("dragover", this.onDragOver), this.view.input.removeEventListener("dragleave", this.onDragLeave);
        }), this.value.emitter.on("change", this.handleValueChange.bind(this)), this.handleValueChange();
      }
      onFile(e3) {
        const t3 = (null == e3 ? void 0 : e3.target).files;
        if (!t3 || !t3.length)
          return;
        const r2 = t3[0];
        this.setValue(r2);
      }
      onDrop(e3) {
        return s(this, void 0, void 0, function* () {
          e3.preventDefault();
          try {
            const { dataTransfer: t3 } = e3, r2 = null == t3 ? void 0 : t3.files[0];
            if (r2)
              this.setValue(r2);
            else {
              const e4 = null == t3 ? void 0 : t3.getData("url");
              if (!e4)
                throw new Error("No url");
              this.setValue(e4);
            }
          } catch (e4) {
            console.error("Could not parse the dropped image", e4);
          } finally {
            this.view.changeDraggingState(false);
          }
        });
      }
      onDragOver(e3) {
        e3.preventDefault(), this.view.changeDraggingState(true);
      }
      onDragLeave() {
        this.view.changeDraggingState(false);
      }
      handleImage(e3) {
        return s(this, void 0, void 0, function* () {
          e3 instanceof HTMLImageElement ? this.updateImage(e3.src) : "string" != typeof e3 && e3 ? yield this.setValue(e3) : ("placeholder" !== e3 && e3 || (e3 = (yield this.handlePlaceholderImage()).src), this.updateImage(e3));
        });
      }
      updateImage(e3) {
        this.view.changeImage(e3);
      }
      setValue(e3) {
        return s(this, void 0, void 0, function* () {
          if (e3 instanceof HTMLImageElement)
            this.value.setRawValue(e3);
          else if (e3 instanceof File) {
            const t3 = URL.createObjectURL(e3) + "#" + e3.name;
            e3.src = t3;
            const r2 = yield o(t3).catch(() => {
            });
            this.value.setRawValue(r2 || e3);
          } else
            e3 ? this.value.setRawValue(yield o(e3)) : this.value.setRawValue(yield this.handlePlaceholderImage());
        });
      }
      handleValueChange() {
        this.handleImage(this.value.rawValue);
      }
      handlePlaceholderImage() {
        return s(this, void 0, void 0, function* () {
          return u || (u = yield function() {
            const e3 = document.createElement("canvas");
            e3.width = 320, e3.height = 50;
            const t3 = e3.getContext("2d");
            return t3.fillStyle = "#00000004", t3.fillRect(0, 0, e3.width, e3.height), t3.fillStyle = "#eee", t3.font = '1.25rem "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace', t3.textAlign = "center", t3.textBaseline = "middle", t3.fillText("No image", 0.5 * e3.width, 0.5 * e3.height), new Promise((t4) => {
              e3.toBlob((e4) => {
                const r2 = new Image();
                r2.src = URL.createObjectURL(e4), r2.isPlaceholder = true, r2.onload = () => {
                  t4(r2);
                };
              });
            });
          }()), u;
        });
      }
    }
    const p = [".jpg", ".png", ".gif"], d = { id: "input-image", type: "input", css: ".tp-imgv{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-imgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-imgv:hover{background-color:var(--in-bg-h)}.tp-imgv:focus{background-color:var(--in-bg-f)}.tp-imgv:active{background-color:var(--in-bg-a)}.tp-imgv:disabled{opacity:0.5}:root{--tp-plugin-image-dragging-color: hsla(230, 100%, 66%, 1.00)}.tp-imgv{cursor:pointer;display:inline-flex;height:auto !important;max-height:calc(var(--bld-us) * 3);border-radius:4px;position:relative}.tp-imgv.tp-v-disabled{opacity:0.5}.tp-imgv_input{width:0;height:0;pointer-events:none;visibility:hidden}.tp-imgv_image{width:100%;height:-webkit-max-content;height:-moz-max-content;height:max-content;max-height:calc(var(--bld-us) * 3);border:0}.tp-imgv_image_contain{-o-object-fit:contain;object-fit:contain}.tp-imgv_image_cover{-o-object-fit:cover;object-fit:cover}.tp-imgv_area_root{transition:opacity 0.16s ease-in-out}.tp-imgv_area_dragging{border:2px dashed var(--tp-plugin-image-dragging-color);border-radius:4px;opacity:0.6}", accept(e3, t3) {
      if (!(e3 instanceof HTMLImageElement || "string" == typeof e3))
        return null;
      const r2 = i, n2 = function(e4, t4) {
        const r3 = i.required.object(t4)(e4);
        return r3.succeeded ? r3.value : void 0;
      }(t3, { view: r2.required.constant("input-image"), acceptUrl: r2.optional.boolean, clickCallback: r2.optional.function, imageFit: r2.optional.custom((e4) => "contain" === e4 || "cover" === e4 ? e4 : void 0), extensions: r2.optional.array(r2.required.string) });
      return n2 ? { initialValue: e3, params: n2 } : null;
    }, binding: { reader: (e3) => (e4) => void 0 !== e4.src ? "" === e4.src ? "placeholder" : e4.src : e4, writer: (e3) => (e4, t3) => {
      e4.write(t3);
    } }, controller(e3) {
      var t3, r2;
      return new h(e3.document, { value: e3.value, imageFit: null !== (t3 = e3.params.imageFit) && void 0 !== t3 ? t3 : "cover", clickCallback: e3.params.clickCallback, viewProps: e3.viewProps, extensions: null !== (r2 = e3.params.extensions) && void 0 !== r2 ? r2 : p });
    } };
    e2.plugin = d, Object.defineProperty(e2, "__esModule", { value: true });
  }(t);
}, 665: function(e, t) {
  !function(e2) {
    class t2 {
      constructor(e3) {
        this.controller_ = e3;
      }
      get disabled() {
        return this.controller_.viewProps.get("disabled");
      }
      set disabled(e3) {
        this.controller_.viewProps.set("disabled", e3);
      }
      get hidden() {
        return this.controller_.viewProps.get("hidden");
      }
      set hidden(e3) {
        this.controller_.viewProps.set("hidden", e3);
      }
      dispose() {
        this.controller_.viewProps.set("disposed", true);
      }
    }
    class r {
      constructor(e3) {
        this.target = e3;
      }
    }
    class n extends r {
      constructor(e3, t3, r2, n2) {
        super(e3), this.value = t3, this.presetKey = r2, this.last = null == n2 || n2;
      }
    }
    class i extends r {
      constructor(e3, t3, r2) {
        super(e3), this.value = t3, this.presetKey = r2;
      }
    }
    class s extends r {
      constructor(e3, t3) {
        super(e3), this.expanded = t3;
      }
    }
    function o(e3) {
      return null == e3;
    }
    function a(e3, t3) {
      if (e3.length !== t3.length)
        return false;
      for (let r2 = 0; r2 < e3.length; r2++)
        if (e3[r2] !== t3[r2])
          return false;
      return true;
    }
    const l = { alreadydisposed: () => "View has been already disposed", invalidparams: (e3) => `Invalid parameters for '${e3.name}'`, nomatchingcontroller: (e3) => `No matching controller for '${e3.key}'`, nomatchingview: (e3) => `No matching view for '${JSON.stringify(e3.params)}'`, notbindable: () => "Value is not bindable", propertynotfound: (e3) => `Property '${e3.name}' not found`, shouldneverhappen: () => "This error should never happen" };
    class c {
      constructor(e3) {
        var t3;
        this.message = null !== (t3 = l[e3.type](e3.context)) && void 0 !== t3 ? t3 : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = e3.type;
      }
      static alreadyDisposed() {
        return new c({ type: "alreadydisposed" });
      }
      static notBindable() {
        return new c({ type: "notbindable" });
      }
      static propertyNotFound(e3) {
        return new c({ type: "propertynotfound", context: { name: e3 } });
      }
      static shouldNeverHappen() {
        return new c({ type: "shouldneverhappen" });
      }
    }
    class u {
      constructor(e3, t3, r2) {
        this.obj_ = e3, this.key_ = t3, this.presetKey_ = null != r2 ? r2 : t3;
      }
      static isBindable(e3) {
        return null !== e3 && "object" == typeof e3;
      }
      get key() {
        return this.key_;
      }
      get presetKey() {
        return this.presetKey_;
      }
      read() {
        return this.obj_[this.key_];
      }
      write(e3) {
        this.obj_[this.key_] = e3;
      }
      writeProperty(e3, t3) {
        const r2 = this.read();
        if (!u.isBindable(r2))
          throw c.notBindable();
        if (!(e3 in r2))
          throw c.propertyNotFound(e3);
        r2[e3] = t3;
      }
    }
    class h extends t2 {
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e3) {
        this.controller_.props.set("label", e3);
      }
      get title() {
        var e3;
        return null !== (e3 = this.controller_.valueController.props.get("title")) && void 0 !== e3 ? e3 : "";
      }
      set title(e3) {
        this.controller_.valueController.props.set("title", e3);
      }
      on(e3, t3) {
        const n2 = t3.bind(this);
        return this.controller_.valueController.emitter.on(e3, () => {
          n2(new r(this));
        }), this;
      }
    }
    class p {
      constructor() {
        this.observers_ = {};
      }
      on(e3, t3) {
        let r2 = this.observers_[e3];
        return r2 || (r2 = this.observers_[e3] = []), r2.push({ handler: t3 }), this;
      }
      off(e3, t3) {
        const r2 = this.observers_[e3];
        return r2 && (this.observers_[e3] = r2.filter((e4) => e4.handler !== t3)), this;
      }
      emit(e3, t3) {
        const r2 = this.observers_[e3];
        r2 && r2.forEach((e4) => {
          e4.handler(t3);
        });
      }
    }
    const d = "tp";
    function f(e3) {
      return (t3, r2) => [d, "-", e3, "v", t3 ? `_${t3}` : "", r2 ? `-${r2}` : ""].join("");
    }
    function m(e3) {
      return e3.rawValue;
    }
    function _(e3, t3) {
      var r2, n2;
      e3.emitter.on("change", (r2 = m, n2 = t3, (e4) => n2(r2(e4)))), t3(e3.rawValue);
    }
    function g(e3, t3, r2) {
      _(e3.value(t3), r2);
    }
    function v(e3, t3) {
      return (r2) => {
        !function(e4, t4, r3) {
          r3 ? e4.classList.add(t4) : e4.classList.remove(t4);
        }(e3, t3, r2);
      };
    }
    function A(e3, t3) {
      _(e3, (e4) => {
        t3.textContent = null != e4 ? e4 : "";
      });
    }
    const b = f("btn");
    class y {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(b()), t3.viewProps.bindClassModifiers(this.element);
        const r2 = e3.createElement("button");
        r2.classList.add(b("b")), t3.viewProps.bindDisabled(r2), this.element.appendChild(r2), this.buttonElement = r2;
        const n2 = e3.createElement("div");
        n2.classList.add(b("t")), A(t3.props.value("title"), n2), this.buttonElement.appendChild(n2);
      }
    }
    class x {
      constructor(e3, t3) {
        this.emitter = new p(), this.onClick_ = this.onClick_.bind(this), this.props = t3.props, this.viewProps = t3.viewProps, this.view = new y(e3, { props: this.props, viewProps: this.viewProps }), this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", { sender: this });
      }
    }
    class w {
      constructor(e3, t3) {
        var r2;
        this.constraint_ = null == t3 ? void 0 : t3.constraint, this.equals_ = null !== (r2 = null == t3 ? void 0 : t3.equals) && void 0 !== r2 ? r2 : (e4, t4) => e4 === t4, this.emitter = new p(), this.rawValue_ = e3;
      }
      get constraint() {
        return this.constraint_;
      }
      get rawValue() {
        return this.rawValue_;
      }
      set rawValue(e3) {
        this.setRawValue(e3, { forceEmit: false, last: true });
      }
      setRawValue(e3, t3) {
        const r2 = null != t3 ? t3 : { forceEmit: false, last: true }, n2 = this.constraint_ ? this.constraint_.constrain(e3) : e3;
        (!this.equals_(this.rawValue_, n2) || r2.forceEmit) && (this.emitter.emit("beforechange", { sender: this }), this.rawValue_ = n2, this.emitter.emit("change", { options: r2, rawValue: n2, sender: this }));
      }
    }
    class E {
      constructor(e3) {
        this.emitter = new p(), this.value_ = e3;
      }
      get rawValue() {
        return this.value_;
      }
      set rawValue(e3) {
        this.setRawValue(e3, { forceEmit: false, last: true });
      }
      setRawValue(e3, t3) {
        const r2 = null != t3 ? t3 : { forceEmit: false, last: true };
        (this.value_ !== e3 || r2.forceEmit) && (this.emitter.emit("beforechange", { sender: this }), this.value_ = e3, this.emitter.emit("change", { options: r2, rawValue: this.value_, sender: this }));
      }
    }
    function S(e3, t3) {
      const r2 = null == t3 ? void 0 : t3.constraint, n2 = null == t3 ? void 0 : t3.equals;
      return r2 || n2 ? new w(e3, t3) : new E(e3);
    }
    class C {
      constructor(e3) {
        this.emitter = new p(), this.valMap_ = e3;
        for (const e4 in this.valMap_)
          this.valMap_[e4].emitter.on("change", () => {
            this.emitter.emit("change", { key: e4, sender: this });
          });
      }
      static createCore(e3) {
        return Object.keys(e3).reduce((t3, r2) => Object.assign(t3, { [r2]: S(e3[r2]) }), {});
      }
      static fromObject(e3) {
        const t3 = this.createCore(e3);
        return new C(t3);
      }
      get(e3) {
        return this.valMap_[e3].rawValue;
      }
      set(e3, t3) {
        this.valMap_[e3].rawValue = t3;
      }
      value(e3) {
        return this.valMap_[e3];
      }
    }
    function M(e3) {
      return (t3) => (r2) => {
        if (!t3 && void 0 === r2)
          return { succeeded: false, value: void 0 };
        if (t3 && void 0 === r2)
          return { succeeded: true, value: void 0 };
        const n2 = e3(r2);
        return void 0 !== n2 ? { succeeded: true, value: n2 } : { succeeded: false, value: void 0 };
      };
    }
    function T(e3) {
      return { custom: (t3) => M(t3)(e3), boolean: M((e4) => "boolean" == typeof e4 ? e4 : void 0)(e3), number: M((e4) => "number" == typeof e4 ? e4 : void 0)(e3), string: M((e4) => "string" == typeof e4 ? e4 : void 0)(e3), function: M((e4) => "function" == typeof e4 ? e4 : void 0)(e3), constant: (t3) => M((e4) => e4 === t3 ? t3 : void 0)(e3), raw: M((e4) => e4)(e3), object: (t3) => M((e4) => {
        if (null !== (r2 = e4) && "object" == typeof r2)
          return function(e5, t4) {
            return Object.keys(t4).reduce((r3, n2) => {
              if (void 0 === r3)
                return;
              const i2 = (0, t4[n2])(e5[n2]);
              return i2.succeeded ? Object.assign(Object.assign({}, r3), { [n2]: i2.value }) : void 0;
            }, {});
          }(e4, t3);
        var r2;
      })(e3), array: (t3) => M((e4) => {
        if (Array.isArray(e4))
          return r2 = t3, e4.reduce((e5, t4) => {
            if (void 0 === e5)
              return;
            const n2 = r2(t4);
            return n2.succeeded && void 0 !== n2.value ? [...e5, n2.value] : void 0;
          }, []);
        var r2;
      })(e3) };
    }
    const I = { optional: T(true), required: T(false) };
    function k(e3, t3) {
      const r2 = I.required.object(t3)(e3);
      return r2.succeeded ? r2.value : void 0;
    }
    const D = f(""), P = { veryfirst: "vfst", first: "fst", last: "lst", verylast: "vlst" };
    class B {
      constructor(e3) {
        this.parent_ = null, this.blade = e3.blade, this.view = e3.view, this.viewProps = e3.viewProps;
        const t3 = this.view.element;
        this.blade.value("positions").emitter.on("change", () => {
          ["veryfirst", "first", "last", "verylast"].forEach((e4) => {
            t3.classList.remove(D(void 0, P[e4]));
          }), this.blade.get("positions").forEach((e4) => {
            t3.classList.add(D(void 0, P[e4]));
          });
        }), this.viewProps.handleDispose(() => {
          !function(e4) {
            e4 && e4.parentElement && e4.parentElement.removeChild(e4);
          }(t3);
        });
      }
      get parent() {
        return this.parent_;
      }
    }
    const R = "http://www.w3.org/2000/svg";
    function L(e3) {
      e3.offsetHeight;
    }
    function O(e3) {
      return void 0 !== e3.ontouchstart;
    }
    function F() {
      return new Function("return this")().document;
    }
    const U = { check: '<path d="M2 8l4 4l8 -8"/>', dropdown: '<path d="M5 7h6l-3 3 z"/>', p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>' };
    function N(e3, t3) {
      const r2 = e3.createElementNS(R, "svg");
      return r2.innerHTML = U[t3], r2;
    }
    function j(e3, t3, r2) {
      e3.insertBefore(t3, e3.children[r2]);
    }
    function z(e3) {
      e3.parentElement && e3.parentElement.removeChild(e3);
    }
    function G(e3) {
      for (; e3.children.length > 0; )
        e3.removeChild(e3.children[0]);
    }
    function V(e3) {
      return e3.relatedTarget ? e3.relatedTarget : "explicitOriginalTarget" in e3 ? e3.explicitOriginalTarget : null;
    }
    const Q = f("lbl");
    class H {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(Q()), t3.viewProps.bindClassModifiers(this.element);
        const r2 = e3.createElement("div");
        r2.classList.add(Q("l")), g(t3.props, "label", (t4) => {
          o(t4) ? this.element.classList.add(Q(void 0, "nol")) : (this.element.classList.remove(Q(void 0, "nol")), function(e4) {
            for (; e4.childNodes.length > 0; )
              e4.removeChild(e4.childNodes[0]);
          }(r2), r2.appendChild(function(e4, t5) {
            const r3 = e4.createDocumentFragment();
            return t5.split("\n").map((t6) => e4.createTextNode(t6)).forEach((t6, n3) => {
              n3 > 0 && r3.appendChild(e4.createElement("br")), r3.appendChild(t6);
            }), r3;
          }(e3, t4)));
        }), this.element.appendChild(r2), this.labelElement = r2;
        const n2 = e3.createElement("div");
        n2.classList.add(Q("v")), this.element.appendChild(n2), this.valueElement = n2;
      }
    }
    class W extends B {
      constructor(e3, t3) {
        const r2 = t3.valueController.viewProps;
        super(Object.assign(Object.assign({}, t3), { view: new H(e3, { props: t3.props, viewProps: r2 }), viewProps: r2 })), this.props = t3.props, this.valueController = t3.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    const q = { id: "button", type: "blade", accept(e3) {
      const t3 = I, r2 = k(e3, { title: t3.required.string, view: t3.required.constant("button"), label: t3.optional.string });
      return r2 ? { params: r2 } : null;
    }, controller: (e3) => new W(e3.document, { blade: e3.blade, props: C.fromObject({ label: e3.params.label }), valueController: new x(e3.document, { props: C.fromObject({ title: e3.params.title }), viewProps: e3.viewProps }) }), api: (e3) => e3.controller instanceof W && e3.controller.valueController instanceof x ? new h(e3.controller) : null };
    class X extends B {
      constructor(e3) {
        super(e3), this.value = e3.value;
      }
    }
    function Y() {
      return new C({ positions: S([], { equals: a }) });
    }
    class K extends C {
      constructor(e3) {
        super(e3);
      }
      static create(e3) {
        const t3 = { completed: true, expanded: e3, expandedHeight: null, shouldFixHeight: false, temporaryExpanded: null }, r2 = C.createCore(t3);
        return new K(r2);
      }
      get styleExpanded() {
        var e3;
        return null !== (e3 = this.get("temporaryExpanded")) && void 0 !== e3 ? e3 : this.get("expanded");
      }
      get styleHeight() {
        if (!this.styleExpanded)
          return "0";
        const e3 = this.get("expandedHeight");
        return this.get("shouldFixHeight") && !o(e3) ? `${e3}px` : "auto";
      }
      bindExpandedClass(e3, t3) {
        const r2 = () => {
          this.styleExpanded ? e3.classList.add(t3) : e3.classList.remove(t3);
        };
        g(this, "expanded", r2), g(this, "temporaryExpanded", r2);
      }
      cleanUpTransition() {
        this.set("shouldFixHeight", false), this.set("expandedHeight", null), this.set("completed", true);
      }
    }
    function J(e3, t3) {
      t3.style.height = e3.styleHeight;
    }
    function Z(e3, t3) {
      e3.value("expanded").emitter.on("beforechange", () => {
        e3.set("completed", false), o(e3.get("expandedHeight")) && e3.set("expandedHeight", function(e4, t4) {
          let r2 = 0;
          return function(e5, t5) {
            const r3 = e5.style.transition;
            e5.style.transition = "none", t5(), e5.style.transition = r3;
          }(t4, () => {
            e4.set("expandedHeight", null), e4.set("temporaryExpanded", true), L(t4), r2 = t4.clientHeight, e4.set("temporaryExpanded", null), L(t4);
          }), r2;
        }(e3, t3)), e3.set("shouldFixHeight", true), L(t3);
      }), e3.emitter.on("change", () => {
        J(e3, t3);
      }), J(e3, t3), t3.addEventListener("transitionend", (t4) => {
        "height" === t4.propertyName && e3.cleanUpTransition();
      });
    }
    class $ extends t2 {
      constructor(e3, t3) {
        super(e3), this.rackApi_ = t3;
      }
    }
    class ee {
      constructor(e3) {
        this.emitter = new p(), this.items_ = [], this.cache_ = /* @__PURE__ */ new Set(), this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = e3;
      }
      get items() {
        return this.items_;
      }
      allItems() {
        return Array.from(this.cache_);
      }
      find(e3) {
        for (const t3 of this.allItems())
          if (e3(t3))
            return t3;
        return null;
      }
      includes(e3) {
        return this.cache_.has(e3);
      }
      add(e3, t3) {
        if (this.includes(e3))
          throw c.shouldNeverHappen();
        const r2 = void 0 !== t3 ? t3 : this.items_.length;
        this.items_.splice(r2, 0, e3), this.cache_.add(e3);
        const n2 = this.extract_(e3);
        n2 && (n2.emitter.on("add", this.onSubListAdd_), n2.emitter.on("remove", this.onSubListRemove_), n2.allItems().forEach((e4) => {
          this.cache_.add(e4);
        })), this.emitter.emit("add", { index: r2, item: e3, root: this, target: this });
      }
      remove(e3) {
        const t3 = this.items_.indexOf(e3);
        if (t3 < 0)
          return;
        this.items_.splice(t3, 1), this.cache_.delete(e3);
        const r2 = this.extract_(e3);
        r2 && (r2.emitter.off("add", this.onSubListAdd_), r2.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", { index: t3, item: e3, root: this, target: this });
      }
      onSubListAdd_(e3) {
        this.cache_.add(e3.item), this.emitter.emit("add", { index: e3.index, item: e3.item, root: this, target: e3.target });
      }
      onSubListRemove_(e3) {
        this.cache_.delete(e3.item), this.emitter.emit("remove", { index: e3.index, item: e3.item, root: this, target: e3.target });
      }
    }
    class te extends t2 {
      constructor(e3) {
        super(e3), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new p(), this.controller_.binding.emitter.on("change", this.onBindingChange_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e3) {
        this.controller_.props.set("label", e3);
      }
      on(e3, t3) {
        const r2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          r2(e4.event);
        }), this;
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingChange_(e3) {
        const t3 = e3.sender.target.read();
        this.emitter_.emit("change", { event: new n(this, t3, this.controller_.binding.target.presetKey, e3.options.last) });
      }
    }
    class re extends W {
      constructor(e3, t3) {
        super(e3, t3), this.binding = t3.binding;
      }
    }
    class ne extends t2 {
      constructor(e3) {
        super(e3), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new p(), this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e3) {
        this.controller_.props.set("label", e3);
      }
      on(e3, t3) {
        const r2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          r2(e4.event);
        }), this;
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingUpdate_(e3) {
        const t3 = e3.sender.target.read();
        this.emitter_.emit("update", { event: new i(this, t3, this.controller_.binding.target.presetKey) });
      }
    }
    class ie extends W {
      constructor(e3, t3) {
        super(e3, t3), this.binding = t3.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose(() => {
          this.binding.dispose();
        });
      }
    }
    function se(e3) {
      return e3 instanceof le ? e3.apiSet_ : e3 instanceof $ ? e3.rackApi_.apiSet_ : null;
    }
    function oe(e3, t3) {
      const r2 = e3.find((e4) => e4.controller_ === t3);
      if (!r2)
        throw c.shouldNeverHappen();
      return r2;
    }
    function ae(e3, t3, r2) {
      if (!u.isBindable(e3))
        throw c.notBindable();
      return new u(e3, t3, r2);
    }
    class le extends t2 {
      constructor(e3, t3) {
        super(e3), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new p(), this.apiSet_ = new ee(se), this.pool_ = t3;
        const r2 = this.controller_.rack;
        r2.emitter.on("add", this.onRackAdd_), r2.emitter.on("remove", this.onRackRemove_), r2.emitter.on("inputchange", this.onRackInputChange_), r2.emitter.on("monitorupdate", this.onRackMonitorUpdate_), r2.children.forEach((e4) => {
          this.setUpApi_(e4);
        });
      }
      get children() {
        return this.controller_.rack.children.map((e3) => oe(this.apiSet_, e3));
      }
      addInput(e3, t3, r2) {
        const n2 = r2 || {}, i2 = this.controller_.view.element.ownerDocument, s2 = this.pool_.createInput(i2, ae(e3, t3, n2.presetKey), n2), o2 = new te(s2);
        return this.add(o2, n2.index);
      }
      addMonitor(e3, t3, r2) {
        const n2 = r2 || {}, i2 = this.controller_.view.element.ownerDocument, s2 = this.pool_.createMonitor(i2, ae(e3, t3), n2), o2 = new ne(s2);
        return this.add(o2, n2.index);
      }
      addFolder(e3) {
        return function(e4, t3) {
          return e4.addBlade(Object.assign(Object.assign({}, t3), { view: "folder" }));
        }(this, e3);
      }
      addButton(e3) {
        return function(e4, t3) {
          return e4.addBlade(Object.assign(Object.assign({}, t3), { view: "button" }));
        }(this, e3);
      }
      addSeparator(e3) {
        return function(e4, t3) {
          const r2 = t3 || {};
          return e4.addBlade(Object.assign(Object.assign({}, r2), { view: "separator" }));
        }(this, e3);
      }
      addTab(e3) {
        return function(e4, t3) {
          return e4.addBlade(Object.assign(Object.assign({}, t3), { view: "tab" }));
        }(this, e3);
      }
      add(e3, t3) {
        this.controller_.rack.add(e3.controller_, t3);
        const r2 = this.apiSet_.find((t4) => t4.controller_ === e3.controller_);
        return r2 && this.apiSet_.remove(r2), this.apiSet_.add(e3), e3;
      }
      remove(e3) {
        this.controller_.rack.remove(e3.controller_);
      }
      addBlade(e3) {
        const t3 = this.controller_.view.element.ownerDocument, r2 = this.pool_.createBlade(t3, e3), n2 = this.pool_.createBladeApi(r2);
        return this.add(n2, e3.index);
      }
      on(e3, t3) {
        const r2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          r2(e4.event);
        }), this;
      }
      setUpApi_(e3) {
        this.apiSet_.find((t3) => t3.controller_ === e3) || this.apiSet_.add(this.pool_.createBladeApi(e3));
      }
      onRackAdd_(e3) {
        this.setUpApi_(e3.bladeController);
      }
      onRackRemove_(e3) {
        if (e3.isRoot) {
          const t3 = oe(this.apiSet_, e3.bladeController);
          this.apiSet_.remove(t3);
        }
      }
      onRackInputChange_(e3) {
        const t3 = e3.bladeController;
        if (t3 instanceof re) {
          const r2 = oe(this.apiSet_, t3), i2 = t3.binding;
          this.emitter_.emit("change", { event: new n(r2, i2.target.read(), i2.target.presetKey, e3.options.last) });
        } else if (t3 instanceof X) {
          const r2 = oe(this.apiSet_, t3);
          this.emitter_.emit("change", { event: new n(r2, t3.value.rawValue, void 0, e3.options.last) });
        }
      }
      onRackMonitorUpdate_(e3) {
        if (!(e3.bladeController instanceof ie))
          throw c.shouldNeverHappen();
        const t3 = oe(this.apiSet_, e3.bladeController), r2 = e3.bladeController.binding;
        this.emitter_.emit("update", { event: new i(t3, r2.target.read(), r2.target.presetKey) });
      }
    }
    class ce extends $ {
      constructor(e3, t3) {
        super(e3, new le(e3.rackController, t3)), this.emitter_ = new p(), this.controller_.foldable.value("expanded").emitter.on("change", (e4) => {
          this.emitter_.emit("fold", { event: new s(this, e4.sender.rawValue) });
        }), this.rackApi_.on("change", (e4) => {
          this.emitter_.emit("change", { event: e4 });
        }), this.rackApi_.on("update", (e4) => {
          this.emitter_.emit("update", { event: e4 });
        });
      }
      get expanded() {
        return this.controller_.foldable.get("expanded");
      }
      set expanded(e3) {
        this.controller_.foldable.set("expanded", e3);
      }
      get title() {
        return this.controller_.props.get("title");
      }
      set title(e3) {
        this.controller_.props.set("title", e3);
      }
      get children() {
        return this.rackApi_.children;
      }
      addInput(e3, t3, r2) {
        return this.rackApi_.addInput(e3, t3, r2);
      }
      addMonitor(e3, t3, r2) {
        return this.rackApi_.addMonitor(e3, t3, r2);
      }
      addFolder(e3) {
        return this.rackApi_.addFolder(e3);
      }
      addButton(e3) {
        return this.rackApi_.addButton(e3);
      }
      addSeparator(e3) {
        return this.rackApi_.addSeparator(e3);
      }
      addTab(e3) {
        return this.rackApi_.addTab(e3);
      }
      add(e3, t3) {
        return this.rackApi_.add(e3, t3);
      }
      remove(e3) {
        this.rackApi_.remove(e3);
      }
      addBlade(e3) {
        return this.rackApi_.addBlade(e3);
      }
      on(e3, t3) {
        const r2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          r2(e4.event);
        }), this;
      }
    }
    class ue extends B {
      constructor(e3) {
        super({ blade: e3.blade, view: e3.view, viewProps: e3.rackController.viewProps }), this.rackController = e3.rackController;
      }
    }
    class he {
      constructor(e3, t3) {
        const r2 = f(t3.viewName);
        this.element = e3.createElement("div"), this.element.classList.add(r2()), t3.viewProps.bindClassModifiers(this.element);
      }
    }
    function pe(e3) {
      return e3 instanceof me ? e3.rack : e3 instanceof ue ? e3.rackController.rack : null;
    }
    function de(e3) {
      const t3 = pe(e3);
      return t3 ? t3.bcSet_ : null;
    }
    class fe {
      constructor(e3) {
        var t3;
        this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new p(), this.blade_ = null != e3 ? e3 : null, null === (t3 = this.blade_) || void 0 === t3 || t3.value("positions").emitter.on("change", this.onBladePositionsChange_), this.bcSet_ = new ee(de), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_);
      }
      get children() {
        return this.bcSet_.items;
      }
      add(e3, t3) {
        e3.parent && e3.parent.remove(e3), e3.parent_ = this, this.bcSet_.add(e3, t3);
      }
      remove(e3) {
        e3.parent_ = null, this.bcSet_.remove(e3);
      }
      find(e3) {
        return this.bcSet_.allItems().filter((t3) => t3 instanceof e3);
      }
      onSetAdd_(e3) {
        this.updatePositions_();
        const t3 = e3.target === e3.root;
        if (this.emitter.emit("add", { bladeController: e3.item, index: e3.index, isRoot: t3, sender: this }), !t3)
          return;
        const r2 = e3.item;
        if (r2.viewProps.emitter.on("change", this.onChildViewPropsChange_), r2.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), r2.viewProps.handleDispose(this.onChildDispose_), r2 instanceof re)
          r2.binding.emitter.on("change", this.onChildInputChange_);
        else if (r2 instanceof ie)
          r2.binding.emitter.on("update", this.onChildMonitorUpdate_);
        else if (r2 instanceof X)
          r2.value.emitter.on("change", this.onChildValueChange_);
        else {
          const e4 = pe(r2);
          if (e4) {
            const t4 = e4.emitter;
            t4.on("layout", this.onDescendantLayout_), t4.on("inputchange", this.onDescendantInputChange_), t4.on("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      onSetRemove_(e3) {
        this.updatePositions_();
        const t3 = e3.target === e3.root;
        if (this.emitter.emit("remove", { bladeController: e3.item, isRoot: t3, sender: this }), !t3)
          return;
        const r2 = e3.item;
        if (r2 instanceof re)
          r2.binding.emitter.off("change", this.onChildInputChange_);
        else if (r2 instanceof ie)
          r2.binding.emitter.off("update", this.onChildMonitorUpdate_);
        else if (r2 instanceof X)
          r2.value.emitter.off("change", this.onChildValueChange_);
        else {
          const e4 = pe(r2);
          if (e4) {
            const t4 = e4.emitter;
            t4.off("layout", this.onDescendantLayout_), t4.off("inputchange", this.onDescendantInputChange_), t4.off("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      updatePositions_() {
        const e3 = this.bcSet_.items.filter((e4) => !e4.viewProps.get("hidden")), t3 = e3[0], r2 = e3[e3.length - 1];
        this.bcSet_.items.forEach((e4) => {
          const n2 = [];
          e4 === t3 && (n2.push("first"), this.blade_ && !this.blade_.get("positions").includes("veryfirst") || n2.push("veryfirst")), e4 === r2 && (n2.push("last"), this.blade_ && !this.blade_.get("positions").includes("verylast") || n2.push("verylast")), e4.blade.set("positions", n2);
        });
      }
      onChildPositionsChange_() {
        this.updatePositions_(), this.emitter.emit("layout", { sender: this });
      }
      onChildViewPropsChange_(e3) {
        this.updatePositions_(), this.emitter.emit("layout", { sender: this });
      }
      onChildDispose_() {
        this.bcSet_.items.filter((e3) => e3.viewProps.get("disposed")).forEach((e3) => {
          this.bcSet_.remove(e3);
        });
      }
      onChildInputChange_(e3) {
        const t3 = function(e4, t4) {
          for (let r2 = 0; r2 < e4.length; r2++) {
            const n2 = e4[r2];
            if (n2 instanceof re && n2.binding === t4)
              return n2;
          }
          return null;
        }(this.find(re), e3.sender);
        if (!t3)
          throw c.shouldNeverHappen();
        this.emitter.emit("inputchange", { bladeController: t3, options: e3.options, sender: this });
      }
      onChildMonitorUpdate_(e3) {
        const t3 = function(e4, t4) {
          for (let r2 = 0; r2 < e4.length; r2++) {
            const n2 = e4[r2];
            if (n2 instanceof ie && n2.binding === t4)
              return n2;
          }
          return null;
        }(this.find(ie), e3.sender);
        if (!t3)
          throw c.shouldNeverHappen();
        this.emitter.emit("monitorupdate", { bladeController: t3, sender: this });
      }
      onChildValueChange_(e3) {
        const t3 = function(e4, t4) {
          for (let r2 = 0; r2 < e4.length; r2++) {
            const n2 = e4[r2];
            if (n2 instanceof X && n2.value === t4)
              return n2;
          }
          return null;
        }(this.find(X), e3.sender);
        if (!t3)
          throw c.shouldNeverHappen();
        this.emitter.emit("inputchange", { bladeController: t3, options: e3.options, sender: this });
      }
      onDescendantLayout_(e3) {
        this.updatePositions_(), this.emitter.emit("layout", { sender: this });
      }
      onDescendantInputChange_(e3) {
        this.emitter.emit("inputchange", { bladeController: e3.bladeController, options: e3.options, sender: this });
      }
      onDescendantMonitorUpdate_(e3) {
        this.emitter.emit("monitorupdate", { bladeController: e3.bladeController, sender: this });
      }
      onBladePositionsChange_() {
        this.updatePositions_();
      }
    }
    class me extends B {
      constructor(e3, t3) {
        super(Object.assign(Object.assign({}, t3), { view: new he(e3, { viewName: "brk", viewProps: t3.viewProps }) })), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
        const r2 = new fe(t3.root ? void 0 : t3.blade);
        r2.emitter.on("add", this.onRackAdd_), r2.emitter.on("remove", this.onRackRemove_), this.rack = r2, this.viewProps.handleDispose(() => {
          for (let e4 = this.rack.children.length - 1; e4 >= 0; e4--)
            this.rack.children[e4].viewProps.set("disposed", true);
        });
      }
      onRackAdd_(e3) {
        e3.isRoot && j(this.view.element, e3.bladeController.view.element, e3.index);
      }
      onRackRemove_(e3) {
        e3.isRoot && z(e3.bladeController.view.element);
      }
    }
    const _e = f("cnt");
    class ge {
      constructor(e3, t3) {
        this.className_ = f(t3.viewName || "fld"), this.element = e3.createElement("div"), this.element.classList.add(this.className_(), _e()), t3.viewProps.bindClassModifiers(this.element), this.foldable_ = t3.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), g(this.foldable_, "completed", v(this.element, this.className_(void 0, "cpl")));
        const r2 = e3.createElement("button");
        r2.classList.add(this.className_("b")), g(t3.props, "title", (e4) => {
          o(e4) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"));
        }), t3.viewProps.bindDisabled(r2), this.element.appendChild(r2), this.buttonElement = r2;
        const n2 = e3.createElement("div");
        n2.classList.add(this.className_("t")), A(t3.props.value("title"), n2), this.buttonElement.appendChild(n2), this.titleElement = n2;
        const i2 = e3.createElement("div");
        i2.classList.add(this.className_("m")), this.buttonElement.appendChild(i2);
        const s2 = t3.containerElement;
        s2.classList.add(this.className_("c")), this.element.appendChild(s2), this.containerElement = s2;
      }
    }
    class ve extends ue {
      constructor(e3, t3) {
        var r2;
        const n2 = K.create(null === (r2 = t3.expanded) || void 0 === r2 || r2), i2 = new me(e3, { blade: t3.blade, root: t3.root, viewProps: t3.viewProps });
        super(Object.assign(Object.assign({}, t3), { rackController: i2, view: new ge(e3, { containerElement: i2.view.element, foldable: n2, props: t3.props, viewName: t3.root ? "rot" : void 0, viewProps: t3.viewProps }) })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = t3.props, this.foldable = n2, Z(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
          this.foldable.cleanUpTransition();
        }), this.rackController.rack.emitter.on("remove", () => {
          this.foldable.cleanUpTransition();
        }), this.view.buttonElement.addEventListener("click", this.onTitleClick_);
      }
      get document() {
        return this.view.element.ownerDocument;
      }
      onTitleClick_() {
        this.foldable.set("expanded", !this.foldable.get("expanded"));
      }
    }
    const Ae = { id: "folder", type: "blade", accept(e3) {
      const t3 = I, r2 = k(e3, { title: t3.required.string, view: t3.required.constant("folder"), expanded: t3.optional.boolean });
      return r2 ? { params: r2 } : null;
    }, controller: (e3) => new ve(e3.document, { blade: e3.blade, expanded: e3.params.expanded, props: C.fromObject({ title: e3.params.title }), viewProps: e3.viewProps }), api: (e3) => e3.controller instanceof ve ? new ce(e3.controller, e3.pool) : null };
    class be extends X {
      constructor(e3, t3) {
        const r2 = t3.valueController.viewProps;
        super(Object.assign(Object.assign({}, t3), { value: t3.valueController.value, view: new H(e3, { props: t3.props, viewProps: r2 }), viewProps: r2 })), this.props = t3.props, this.valueController = t3.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    class ye extends t2 {
    }
    const xe = f("spr");
    class we {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(xe()), t3.viewProps.bindClassModifiers(this.element);
        const r2 = e3.createElement("hr");
        r2.classList.add(xe("r")), this.element.appendChild(r2);
      }
    }
    class Ee extends B {
      constructor(e3, t3) {
        super(Object.assign(Object.assign({}, t3), { view: new we(e3, { viewProps: t3.viewProps }) }));
      }
    }
    const Se = { id: "separator", type: "blade", accept(e3) {
      const t3 = k(e3, { view: I.required.constant("separator") });
      return t3 ? { params: t3 } : null;
    }, controller: (e3) => new Ee(e3.document, { blade: e3.blade, viewProps: e3.viewProps }), api: (e3) => e3.controller instanceof Ee ? new ye(e3.controller) : null }, Ce = f("");
    function Me(e3, t3) {
      return v(e3, Ce(void 0, t3));
    }
    class Te extends C {
      constructor(e3) {
        super(e3);
      }
      static create(e3) {
        var t3, r2;
        const n2 = null != e3 ? e3 : {}, i2 = { disabled: null !== (t3 = n2.disabled) && void 0 !== t3 && t3, disposed: false, hidden: null !== (r2 = n2.hidden) && void 0 !== r2 && r2 }, s2 = C.createCore(i2);
        return new Te(s2);
      }
      bindClassModifiers(e3) {
        g(this, "disabled", Me(e3, "disabled")), g(this, "hidden", Me(e3, "hidden"));
      }
      bindDisabled(e3) {
        g(this, "disabled", (t3) => {
          e3.disabled = t3;
        });
      }
      bindTabIndex(e3) {
        g(this, "disabled", (t3) => {
          e3.tabIndex = t3 ? -1 : 0;
        });
      }
      handleDispose(e3) {
        this.value("disposed").emitter.on("change", (t3) => {
          t3 && e3();
        });
      }
    }
    const Ie = f("tbi");
    class ke {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(Ie()), t3.viewProps.bindClassModifiers(this.element), g(t3.props, "selected", (e4) => {
          e4 ? this.element.classList.add(Ie(void 0, "sel")) : this.element.classList.remove(Ie(void 0, "sel"));
        });
        const r2 = e3.createElement("button");
        r2.classList.add(Ie("b")), t3.viewProps.bindDisabled(r2), this.element.appendChild(r2), this.buttonElement = r2;
        const n2 = e3.createElement("div");
        n2.classList.add(Ie("t")), A(t3.props.value("title"), n2), this.buttonElement.appendChild(n2), this.titleElement = n2;
      }
    }
    class De {
      constructor(e3, t3) {
        this.emitter = new p(), this.onClick_ = this.onClick_.bind(this), this.props = t3.props, this.viewProps = t3.viewProps, this.view = new ke(e3, { props: t3.props, viewProps: t3.viewProps }), this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", { sender: this });
      }
    }
    class Pe {
      constructor(e3, t3) {
        this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new De(e3, { props: t3.itemProps, viewProps: Te.create() }), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new me(e3, { blade: Y(), viewProps: Te.create() }), this.props = t3.props, g(this.props, "selected", (e4) => {
          this.itemController.props.set("selected", e4), this.contentController.viewProps.set("hidden", !e4);
        });
      }
      get itemController() {
        return this.ic_;
      }
      get contentController() {
        return this.cc_;
      }
      onItemClick_() {
        this.props.set("selected", true);
      }
    }
    class Be {
      constructor(e3, t3) {
        this.controller_ = e3, this.rackApi_ = t3;
      }
      get title() {
        var e3;
        return null !== (e3 = this.controller_.itemController.props.get("title")) && void 0 !== e3 ? e3 : "";
      }
      set title(e3) {
        this.controller_.itemController.props.set("title", e3);
      }
      get selected() {
        return this.controller_.props.get("selected");
      }
      set selected(e3) {
        this.controller_.props.set("selected", e3);
      }
      get children() {
        return this.rackApi_.children;
      }
      addButton(e3) {
        return this.rackApi_.addButton(e3);
      }
      addFolder(e3) {
        return this.rackApi_.addFolder(e3);
      }
      addSeparator(e3) {
        return this.rackApi_.addSeparator(e3);
      }
      addTab(e3) {
        return this.rackApi_.addTab(e3);
      }
      add(e3, t3) {
        this.rackApi_.add(e3, t3);
      }
      remove(e3) {
        this.rackApi_.remove(e3);
      }
      addInput(e3, t3, r2) {
        return this.rackApi_.addInput(e3, t3, r2);
      }
      addMonitor(e3, t3, r2) {
        return this.rackApi_.addMonitor(e3, t3, r2);
      }
      addBlade(e3) {
        return this.rackApi_.addBlade(e3);
      }
    }
    class Re extends $ {
      constructor(e3, t3) {
        super(e3, new le(e3.rackController, t3)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.emitter_ = new p(), this.pageApiMap_ = /* @__PURE__ */ new Map(), this.rackApi_.on("change", (e4) => {
          this.emitter_.emit("change", { event: e4 });
        }), this.rackApi_.on("update", (e4) => {
          this.emitter_.emit("update", { event: e4 });
        }), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach((e4) => {
          this.setUpPageApi_(e4);
        });
      }
      get pages() {
        return this.controller_.pageSet.items.map((e3) => {
          const t3 = this.pageApiMap_.get(e3);
          if (!t3)
            throw c.shouldNeverHappen();
          return t3;
        });
      }
      addPage(e3) {
        const t3 = this.controller_.view.element.ownerDocument, r2 = new Pe(t3, { itemProps: C.fromObject({ selected: false, title: e3.title }), props: C.fromObject({ selected: false }) });
        this.controller_.add(r2, e3.index);
        const n2 = this.pageApiMap_.get(r2);
        if (!n2)
          throw c.shouldNeverHappen();
        return n2;
      }
      removePage(e3) {
        this.controller_.remove(e3);
      }
      on(e3, t3) {
        const r2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          r2(e4.event);
        }), this;
      }
      setUpPageApi_(e3) {
        const t3 = this.rackApi_.apiSet_.find((t4) => t4.controller_ === e3.contentController);
        if (!t3)
          throw c.shouldNeverHappen();
        const r2 = new Be(e3, t3);
        this.pageApiMap_.set(e3, r2);
      }
      onPageAdd_(e3) {
        this.setUpPageApi_(e3.item);
      }
      onPageRemove_(e3) {
        if (!this.pageApiMap_.get(e3.item))
          throw c.shouldNeverHappen();
        this.pageApiMap_.delete(e3.item);
      }
    }
    const Le = f("tab");
    class Oe {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(Le(), _e()), t3.viewProps.bindClassModifiers(this.element), _(t3.empty, v(this.element, Le(void 0, "nop")));
        const r2 = e3.createElement("div");
        r2.classList.add(Le("i")), this.element.appendChild(r2), this.itemsElement = r2;
        const n2 = t3.contentsElement;
        n2.classList.add(Le("c")), this.element.appendChild(n2), this.contentsElement = n2;
      }
    }
    class Fe extends ue {
      constructor(e3, t3) {
        const r2 = new me(e3, { blade: t3.blade, viewProps: t3.viewProps }), n2 = S(true);
        super({ blade: t3.blade, rackController: r2, view: new Oe(e3, { contentsElement: r2.view.element, empty: n2, viewProps: t3.viewProps }) }), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onPageSelectedChange_ = this.onPageSelectedChange_.bind(this), this.pageSet_ = new ee(() => null), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.empty_ = n2, this.applyPages_();
      }
      get pageSet() {
        return this.pageSet_;
      }
      add(e3, t3) {
        this.pageSet_.add(e3, null != t3 ? t3 : this.pageSet_.items.length);
      }
      remove(e3) {
        this.pageSet_.remove(this.pageSet_.items[e3]);
      }
      applyPages_() {
        this.keepSelection_(), this.empty_.rawValue = 0 === this.pageSet_.items.length;
      }
      onPageAdd_(e3) {
        const t3 = e3.item;
        j(this.view.itemsElement, t3.itemController.view.element, e3.index), this.rackController.rack.add(t3.contentController, e3.index), t3.props.value("selected").emitter.on("change", this.onPageSelectedChange_), this.applyPages_();
      }
      onPageRemove_(e3) {
        const t3 = e3.item;
        z(t3.itemController.view.element), this.rackController.rack.remove(t3.contentController), t3.props.value("selected").emitter.off("change", this.onPageSelectedChange_), this.applyPages_();
      }
      keepSelection_() {
        if (0 === this.pageSet_.items.length)
          return;
        const e3 = this.pageSet_.items.findIndex((e4) => e4.props.get("selected"));
        e3 < 0 ? this.pageSet_.items.forEach((e4, t3) => {
          e4.props.set("selected", 0 === t3);
        }) : this.pageSet_.items.forEach((t3, r2) => {
          t3.props.set("selected", r2 === e3);
        });
      }
      onPageSelectedChange_(e3) {
        if (e3.rawValue) {
          const t3 = this.pageSet_.items.findIndex((t4) => t4.props.value("selected") === e3.sender);
          this.pageSet_.items.forEach((e4, r2) => {
            e4.props.set("selected", r2 === t3);
          });
        } else
          this.keepSelection_();
      }
    }
    const Ue = { id: "tab", type: "blade", accept(e3) {
      const t3 = I, r2 = k(e3, { pages: t3.required.array(t3.required.object({ title: t3.required.string })), view: t3.required.constant("tab") });
      return r2 && 0 !== r2.pages.length ? { params: r2 } : null;
    }, controller(e3) {
      const t3 = new Fe(e3.document, { blade: e3.blade, viewProps: e3.viewProps });
      return e3.params.pages.forEach((r2) => {
        const n2 = new Pe(e3.document, { itemProps: C.fromObject({ selected: false, title: r2.title }), props: C.fromObject({ selected: false }) });
        t3.add(n2);
      }), t3;
    }, api: (e3) => e3.controller instanceof Fe ? new Re(e3.controller, e3.pool) : null };
    class Ne {
      constructor() {
        this.disabled = false, this.emitter = new p();
      }
      dispose() {
      }
      tick() {
        this.disabled || this.emitter.emit("tick", { sender: this });
      }
    }
    class je {
      constructor(e3, t3) {
        this.disabled_ = false, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = e3, this.emitter = new p(), this.interval_ = t3, this.setTimer_();
      }
      get disabled() {
        return this.disabled_;
      }
      set disabled(e3) {
        this.disabled_ = e3, this.disabled_ ? this.clearTimer_() : this.setTimer_();
      }
      dispose() {
        this.clearTimer_();
      }
      clearTimer_() {
        if (null === this.timerId_)
          return;
        const e3 = this.doc_.defaultView;
        e3 && e3.clearInterval(this.timerId_), this.timerId_ = null;
      }
      setTimer_() {
        if (this.clearTimer_(), this.interval_ <= 0)
          return;
        const e3 = this.doc_.defaultView;
        e3 && (this.timerId_ = e3.setInterval(this.onTick_, this.interval_));
      }
      onTick_() {
        this.disabled_ || this.emitter.emit("tick", { sender: this });
      }
    }
    class ze {
      constructor(e3) {
        this.constraints = e3;
      }
      constrain(e3) {
        return this.constraints.reduce((e4, t3) => t3.constrain(e4), e3);
      }
    }
    function Ge(e3, t3) {
      if (e3 instanceof t3)
        return e3;
      if (e3 instanceof ze) {
        const r2 = e3.constraints.reduce((e4, r3) => e4 || (r3 instanceof t3 ? r3 : null), null);
        if (r2)
          return r2;
      }
      return null;
    }
    class Ve {
      constructor(e3) {
        this.options = e3;
      }
      constrain(e3) {
        const t3 = this.options;
        return 0 === t3.length || t3.filter((t4) => t4.value === e3).length > 0 ? e3 : t3[0].value;
      }
    }
    class Qe {
      constructor(e3) {
        this.maxValue = e3.max, this.minValue = e3.min;
      }
      constrain(e3) {
        let t3 = e3;
        return o(this.minValue) || (t3 = Math.max(t3, this.minValue)), o(this.maxValue) || (t3 = Math.min(t3, this.maxValue)), t3;
      }
    }
    class He {
      constructor(e3) {
        this.step = e3;
      }
      constrain(e3) {
        return (e3 < 0 ? -Math.round(-e3 / this.step) : Math.round(e3 / this.step)) * this.step;
      }
    }
    const We = f("lst");
    class qe {
      constructor(e3, t3) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t3.props, this.element = e3.createElement("div"), this.element.classList.add(We()), t3.viewProps.bindClassModifiers(this.element);
        const r2 = e3.createElement("select");
        r2.classList.add(We("s")), g(this.props_, "options", (t4) => {
          G(r2), t4.forEach((t5, n3) => {
            const i2 = e3.createElement("option");
            i2.dataset.index = String(n3), i2.textContent = t5.text, i2.value = String(t5.value), r2.appendChild(i2);
          });
        }), t3.viewProps.bindDisabled(r2), this.element.appendChild(r2), this.selectElement = r2;
        const n2 = e3.createElement("div");
        n2.classList.add(We("m")), n2.appendChild(N(e3, "dropdown")), this.element.appendChild(n2), t3.value.emitter.on("change", this.onValueChange_), this.value_ = t3.value, this.update_();
      }
      update_() {
        this.selectElement.value = String(this.value_.rawValue);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class Xe {
      constructor(e3, t3) {
        this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = t3.props, this.value = t3.value, this.viewProps = t3.viewProps, this.view = new qe(e3, { props: this.props, value: this.value, viewProps: this.viewProps }), this.view.selectElement.addEventListener("change", this.onSelectChange_);
      }
      onSelectChange_(e3) {
        const t3 = e3.currentTarget.selectedOptions.item(0);
        if (!t3)
          return;
        const r2 = Number(t3.dataset.index);
        this.value.rawValue = this.props.get("options")[r2].value;
      }
    }
    const Ye = f("pop");
    class Ke {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(Ye()), t3.viewProps.bindClassModifiers(this.element), _(t3.shows, v(this.element, Ye(void 0, "v")));
      }
    }
    class Je {
      constructor(e3, t3) {
        this.shows = S(false), this.viewProps = t3.viewProps, this.view = new Ke(e3, { shows: this.shows, viewProps: this.viewProps });
      }
    }
    const Ze = f("txt");
    class $e {
      constructor(e3, t3) {
        this.onChange_ = this.onChange_.bind(this), this.element = e3.createElement("div"), this.element.classList.add(Ze()), t3.viewProps.bindClassModifiers(this.element), this.props_ = t3.props, this.props_.emitter.on("change", this.onChange_);
        const r2 = e3.createElement("input");
        r2.classList.add(Ze("i")), r2.type = "text", t3.viewProps.bindDisabled(r2), this.element.appendChild(r2), this.inputElement = r2, t3.value.emitter.on("change", this.onChange_), this.value_ = t3.value, this.refresh();
      }
      refresh() {
        const e3 = this.props_.get("formatter");
        this.inputElement.value = e3(this.value_.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class et {
      constructor(e3, t3) {
        this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = t3.parser, this.props = t3.props, this.value = t3.value, this.viewProps = t3.viewProps, this.view = new $e(e3, { props: t3.props, value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_);
      }
      onInputChange_(e3) {
        const t3 = e3.currentTarget.value, r2 = this.parser_(t3);
        o(r2) || (this.value.rawValue = r2), this.view.refresh();
      }
    }
    function tt(e3) {
      return "false" !== e3 && !!e3;
    }
    function rt(e3) {
      return function(e4) {
        return String(e4);
      }(e3);
    }
    class nt {
      constructor(e3) {
        this.text = e3;
      }
      evaluate() {
        return Number(this.text);
      }
      toString() {
        return this.text;
      }
    }
    const it = { "**": (e3, t3) => Math.pow(e3, t3), "*": (e3, t3) => e3 * t3, "/": (e3, t3) => e3 / t3, "%": (e3, t3) => e3 % t3, "+": (e3, t3) => e3 + t3, "-": (e3, t3) => e3 - t3, "<<": (e3, t3) => e3 << t3, ">>": (e3, t3) => e3 >> t3, ">>>": (e3, t3) => e3 >>> t3, "&": (e3, t3) => e3 & t3, "^": (e3, t3) => e3 ^ t3, "|": (e3, t3) => e3 | t3 };
    class st {
      constructor(e3, t3, r2) {
        this.left = t3, this.operator = e3, this.right = r2;
      }
      evaluate() {
        const e3 = it[this.operator];
        if (!e3)
          throw new Error(`unexpected binary operator: '${this.operator}`);
        return e3(this.left.evaluate(), this.right.evaluate());
      }
      toString() {
        return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ");
      }
    }
    const ot = { "+": (e3) => e3, "-": (e3) => -e3, "~": (e3) => ~e3 };
    class at {
      constructor(e3, t3) {
        this.operator = e3, this.expression = t3;
      }
      evaluate() {
        const e3 = ot[this.operator];
        if (!e3)
          throw new Error(`unexpected unary operator: '${this.operator}`);
        return e3(this.expression.evaluate());
      }
      toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
      }
    }
    function lt(e3) {
      return (t3, r2) => {
        for (let n2 = 0; n2 < e3.length; n2++) {
          const i2 = e3[n2](t3, r2);
          if ("" !== i2)
            return i2;
        }
        return "";
      };
    }
    function ct(e3, t3) {
      var r2;
      const n2 = e3.substr(t3).match(/^\s+/);
      return null !== (r2 = n2 && n2[0]) && void 0 !== r2 ? r2 : "";
    }
    function ut(e3, t3) {
      var r2;
      const n2 = e3.substr(t3).match(/^[0-9]+/);
      return null !== (r2 = n2 && n2[0]) && void 0 !== r2 ? r2 : "";
    }
    function ht(e3, t3) {
      const r2 = e3.substr(t3, 1);
      if (t3 += 1, "e" !== r2.toLowerCase())
        return "";
      const n2 = function(e4, t4) {
        const r3 = ut(e4, t4);
        if ("" !== r3)
          return r3;
        const n3 = e4.substr(t4, 1);
        if ("-" !== n3 && "+" !== n3)
          return "";
        const i2 = ut(e4, t4 += 1);
        return "" === i2 ? "" : n3 + i2;
      }(e3, t3);
      return "" === n2 ? "" : r2 + n2;
    }
    function pt(e3, t3) {
      const r2 = e3.substr(t3, 1);
      if ("0" === r2)
        return r2;
      const n2 = function(e4, t4) {
        const r3 = e4.substr(t4, 1);
        return r3.match(/^[1-9]$/) ? r3 : "";
      }(e3, t3);
      return t3 += n2.length, "" === n2 ? "" : n2 + ut(e3, t3);
    }
    const dt = lt([function(e3, t3) {
      const r2 = pt(e3, t3);
      if (t3 += r2.length, "" === r2)
        return "";
      const n2 = e3.substr(t3, 1);
      if (t3 += n2.length, "." !== n2)
        return "";
      const i2 = ut(e3, t3);
      return r2 + n2 + i2 + ht(e3, t3 += i2.length);
    }, function(e3, t3) {
      const r2 = e3.substr(t3, 1);
      if (t3 += r2.length, "." !== r2)
        return "";
      const n2 = ut(e3, t3);
      return t3 += n2.length, "" === n2 ? "" : r2 + n2 + ht(e3, t3);
    }, function(e3, t3) {
      const r2 = pt(e3, t3);
      return t3 += r2.length, "" === r2 ? "" : r2 + ht(e3, t3);
    }]);
    const ft = lt([function(e3, t3) {
      const r2 = e3.substr(t3, 2);
      if (t3 += r2.length, "0b" !== r2.toLowerCase())
        return "";
      const n2 = function(e4, t4) {
        var r3;
        const n3 = e4.substr(t4).match(/^[01]+/);
        return null !== (r3 = n3 && n3[0]) && void 0 !== r3 ? r3 : "";
      }(e3, t3);
      return "" === n2 ? "" : r2 + n2;
    }, function(e3, t3) {
      const r2 = e3.substr(t3, 2);
      if (t3 += r2.length, "0o" !== r2.toLowerCase())
        return "";
      const n2 = function(e4, t4) {
        var r3;
        const n3 = e4.substr(t4).match(/^[0-7]+/);
        return null !== (r3 = n3 && n3[0]) && void 0 !== r3 ? r3 : "";
      }(e3, t3);
      return "" === n2 ? "" : r2 + n2;
    }, function(e3, t3) {
      const r2 = e3.substr(t3, 2);
      if (t3 += r2.length, "0x" !== r2.toLowerCase())
        return "";
      const n2 = function(e4, t4) {
        var r3;
        const n3 = e4.substr(t4).match(/^[0-9a-f]+/i);
        return null !== (r3 = n3 && n3[0]) && void 0 !== r3 ? r3 : "";
      }(e3, t3);
      return "" === n2 ? "" : r2 + n2;
    }]), mt = lt([ft, dt]);
    function _t(e3, t3) {
      return function(e4, t4) {
        const r2 = mt(e4, t4);
        return t4 += r2.length, "" === r2 ? null : { evaluable: new nt(r2), cursor: t4 };
      }(e3, t3) || function(e4, t4) {
        const r2 = e4.substr(t4, 1);
        if (t4 += r2.length, "(" !== r2)
          return null;
        const n2 = At(e4, t4);
        if (!n2)
          return null;
        t4 = n2.cursor, t4 += ct(e4, t4).length;
        const i2 = e4.substr(t4, 1);
        return t4 += i2.length, ")" !== i2 ? null : { evaluable: n2.evaluable, cursor: t4 };
      }(e3, t3);
    }
    function gt(e3, t3, r2) {
      r2 += ct(t3, r2).length;
      const n2 = e3.filter((e4) => t3.startsWith(e4, r2))[0];
      return n2 ? (r2 += n2.length, { cursor: r2 += ct(t3, r2).length, operator: n2 }) : null;
    }
    const vt = [["**"], ["*", "/", "%"], ["+", "-"], ["<<", ">>>", ">>"], ["&"], ["^"], ["|"]].reduce((e3, t3) => function(e4, t4) {
      return (r2, n2) => {
        const i2 = e4(r2, n2);
        if (!i2)
          return null;
        n2 = i2.cursor;
        let s2 = i2.evaluable;
        for (; ; ) {
          const i3 = gt(t4, r2, n2);
          if (!i3)
            break;
          n2 = i3.cursor;
          const o2 = e4(r2, n2);
          if (!o2)
            return null;
          n2 = o2.cursor, s2 = new st(i3.operator, s2, o2.evaluable);
        }
        return s2 ? { cursor: n2, evaluable: s2 } : null;
      };
    }(e3, t3), function e3(t3, r2) {
      const n2 = _t(t3, r2);
      if (n2)
        return n2;
      const i2 = t3.substr(r2, 1);
      if (r2 += i2.length, "+" !== i2 && "-" !== i2 && "~" !== i2)
        return null;
      const s2 = e3(t3, r2);
      return s2 ? { cursor: r2 = s2.cursor, evaluable: new at(i2, s2.evaluable) } : null;
    });
    function At(e3, t3) {
      return t3 += ct(e3, t3).length, vt(e3, t3);
    }
    function bt(e3) {
      var t3;
      const r2 = function(e4) {
        const t4 = At(e4, 0);
        return t4 ? t4.cursor + ct(e4, t4.cursor).length !== e4.length ? null : t4.evaluable : null;
      }(e3);
      return null !== (t3 = null == r2 ? void 0 : r2.evaluate()) && void 0 !== t3 ? t3 : null;
    }
    function yt(e3) {
      if ("number" == typeof e3)
        return e3;
      if ("string" == typeof e3) {
        const t3 = bt(e3);
        if (!o(t3))
          return t3;
      }
      return 0;
    }
    function xt(e3) {
      return String(e3);
    }
    function wt(e3) {
      return (t3) => t3.toFixed(Math.max(Math.min(e3, 20), 0));
    }
    const Et = wt(0);
    function St(e3) {
      return Et(e3) + "%";
    }
    function Ct(e3) {
      return String(e3);
    }
    function Mt(e3) {
      return e3;
    }
    function Tt(e3, t3) {
      for (; e3.length < t3; )
        e3.push(void 0);
    }
    function It(e3) {
      const t3 = [];
      return Tt(t3, e3), S(t3);
    }
    function kt(e3) {
      const t3 = e3.indexOf(void 0);
      return t3 < 0 ? e3 : e3.slice(0, t3);
    }
    function Dt({ primary: e3, secondary: t3, forward: r2, backward: n2 }) {
      let i2 = false;
      function s2(e4) {
        i2 || (i2 = true, e4(), i2 = false);
      }
      e3.emitter.on("change", (n3) => {
        s2(() => {
          t3.setRawValue(r2(e3, t3), n3.options);
        });
      }), t3.emitter.on("change", (i3) => {
        s2(() => {
          e3.setRawValue(n2(e3, t3), i3.options);
        }), s2(() => {
          t3.setRawValue(r2(e3, t3), i3.options);
        });
      }), s2(() => {
        t3.setRawValue(r2(e3, t3), { forceEmit: false, last: true });
      });
    }
    function Pt(e3, t3) {
      const r2 = e3 * (t3.altKey ? 0.1 : 1) * (t3.shiftKey ? 10 : 1);
      return t3.upKey ? +r2 : t3.downKey ? -r2 : 0;
    }
    function Bt(e3) {
      return { altKey: e3.altKey, downKey: "ArrowDown" === e3.key, shiftKey: e3.shiftKey, upKey: "ArrowUp" === e3.key };
    }
    function Rt(e3) {
      return { altKey: e3.altKey, downKey: "ArrowLeft" === e3.key, shiftKey: e3.shiftKey, upKey: "ArrowRight" === e3.key };
    }
    function Lt(e3) {
      return function(e4) {
        return "ArrowUp" === e4 || "ArrowDown" === e4;
      }(e3) || "ArrowLeft" === e3 || "ArrowRight" === e3;
    }
    function Ot(e3, t3) {
      const r2 = t3.ownerDocument.defaultView, n2 = t3.getBoundingClientRect();
      return { x: e3.pageX - ((r2 && r2.scrollX || 0) + n2.left), y: e3.pageY - ((r2 && r2.scrollY || 0) + n2.top) };
    }
    class Ft {
      constructor(e3) {
        this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = e3, this.emitter = new p(), e3.addEventListener("touchstart", this.onTouchStart_, { passive: false }), e3.addEventListener("touchmove", this.onTouchMove_, { passive: true }), e3.addEventListener("touchend", this.onTouchEnd_), e3.addEventListener("mousedown", this.onMouseDown_);
      }
      computePosition_(e3) {
        const t3 = this.elem_.getBoundingClientRect();
        return { bounds: { width: t3.width, height: t3.height }, point: e3 ? { x: e3.x, y: e3.y } : null };
      }
      onMouseDown_(e3) {
        var t3;
        e3.preventDefault(), null === (t3 = e3.currentTarget) || void 0 === t3 || t3.focus();
        const r2 = this.elem_.ownerDocument;
        r2.addEventListener("mousemove", this.onDocumentMouseMove_), r2.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", { altKey: e3.altKey, data: this.computePosition_(Ot(e3, this.elem_)), sender: this, shiftKey: e3.shiftKey });
      }
      onDocumentMouseMove_(e3) {
        this.emitter.emit("move", { altKey: e3.altKey, data: this.computePosition_(Ot(e3, this.elem_)), sender: this, shiftKey: e3.shiftKey });
      }
      onDocumentMouseUp_(e3) {
        const t3 = this.elem_.ownerDocument;
        t3.removeEventListener("mousemove", this.onDocumentMouseMove_), t3.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", { altKey: e3.altKey, data: this.computePosition_(Ot(e3, this.elem_)), sender: this, shiftKey: e3.shiftKey });
      }
      onTouchStart_(e3) {
        e3.preventDefault();
        const t3 = e3.targetTouches.item(0), r2 = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", { altKey: e3.altKey, data: this.computePosition_(t3 ? { x: t3.clientX - r2.left, y: t3.clientY - r2.top } : void 0), sender: this, shiftKey: e3.shiftKey }), this.lastTouch_ = t3;
      }
      onTouchMove_(e3) {
        const t3 = e3.targetTouches.item(0), r2 = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", { altKey: e3.altKey, data: this.computePosition_(t3 ? { x: t3.clientX - r2.left, y: t3.clientY - r2.top } : void 0), sender: this, shiftKey: e3.shiftKey }), this.lastTouch_ = t3;
      }
      onTouchEnd_(e3) {
        var t3;
        const r2 = null !== (t3 = e3.targetTouches.item(0)) && void 0 !== t3 ? t3 : this.lastTouch_, n2 = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", { altKey: e3.altKey, data: this.computePosition_(r2 ? { x: r2.clientX - n2.left, y: r2.clientY - n2.top } : void 0), sender: this, shiftKey: e3.shiftKey });
      }
    }
    function Ut(e3, t3, r2, n2, i2) {
      return n2 + (e3 - t3) / (r2 - t3) * (i2 - n2);
    }
    function Nt(e3) {
      return String(e3.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
    }
    function jt(e3, t3, r2) {
      return Math.min(Math.max(e3, t3), r2);
    }
    function zt(e3, t3) {
      return (e3 % t3 + t3) % t3;
    }
    const Gt = f("txt");
    class Vt {
      constructor(e3, t3) {
        this.onChange_ = this.onChange_.bind(this), this.props_ = t3.props, this.props_.emitter.on("change", this.onChange_), this.element = e3.createElement("div"), this.element.classList.add(Gt(), Gt(void 0, "num")), t3.arrayPosition && this.element.classList.add(Gt(void 0, t3.arrayPosition)), t3.viewProps.bindClassModifiers(this.element);
        const r2 = e3.createElement("input");
        r2.classList.add(Gt("i")), r2.type = "text", t3.viewProps.bindDisabled(r2), this.element.appendChild(r2), this.inputElement = r2, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = t3.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(Gt()), this.inputElement.classList.add(Gt("i"));
        const n2 = e3.createElement("div");
        n2.classList.add(Gt("k")), this.element.appendChild(n2), this.knobElement = n2;
        const i2 = e3.createElementNS(R, "svg");
        i2.classList.add(Gt("g")), this.knobElement.appendChild(i2);
        const s2 = e3.createElementNS(R, "path");
        s2.classList.add(Gt("gb")), i2.appendChild(s2), this.guideBodyElem_ = s2;
        const o2 = e3.createElementNS(R, "path");
        o2.classList.add(Gt("gh")), i2.appendChild(o2), this.guideHeadElem_ = o2;
        const a2 = e3.createElement("div");
        a2.classList.add(f("tt")()), this.knobElement.appendChild(a2), this.tooltipElem_ = a2, t3.value.emitter.on("change", this.onChange_), this.value = t3.value, this.refresh();
      }
      onDraggingChange_(e3) {
        if (null === e3.rawValue)
          return void this.element.classList.remove(Gt(void 0, "drg"));
        this.element.classList.add(Gt(void 0, "drg"));
        const t3 = e3.rawValue / this.props_.get("draggingScale"), r2 = t3 + (t3 > 0 ? -1 : t3 < 0 ? 1 : 0), n2 = jt(-r2, -4, 4);
        this.guideHeadElem_.setAttributeNS(null, "d", [`M ${r2 + n2},0 L${r2},4 L${r2 + n2},8`, `M ${t3},-1 L${t3},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${t3},4`);
        const i2 = this.props_.get("formatter");
        this.tooltipElem_.textContent = i2(this.value.rawValue), this.tooltipElem_.style.left = `${t3}px`;
      }
      refresh() {
        const e3 = this.props_.get("formatter");
        this.inputElement.value = e3(this.value.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class Qt {
      constructor(e3, t3) {
        this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t3.baseStep, this.parser_ = t3.parser, this.props = t3.props, this.value = t3.value, this.viewProps = t3.viewProps, this.dragging_ = S(null), this.view = new Vt(e3, { arrayPosition: t3.arrayPosition, dragging: this.dragging_, props: this.props, value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
        const r2 = new Ft(this.view.knobElement);
        r2.emitter.on("down", this.onPointerDown_), r2.emitter.on("move", this.onPointerMove_), r2.emitter.on("up", this.onPointerUp_);
      }
      onInputChange_(e3) {
        const t3 = e3.currentTarget.value, r2 = this.parser_(t3);
        o(r2) || (this.value.rawValue = r2), this.view.refresh();
      }
      onInputKeyDown_(e3) {
        const t3 = Pt(this.baseStep_, Bt(e3));
        0 !== t3 && this.value.setRawValue(this.value.rawValue + t3, { forceEmit: false, last: false });
      }
      onInputKeyUp_(e3) {
        0 !== Pt(this.baseStep_, Bt(e3)) && this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
      }
      onPointerDown_() {
        this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0;
      }
      computeDraggingValue_(e3) {
        if (!e3.point)
          return null;
        const t3 = e3.point.x - e3.bounds.width / 2;
        return this.originRawValue_ + t3 * this.props.get("draggingScale");
      }
      onPointerMove_(e3) {
        const t3 = this.computeDraggingValue_(e3.data);
        null !== t3 && (this.value.setRawValue(t3, { forceEmit: false, last: false }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_);
      }
      onPointerUp_(e3) {
        const t3 = this.computeDraggingValue_(e3.data);
        null !== t3 && (this.value.setRawValue(t3, { forceEmit: true, last: true }), this.dragging_.rawValue = null);
      }
    }
    const Ht = f("sld");
    class Wt {
      constructor(e3, t3) {
        this.onChange_ = this.onChange_.bind(this), this.props_ = t3.props, this.props_.emitter.on("change", this.onChange_), this.element = e3.createElement("div"), this.element.classList.add(Ht()), t3.viewProps.bindClassModifiers(this.element);
        const r2 = e3.createElement("div");
        r2.classList.add(Ht("t")), t3.viewProps.bindTabIndex(r2), this.element.appendChild(r2), this.trackElement = r2;
        const n2 = e3.createElement("div");
        n2.classList.add(Ht("k")), this.trackElement.appendChild(n2), this.knobElement = n2, t3.value.emitter.on("change", this.onChange_), this.value = t3.value, this.update_();
      }
      update_() {
        const e3 = jt(Ut(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
        this.knobElement.style.width = `${e3}%`;
      }
      onChange_() {
        this.update_();
      }
    }
    class qt {
      constructor(e3, t3) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t3.baseStep, this.value = t3.value, this.viewProps = t3.viewProps, this.props = t3.props, this.view = new Wt(e3, { props: this.props, value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Ft(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(e3, t3) {
        e3.point && this.value.setRawValue(Ut(jt(e3.point.x, 0, e3.bounds.width), 0, e3.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), t3);
      }
      onPointerDownOrMove_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerUp_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: true, last: true });
      }
      onKeyDown_(e3) {
        const t3 = Pt(this.baseStep_, Rt(e3));
        0 !== t3 && this.value.setRawValue(this.value.rawValue + t3, { forceEmit: false, last: false });
      }
      onKeyUp_(e3) {
        0 !== Pt(this.baseStep_, Rt(e3)) && this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
      }
    }
    const Xt = f("sldtxt");
    class Yt {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(Xt());
        const r2 = e3.createElement("div");
        r2.classList.add(Xt("s")), this.sliderView_ = t3.sliderView, r2.appendChild(this.sliderView_.element), this.element.appendChild(r2);
        const n2 = e3.createElement("div");
        n2.classList.add(Xt("t")), this.textView_ = t3.textView, n2.appendChild(this.textView_.element), this.element.appendChild(n2);
      }
    }
    class Kt {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.sliderC_ = new qt(e3, { baseStep: t3.baseStep, props: t3.sliderProps, value: t3.value, viewProps: this.viewProps }), this.textC_ = new Qt(e3, { baseStep: t3.baseStep, parser: t3.parser, props: t3.textProps, value: t3.value, viewProps: t3.viewProps }), this.view = new Yt(e3, { sliderView: this.sliderC_.view, textView: this.textC_.view });
      }
      get sliderController() {
        return this.sliderC_;
      }
      get textController() {
        return this.textC_;
      }
    }
    function Jt(e3, t3) {
      e3.write(t3);
    }
    function Zt(e3) {
      const t3 = I;
      return Array.isArray(e3) ? t3.required.array(t3.required.object({ text: t3.required.string, value: t3.required.raw }))(e3).value : "object" == typeof e3 ? t3.required.raw(e3).value : void 0;
    }
    function $t(e3) {
      if ("inline" === e3 || "popup" === e3)
        return e3;
    }
    function er(e3) {
      const t3 = I;
      return t3.required.object({ max: t3.optional.number, min: t3.optional.number, step: t3.optional.number })(e3).value;
    }
    function tr(e3) {
      if (Array.isArray(e3))
        return e3;
      const t3 = [];
      return Object.keys(e3).forEach((r2) => {
        t3.push({ text: r2, value: e3[r2] });
      }), t3;
    }
    function rr(e3) {
      return o(e3) ? null : new Ve(tr(e3));
    }
    function nr(e3) {
      const t3 = e3 ? Ge(e3, Ve) : null;
      return t3 ? t3.options : null;
    }
    function ir(e3, t3) {
      const r2 = e3 && Ge(e3, He);
      return r2 ? Nt(r2.step) : Math.max(Nt(t3), 2);
    }
    function sr(e3) {
      const t3 = function(e4) {
        const t4 = e4 ? Ge(e4, He) : null;
        return t4 ? t4.step : null;
      }(e3);
      return null != t3 ? t3 : 1;
    }
    function or(e3, t3) {
      var r2;
      const n2 = e3 && Ge(e3, He), i2 = Math.abs(null !== (r2 = null == n2 ? void 0 : n2.step) && void 0 !== r2 ? r2 : t3);
      return 0 === i2 ? 0.1 : Math.pow(10, Math.floor(Math.log10(i2)) - 1);
    }
    const ar = f("ckb");
    class lr {
      constructor(e3, t3) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.element = e3.createElement("div"), this.element.classList.add(ar()), t3.viewProps.bindClassModifiers(this.element);
        const r2 = e3.createElement("label");
        r2.classList.add(ar("l")), this.element.appendChild(r2);
        const n2 = e3.createElement("input");
        n2.classList.add(ar("i")), n2.type = "checkbox", r2.appendChild(n2), this.inputElement = n2, t3.viewProps.bindDisabled(this.inputElement);
        const i2 = e3.createElement("div");
        i2.classList.add(ar("w")), r2.appendChild(i2);
        const s2 = N(e3, "check");
        i2.appendChild(s2), t3.value.emitter.on("change", this.onValueChange_), this.value = t3.value, this.update_();
      }
      update_() {
        this.inputElement.checked = this.value.rawValue;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class cr {
      constructor(e3, t3) {
        this.onInputChange_ = this.onInputChange_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.view = new lr(e3, { value: this.value, viewProps: this.viewProps }), this.view.inputElement.addEventListener("change", this.onInputChange_);
      }
      onInputChange_(e3) {
        const t3 = e3.currentTarget;
        this.value.rawValue = t3.checked;
      }
    }
    const ur = { id: "input-bool", type: "input", accept: (e3, t3) => {
      if ("boolean" != typeof e3)
        return null;
      const r2 = k(t3, { options: I.optional.custom(Zt) });
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { reader: (e3) => tt, constraint: (e3) => function(e4) {
      const t3 = [], r2 = rr(e4.options);
      return r2 && t3.push(r2), new ze(t3);
    }(e3.params), writer: (e3) => Jt }, controller: (e3) => {
      var t3;
      const r2 = e3.document, n2 = e3.value, i2 = e3.constraint;
      return i2 && Ge(i2, Ve) ? new Xe(r2, { props: C.fromObject({ options: null !== (t3 = nr(i2)) && void 0 !== t3 ? t3 : [] }), value: n2, viewProps: e3.viewProps }) : new cr(r2, { value: n2, viewProps: e3.viewProps });
    } }, hr = f("col");
    class pr {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(hr()), t3.foldable.bindExpandedClass(this.element, hr(void 0, "expanded")), g(t3.foldable, "completed", v(this.element, hr(void 0, "cpl")));
        const r2 = e3.createElement("div");
        r2.classList.add(hr("h")), this.element.appendChild(r2);
        const n2 = e3.createElement("div");
        n2.classList.add(hr("s")), r2.appendChild(n2), this.swatchElement = n2;
        const i2 = e3.createElement("div");
        if (i2.classList.add(hr("t")), r2.appendChild(i2), this.textElement = i2, "inline" === t3.pickerLayout) {
          const t4 = e3.createElement("div");
          t4.classList.add(hr("p")), this.element.appendChild(t4), this.pickerElement = t4;
        } else
          this.pickerElement = null;
      }
    }
    function dr(e3, t3, r2) {
      const n2 = zt(e3, 360), i2 = jt(t3 / 100, 0, 1), s2 = jt(r2 / 100, 0, 1), o2 = s2 * i2, a2 = o2 * (1 - Math.abs(n2 / 60 % 2 - 1)), l2 = s2 - o2;
      let c2, u2, h2;
      return [c2, u2, h2] = n2 >= 0 && n2 < 60 ? [o2, a2, 0] : n2 >= 60 && n2 < 120 ? [a2, o2, 0] : n2 >= 120 && n2 < 180 ? [0, o2, a2] : n2 >= 180 && n2 < 240 ? [0, a2, o2] : n2 >= 240 && n2 < 300 ? [a2, 0, o2] : [o2, 0, a2], [255 * (c2 + l2), 255 * (u2 + l2), 255 * (h2 + l2)];
    }
    function fr(e3) {
      return [e3[0], e3[1], e3[2]];
    }
    function mr(e3, t3) {
      return [e3[0], e3[1], e3[2], t3];
    }
    const _r = { hsl: { hsl: (e3, t3, r2) => [e3, t3, r2], hsv: function(e3, t3, r2) {
      const n2 = r2 + t3 * (100 - Math.abs(2 * r2 - 100)) / 200;
      return [e3, 0 !== n2 ? t3 * (100 - Math.abs(2 * r2 - 100)) / n2 : 0, r2 + t3 * (100 - Math.abs(2 * r2 - 100)) / 200];
    }, rgb: function(e3, t3, r2) {
      const n2 = (e3 % 360 + 360) % 360, i2 = jt(t3 / 100, 0, 1), s2 = jt(r2 / 100, 0, 1), o2 = (1 - Math.abs(2 * s2 - 1)) * i2, a2 = o2 * (1 - Math.abs(n2 / 60 % 2 - 1)), l2 = s2 - o2 / 2;
      let c2, u2, h2;
      return [c2, u2, h2] = n2 >= 0 && n2 < 60 ? [o2, a2, 0] : n2 >= 60 && n2 < 120 ? [a2, o2, 0] : n2 >= 120 && n2 < 180 ? [0, o2, a2] : n2 >= 180 && n2 < 240 ? [0, a2, o2] : n2 >= 240 && n2 < 300 ? [a2, 0, o2] : [o2, 0, a2], [255 * (c2 + l2), 255 * (u2 + l2), 255 * (h2 + l2)];
    } }, hsv: { hsl: function(e3, t3, r2) {
      const n2 = 100 - Math.abs(r2 * (200 - t3) / 100 - 100);
      return [e3, 0 !== n2 ? t3 * r2 / n2 : 0, r2 * (200 - t3) / 200];
    }, hsv: (e3, t3, r2) => [e3, t3, r2], rgb: dr }, rgb: { hsl: function(e3, t3, r2) {
      const n2 = jt(e3 / 255, 0, 1), i2 = jt(t3 / 255, 0, 1), s2 = jt(r2 / 255, 0, 1), o2 = Math.max(n2, i2, s2), a2 = Math.min(n2, i2, s2), l2 = o2 - a2;
      let c2 = 0, u2 = 0;
      const h2 = (a2 + o2) / 2;
      return 0 !== l2 && (u2 = l2 / (1 - Math.abs(o2 + a2 - 1)), c2 = n2 === o2 ? (i2 - s2) / l2 : i2 === o2 ? 2 + (s2 - n2) / l2 : 4 + (n2 - i2) / l2, c2 = c2 / 6 + (c2 < 0 ? 1 : 0)), [360 * c2, 100 * u2, 100 * h2];
    }, hsv: function(e3, t3, r2) {
      const n2 = jt(e3 / 255, 0, 1), i2 = jt(t3 / 255, 0, 1), s2 = jt(r2 / 255, 0, 1), o2 = Math.max(n2, i2, s2), a2 = o2 - Math.min(n2, i2, s2);
      let l2;
      return l2 = 0 === a2 ? 0 : o2 === n2 ? ((i2 - s2) / a2 % 6 + 6) % 6 * 60 : o2 === i2 ? 60 * ((s2 - n2) / a2 + 2) : 60 * ((n2 - i2) / a2 + 4), [l2, 100 * (0 === o2 ? 0 : a2 / o2), 100 * o2];
    }, rgb: (e3, t3, r2) => [e3, t3, r2] } };
    const gr = { hsl: (e3) => {
      var t3;
      return [zt(e3[0], 360), jt(e3[1], 0, 100), jt(e3[2], 0, 100), jt(null !== (t3 = e3[3]) && void 0 !== t3 ? t3 : 1, 0, 1)];
    }, hsv: (e3) => {
      var t3;
      return [zt(e3[0], 360), jt(e3[1], 0, 100), jt(e3[2], 0, 100), jt(null !== (t3 = e3[3]) && void 0 !== t3 ? t3 : 1, 0, 1)];
    }, rgb: (e3) => {
      var t3;
      return [jt(e3[0], 0, 255), jt(e3[1], 0, 255), jt(e3[2], 0, 255), jt(null !== (t3 = e3[3]) && void 0 !== t3 ? t3 : 1, 0, 1)];
    } };
    function vr(e3, t3) {
      return "object" == typeof e3 && !o(e3) && t3 in e3 && "number" == typeof e3[t3];
    }
    class Ar {
      constructor(e3, t3) {
        this.mode_ = t3, this.comps_ = gr[t3](e3);
      }
      static black() {
        return new Ar([0, 0, 0], "rgb");
      }
      static fromObject(e3) {
        const t3 = "a" in e3 ? [e3.r, e3.g, e3.b, e3.a] : [e3.r, e3.g, e3.b];
        return new Ar(t3, "rgb");
      }
      static toRgbaObject(e3) {
        return e3.toRgbaObject();
      }
      static isRgbColorObject(e3) {
        return vr(e3, "r") && vr(e3, "g") && vr(e3, "b");
      }
      static isRgbaColorObject(e3) {
        return this.isRgbColorObject(e3) && vr(e3, "a");
      }
      static isColorObject(e3) {
        return this.isRgbColorObject(e3);
      }
      static equals(e3, t3) {
        if (e3.mode_ !== t3.mode_)
          return false;
        const r2 = e3.comps_, n2 = t3.comps_;
        for (let e4 = 0; e4 < r2.length; e4++)
          if (r2[e4] !== n2[e4])
            return false;
        return true;
      }
      get mode() {
        return this.mode_;
      }
      getComponents(e3) {
        return mr((t3 = fr(this.comps_), r2 = this.mode_, n2 = e3 || this.mode_, _r[r2][n2](...t3)), this.comps_[3]);
        var t3, r2, n2;
      }
      toRgbaObject() {
        const e3 = this.getComponents("rgb");
        return { r: e3[0], g: e3[1], b: e3[2], a: e3[3] };
      }
    }
    const br = f("colp");
    class yr {
      constructor(e3, t3) {
        this.alphaViews_ = null, this.element = e3.createElement("div"), this.element.classList.add(br());
        const r2 = e3.createElement("div");
        r2.classList.add(br("hsv"));
        const n2 = e3.createElement("div");
        n2.classList.add(br("sv")), this.svPaletteView_ = t3.svPaletteView, n2.appendChild(this.svPaletteView_.element), r2.appendChild(n2);
        const i2 = e3.createElement("div");
        i2.classList.add(br("h")), this.hPaletteView_ = t3.hPaletteView, i2.appendChild(this.hPaletteView_.element), r2.appendChild(i2), this.element.appendChild(r2);
        const s2 = e3.createElement("div");
        if (s2.classList.add(br("rgb")), this.textView_ = t3.textView, s2.appendChild(this.textView_.element), this.element.appendChild(s2), t3.alphaViews) {
          this.alphaViews_ = { palette: t3.alphaViews.palette, text: t3.alphaViews.text };
          const r3 = e3.createElement("div");
          r3.classList.add(br("a"));
          const n3 = e3.createElement("div");
          n3.classList.add(br("ap")), n3.appendChild(this.alphaViews_.palette.element), r3.appendChild(n3);
          const i3 = e3.createElement("div");
          i3.classList.add(br("at")), i3.appendChild(this.alphaViews_.text.element), r3.appendChild(i3), this.element.appendChild(r3);
        }
      }
      get allFocusableElements() {
        const e3 = [this.svPaletteView_.element, this.hPaletteView_.element, this.textView_.modeSelectElement, ...this.textView_.textViews.map((e4) => e4.inputElement)];
        return this.alphaViews_ && e3.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), e3;
      }
    }
    function xr(e3) {
      const t3 = I;
      return k(e3, { alpha: t3.optional.boolean, expanded: t3.optional.boolean, picker: t3.optional.custom($t) });
    }
    function wr(e3) {
      return e3 ? 0.1 : 1;
    }
    function Er(e3, t3) {
      const r2 = e3.match(/^(.+)%$/);
      return r2 ? Math.min(0.01 * parseFloat(r2[1]) * t3, t3) : Math.min(parseFloat(e3), t3);
    }
    const Sr = { deg: (e3) => e3, grad: (e3) => 360 * e3 / 400, rad: (e3) => 360 * e3 / (2 * Math.PI), turn: (e3) => 360 * e3 };
    function Cr(e3) {
      const t3 = e3.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
      if (!t3)
        return parseFloat(e3);
      const r2 = parseFloat(t3[1]), n2 = t3[2];
      return Sr[n2](r2);
    }
    const Mr = { "func.rgb": (e3) => {
      const t3 = e3.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!t3)
        return null;
      const r2 = [Er(t3[1], 255), Er(t3[2], 255), Er(t3[3], 255)];
      return isNaN(r2[0]) || isNaN(r2[1]) || isNaN(r2[2]) ? null : new Ar(r2, "rgb");
    }, "func.rgba": (e3) => {
      const t3 = e3.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!t3)
        return null;
      const r2 = [Er(t3[1], 255), Er(t3[2], 255), Er(t3[3], 255), Er(t3[4], 1)];
      return isNaN(r2[0]) || isNaN(r2[1]) || isNaN(r2[2]) || isNaN(r2[3]) ? null : new Ar(r2, "rgb");
    }, "func.hsl": (e3) => {
      const t3 = e3.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!t3)
        return null;
      const r2 = [Cr(t3[1]), Er(t3[2], 100), Er(t3[3], 100)];
      return isNaN(r2[0]) || isNaN(r2[1]) || isNaN(r2[2]) ? null : new Ar(r2, "hsl");
    }, "func.hsla": (e3) => {
      const t3 = e3.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!t3)
        return null;
      const r2 = [Cr(t3[1]), Er(t3[2], 100), Er(t3[3], 100), Er(t3[4], 1)];
      return isNaN(r2[0]) || isNaN(r2[1]) || isNaN(r2[2]) || isNaN(r2[3]) ? null : new Ar(r2, "hsl");
    }, "hex.rgb": (e3) => {
      const t3 = e3.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
      if (t3)
        return new Ar([parseInt(t3[1] + t3[1], 16), parseInt(t3[2] + t3[2], 16), parseInt(t3[3] + t3[3], 16)], "rgb");
      const r2 = e3.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
      return r2 ? new Ar([parseInt(r2[1], 16), parseInt(r2[2], 16), parseInt(r2[3], 16)], "rgb") : null;
    }, "hex.rgba": (e3) => {
      const t3 = e3.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
      if (t3)
        return new Ar([parseInt(t3[1] + t3[1], 16), parseInt(t3[2] + t3[2], 16), parseInt(t3[3] + t3[3], 16), Ut(parseInt(t3[4] + t3[4], 16), 0, 255, 0, 1)], "rgb");
      const r2 = e3.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
      return r2 ? new Ar([parseInt(r2[1], 16), parseInt(r2[2], 16), parseInt(r2[3], 16), Ut(parseInt(r2[4], 16), 0, 255, 0, 1)], "rgb") : null;
    } };
    function Tr(e3) {
      return Object.keys(Mr).reduce((t3, r2) => t3 || ((0, Mr[r2])(e3) ? r2 : null), null);
    }
    const Ir = (e3) => {
      const t3 = Tr(e3);
      return t3 ? Mr[t3](e3) : null;
    };
    function kr(e3) {
      return "func.hsla" === e3 || "func.rgba" === e3 || "hex.rgba" === e3;
    }
    function Dr(e3) {
      if ("string" == typeof e3) {
        const t3 = Ir(e3);
        if (t3)
          return t3;
      }
      return Ar.black();
    }
    function Pr(e3) {
      const t3 = jt(Math.floor(e3), 0, 255).toString(16);
      return 1 === t3.length ? `0${t3}` : t3;
    }
    function Br(e3, t3 = "#") {
      return `${t3}${fr(e3.getComponents("rgb")).map(Pr).join("")}`;
    }
    function Rr(e3, t3 = "#") {
      const r2 = e3.getComponents("rgb");
      return `${t3}${[r2[0], r2[1], r2[2], 255 * r2[3]].map(Pr).join("")}`;
    }
    function Lr(e3) {
      const t3 = wt(0);
      return `rgb(${fr(e3.getComponents("rgb")).map((e4) => t3(e4)).join(", ")})`;
    }
    function Or(e3) {
      const t3 = wt(2), r2 = wt(0);
      return `rgba(${e3.getComponents("rgb").map((e4, n2) => (3 === n2 ? t3 : r2)(e4)).join(", ")})`;
    }
    const Fr = { "func.hsl": function(e3) {
      const t3 = [wt(0), St, St];
      return `hsl(${fr(e3.getComponents("hsl")).map((e4, r2) => t3[r2](e4)).join(", ")})`;
    }, "func.hsla": function(e3) {
      const t3 = [wt(0), St, St, wt(2)];
      return `hsla(${e3.getComponents("hsl").map((e4, r2) => t3[r2](e4)).join(", ")})`;
    }, "func.rgb": Lr, "func.rgba": Or, "hex.rgb": Br, "hex.rgba": Rr };
    function Ur(e3) {
      return Fr[e3];
    }
    const Nr = f("apl");
    class jr {
      constructor(e3, t3) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = t3.value, this.value.emitter.on("change", this.onValueChange_), this.element = e3.createElement("div"), this.element.classList.add(Nr()), t3.viewProps.bindTabIndex(this.element);
        const r2 = e3.createElement("div");
        r2.classList.add(Nr("b")), this.element.appendChild(r2);
        const n2 = e3.createElement("div");
        n2.classList.add(Nr("c")), r2.appendChild(n2), this.colorElem_ = n2;
        const i2 = e3.createElement("div");
        i2.classList.add(Nr("m")), this.element.appendChild(i2), this.markerElem_ = i2;
        const s2 = e3.createElement("div");
        s2.classList.add(Nr("p")), this.markerElem_.appendChild(s2), this.previewElem_ = s2, this.update_();
      }
      update_() {
        const e3 = this.value.rawValue, t3 = e3.getComponents("rgb"), r2 = new Ar([t3[0], t3[1], t3[2], 0], "rgb"), n2 = new Ar([t3[0], t3[1], t3[2], 255], "rgb"), i2 = ["to right", Or(r2), Or(n2)];
        this.colorElem_.style.background = `linear-gradient(${i2.join(",")})`, this.previewElem_.style.backgroundColor = Or(e3);
        const s2 = Ut(t3[3], 0, 1, 0, 100);
        this.markerElem_.style.left = `${s2}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class zr {
      constructor(e3, t3) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.view = new jr(e3, { value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Ft(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(e3, t3) {
        if (!e3.point)
          return;
        const r2 = e3.point.x / e3.bounds.width, n2 = this.value.rawValue, [i2, s2, o2] = n2.getComponents("hsv");
        this.value.setRawValue(new Ar([i2, s2, o2, r2], "hsv"), t3);
      }
      onPointerDown_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerMove_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerUp_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: true, last: true });
      }
      onKeyDown_(e3) {
        const t3 = Pt(wr(true), Rt(e3));
        if (0 === t3)
          return;
        const r2 = this.value.rawValue, [n2, i2, s2, o2] = r2.getComponents("hsv");
        this.value.setRawValue(new Ar([n2, i2, s2, o2 + t3], "hsv"), { forceEmit: false, last: false });
      }
      onKeyUp_(e3) {
        0 !== Pt(wr(true), Rt(e3)) && this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
      }
    }
    const Gr = f("coltxt");
    class Vr {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(Gr());
        const r2 = e3.createElement("div");
        r2.classList.add(Gr("m")), this.modeElem_ = function(e4) {
          const t4 = e4.createElement("select");
          return t4.appendChild([{ text: "RGB", value: "rgb" }, { text: "HSL", value: "hsl" }, { text: "HSV", value: "hsv" }].reduce((t5, r3) => {
            const n3 = e4.createElement("option");
            return n3.textContent = r3.text, n3.value = r3.value, t5.appendChild(n3), t5;
          }, e4.createDocumentFragment())), t4;
        }(e3), this.modeElem_.classList.add(Gr("ms")), r2.appendChild(this.modeSelectElement);
        const n2 = e3.createElement("div");
        n2.classList.add(Gr("mm")), n2.appendChild(N(e3, "dropdown")), r2.appendChild(n2), this.element.appendChild(r2);
        const i2 = e3.createElement("div");
        i2.classList.add(Gr("w")), this.element.appendChild(i2), this.textsElem_ = i2, this.textViews_ = t3.textViews, this.applyTextViews_(), _(t3.colorMode, (e4) => {
          this.modeElem_.value = e4;
        });
      }
      get modeSelectElement() {
        return this.modeElem_;
      }
      get textViews() {
        return this.textViews_;
      }
      set textViews(e3) {
        this.textViews_ = e3, this.applyTextViews_();
      }
      applyTextViews_() {
        G(this.textsElem_);
        const e3 = this.element.ownerDocument;
        this.textViews_.forEach((t3) => {
          const r2 = e3.createElement("div");
          r2.classList.add(Gr("c")), r2.appendChild(t3.element), this.textsElem_.appendChild(r2);
        });
      }
    }
    const Qr = wt(0), Hr = { rgb: () => new Qe({ min: 0, max: 255 }), hsl: (e3) => new Qe(0 === e3 ? { min: 0, max: 360 } : { min: 0, max: 100 }), hsv: (e3) => new Qe(0 === e3 ? { min: 0, max: 360 } : { min: 0, max: 100 }) };
    function Wr(e3, t3, r2) {
      return new Qt(e3, { arrayPosition: 0 === r2 ? "fst" : 2 === r2 ? "lst" : "mid", baseStep: wr(false), parser: t3.parser, props: C.fromObject({ draggingScale: 1, formatter: Qr }), value: S(0, { constraint: Hr[t3.colorMode](r2) }), viewProps: t3.viewProps });
    }
    class qr {
      constructor(e3, t3) {
        this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.parser_ = t3.parser, this.value = t3.value, this.viewProps = t3.viewProps, this.colorMode = S(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(e3), this.view = new Vr(e3, { colorMode: this.colorMode, textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view] }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
      }
      createComponentControllers_(e3) {
        const t3 = { colorMode: this.colorMode.rawValue, parser: this.parser_, viewProps: this.viewProps }, r2 = [Wr(e3, t3, 0), Wr(e3, t3, 1), Wr(e3, t3, 2)];
        return r2.forEach((e4, t4) => {
          Dt({ primary: this.value, secondary: e4.value, forward: (e5) => e5.rawValue.getComponents(this.colorMode.rawValue)[t4], backward: (e5, r3) => {
            const n2 = this.colorMode.rawValue, i2 = e5.rawValue.getComponents(n2);
            return i2[t4] = r3.rawValue, new Ar(mr(fr(i2), i2[3]), n2);
          } });
        }), r2;
      }
      onModeSelectChange_(e3) {
        const t3 = e3.currentTarget;
        this.colorMode.rawValue = t3.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.textViews = [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view];
      }
    }
    const Xr = f("hpl");
    class Yr {
      constructor(e3, t3) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = t3.value, this.value.emitter.on("change", this.onValueChange_), this.element = e3.createElement("div"), this.element.classList.add(Xr()), t3.viewProps.bindTabIndex(this.element);
        const r2 = e3.createElement("div");
        r2.classList.add(Xr("c")), this.element.appendChild(r2);
        const n2 = e3.createElement("div");
        n2.classList.add(Xr("m")), this.element.appendChild(n2), this.markerElem_ = n2, this.update_();
      }
      update_() {
        const e3 = this.value.rawValue, [t3] = e3.getComponents("hsv");
        this.markerElem_.style.backgroundColor = Lr(new Ar([t3, 100, 100], "hsv"));
        const r2 = Ut(t3, 0, 360, 0, 100);
        this.markerElem_.style.left = `${r2}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class Kr {
      constructor(e3, t3) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.view = new Yr(e3, { value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Ft(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(e3, t3) {
        if (!e3.point)
          return;
        const r2 = Ut(jt(e3.point.x, 0, e3.bounds.width), 0, e3.bounds.width, 0, 359), n2 = this.value.rawValue, [, i2, s2, o2] = n2.getComponents("hsv");
        this.value.setRawValue(new Ar([r2, i2, s2, o2], "hsv"), t3);
      }
      onPointerDown_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerMove_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerUp_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: true, last: true });
      }
      onKeyDown_(e3) {
        const t3 = Pt(wr(false), Rt(e3));
        if (0 === t3)
          return;
        const r2 = this.value.rawValue, [n2, i2, s2, o2] = r2.getComponents("hsv");
        this.value.setRawValue(new Ar([n2 + t3, i2, s2, o2], "hsv"), { forceEmit: false, last: false });
      }
      onKeyUp_(e3) {
        0 !== Pt(wr(false), Rt(e3)) && this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
      }
    }
    const Jr = f("svp");
    class Zr {
      constructor(e3, t3) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = t3.value, this.value.emitter.on("change", this.onValueChange_), this.element = e3.createElement("div"), this.element.classList.add(Jr()), t3.viewProps.bindTabIndex(this.element);
        const r2 = e3.createElement("canvas");
        r2.height = 64, r2.width = 64, r2.classList.add(Jr("c")), this.element.appendChild(r2), this.canvasElement = r2;
        const n2 = e3.createElement("div");
        n2.classList.add(Jr("m")), this.element.appendChild(n2), this.markerElem_ = n2, this.update_();
      }
      update_() {
        const e3 = function(e4) {
          const t4 = e4.ownerDocument.defaultView;
          return t4 && "document" in t4 ? e4.getContext("2d") : null;
        }(this.canvasElement);
        if (!e3)
          return;
        const t3 = this.value.rawValue.getComponents("hsv"), r2 = this.canvasElement.width, n2 = this.canvasElement.height, i2 = e3.getImageData(0, 0, r2, n2), s2 = i2.data;
        for (let e4 = 0; e4 < n2; e4++)
          for (let i3 = 0; i3 < r2; i3++) {
            const o3 = Ut(i3, 0, r2, 0, 100), a3 = Ut(e4, 0, n2, 100, 0), l2 = dr(t3[0], o3, a3), c2 = 4 * (e4 * r2 + i3);
            s2[c2] = l2[0], s2[c2 + 1] = l2[1], s2[c2 + 2] = l2[2], s2[c2 + 3] = 255;
          }
        e3.putImageData(i2, 0, 0);
        const o2 = Ut(t3[1], 0, 100, 0, 100);
        this.markerElem_.style.left = `${o2}%`;
        const a2 = Ut(t3[2], 0, 100, 100, 0);
        this.markerElem_.style.top = `${a2}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class $r {
      constructor(e3, t3) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.view = new Zr(e3, { value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Ft(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(e3, t3) {
        if (!e3.point)
          return;
        const r2 = Ut(e3.point.x, 0, e3.bounds.width, 0, 100), n2 = Ut(e3.point.y, 0, e3.bounds.height, 100, 0), [i2, , , s2] = this.value.rawValue.getComponents("hsv");
        this.value.setRawValue(new Ar([i2, r2, n2, s2], "hsv"), t3);
      }
      onPointerDown_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerMove_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerUp_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: true, last: true });
      }
      onKeyDown_(e3) {
        Lt(e3.key) && e3.preventDefault();
        const [t3, r2, n2, i2] = this.value.rawValue.getComponents("hsv"), s2 = wr(false), o2 = Pt(s2, Rt(e3)), a2 = Pt(s2, Bt(e3));
        0 === o2 && 0 === a2 || this.value.setRawValue(new Ar([t3, r2 + o2, n2 + a2, i2], "hsv"), { forceEmit: false, last: false });
      }
      onKeyUp_(e3) {
        const t3 = wr(false), r2 = Pt(t3, Rt(e3)), n2 = Pt(t3, Bt(e3));
        0 === r2 && 0 === n2 || this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
      }
    }
    class en {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.hPaletteC_ = new Kr(e3, { value: this.value, viewProps: this.viewProps }), this.svPaletteC_ = new $r(e3, { value: this.value, viewProps: this.viewProps }), this.alphaIcs_ = t3.supportsAlpha ? { palette: new zr(e3, { value: this.value, viewProps: this.viewProps }), text: new Qt(e3, { parser: bt, baseStep: 0.1, props: C.fromObject({ draggingScale: 0.01, formatter: wt(2) }), value: S(0, { constraint: new Qe({ min: 0, max: 1 }) }), viewProps: this.viewProps }) } : null, this.alphaIcs_ && Dt({ primary: this.value, secondary: this.alphaIcs_.text.value, forward: (e4) => e4.rawValue.getComponents()[3], backward: (e4, t4) => {
          const r2 = e4.rawValue.getComponents();
          return r2[3] = t4.rawValue, new Ar(r2, e4.rawValue.mode);
        } }), this.textC_ = new qr(e3, { parser: bt, value: this.value, viewProps: this.viewProps }), this.view = new yr(e3, { alphaViews: this.alphaIcs_ ? { palette: this.alphaIcs_.palette.view, text: this.alphaIcs_.text.view } : null, hPaletteView: this.hPaletteC_.view, supportsAlpha: t3.supportsAlpha, svPaletteView: this.svPaletteC_.view, textView: this.textC_.view });
      }
      get textController() {
        return this.textC_;
      }
    }
    const tn = f("colsw");
    class rn {
      constructor(e3, t3) {
        this.onValueChange_ = this.onValueChange_.bind(this), t3.value.emitter.on("change", this.onValueChange_), this.value = t3.value, this.element = e3.createElement("div"), this.element.classList.add(tn()), t3.viewProps.bindClassModifiers(this.element);
        const r2 = e3.createElement("div");
        r2.classList.add(tn("sw")), this.element.appendChild(r2), this.swatchElem_ = r2;
        const n2 = e3.createElement("button");
        n2.classList.add(tn("b")), t3.viewProps.bindDisabled(n2), this.element.appendChild(n2), this.buttonElement = n2, this.update_();
      }
      update_() {
        const e3 = this.value.rawValue;
        this.swatchElem_.style.backgroundColor = Rr(e3);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class nn {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.view = new rn(e3, { value: this.value, viewProps: this.viewProps });
      }
    }
    class sn {
      constructor(e3, t3) {
        this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.foldable_ = K.create(t3.expanded), this.swatchC_ = new nn(e3, { value: this.value, viewProps: this.viewProps });
        const r2 = this.swatchC_.view.buttonElement;
        r2.addEventListener("blur", this.onButtonBlur_), r2.addEventListener("click", this.onButtonClick_), this.textC_ = new et(e3, { parser: t3.parser, props: C.fromObject({ formatter: t3.formatter }), value: this.value, viewProps: this.viewProps }), this.view = new pr(e3, { foldable: this.foldable_, pickerLayout: t3.pickerLayout }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = "popup" === t3.pickerLayout ? new Je(e3, { viewProps: this.viewProps }) : null;
        const n2 = new en(e3, { supportsAlpha: t3.supportsAlpha, value: this.value, viewProps: this.viewProps });
        n2.view.allFocusableElements.forEach((e4) => {
          e4.addEventListener("blur", this.onPopupChildBlur_), e4.addEventListener("keydown", this.onPopupChildKeydown_);
        }), this.pickerC_ = n2, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(n2.view.element), Dt({ primary: this.foldable_.value("expanded"), secondary: this.popC_.shows, forward: (e4) => e4.rawValue, backward: (e4, t4) => t4.rawValue })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), Z(this.foldable_, this.view.pickerElement));
      }
      get textController() {
        return this.textC_;
      }
      onButtonBlur_(e3) {
        if (!this.popC_)
          return;
        const t3 = this.view.element, r2 = e3.relatedTarget;
        r2 && t3.contains(r2) || (this.popC_.shows.rawValue = false);
      }
      onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(e3) {
        if (!this.popC_)
          return;
        const t3 = this.popC_.view.element, r2 = V(e3);
        r2 && t3.contains(r2) || r2 && r2 === this.swatchC_.view.buttonElement && !O(t3.ownerDocument) || (this.popC_.shows.rawValue = false);
      }
      onPopupChildKeydown_(e3) {
        this.popC_ ? "Escape" === e3.key && (this.popC_.shows.rawValue = false) : this.view.pickerElement && "Escape" === e3.key && this.swatchC_.view.buttonElement.focus();
      }
    }
    function on(e3) {
      return Ar.isColorObject(e3) ? Ar.fromObject(e3) : Ar.black();
    }
    function an(e3) {
      return fr(e3.getComponents("rgb")).reduce((e4, t3) => e4 << 8 | 255 & Math.floor(t3), 0);
    }
    function ln(e3) {
      return e3.getComponents("rgb").reduce((e4, t3, r2) => e4 << 8 | 255 & Math.floor(3 === r2 ? 255 * t3 : t3), 0) >>> 0;
    }
    function cn(e3) {
      return "number" != typeof e3 ? Ar.black() : new Ar([(t3 = e3) >> 16 & 255, t3 >> 8 & 255, 255 & t3], "rgb");
      var t3;
    }
    function un(e3) {
      return "number" != typeof e3 ? Ar.black() : new Ar([(t3 = e3) >> 24 & 255, t3 >> 16 & 255, t3 >> 8 & 255, Ut(255 & t3, 0, 255, 0, 1)], "rgb");
      var t3;
    }
    function hn(e3, t3) {
      const r2 = t3.toRgbaObject();
      e3.writeProperty("r", r2.r), e3.writeProperty("g", r2.g), e3.writeProperty("b", r2.b), e3.writeProperty("a", r2.a);
    }
    function pn(e3, t3) {
      const r2 = t3.toRgbaObject();
      e3.writeProperty("r", r2.r), e3.writeProperty("g", r2.g), e3.writeProperty("b", r2.b);
    }
    function dn(e3) {
      return "alpha" in e3 && true === e3.alpha;
    }
    function fn(e3) {
      return e3 ? (e4) => Rr(e4, "0x") : (e4) => Br(e4, "0x");
    }
    const mn = { id: "input-color-number", type: "input", accept: (e3, t3) => {
      if ("number" != typeof e3)
        return null;
      if (!("view" in t3))
        return null;
      if ("color" !== t3.view)
        return null;
      const r2 = xr(t3);
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { reader: (e3) => dn(e3.params) ? un : cn, equals: Ar.equals, writer: (e3) => function(e4) {
      const t3 = e4 ? ln : an;
      return (e5, r2) => {
        Jt(e5, t3(r2));
      };
    }(dn(e3.params)) }, controller: (e3) => {
      const t3 = dn(e3.params), r2 = "expanded" in e3.params ? e3.params.expanded : void 0, n2 = "picker" in e3.params ? e3.params.picker : void 0;
      return new sn(e3.document, { expanded: null != r2 && r2, formatter: fn(t3), parser: Ir, pickerLayout: null != n2 ? n2 : "popup", supportsAlpha: t3, value: e3.value, viewProps: e3.viewProps });
    } };
    const _n = { id: "input-color-object", type: "input", accept: (e3, t3) => {
      if (!Ar.isColorObject(e3))
        return null;
      const r2 = xr(t3);
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { reader: (e3) => on, equals: Ar.equals, writer: (e3) => {
      return t3 = e3.initialValue, Ar.isRgbaColorObject(t3) ? hn : pn;
      var t3;
    } }, controller: (e3) => {
      const t3 = Ar.isRgbaColorObject(e3.initialValue), r2 = "expanded" in e3.params ? e3.params.expanded : void 0, n2 = "picker" in e3.params ? e3.params.picker : void 0, i2 = t3 ? Rr : Br;
      return new sn(e3.document, { expanded: null != r2 && r2, formatter: i2, parser: Ir, pickerLayout: null != n2 ? n2 : "popup", supportsAlpha: t3, value: e3.value, viewProps: e3.viewProps });
    } }, gn = { id: "input-color-string", type: "input", accept: (e3, t3) => {
      if ("string" != typeof e3)
        return null;
      if ("view" in t3 && "text" === t3.view)
        return null;
      if (!Tr(e3))
        return null;
      const r2 = xr(t3);
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { reader: (e3) => Dr, equals: Ar.equals, writer: (e3) => {
      const t3 = Tr(e3.initialValue);
      if (!t3)
        throw c.shouldNeverHappen();
      return function(e4) {
        const t4 = Ur(e4);
        return (e5, r2) => {
          Jt(e5, t4(r2));
        };
      }(t3);
    } }, controller: (e3) => {
      const t3 = Tr(e3.initialValue);
      if (!t3)
        throw c.shouldNeverHappen();
      const r2 = Ur(t3), n2 = "expanded" in e3.params ? e3.params.expanded : void 0, i2 = "picker" in e3.params ? e3.params.picker : void 0;
      return new sn(e3.document, { expanded: null != n2 && n2, formatter: r2, parser: Ir, pickerLayout: null != i2 ? i2 : "popup", supportsAlpha: kr(t3), value: e3.value, viewProps: e3.viewProps });
    } };
    class vn {
      constructor(e3) {
        this.components = e3.components, this.asm_ = e3.assembly;
      }
      constrain(e3) {
        const t3 = this.asm_.toComponents(e3).map((e4, t4) => {
          var r2, n2;
          return null !== (n2 = null === (r2 = this.components[t4]) || void 0 === r2 ? void 0 : r2.constrain(e4)) && void 0 !== n2 ? n2 : e4;
        });
        return this.asm_.fromComponents(t3);
      }
    }
    const An = f("pndtxt");
    class bn {
      constructor(e3, t3) {
        this.textViews = t3.textViews, this.element = e3.createElement("div"), this.element.classList.add(An()), this.textViews.forEach((t4) => {
          const r2 = e3.createElement("div");
          r2.classList.add(An("a")), r2.appendChild(t4.element), this.element.appendChild(r2);
        });
      }
    }
    class yn {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.acs_ = t3.axes.map((r2, n2) => function(e4, t4, r3) {
          return new Qt(e4, { arrayPosition: 0 === r3 ? "fst" : r3 === t4.axes.length - 1 ? "lst" : "mid", baseStep: t4.axes[r3].baseStep, parser: t4.parser, props: t4.axes[r3].textProps, value: S(0, { constraint: t4.axes[r3].constraint }), viewProps: t4.viewProps });
        }(e3, t3, n2)), this.acs_.forEach((e4, r2) => {
          Dt({ primary: this.value, secondary: e4.value, forward: (e5) => t3.assembly.toComponents(e5.rawValue)[r2], backward: (e5, n2) => {
            const i2 = t3.assembly.toComponents(e5.rawValue);
            return i2[r2] = n2.rawValue, t3.assembly.fromComponents(i2);
          } });
        }), this.view = new bn(e3, { textViews: this.acs_.map((e4) => e4.view) });
      }
    }
    function xn(e3) {
      const t3 = [], r2 = function(e4) {
        return "step" in e4 && !o(e4.step) ? new He(e4.step) : null;
      }(e3);
      r2 && t3.push(r2);
      const n2 = function(e4) {
        return "max" in e4 && !o(e4.max) || "min" in e4 && !o(e4.min) ? new Qe({ max: e4.max, min: e4.min }) : null;
      }(e3);
      n2 && t3.push(n2);
      const i2 = rr(e3.options);
      return i2 && t3.push(i2), new ze(t3);
    }
    function wn(e3) {
      const [t3, r2] = function(e4) {
        const t4 = e4 ? Ge(e4, Qe) : null;
        return t4 ? [t4.minValue, t4.maxValue] : [void 0, void 0];
      }(e3);
      return [null != t3 ? t3 : 0, null != r2 ? r2 : 100];
    }
    const En = { id: "input-number", type: "input", accept: (e3, t3) => {
      if ("number" != typeof e3)
        return null;
      const r2 = I, n2 = k(t3, { format: r2.optional.function, max: r2.optional.number, min: r2.optional.number, options: r2.optional.custom(Zt), step: r2.optional.number });
      return n2 ? { initialValue: e3, params: n2 } : null;
    }, binding: { reader: (e3) => yt, constraint: (e3) => xn(e3.params), writer: (e3) => Jt }, controller: (e3) => {
      var t3, r2;
      const n2 = e3.value, i2 = e3.constraint;
      if (i2 && Ge(i2, Ve))
        return new Xe(e3.document, { props: C.fromObject({ options: null !== (t3 = nr(i2)) && void 0 !== t3 ? t3 : [] }), value: n2, viewProps: e3.viewProps });
      const s2 = null !== (r2 = "format" in e3.params ? e3.params.format : void 0) && void 0 !== r2 ? r2 : wt(ir(i2, n2.rawValue));
      if (i2 && Ge(i2, Qe)) {
        const [t4, r3] = wn(i2);
        return new Kt(e3.document, { baseStep: sr(i2), parser: bt, sliderProps: C.fromObject({ maxValue: r3, minValue: t4 }), textProps: C.fromObject({ draggingScale: or(i2, n2.rawValue), formatter: s2 }), value: n2, viewProps: e3.viewProps });
      }
      return new Qt(e3.document, { baseStep: sr(i2), parser: bt, props: C.fromObject({ draggingScale: or(i2, n2.rawValue), formatter: s2 }), value: n2, viewProps: e3.viewProps });
    } };
    class Sn {
      constructor(e3 = 0, t3 = 0) {
        this.x = e3, this.y = t3;
      }
      getComponents() {
        return [this.x, this.y];
      }
      static isObject(e3) {
        if (o(e3))
          return false;
        const t3 = e3.x, r2 = e3.y;
        return "number" == typeof t3 && "number" == typeof r2;
      }
      static equals(e3, t3) {
        return e3.x === t3.x && e3.y === t3.y;
      }
      toObject() {
        return { x: this.x, y: this.y };
      }
    }
    const Cn = { toComponents: (e3) => e3.getComponents(), fromComponents: (e3) => new Sn(...e3) }, Mn = f("p2d");
    class Tn {
      constructor(e3, t3) {
        this.element = e3.createElement("div"), this.element.classList.add(Mn()), t3.viewProps.bindClassModifiers(this.element), _(t3.expanded, v(this.element, Mn(void 0, "expanded")));
        const r2 = e3.createElement("div");
        r2.classList.add(Mn("h")), this.element.appendChild(r2);
        const n2 = e3.createElement("button");
        n2.classList.add(Mn("b")), n2.appendChild(N(e3, "p2dpad")), t3.viewProps.bindDisabled(n2), r2.appendChild(n2), this.buttonElement = n2;
        const i2 = e3.createElement("div");
        if (i2.classList.add(Mn("t")), r2.appendChild(i2), this.textElement = i2, "inline" === t3.pickerLayout) {
          const t4 = e3.createElement("div");
          t4.classList.add(Mn("p")), this.element.appendChild(t4), this.pickerElement = t4;
        } else
          this.pickerElement = null;
      }
    }
    const In = f("p2dp");
    class kn {
      constructor(e3, t3) {
        this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = t3.invertsY, this.maxValue_ = t3.maxValue, this.element = e3.createElement("div"), this.element.classList.add(In()), "popup" === t3.layout && this.element.classList.add(In(void 0, "p"));
        const r2 = e3.createElement("div");
        r2.classList.add(In("p")), t3.viewProps.bindTabIndex(r2), this.element.appendChild(r2), this.padElement = r2;
        const n2 = e3.createElementNS(R, "svg");
        n2.classList.add(In("g")), this.padElement.appendChild(n2), this.svgElem_ = n2;
        const i2 = e3.createElementNS(R, "line");
        i2.classList.add(In("ax")), i2.setAttributeNS(null, "x1", "0"), i2.setAttributeNS(null, "y1", "50%"), i2.setAttributeNS(null, "x2", "100%"), i2.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(i2);
        const s2 = e3.createElementNS(R, "line");
        s2.classList.add(In("ax")), s2.setAttributeNS(null, "x1", "50%"), s2.setAttributeNS(null, "y1", "0"), s2.setAttributeNS(null, "x2", "50%"), s2.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(s2);
        const o2 = e3.createElementNS(R, "line");
        o2.classList.add(In("l")), o2.setAttributeNS(null, "x1", "50%"), o2.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(o2), this.lineElem_ = o2;
        const a2 = e3.createElement("div");
        a2.classList.add(In("m")), this.padElement.appendChild(a2), this.markerElem_ = a2, t3.value.emitter.on("change", this.onValueChange_), this.value = t3.value, this.update_();
      }
      get allFocusableElements() {
        return [this.padElement];
      }
      update_() {
        const [e3, t3] = this.value.rawValue.getComponents(), r2 = this.maxValue_, n2 = Ut(e3, -r2, +r2, 0, 100), i2 = Ut(t3, -r2, +r2, 0, 100), s2 = this.invertsY_ ? 100 - i2 : i2;
        this.lineElem_.setAttributeNS(null, "x2", `${n2}%`), this.lineElem_.setAttributeNS(null, "y2", `${s2}%`), this.markerElem_.style.left = `${n2}%`, this.markerElem_.style.top = `${s2}%`;
      }
      onValueChange_() {
        this.update_();
      }
      onFoldableChange_() {
        this.update_();
      }
    }
    function Dn(e3, t3, r2) {
      return [Pt(t3[0], Rt(e3)), Pt(t3[1], Bt(e3)) * (r2 ? 1 : -1)];
    }
    class Pn {
      constructor(e3, t3) {
        this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.baseSteps_ = t3.baseSteps, this.maxValue_ = t3.maxValue, this.invertsY_ = t3.invertsY, this.view = new kn(e3, { invertsY: this.invertsY_, layout: t3.layout, maxValue: this.maxValue_, value: this.value, viewProps: this.viewProps }), this.ptHandler_ = new Ft(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
      }
      handlePointerEvent_(e3, t3) {
        if (!e3.point)
          return;
        const r2 = this.maxValue_, n2 = Ut(e3.point.x, 0, e3.bounds.width, -r2, +r2), i2 = Ut(this.invertsY_ ? e3.bounds.height - e3.point.y : e3.point.y, 0, e3.bounds.height, -r2, +r2);
        this.value.setRawValue(new Sn(n2, i2), t3);
      }
      onPointerDown_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerMove_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: false, last: false });
      }
      onPointerUp_(e3) {
        this.handlePointerEvent_(e3.data, { forceEmit: true, last: true });
      }
      onPadKeyDown_(e3) {
        Lt(e3.key) && e3.preventDefault();
        const [t3, r2] = Dn(e3, this.baseSteps_, this.invertsY_);
        0 === t3 && 0 === r2 || this.value.setRawValue(new Sn(this.value.rawValue.x + t3, this.value.rawValue.y + r2), { forceEmit: false, last: false });
      }
      onPadKeyUp_(e3) {
        const [t3, r2] = Dn(e3, this.baseSteps_, this.invertsY_);
        0 === t3 && 0 === r2 || this.value.setRawValue(this.value.rawValue, { forceEmit: true, last: true });
      }
    }
    class Bn {
      constructor(e3, t3) {
        var r2, n2;
        this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.foldable_ = K.create(t3.expanded), this.popC_ = "popup" === t3.pickerLayout ? new Je(e3, { viewProps: this.viewProps }) : null;
        const i2 = new Pn(e3, { baseSteps: [t3.axes[0].baseStep, t3.axes[1].baseStep], invertsY: t3.invertsY, layout: t3.pickerLayout, maxValue: t3.maxValue, value: this.value, viewProps: this.viewProps });
        i2.view.allFocusableElements.forEach((e4) => {
          e4.addEventListener("blur", this.onPopupChildBlur_), e4.addEventListener("keydown", this.onPopupChildKeydown_);
        }), this.pickerC_ = i2, this.textC_ = new yn(e3, { assembly: Cn, axes: t3.axes, parser: t3.parser, value: this.value, viewProps: this.viewProps }), this.view = new Tn(e3, { expanded: this.foldable_.value("expanded"), pickerLayout: t3.pickerLayout, viewProps: this.viewProps }), this.view.textElement.appendChild(this.textC_.view.element), null === (r2 = this.view.buttonElement) || void 0 === r2 || r2.addEventListener("blur", this.onPadButtonBlur_), null === (n2 = this.view.buttonElement) || void 0 === n2 || n2.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), Dt({ primary: this.foldable_.value("expanded"), secondary: this.popC_.shows, forward: (e4) => e4.rawValue, backward: (e4, t4) => t4.rawValue })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), Z(this.foldable_, this.view.pickerElement));
      }
      onPadButtonBlur_(e3) {
        if (!this.popC_)
          return;
        const t3 = this.view.element, r2 = e3.relatedTarget;
        r2 && t3.contains(r2) || (this.popC_.shows.rawValue = false);
      }
      onPadButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(e3) {
        if (!this.popC_)
          return;
        const t3 = this.popC_.view.element, r2 = V(e3);
        r2 && t3.contains(r2) || r2 && r2 === this.view.buttonElement && !O(t3.ownerDocument) || (this.popC_.shows.rawValue = false);
      }
      onPopupChildKeydown_(e3) {
        this.popC_ ? "Escape" === e3.key && (this.popC_.shows.rawValue = false) : this.view.pickerElement && "Escape" === e3.key && this.view.buttonElement.focus();
      }
    }
    function Rn(e3) {
      return Sn.isObject(e3) ? new Sn(e3.x, e3.y) : new Sn();
    }
    function Ln(e3, t3) {
      e3.writeProperty("x", t3.x), e3.writeProperty("y", t3.y);
    }
    function On(e3) {
      if (!e3)
        return;
      const t3 = [];
      return o(e3.step) || t3.push(new He(e3.step)), o(e3.max) && o(e3.min) || t3.push(new Qe({ max: e3.max, min: e3.min })), new ze(t3);
    }
    function Fn(e3, t3) {
      const r2 = e3 && Ge(e3, Qe);
      if (r2)
        return Math.max(Math.abs(r2.minValue || 0), Math.abs(r2.maxValue || 0));
      const n2 = sr(e3);
      return Math.max(10 * Math.abs(n2), 10 * Math.abs(t3));
    }
    function Un(e3, t3) {
      const r2 = t3 instanceof vn ? t3.components[0] : void 0, n2 = t3 instanceof vn ? t3.components[1] : void 0, i2 = Fn(r2, e3.x), s2 = Fn(n2, e3.y);
      return Math.max(i2, s2);
    }
    function Nn(e3, t3) {
      return { baseStep: sr(t3), constraint: t3, textProps: C.fromObject({ draggingScale: or(t3, e3), formatter: wt(ir(t3, e3)) }) };
    }
    function jn(e3) {
      if (!("y" in e3))
        return false;
      const t3 = e3.y;
      return !!t3 && "inverted" in t3 && !!t3.inverted;
    }
    const zn = { id: "input-point2d", type: "input", accept: (e3, t3) => {
      if (!Sn.isObject(e3))
        return null;
      const r2 = I, n2 = k(t3, { expanded: r2.optional.boolean, picker: r2.optional.custom($t), x: r2.optional.custom(er), y: r2.optional.object({ inverted: r2.optional.boolean, max: r2.optional.number, min: r2.optional.number, step: r2.optional.number }) });
      return n2 ? { initialValue: e3, params: n2 } : null;
    }, binding: { reader: (e3) => Rn, constraint: (e3) => {
      return t3 = e3.params, new vn({ assembly: Cn, components: [On("x" in t3 ? t3.x : void 0), On("y" in t3 ? t3.y : void 0)] });
      var t3;
    }, equals: Sn.equals, writer: (e3) => Ln }, controller: (e3) => {
      const t3 = e3.document, r2 = e3.value, n2 = e3.constraint;
      if (!(n2 instanceof vn))
        throw c.shouldNeverHappen();
      const i2 = "expanded" in e3.params ? e3.params.expanded : void 0, s2 = "picker" in e3.params ? e3.params.picker : void 0;
      return new Bn(t3, { axes: [Nn(r2.rawValue.x, n2.components[0]), Nn(r2.rawValue.y, n2.components[1])], expanded: null != i2 && i2, invertsY: jn(e3.params), maxValue: Un(r2.rawValue, n2), parser: bt, pickerLayout: null != s2 ? s2 : "popup", value: r2, viewProps: e3.viewProps });
    } };
    class Gn {
      constructor(e3 = 0, t3 = 0, r2 = 0) {
        this.x = e3, this.y = t3, this.z = r2;
      }
      getComponents() {
        return [this.x, this.y, this.z];
      }
      static isObject(e3) {
        if (o(e3))
          return false;
        const t3 = e3.x, r2 = e3.y, n2 = e3.z;
        return "number" == typeof t3 && "number" == typeof r2 && "number" == typeof n2;
      }
      static equals(e3, t3) {
        return e3.x === t3.x && e3.y === t3.y && e3.z === t3.z;
      }
      toObject() {
        return { x: this.x, y: this.y, z: this.z };
      }
    }
    const Vn = { toComponents: (e3) => e3.getComponents(), fromComponents: (e3) => new Gn(...e3) };
    function Qn(e3) {
      return Gn.isObject(e3) ? new Gn(e3.x, e3.y, e3.z) : new Gn();
    }
    function Hn(e3, t3) {
      e3.writeProperty("x", t3.x), e3.writeProperty("y", t3.y), e3.writeProperty("z", t3.z);
    }
    function Wn(e3) {
      if (!e3)
        return;
      const t3 = [];
      return o(e3.step) || t3.push(new He(e3.step)), o(e3.max) && o(e3.min) || t3.push(new Qe({ max: e3.max, min: e3.min })), new ze(t3);
    }
    function qn(e3, t3) {
      return { baseStep: sr(t3), constraint: t3, textProps: C.fromObject({ draggingScale: or(t3, e3), formatter: wt(ir(t3, e3)) }) };
    }
    const Xn = { id: "input-point3d", type: "input", accept: (e3, t3) => {
      if (!Gn.isObject(e3))
        return null;
      const r2 = I, n2 = k(t3, { x: r2.optional.custom(er), y: r2.optional.custom(er), z: r2.optional.custom(er) });
      return n2 ? { initialValue: e3, params: n2 } : null;
    }, binding: { reader: (e3) => Qn, constraint: (e3) => {
      return t3 = e3.params, new vn({ assembly: Vn, components: [Wn("x" in t3 ? t3.x : void 0), Wn("y" in t3 ? t3.y : void 0), Wn("z" in t3 ? t3.z : void 0)] });
      var t3;
    }, equals: Gn.equals, writer: (e3) => Hn }, controller: (e3) => {
      const t3 = e3.value, r2 = e3.constraint;
      if (!(r2 instanceof vn))
        throw c.shouldNeverHappen();
      return new yn(e3.document, { assembly: Vn, axes: [qn(t3.rawValue.x, r2.components[0]), qn(t3.rawValue.y, r2.components[1]), qn(t3.rawValue.z, r2.components[2])], parser: bt, value: t3, viewProps: e3.viewProps });
    } };
    class Yn {
      constructor(e3 = 0, t3 = 0, r2 = 0, n2 = 0) {
        this.x = e3, this.y = t3, this.z = r2, this.w = n2;
      }
      getComponents() {
        return [this.x, this.y, this.z, this.w];
      }
      static isObject(e3) {
        if (o(e3))
          return false;
        const t3 = e3.x, r2 = e3.y, n2 = e3.z, i2 = e3.w;
        return "number" == typeof t3 && "number" == typeof r2 && "number" == typeof n2 && "number" == typeof i2;
      }
      static equals(e3, t3) {
        return e3.x === t3.x && e3.y === t3.y && e3.z === t3.z && e3.w === t3.w;
      }
      toObject() {
        return { x: this.x, y: this.y, z: this.z, w: this.w };
      }
    }
    const Kn = { toComponents: (e3) => e3.getComponents(), fromComponents: (e3) => new Yn(...e3) };
    function Jn(e3) {
      return Yn.isObject(e3) ? new Yn(e3.x, e3.y, e3.z, e3.w) : new Yn();
    }
    function Zn(e3, t3) {
      e3.writeProperty("x", t3.x), e3.writeProperty("y", t3.y), e3.writeProperty("z", t3.z), e3.writeProperty("w", t3.w);
    }
    function $n(e3) {
      if (!e3)
        return;
      const t3 = [];
      return o(e3.step) || t3.push(new He(e3.step)), o(e3.max) && o(e3.min) || t3.push(new Qe({ max: e3.max, min: e3.min })), new ze(t3);
    }
    const ei = { id: "input-point4d", type: "input", accept: (e3, t3) => {
      if (!Yn.isObject(e3))
        return null;
      const r2 = I, n2 = k(t3, { x: r2.optional.custom(er), y: r2.optional.custom(er), z: r2.optional.custom(er), w: r2.optional.custom(er) });
      return n2 ? { initialValue: e3, params: n2 } : null;
    }, binding: { reader: (e3) => Jn, constraint: (e3) => {
      return t3 = e3.params, new vn({ assembly: Kn, components: [$n("x" in t3 ? t3.x : void 0), $n("y" in t3 ? t3.y : void 0), $n("z" in t3 ? t3.z : void 0), $n("w" in t3 ? t3.w : void 0)] });
      var t3;
    }, equals: Yn.equals, writer: (e3) => Zn }, controller: (e3) => {
      const t3 = e3.value, r2 = e3.constraint;
      if (!(r2 instanceof vn))
        throw c.shouldNeverHappen();
      return new yn(e3.document, { assembly: Kn, axes: t3.rawValue.getComponents().map((e4, t4) => {
        return n2 = e4, { baseStep: sr(i2 = r2.components[t4]), constraint: i2, textProps: C.fromObject({ draggingScale: or(i2, n2), formatter: wt(ir(i2, n2)) }) };
        var n2, i2;
      }), parser: bt, value: t3, viewProps: e3.viewProps });
    } };
    const ti = { id: "input-string", type: "input", accept: (e3, t3) => {
      if ("string" != typeof e3)
        return null;
      const r2 = k(t3, { options: I.optional.custom(Zt) });
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { reader: (e3) => Ct, constraint: (e3) => function(e4) {
      const t3 = [], r2 = rr(e4.options);
      return r2 && t3.push(r2), new ze(t3);
    }(e3.params), writer: (e3) => Jt }, controller: (e3) => {
      var t3;
      const r2 = e3.document, n2 = e3.value, i2 = e3.constraint;
      return i2 && Ge(i2, Ve) ? new Xe(r2, { props: C.fromObject({ options: null !== (t3 = nr(i2)) && void 0 !== t3 ? t3 : [] }), value: n2, viewProps: e3.viewProps }) : new et(r2, { parser: (e4) => e4, props: C.fromObject({ formatter: Mt }), value: n2, viewProps: e3.viewProps });
    } }, ri = { defaultInterval: 200, defaultLineCount: 3 }, ni = f("mll");
    class ii {
      constructor(e3, t3) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t3.formatter, this.element = e3.createElement("div"), this.element.classList.add(ni()), t3.viewProps.bindClassModifiers(this.element);
        const r2 = e3.createElement("textarea");
        r2.classList.add(ni("i")), r2.style.height = `calc(var(--bld-us) * ${t3.lineCount})`, r2.readOnly = true, t3.viewProps.bindDisabled(r2), this.element.appendChild(r2), this.textareaElem_ = r2, t3.value.emitter.on("change", this.onValueUpdate_), this.value = t3.value, this.update_();
      }
      update_() {
        const e3 = this.textareaElem_, t3 = e3.scrollTop === e3.scrollHeight - e3.clientHeight, r2 = [];
        this.value.rawValue.forEach((e4) => {
          void 0 !== e4 && r2.push(this.formatter_(e4));
        }), e3.textContent = r2.join("\n"), t3 && (e3.scrollTop = e3.scrollHeight);
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class si {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.view = new ii(e3, { formatter: t3.formatter, lineCount: t3.lineCount, value: this.value, viewProps: this.viewProps });
      }
    }
    const oi = f("sgl");
    class ai {
      constructor(e3, t3) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t3.formatter, this.element = e3.createElement("div"), this.element.classList.add(oi()), t3.viewProps.bindClassModifiers(this.element);
        const r2 = e3.createElement("input");
        r2.classList.add(oi("i")), r2.readOnly = true, r2.type = "text", t3.viewProps.bindDisabled(r2), this.element.appendChild(r2), this.inputElement = r2, t3.value.emitter.on("change", this.onValueUpdate_), this.value = t3.value, this.update_();
      }
      update_() {
        const e3 = this.value.rawValue, t3 = e3[e3.length - 1];
        this.inputElement.value = void 0 !== t3 ? this.formatter_(t3) : "";
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class li {
      constructor(e3, t3) {
        this.value = t3.value, this.viewProps = t3.viewProps, this.view = new ai(e3, { formatter: t3.formatter, value: this.value, viewProps: this.viewProps });
      }
    }
    const ci = { id: "monitor-bool", type: "monitor", accept: (e3, t3) => {
      if ("boolean" != typeof e3)
        return null;
      const r2 = k(t3, { lineCount: I.optional.number });
      return r2 ? { initialValue: e3, params: r2 } : null;
    }, binding: { reader: (e3) => tt }, controller: (e3) => {
      var t3;
      return 1 === e3.value.rawValue.length ? new li(e3.document, { formatter: rt, value: e3.value, viewProps: e3.viewProps }) : new si(e3.document, { formatter: rt, lineCount: null !== (t3 = e3.params.lineCount) && void 0 !== t3 ? t3 : ri.defaultLineCount, value: e3.value, viewProps: e3.viewProps });
    } };
    class ui {
      constructor() {
        this.emitter = new p(), this.index_ = -1;
      }
      get index() {
        return this.index_;
      }
      set index(e3) {
        this.index_ !== e3 && (this.index_ = e3, this.emitter.emit("change", { index: e3, sender: this }));
      }
    }
    const hi = f("grl");
    class pi {
      constructor(e3, t3) {
        this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = e3.createElement("div"), this.element.classList.add(hi()), t3.viewProps.bindClassModifiers(this.element), this.formatter_ = t3.formatter, this.minValue_ = t3.minValue, this.maxValue_ = t3.maxValue, this.cursor_ = t3.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
        const r2 = e3.createElementNS(R, "svg");
        r2.classList.add(hi("g")), r2.style.height = `calc(var(--bld-us) * ${t3.lineCount})`, this.element.appendChild(r2), this.svgElem_ = r2;
        const n2 = e3.createElementNS(R, "polyline");
        this.svgElem_.appendChild(n2), this.lineElem_ = n2;
        const i2 = e3.createElement("div");
        i2.classList.add(hi("t"), f("tt")()), this.element.appendChild(i2), this.tooltipElem_ = i2, t3.value.emitter.on("change", this.onValueUpdate_), this.value = t3.value, this.update_();
      }
      get graphElement() {
        return this.svgElem_;
      }
      update_() {
        const e3 = this.svgElem_.getBoundingClientRect(), t3 = this.value.rawValue.length - 1, r2 = this.minValue_, n2 = this.maxValue_, i2 = [];
        this.value.rawValue.forEach((s3, o3) => {
          if (void 0 === s3)
            return;
          const a3 = Ut(o3, 0, t3, 0, e3.width), l3 = Ut(s3, r2, n2, e3.height, 0);
          i2.push([a3, l3].join(","));
        }), this.lineElem_.setAttributeNS(null, "points", i2.join(" "));
        const s2 = this.tooltipElem_, o2 = this.value.rawValue[this.cursor_.index];
        if (void 0 === o2)
          return void s2.classList.remove(hi("t", "a"));
        const a2 = Ut(this.cursor_.index, 0, t3, 0, e3.width), l2 = Ut(o2, r2, n2, e3.height, 0);
        s2.style.left = `${a2}px`, s2.style.top = `${l2}px`, s2.textContent = `${this.formatter_(o2)}`, s2.classList.contains(hi("t", "a")) || (s2.classList.add(hi("t", "a"), hi("t", "in")), L(s2), s2.classList.remove(hi("t", "in")));
      }
      onValueUpdate_() {
        this.update_();
      }
      onCursorChange_() {
        this.update_();
      }
    }
    class di {
      constructor(e3, t3) {
        if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.value = t3.value, this.viewProps = t3.viewProps, this.cursor_ = new ui(), this.view = new pi(e3, { cursor: this.cursor_, formatter: t3.formatter, lineCount: t3.lineCount, maxValue: t3.maxValue, minValue: t3.minValue, value: this.value, viewProps: this.viewProps }), O(e3)) {
          const e4 = new Ft(this.view.element);
          e4.emitter.on("down", this.onGraphPointerDown_), e4.emitter.on("move", this.onGraphPointerMove_), e4.emitter.on("up", this.onGraphPointerUp_);
        } else
          this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
      }
      onGraphMouseLeave_() {
        this.cursor_.index = -1;
      }
      onGraphMouseMove_(e3) {
        const t3 = this.view.element.getBoundingClientRect();
        this.cursor_.index = Math.floor(Ut(e3.offsetX, 0, t3.width, 0, this.value.rawValue.length));
      }
      onGraphPointerDown_(e3) {
        this.onGraphPointerMove_(e3);
      }
      onGraphPointerMove_(e3) {
        e3.data.point ? this.cursor_.index = Math.floor(Ut(e3.data.point.x, 0, e3.data.bounds.width, 0, this.value.rawValue.length)) : this.cursor_.index = -1;
      }
      onGraphPointerUp_() {
        this.cursor_.index = -1;
      }
    }
    function fi(e3) {
      return "format" in e3 && !o(e3.format) ? e3.format : wt(2);
    }
    function mi(e3) {
      return "view" in e3 && "graph" === e3.view;
    }
    const _i = { id: "monitor-number", type: "monitor", accept: (e3, t3) => {
      if ("number" != typeof e3)
        return null;
      const r2 = I, n2 = k(t3, { format: r2.optional.function, lineCount: r2.optional.number, max: r2.optional.number, min: r2.optional.number, view: r2.optional.string });
      return n2 ? { initialValue: e3, params: n2 } : null;
    }, binding: { defaultBufferSize: (e3) => mi(e3) ? 64 : 1, reader: (e3) => yt }, controller: (e3) => mi(e3.params) ? function(e4) {
      var t3, r2, n2;
      return new di(e4.document, { formatter: fi(e4.params), lineCount: null !== (t3 = e4.params.lineCount) && void 0 !== t3 ? t3 : ri.defaultLineCount, maxValue: null !== (r2 = "max" in e4.params ? e4.params.max : null) && void 0 !== r2 ? r2 : 100, minValue: null !== (n2 = "min" in e4.params ? e4.params.min : null) && void 0 !== n2 ? n2 : 0, value: e4.value, viewProps: e4.viewProps });
    }(e3) : function(e4) {
      var t3;
      return 1 === e4.value.rawValue.length ? new li(e4.document, { formatter: fi(e4.params), value: e4.value, viewProps: e4.viewProps }) : new si(e4.document, { formatter: fi(e4.params), lineCount: null !== (t3 = e4.params.lineCount) && void 0 !== t3 ? t3 : ri.defaultLineCount, value: e4.value, viewProps: e4.viewProps });
    }(e3) }, gi = { id: "monitor-string", type: "monitor", accept: (e3, t3) => {
      if ("string" != typeof e3)
        return null;
      const r2 = I, n2 = k(t3, { lineCount: r2.optional.number, multiline: r2.optional.boolean });
      return n2 ? { initialValue: e3, params: n2 } : null;
    }, binding: { reader: (e3) => Ct }, controller: (e3) => {
      var t3;
      const r2 = e3.value;
      return r2.rawValue.length > 1 || "multiline" in e3.params && e3.params.multiline ? new si(e3.document, { formatter: Mt, lineCount: null !== (t3 = e3.params.lineCount) && void 0 !== t3 ? t3 : ri.defaultLineCount, value: r2, viewProps: e3.viewProps }) : new li(e3.document, { formatter: Mt, value: r2, viewProps: e3.viewProps });
    } };
    class vi {
      constructor(e3) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.reader = e3.reader, this.writer = e3.writer, this.emitter = new p(), this.value = e3.value, this.value.emitter.on("change", this.onValueChange_), this.target = e3.target, this.read();
      }
      read() {
        const e3 = this.target.read();
        void 0 !== e3 && (this.value.rawValue = this.reader(e3));
      }
      write_(e3) {
        this.writer(this.target, e3);
      }
      onValueChange_(e3) {
        this.write_(e3.rawValue), this.emitter.emit("change", { options: e3.options, rawValue: e3.rawValue, sender: this });
      }
    }
    class Ai {
      constructor(e3) {
        this.onTick_ = this.onTick_.bind(this), this.reader_ = e3.reader, this.target = e3.target, this.emitter = new p(), this.value = e3.value, this.ticker = e3.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read();
      }
      dispose() {
        this.ticker.dispose();
      }
      read() {
        const e3 = this.target.read();
        if (void 0 === e3)
          return;
        const t3 = this.value.rawValue, r2 = this.reader_(e3);
        this.value.rawValue = function(e4, t4) {
          const r3 = [...kt(e4), t4];
          return r3.length > e4.length ? r3.splice(0, r3.length - e4.length) : Tt(r3, e4.length), r3;
        }(t3, r2), this.emitter.emit("update", { rawValue: r2, sender: this });
      }
      onTick_(e3) {
        this.read();
      }
    }
    function bi(e3, t3) {
      return 0 === t3 ? new Ne() : new je(e3, null != t3 ? t3 : ri.defaultInterval);
    }
    class yi {
      constructor() {
        this.pluginsMap_ = { blades: [], inputs: [], monitors: [] };
      }
      getAll() {
        return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors];
      }
      register(e3) {
        "blade" === e3.type ? this.pluginsMap_.blades.unshift(e3) : "input" === e3.type ? this.pluginsMap_.inputs.unshift(e3) : "monitor" === e3.type && this.pluginsMap_.monitors.unshift(e3);
      }
      createInput(e3, t3, r2) {
        if (o(t3.read()))
          throw new c({ context: { key: t3.key }, type: "nomatchingcontroller" });
        const n2 = this.pluginsMap_.inputs.reduce((n3, i2) => n3 || function(e4, t4) {
          const r3 = e4.accept(t4.target.read(), t4.params);
          if (o(r3))
            return null;
          const n4 = I, i3 = { target: t4.target, initialValue: r3.initialValue, params: r3.params }, s2 = e4.binding.reader(i3), a2 = e4.binding.constraint ? e4.binding.constraint(i3) : void 0, l2 = S(s2(r3.initialValue), { constraint: a2, equals: e4.binding.equals }), c2 = new vi({ reader: s2, target: t4.target, value: l2, writer: e4.binding.writer(i3) }), u2 = n4.optional.boolean(t4.params.disabled).value, h2 = n4.optional.boolean(t4.params.hidden).value, p2 = e4.controller({ constraint: a2, document: t4.document, initialValue: r3.initialValue, params: r3.params, value: c2.value, viewProps: Te.create({ disabled: u2, hidden: h2 }) }), d2 = n4.optional.string(t4.params.label).value;
          return new re(t4.document, { binding: c2, blade: Y(), props: C.fromObject({ label: d2 || t4.target.key }), valueController: p2 });
        }(i2, { document: e3, target: t3, params: r2 }), null);
        if (n2)
          return n2;
        throw new c({ context: { key: t3.key }, type: "nomatchingcontroller" });
      }
      createMonitor(e3, t3, r2) {
        const n2 = this.pluginsMap_.monitors.reduce((n3, i2) => n3 || function(e4, t4) {
          var r3, n4, i3;
          const s2 = I, a2 = e4.accept(t4.target.read(), t4.params);
          if (o(a2))
            return null;
          const l2 = { target: t4.target, initialValue: a2.initialValue, params: a2.params }, c2 = e4.binding.reader(l2), u2 = null !== (n4 = null !== (r3 = s2.optional.number(t4.params.bufferSize).value) && void 0 !== r3 ? r3 : e4.binding.defaultBufferSize && e4.binding.defaultBufferSize(a2.params)) && void 0 !== n4 ? n4 : 1, h2 = s2.optional.number(t4.params.interval).value, p2 = new Ai({ reader: c2, target: t4.target, ticker: bi(t4.document, h2), value: It(u2) }), d2 = s2.optional.boolean(t4.params.disabled).value, f2 = s2.optional.boolean(t4.params.hidden).value, m2 = e4.controller({ document: t4.document, params: a2.params, value: p2.value, viewProps: Te.create({ disabled: d2, hidden: f2 }) }), _2 = null !== (i3 = s2.optional.string(t4.params.label).value) && void 0 !== i3 ? i3 : t4.target.key;
          return new ie(t4.document, { binding: p2, blade: Y(), props: C.fromObject({ label: _2 }), valueController: m2 });
        }(i2, { document: e3, params: r2, target: t3 }), null);
        if (n2)
          return n2;
        throw new c({ context: { key: t3.key }, type: "nomatchingcontroller" });
      }
      createBlade(e3, t3) {
        const r2 = this.pluginsMap_.blades.reduce((r3, n2) => r3 || function(e4, t4) {
          const r4 = e4.accept(t4.params);
          if (!r4)
            return null;
          const n3 = I.optional.boolean(t4.params.disabled).value, i2 = I.optional.boolean(t4.params.hidden).value;
          return e4.controller({ blade: Y(), document: t4.document, params: Object.assign(Object.assign({}, r4.params), { disabled: n3, hidden: i2 }), viewProps: Te.create({ disabled: n3, hidden: i2 }) });
        }(n2, { document: e3, params: t3 }), null);
        if (!r2)
          throw new c({ type: "nomatchingview", context: { params: t3 } });
        return r2;
      }
      createBladeApi(e3) {
        if (e3 instanceof re)
          return new te(e3);
        if (e3 instanceof ie)
          return new ne(e3);
        if (e3 instanceof me)
          return new le(e3, this);
        const t3 = this.pluginsMap_.blades.reduce((t4, r2) => t4 || r2.api({ controller: e3, pool: this }), null);
        if (!t3)
          throw c.shouldNeverHappen();
        return t3;
      }
    }
    class xi extends t2 {
      constructor(e3) {
        super(e3), this.emitter_ = new p(), this.controller_.valueController.value.emitter.on("change", (e4) => {
          this.emitter_.emit("change", { event: new n(this, e4.rawValue) });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e3) {
        this.controller_.props.set("label", e3);
      }
      get options() {
        return this.controller_.valueController.props.get("options");
      }
      set options(e3) {
        this.controller_.valueController.props.set("options", e3);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(e3) {
        this.controller_.valueController.value.rawValue = e3;
      }
      on(e3, t3) {
        const r2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          r2(e4.event);
        }), this;
      }
    }
    class wi extends t2 {
      constructor(e3) {
        super(e3), this.emitter_ = new p(), this.controller_.valueController.value.emitter.on("change", (e4) => {
          this.emitter_.emit("change", { event: new n(this, e4.rawValue) });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e3) {
        this.controller_.props.set("label", e3);
      }
      get maxValue() {
        return this.controller_.valueController.sliderController.props.get("maxValue");
      }
      set maxValue(e3) {
        this.controller_.valueController.sliderController.props.set("maxValue", e3);
      }
      get minValue() {
        return this.controller_.valueController.sliderController.props.get("minValue");
      }
      set minValue(e3) {
        this.controller_.valueController.sliderController.props.set("minValue", e3);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(e3) {
        this.controller_.valueController.value.rawValue = e3;
      }
      on(e3, t3) {
        const r2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          r2(e4.event);
        }), this;
      }
    }
    class Ei extends t2 {
      constructor(e3) {
        super(e3), this.emitter_ = new p(), this.controller_.valueController.value.emitter.on("change", (e4) => {
          this.emitter_.emit("change", { event: new n(this, e4.rawValue) });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e3) {
        this.controller_.props.set("label", e3);
      }
      get formatter() {
        return this.controller_.valueController.props.get("formatter");
      }
      set formatter(e3) {
        this.controller_.valueController.props.set("formatter", e3);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(e3) {
        this.controller_.valueController.value.rawValue = e3;
      }
      on(e3, t3) {
        const r2 = t3.bind(this);
        return this.emitter_.on(e3, (e4) => {
          r2(e4.event);
        }), this;
      }
    }
    const Si = { id: "list", type: "blade", accept(e3) {
      const t3 = I, r2 = k(e3, { options: t3.required.custom(Zt), value: t3.required.raw, view: t3.required.constant("list"), label: t3.optional.string });
      return r2 ? { params: r2 } : null;
    }, controller(e3) {
      const t3 = new Xe(e3.document, { props: C.fromObject({ options: tr(e3.params.options) }), value: S(e3.params.value), viewProps: e3.viewProps });
      return new be(e3.document, { blade: e3.blade, props: C.fromObject({ label: e3.params.label }), valueController: t3 });
    }, api: (e3) => e3.controller instanceof be && e3.controller.valueController instanceof Xe ? new xi(e3.controller) : null };
    class Ci extends ce {
      constructor(e3, t3) {
        super(e3, t3);
      }
      get element() {
        return this.controller_.view.element;
      }
      importPreset(e3) {
        (function(e4, t3) {
          e4.forEach((e5) => {
            const r2 = t3[e5.presetKey];
            void 0 !== r2 && e5.write(r2);
          });
        })(this.controller_.rackController.rack.find(re).map((e4) => e4.binding.target), e3), this.refresh();
      }
      exportPreset() {
        return this.controller_.rackController.rack.find(re).map((e3) => e3.binding.target).reduce((e3, t3) => Object.assign(e3, { [t3.presetKey]: t3.read() }), {});
      }
      refresh() {
        this.controller_.rackController.rack.find(re).forEach((e3) => {
          e3.binding.read();
        }), this.controller_.rackController.rack.find(ie).forEach((e3) => {
          e3.binding.read();
        });
      }
    }
    class Mi extends ve {
      constructor(e3, t3) {
        super(e3, { expanded: t3.expanded, blade: t3.blade, props: t3.props, root: true, viewProps: t3.viewProps });
      }
    }
    const Ti = { id: "slider", type: "blade", accept(e3) {
      const t3 = I, r2 = k(e3, { max: t3.required.number, min: t3.required.number, view: t3.required.constant("slider"), format: t3.optional.function, label: t3.optional.string, value: t3.optional.number });
      return r2 ? { params: r2 } : null;
    }, controller(e3) {
      var t3, r2;
      const n2 = null !== (t3 = e3.params.value) && void 0 !== t3 ? t3 : 0, i2 = new Kt(e3.document, { baseStep: 1, parser: bt, sliderProps: C.fromObject({ maxValue: e3.params.max, minValue: e3.params.min }), textProps: C.fromObject({ draggingScale: or(void 0, n2), formatter: null !== (r2 = e3.params.format) && void 0 !== r2 ? r2 : xt }), value: S(n2), viewProps: e3.viewProps });
      return new be(e3.document, { blade: e3.blade, props: C.fromObject({ label: e3.params.label }), valueController: i2 });
    }, api: (e3) => e3.controller instanceof be && e3.controller.valueController instanceof Kt ? new wi(e3.controller) : null }, Ii = { id: "text", type: "blade", accept(e3) {
      const t3 = I, r2 = k(e3, { parse: t3.required.function, value: t3.required.raw, view: t3.required.constant("text"), format: t3.optional.function, label: t3.optional.string });
      return r2 ? { params: r2 } : null;
    }, controller(e3) {
      var t3;
      const r2 = new et(e3.document, { parser: e3.params.parse, props: C.fromObject({ formatter: null !== (t3 = e3.params.format) && void 0 !== t3 ? t3 : (e4) => String(e4) }), value: S(e3.params.value), viewProps: e3.viewProps });
      return new be(e3.document, { blade: e3.blade, props: C.fromObject({ label: e3.params.label }), valueController: r2 });
    }, api: (e3) => e3.controller instanceof be && e3.controller.valueController instanceof et ? new Ei(e3.controller) : null };
    function ki(e3, t3, r2) {
      if (e3.querySelector(`style[data-tp-style=${t3}]`))
        return;
      const n2 = e3.createElement("style");
      n2.dataset.tpStyle = t3, n2.textContent = r2, e3.head.appendChild(n2);
    }
    const Di = new class {
      constructor(e3) {
        const [t3, r2] = e3.split("-"), n2 = t3.split(".");
        this.major = parseInt(n2[0], 10), this.minor = parseInt(n2[1], 10), this.patch = parseInt(n2[2], 10), this.prerelease = null != r2 ? r2 : null;
      }
      toString() {
        const e3 = [this.major, this.minor, this.patch].join(".");
        return null !== this.prerelease ? [e3, this.prerelease].join("-") : e3;
      }
    }("3.0.8");
    e2.BladeApi = t2, e2.ButtonApi = h, e2.FolderApi = ce, e2.InputBindingApi = te, e2.ListApi = xi, e2.MonitorBindingApi = ne, e2.Pane = class extends Ci {
      constructor(e3) {
        var t3;
        const r2 = e3 || {}, n2 = null !== (t3 = r2.document) && void 0 !== t3 ? t3 : F(), i2 = function() {
          const e4 = new yi();
          return [zn, Xn, ei, ti, En, gn, _n, mn, ur, ci, gi, _i, q, Ae, Se, Ue].forEach((t4) => {
            e4.register(t4);
          }), e4;
        }();
        super(new Mi(n2, { expanded: r2.expanded, blade: Y(), props: C.fromObject({ title: r2.title }), viewProps: Te.create() }), i2), this.pool_ = i2, this.containerElem_ = r2.container || function(e4) {
          const t4 = e4.createElement("div");
          return t4.classList.add(f("dfw")()), e4.body && e4.body.appendChild(t4), t4;
        }(n2), this.containerElem_.appendChild(this.element), this.doc_ = n2, this.usesDefaultWrapper_ = !r2.container, this.setUpDefaultPlugins_();
      }
      get document() {
        if (!this.doc_)
          throw c.alreadyDisposed();
        return this.doc_;
      }
      dispose() {
        const e3 = this.containerElem_;
        if (!e3)
          throw c.alreadyDisposed();
        if (this.usesDefaultWrapper_) {
          const t3 = e3.parentElement;
          t3 && t3.removeChild(e3);
        }
        this.containerElem_ = null, this.doc_ = null, super.dispose();
      }
      registerPlugin(e3) {
        ("plugin" in e3 ? [e3.plugin] : "plugins" in e3 ? e3.plugins : []).forEach((e4) => {
          this.pool_.register(e4), this.embedPluginStyle_(e4);
        });
      }
      embedPluginStyle_(e3) {
        e3.css && ki(this.document, `plugin-${e3.id}`, e3.css);
      }
      setUpDefaultPlugins_() {
        ki(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor transparent;scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:transparent}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:transparent solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #28292e);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #28292e);--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i,.tp-fldv_c>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'), this.pool_.getAll().forEach((e3) => {
          this.embedPluginStyle_(e3);
        }), this.registerPlugin({ plugins: [Ti, Si, Ue, Ii] });
      }
    }, e2.SeparatorApi = ye, e2.SliderApi = wi, e2.TabApi = Re, e2.TabPageApi = Be, e2.TextApi = Ei, e2.TpChangeEvent = n, e2.VERSION = Di, Object.defineProperty(e2, "__esModule", { value: true });
  }(t);
}, 23: function(__unused_webpack_module, __webpackgi_exports__, __webpackgi_require__) {
  __webpackgi_require__.d(__webpackgi_exports__, { Q: function() {
    return DRACOLoader2;
  } });
  var three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpackgi_require__(553), three__WEBPACK_IMPORTED_MODULE_1__ = __webpackgi_require__(988);
  class DRACOLoader2 extends three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_0__._ {
    constructor(e) {
      super(e), this.encoderPending = null, this.encoderConfig = { type: "js" }, this.setDecoderPath("https://cdn.jsdelivr.net/gh/google/draco@1.4.1/javascript/"), this.setDecoderConfig({ type: "js" });
    }
    async loadAsync(e, t) {
      const r = await super.loadAsync(e, t);
      return r ? new three__WEBPACK_IMPORTED_MODULE_1__.Kj0(r, new three__WEBPACK_IMPORTED_MODULE_1__.Wid()) : void 0;
    }
    preload(e = true, t = false) {
      return e && super.preload(), t && this.initEncoder(), this;
    }
    async initEncoder() {
      if (this.encoderPending)
        return this.encoderPending;
      const useJS = "object" != typeof WebAssembly || "js" === this.encoderConfig.type, librariesPending = [], libLoader = this._loadLibrary.bind(this);
      return useJS ? librariesPending.push(libLoader("draco_encoder.js", "text")) : (librariesPending.push(libLoader("draco_wasm_wrapper.js", "text")), librariesPending.push(libLoader("draco_encoder.wasm", "arraybuffer"))), this.encoderPending = Promise.all(librariesPending).then((libraries) => {
        var _a;
        const jsContent = libraries[0];
        return useJS || (this.encoderConfig.wasmBinary = libraries[1]), null === (_a = eval(jsContent + "\nDracoEncoderModule;")) || void 0 === _a ? void 0 : _a();
      }), this.encoderPending;
    }
    async initDecoder() {
      var _a;
      await this._initDecoder();
      const jsContent = await fetch(this.workerSourceURL).then(async (e) => e.text()).then((e) => {
        const t = e.indexOf("/* worker */");
        if (t < 1)
          throw new Error("unable to load decoder module");
        return e.substring(0, t - 1);
      });
      return null === (_a = eval(jsContent + "\nDracoDecoderModule;")) || void 0 === _a ? void 0 : _a();
    }
  }
}, 87: function() {
}, 263: function() {
}, 988: function(e, t, r) {
  r.d(t, { $TI: function() {
    return Gp;
  }, $V: function() {
    return qp;
  }, $Vf: function() {
    return Hd;
  }, $YQ: function() {
    return nl;
  }, A5E: function() {
    return Rd;
  }, AHu: function() {
    return Ld;
  }, AXT: function() {
    return Dc;
  }, Aip: function() {
    return $d;
  }, B02: function() {
    return c;
  }, BFQ: function() {
    return He;
  }, BG$: function() {
    return ot;
  }, BKK: function() {
    return Yd;
  }, BVF: function() {
    return N;
  }, BVQ: function() {
    return Gc;
  }, BbS: function() {
    return yp;
  }, Bf4: function() {
    return oe;
  }, BtG: function() {
    return bs;
  }, CJI: function() {
    return yi;
  }, CN8: function() {
    return Fd;
  }, CP7: function() {
    return al;
  }, CaW: function() {
    return Je;
  }, CdI: function() {
    return Z;
  }, Cne: function() {
    return tf;
  }, CtA: function() {
    return Ge;
  }, CtF: function() {
    return vh;
  }, D1R: function() {
    return Ae;
  }, D9w: function() {
    return je;
  }, DT1: function() {
    return Qd;
  }, Djp: function() {
    return st;
  }, DqL: function() {
    return Ch;
  }, DvJ: function() {
    return hs;
  }, E2K: function() {
    return Ve;
  }, EB7: function() {
    return gc;
  }, EJi: function() {
    return Qu;
  }, EoG: function() {
    return J;
  }, F5T: function() {
    return wi;
  }, FDw: function() {
    return be;
  }, FE5: function() {
    return Ou;
  }, FIo: function() {
    return Gu;
  }, FM8: function() {
    return kr;
  }, FT0: function() {
    return Ku;
  }, FUD: function() {
    return pt;
  }, FvO: function() {
    return td;
  }, GG6: function() {
    return ut;
  }, GQ: function() {
    return Ed;
  }, GUF: function() {
    return jt;
  }, GVz: function() {
    return rn;
  }, GZb: function() {
    return qd;
  }, Gih: function() {
    return ht;
  }, Gql: function() {
    return ep;
  }, H$k: function() {
    return Ru;
  }, HTd: function() {
    return de;
  }, HW6: function() {
    return Zd;
  }, HgB: function() {
    return cr;
  }, HkE: function() {
    return $a;
  }, Hmr: function() {
    return op;
  }, Hw6: function() {
    return Yr;
  }, Hy8: function() {
    return L;
  }, Hyl: function() {
    return Ac;
  }, IEO: function() {
    return zl;
  }, IFH: function() {
    return St;
  }, IKL: function() {
    return Wu;
  }, ILR: function() {
    return qe;
  }, IOt: function() {
    return Ot;
  }, Ilk: function() {
    return Wr;
  }, Inb: function() {
    return Bt;
  }, Ir4: function() {
    return lr;
  }, JOQ: function() {
    return Ss;
  }, JQ4: function() {
    return Ce;
  }, JUT: function() {
    return nn;
  }, JWc: function() {
    return or;
  }, KI_: function() {
    return Nt;
  }, Kgo: function() {
    return qc;
  }, KhW: function() {
    return k;
  }, Kj0: function() {
    return cs;
  }, Kz5: function() {
    return Se;
  }, L5g: function() {
    return ef;
  }, L5s: function() {
    return Zh;
  }, LBq: function() {
    return Xp;
  }, LSk: function() {
    return dr;
  }, LY2: function() {
    return ee;
  }, L_r: function() {
    return fr;
  }, Lcc: function() {
    return nf;
  }, LgE: function() {
    return Pt;
  }, LgZ: function() {
    return B;
  }, LsT: function() {
    return Ee;
  }, Ltg: function() {
    return $r;
  }, Lun: function() {
    return Xa;
  }, M5h: function() {
    return y;
  }, M6v: function() {
    return W;
  }, M8C: function() {
    return Ir;
  }, Mig: function() {
    return Wh;
  }, MyG: function() {
    return Yt;
  }, N$j: function() {
    return jl;
  }, N4l: function() {
    return b;
  }, NDo: function() {
    return Y;
  }, NMF: function() {
    return bt;
  }, NYV: function() {
    return at;
  }, Ns1: function() {
    return q;
  }, NwF: function() {
    return fh;
  }, Ny0: function() {
    return bc;
  }, O7d: function() {
    return Mu;
  }, OAl: function() {
    return $t;
  }, OM3: function() {
    return Fi;
  }, OTo: function() {
    return Pe;
  }, OdW: function() {
    return Ql;
  }, OoA: function() {
    return ue;
  }, Ox3: function() {
    return Hh;
  }, PA7: function() {
    return Ft;
  }, PMe: function() {
    return Uh;
  }, Pa4: function() {
    return ln;
  }, PeU: function() {
    return o;
  }, Pnf: function() {
    return xt;
  }, PpQ: function() {
    return Xr;
  }, QM0: function() {
    return ar;
  }, QRU: function() {
    return ip;
  }, QZ1: function() {
    return sr;
  }, QmN: function() {
    return s;
  }, Qpg: function() {
    return hd;
  }, R2R: function() {
    return uh;
  }, REq: function() {
    return Xd;
  }, RNb: function() {
    return Ti;
  }, ROQ: function() {
    return vc;
  }, RSm: function() {
    return qu;
  }, Rki: function() {
    return bd;
  }, RlZ: function() {
    return U;
  }, RsA: function() {
    return i;
  }, RvT: function() {
    return er;
  }, S2y: function() {
    return l;
  }, S3k: function() {
    return Mh;
  }, S9g: function() {
    return Kn;
  }, SJI: function() {
    return bp;
  }, SPe: function() {
    return Kl;
  }, SUY: function() {
    return fp;
  }, Se2: function() {
    return j;
  }, Sm8: function() {
    return M;
  }, So8: function() {
    return lp;
  }, SvJ: function() {
    return ft;
  }, Syv: function() {
    return At;
  }, T95: function() {
    return xe;
  }, TOt: function() {
    return Zc;
  }, TUj: function() {
    return Kp;
  }, TUv: function() {
    return Nl;
  }, T_1: function() {
    return Dd;
  }, T_J: function() {
    return qt;
  }, T__: function() {
    return yc;
  }, T_f: function() {
    return qh;
  }, TlE: function() {
    return Mi;
  }, Tme: function() {
    return ui;
  }, Tn7: function() {
    return zu;
  }, TyD: function() {
    return he;
  }, U7: function() {
    return Rc;
  }, UCm: function() {
    return Be;
  }, USm: function() {
    return Yn;
  }, UY4: function() {
    return lc;
  }, UZH: function() {
    return n;
  }, Uk6: function() {
    return Uu;
  }, UlW: function() {
    return Tt;
  }, Uol: function() {
    return Wc;
  }, V1s: function() {
    return _s;
  }, V4E: function() {
    return Jd;
  }, VLJ: function() {
    return pd;
  }, VYz: function() {
    return Cp;
  }, Vdb: function() {
    return O;
  }, Vj0: function() {
    return Rs;
  }, Vkp: function() {
    return Dr;
  }, VzW: function() {
    return Me;
  }, W2J: function() {
    return nr;
  }, WMw: function() {
    return A;
  }, WTc: function() {
    return Ii;
  }, WXh: function() {
    return Fu;
  }, Wbm: function() {
    return E;
  }, WdD: function() {
    return Ps;
  }, Wid: function() {
    return Vu;
  }, Wjw: function() {
    return Wd;
  }, Wl3: function() {
    return f;
  }, Wpd: function() {
    return F;
  }, Wqd: function() {
    return Nc;
  }, WwZ: function() {
    return Mt;
  }, Wzm: function() {
    return _c;
  }, XZw: function() {
    return rf;
  }, Xaj: function() {
    return x;
  }, Xcj: function() {
    return Up;
  }, XvJ: function() {
    return Lu;
  }, Y8D: function() {
    return Le;
  }, YBo: function() {
    return Xu;
  }, YGz: function() {
    return $;
  }, YKA: function() {
    return gt;
  }, YLQ: function() {
    return pe;
  }, YN5: function() {
    return jd;
  }, YT8: function() {
    return Mc;
  }, Ywn: function() {
    return sn;
  }, Z6B: function() {
    return hr;
  }, ZAu: function() {
    return el;
  }, ZQ6: function() {
    return Lc;
  }, ZRs: function() {
    return Qt;
  }, ZZA: function() {
    return nh;
  }, Zp0: function() {
    return Jh;
  }, Zr5: function() {
    return z;
  }, ZzF: function() {
    return hn;
  }, Zzh: function() {
    return $p;
  }, _12: function() {
    return Ds;
  }, _3: function() {
    return Gd;
  }, _AM: function() {
    return Xe;
  }, _C8: function() {
    return ih;
  }, _Li: function() {
    return m;
  }, _MY: function() {
    return u;
  }, _YM: function() {
    return ch;
  }, _YX: function() {
    return sd;
  }, _am: function() {
    return As;
  }, _fP: function() {
    return an;
  }, _iA: function() {
    return h;
  }, _kC: function() {
    return Dh;
  }, _lf: function() {
    return wt;
  }, _sL: function() {
    return Et;
  }, a$l: function() {
    return Oi;
  }, aCh: function() {
    return Ut;
  }, aH4: function() {
    return fe;
  }, aLr: function() {
    return kn;
  }, aNw: function() {
    return yh;
  }, aVm: function() {
    return Di;
  }, ad5: function() {
    return zt;
  }, anP: function() {
    return Ys;
  }, aq0: function() {
    return dd;
  }, av9: function() {
    return ze;
  }, b5g: function() {
    return ll;
  }, bGH: function() {
    return w;
  }, b_z: function() {
    return Hc;
  }, bdR: function() {
    return v;
  }, blk: function() {
    return ac;
  }, bnF: function() {
    return $c;
  }, brP: function() {
    return Ue;
  }, bsb: function() {
    return mt;
  }, c8b: function() {
    return T;
  }, cBI: function() {
    return gd;
  }, cBK: function() {
    return Th;
  }, cJO: function() {
    return Iu;
  }, cLu: function() {
    return Te;
  }, cPb: function() {
    return gs;
  }, cRx: function() {
    return Oe;
  }, cU9: function() {
    return ah;
  }, ce8: function() {
    return Vt;
  }, cek: function() {
    return Vh;
  }, cum: function() {
    return rr;
  }, dSO: function() {
    return se;
  }, dUE: function() {
    return hh;
  }, dYG: function() {
    return sh;
  }, dZ3: function() {
    return te;
  }, dd2: function() {
    return en;
  }, dj0: function() {
    return ir;
  }, dpR: function() {
    return kh;
  }, dwk: function() {
    return d;
  }, e62: function() {
    return Li;
  }, eD: function() {
    return V;
  }, eMJ: function() {
    return Xt;
  }, eaV: function() {
    return Ke;
  }, ehD: function() {
    return _;
  }, ejS: function() {
    return oc;
  }, ekQ: function() {
    return et;
  }, epp: function() {
    return Nr;
  }, fHI: function() {
    return Qc;
  }, fO1: function() {
    return mc;
  }, fQA: function() {
    return wd;
  }, fQK: function() {
    return Za;
  }, fSK: function() {
    return R;
  }, fY$: function() {
    return ne;
  }, fto: function() {
    return Ze;
  }, g8_: function() {
    return ae;
  }, gH0: function() {
    return zp;
  }, gSk: function() {
    return Ct;
  }, g_z: function() {
    return Bc;
  }, ghN: function() {
    return I;
  }, gi4: function() {
    return it;
  }, gti: function() {
    return Fc;
  }, hEm: function() {
    return Ne;
  }, hH6: function() {
    return Eh;
  }, iAb: function() {
    return we;
  }, iDF: function() {
    return Eu;
  }, iKG: function() {
    return zs;
  }, iLg: function() {
    return dh;
  }, iMs: function() {
    return Qp;
  }, iUV: function() {
    return Rp;
  }, iWC: function() {
    return D;
  }, iWj: function() {
    return Ts;
  }, i_9: function() {
    return cp;
  }, iiP: function() {
    return dt;
  }, irR: function() {
    return ke;
  }, j4z: function() {
    return tr;
  }, j87: function() {
    return Bi;
  }, jAl: function() {
    return _t;
  }, jFi: function() {
    return g;
  }, jZA: function() {
    return rt;
  }, jfJ: function() {
    return Ht;
  }, jwo: function() {
    return Jt;
  }, jyi: function() {
    return Il;
  }, jyz: function() {
    return ms;
  }, k0A: function() {
    return Ie;
  }, k74: function() {
    return P;
  }, kB5: function() {
    return fl;
  }, kFz: function() {
    return on;
  }, kaV: function() {
    return Yu;
  }, knz: function() {
    return Dt;
  }, kqm: function() {
    return Mp;
  }, ksN: function() {
    return Q;
  }, l0P: function() {
    return $e;
  }, l8J: function() {
    return ur;
  }, lCJ: function() {
    return Ri;
  }, lDi: function() {
    return Xh;
  }, lLk: function() {
    return Ah;
  }, lRF: function() {
    return qa;
  }, lRj: function() {
    return ve;
  }, lb7: function() {
    return Hl;
  }, lfu: function() {
    return oh;
  }, lk7: function() {
    return Yh;
  }, m7l: function() {
    return _h;
  }, mSO: function() {
    return Lt;
  }, mTL: function() {
    return ap;
  }, mXe: function() {
    return Oc;
  }, m_w: function() {
    return Vd;
  }, mzJ: function() {
    return Lp;
  }, nls: function() {
    return Jl;
  }, ntZ: function() {
    return p;
  }, nvb: function() {
    return Nd;
  }, o8S: function() {
    return Du;
  }, oAp: function() {
    return ys;
  }, oa8: function() {
    return Pu;
  }, oqc: function() {
    return Wt;
  }, p3g: function() {
    return tn;
  }, p7A: function() {
    return Od;
  }, p7y: function() {
    return zc;
  }, pBf: function() {
    return mr;
  }, pIN: function() {
    return yt;
  }, pKu: function() {
    return ct;
  }, pQR: function() {
    return ku;
  }, ptH: function() {
    return tt;
  }, qhX: function() {
    return X;
  }, qkB: function() {
    return Fe;
  }, qlB: function() {
    return Pi;
  }, qyh: function() {
    return ge;
  }, rAo: function() {
    return ki;
  }, rBU: function() {
    return Bs;
  }, rDY: function() {
    return fs;
  }, rOj: function() {
    return S;
  }, r_: function() {
    return C;
  }, rnI: function() {
    return kt;
  }, rpg: function() {
    return le;
  }, s4_: function() {
    return $h;
  }, sYA: function() {
    return Sh;
  }, tEQ: function() {
    return bh;
  }, tGC: function() {
    return Id;
  }, tJx: function() {
    return Sd;
  }, tUh: function() {
    return lh;
  }, tf: function() {
    return Tp;
  }, tm_: function() {
    return a;
  }, trn: function() {
    return zd;
  }, u37: function() {
    return dp;
  }, u7G: function() {
    return Kh;
  }, u9r: function() {
    return Hi;
  }, uEv: function() {
    return vt;
  }, uL9: function() {
    return K;
  }, uWy: function() {
    return ce;
  }, uXU: function() {
    return Kt;
  }, ujx: function() {
    return Kd;
  }, v3W: function() {
    return We;
  }, v9Y: function() {
    return pr;
  }, vBJ: function() {
    return Ei;
  }, vCF: function() {
    return G;
  }, vCx: function() {
    return Ye;
  }, vZf: function() {
    return me;
  }, vmT: function() {
    return Ph;
  }, vpT: function() {
    return pl;
  }, vxC: function() {
    return ie;
  }, w$m: function() {
    return H;
  }, wJv: function() {
    return De;
  }, wem: function() {
    return _e;
  }, wk1: function() {
    return Re;
  }, woe: function() {
    return dc;
  }, wuA: function() {
    return Qe;
  }, x12: function() {
    return nc;
  }, x5V: function() {
    return Gt;
  }, xEZ: function() {
    return Zr;
  }, xG9: function() {
    return ad;
  }, xJs: function() {
    return lt;
  }, xWb: function() {
    return Np;
  }, xeV: function() {
    return ml;
  }, xfE: function() {
    return re;
  }, xo$: function() {
    return Bu;
  }, xoR: function() {
    return Hu;
  }, xsS: function() {
    return hl;
  }, y$t: function() {
    return jc;
  }, y2t: function() {
    return nt;
  }, y8_: function() {
    return kd;
  }, yC1: function() {
    return mh;
  }, yGw: function() {
    return Nn;
  }, ybr: function() {
    return ul;
  }, yj7: function() {
    return Pc;
  }, ylh: function() {
    return Vp;
  }, yo9: function() {
    return cl;
  }, yt0: function() {
    return Zt;
  }, ywz: function() {
    return ye;
  }, yxD: function() {
    return Ih;
  }, z$h: function() {
    return It;
  }, z81: function() {
    return Rt;
  }, z8B: function() {
    return Bl;
  }, zHn: function() {
    return Un;
  }, zbs: function() {
    return ph;
  }, zf8: function() {
    return Vc;
  }, zob: function() {
    return Ud;
  } });
  const n = "144dev", i = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, s = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, o = 0, a = 1, l = 2, c = 3, u = 0, h = 1, p = 2, d = 3, f = 0, m = 1, _ = 2, g = 0, v = 1, A = 2, b = 3, y = 4, x = 5, w = 100, E = 101, S = 102, C = 103, M = 104, T = 200, I = 201, k = 202, D = 203, P = 204, B = 205, R = 206, L = 207, O = 208, F = 209, U = 210, N = 0, j = 1, z = 2, G = 3, V = 4, Q = 5, H = 6, W = 7, q = 0, X = 1, Y = 2, K = 0, J = 1, Z = 2, $ = 3, ee = 4, te = 5, re = 300, ne = 301, ie = 302, se = 303, oe = 304, ae = 306, le = 1e3, ce = 1001, ue = 1002, he = 1003, pe = 1004, de = 1004, fe = 1005, me = 1005, _e = 1006, ge = 1007, ve = 1007, Ae = 1008, be = 1008, ye = 1009, xe = 1010, we = 1011, Ee = 1012, Se = 1013, Ce = 1014, Me = 1015, Te = 1016, Ie = 1017, ke = 1018, De = 1020, Pe = 1021, Be = 1022, Re = 1023, Le = 1024, Oe = 1025, Fe = 1026, Ue = 1027, Ne = 1028, je = 1029, ze = 1030, Ge = 1031, Ve = 1033, Qe = 33776, He = 33777, We = 33778, qe = 33779, Xe = 35840, Ye = 35841, Ke = 35842, Je = 35843, Ze = 36196, $e = 37492, et = 37496, tt = 37808, rt = 37809, nt = 37810, it = 37811, st = 37812, ot = 37813, at = 37814, lt = 37815, ct = 37816, ut = 37817, ht = 37818, pt = 37819, dt = 37820, ft = 37821, mt = 36492, _t = 2200, gt = 2201, vt = 2202, At = 2300, bt = 2301, yt = 2302, xt = 2400, wt = 2401, Et = 2402, St = 2500, Ct = 2501, Mt = 0, Tt = 1, It = 2, kt = 3e3, Dt = 3001, Pt = 3004, Bt = 3005, Rt = 3200, Lt = 3201, Ot = 0, Ft = 1, Ut = "", Nt = "srgb", jt = "srgb-linear", zt = 0, Gt = 7680, Vt = 7681, Qt = 7682, Ht = 7683, Wt = 34055, qt = 34056, Xt = 5386, Yt = 512, Kt = 513, Jt = 514, Zt = 515, $t = 516, er = 517, tr = 518, rr = 519, nr = 35044, ir = 35048, sr = 35040, or = 35045, ar = 35049, lr = 35041, cr = 35046, ur = 35050, hr = 35042, pr = "100", dr = "300 es", fr = 1035;
  class mr {
    addEventListener(e2, t2) {
      void 0 === this._listeners && (this._listeners = {});
      const r2 = this._listeners;
      void 0 === r2[e2] && (r2[e2] = []), -1 === r2[e2].indexOf(t2) && r2[e2].push(t2);
    }
    hasEventListener(e2, t2) {
      if (void 0 === this._listeners)
        return false;
      const r2 = this._listeners;
      return void 0 !== r2[e2] && -1 !== r2[e2].indexOf(t2);
    }
    removeEventListener(e2, t2) {
      if (void 0 === this._listeners)
        return;
      const r2 = this._listeners[e2];
      if (void 0 !== r2) {
        const e3 = r2.indexOf(t2);
        -1 !== e3 && r2.splice(e3, 1);
      }
    }
    dispatchEvent(e2) {
      if (void 0 === this._listeners)
        return;
      const t2 = this._listeners[e2.type];
      if (void 0 !== t2) {
        e2.target = this;
        const r2 = t2.slice(0);
        for (let t3 = 0, n2 = r2.length; t3 < n2; t3++)
          r2[t3].call(this, e2);
        e2.target = null;
      }
    }
  }
  const _r = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
  let gr = 1234567;
  const vr = Math.PI / 180, Ar = 180 / Math.PI;
  function br() {
    const e2 = 4294967295 * Math.random() | 0, t2 = 4294967295 * Math.random() | 0, r2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0;
    return (_r[255 & e2] + _r[e2 >> 8 & 255] + _r[e2 >> 16 & 255] + _r[e2 >> 24 & 255] + "-" + _r[255 & t2] + _r[t2 >> 8 & 255] + "-" + _r[t2 >> 16 & 15 | 64] + _r[t2 >> 24 & 255] + "-" + _r[63 & r2 | 128] + _r[r2 >> 8 & 255] + "-" + _r[r2 >> 16 & 255] + _r[r2 >> 24 & 255] + _r[255 & n2] + _r[n2 >> 8 & 255] + _r[n2 >> 16 & 255] + _r[n2 >> 24 & 255]).toLowerCase();
  }
  function yr(e2, t2, r2) {
    return Math.max(t2, Math.min(r2, e2));
  }
  function xr(e2, t2) {
    return (e2 % t2 + t2) % t2;
  }
  function wr(e2, t2, r2) {
    return (1 - r2) * e2 + r2 * t2;
  }
  function Er(e2) {
    return 0 == (e2 & e2 - 1) && 0 !== e2;
  }
  function Sr(e2) {
    return Math.pow(2, Math.ceil(Math.log(e2) / Math.LN2));
  }
  function Cr(e2) {
    return Math.pow(2, Math.floor(Math.log(e2) / Math.LN2));
  }
  function Mr(e2, t2) {
    switch (t2.constructor) {
      case Float32Array:
        return e2;
      case Uint16Array:
        return e2 / 65535;
      case Uint8Array:
        return e2 / 255;
      case Int16Array:
        return Math.max(e2 / 32767, -1);
      case Int8Array:
        return Math.max(e2 / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function Tr(e2, t2) {
    switch (t2.constructor) {
      case Float32Array:
        return e2;
      case Uint16Array:
        return Math.round(65535 * e2);
      case Uint8Array:
        return Math.round(255 * e2);
      case Int16Array:
        return Math.round(32767 * e2);
      case Int8Array:
        return Math.round(127 * e2);
      default:
        throw new Error("Invalid component type.");
    }
  }
  var Ir = Object.freeze({ __proto__: null, DEG2RAD: vr, RAD2DEG: Ar, generateUUID: br, clamp: yr, euclideanModulo: xr, mapLinear: function(e2, t2, r2, n2, i2) {
    return n2 + (e2 - t2) * (i2 - n2) / (r2 - t2);
  }, inverseLerp: function(e2, t2, r2) {
    return e2 !== t2 ? (r2 - e2) / (t2 - e2) : 0;
  }, lerp: wr, damp: function(e2, t2, r2, n2) {
    return wr(e2, t2, 1 - Math.exp(-r2 * n2));
  }, pingpong: function(e2, t2 = 1) {
    return t2 - Math.abs(xr(e2, 2 * t2) - t2);
  }, smoothstep: function(e2, t2, r2) {
    return e2 <= t2 ? 0 : e2 >= r2 ? 1 : (e2 = (e2 - t2) / (r2 - t2)) * e2 * (3 - 2 * e2);
  }, smootherstep: function(e2, t2, r2) {
    return e2 <= t2 ? 0 : e2 >= r2 ? 1 : (e2 = (e2 - t2) / (r2 - t2)) * e2 * e2 * (e2 * (6 * e2 - 15) + 10);
  }, randInt: function(e2, t2) {
    return e2 + Math.floor(Math.random() * (t2 - e2 + 1));
  }, randFloat: function(e2, t2) {
    return e2 + Math.random() * (t2 - e2);
  }, randFloatSpread: function(e2) {
    return e2 * (0.5 - Math.random());
  }, seededRandom: function(e2) {
    void 0 !== e2 && (gr = e2);
    let t2 = gr += 1831565813;
    return t2 = Math.imul(t2 ^ t2 >>> 15, 1 | t2), t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, 61 | t2), ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;
  }, degToRad: function(e2) {
    return e2 * vr;
  }, radToDeg: function(e2) {
    return e2 * Ar;
  }, isPowerOfTwo: Er, ceilPowerOfTwo: Sr, floorPowerOfTwo: Cr, setQuaternionFromProperEuler: function(e2, t2, r2, n2, i2) {
    const s2 = Math.cos, o2 = Math.sin, a2 = s2(r2 / 2), l2 = o2(r2 / 2), c2 = s2((t2 + n2) / 2), u2 = o2((t2 + n2) / 2), h2 = s2((t2 - n2) / 2), p2 = o2((t2 - n2) / 2), d2 = s2((n2 - t2) / 2), f2 = o2((n2 - t2) / 2);
    switch (i2) {
      case "XYX":
        e2.set(a2 * u2, l2 * h2, l2 * p2, a2 * c2);
        break;
      case "YZY":
        e2.set(l2 * p2, a2 * u2, l2 * h2, a2 * c2);
        break;
      case "ZXZ":
        e2.set(l2 * h2, l2 * p2, a2 * u2, a2 * c2);
        break;
      case "XZX":
        e2.set(a2 * u2, l2 * f2, l2 * d2, a2 * c2);
        break;
      case "YXY":
        e2.set(l2 * d2, a2 * u2, l2 * f2, a2 * c2);
        break;
      case "ZYZ":
        e2.set(l2 * f2, l2 * d2, a2 * u2, a2 * c2);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i2);
    }
  }, normalize: Tr, denormalize: Mr });
  class kr {
    constructor(e2 = 0, t2 = 0) {
      kr.prototype.isVector2 = true, this.x = e2, this.y = t2;
    }
    get width() {
      return this.x;
    }
    set width(e2) {
      this.x = e2;
    }
    get height() {
      return this.y;
    }
    set height(e2) {
      this.y = e2;
    }
    set(e2, t2) {
      return this.x = e2, this.y = t2, this;
    }
    setScalar(e2) {
      return this.x = e2, this.y = e2, this;
    }
    setX(e2) {
      return this.x = e2, this;
    }
    setY(e2) {
      return this.y = e2, this;
    }
    setComponent(e2, t2) {
      switch (e2) {
        case 0:
          this.x = t2;
          break;
        case 1:
          this.y = t2;
          break;
        default:
          throw new Error("index is out of range: " + e2);
      }
      return this;
    }
    getComponent(e2) {
      switch (e2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this;
    }
    add(e2) {
      return this.x += e2.x, this.y += e2.y, this;
    }
    addScalar(e2) {
      return this.x += e2, this.y += e2, this;
    }
    addVectors(e2, t2) {
      return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this;
    }
    addScaledVector(e2, t2) {
      return this.x += e2.x * t2, this.y += e2.y * t2, this;
    }
    sub(e2) {
      return this.x -= e2.x, this.y -= e2.y, this;
    }
    subScalar(e2) {
      return this.x -= e2, this.y -= e2, this;
    }
    subVectors(e2, t2) {
      return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this;
    }
    multiply(e2) {
      return this.x *= e2.x, this.y *= e2.y, this;
    }
    multiplyScalar(e2) {
      return this.x *= e2, this.y *= e2, this;
    }
    divide(e2) {
      return this.x /= e2.x, this.y /= e2.y, this;
    }
    divideScalar(e2) {
      return this.multiplyScalar(1 / e2);
    }
    applyMatrix3(e2) {
      const t2 = this.x, r2 = this.y, n2 = e2.elements;
      return this.x = n2[0] * t2 + n2[3] * r2 + n2[6], this.y = n2[1] * t2 + n2[4] * r2 + n2[7], this;
    }
    min(e2) {
      return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this;
    }
    max(e2) {
      return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this;
    }
    clamp(e2, t2) {
      return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this;
    }
    clampScalar(e2, t2) {
      return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this;
    }
    clampLength(e2, t2) {
      const r2 = this.length();
      return this.divideScalar(r2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, r2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(e2) {
      return this.x * e2.x + this.y * e2.y;
    }
    cross(e2) {
      return this.x * e2.y - this.y * e2.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(e2) {
      return Math.sqrt(this.distanceToSquared(e2));
    }
    distanceToSquared(e2) {
      const t2 = this.x - e2.x, r2 = this.y - e2.y;
      return t2 * t2 + r2 * r2;
    }
    manhattanDistanceTo(e2) {
      return Math.abs(this.x - e2.x) + Math.abs(this.y - e2.y);
    }
    setLength(e2) {
      return this.normalize().multiplyScalar(e2);
    }
    lerp(e2, t2) {
      return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this;
    }
    lerpVectors(e2, t2, r2) {
      return this.x = e2.x + (t2.x - e2.x) * r2, this.y = e2.y + (t2.y - e2.y) * r2, this;
    }
    equals(e2) {
      return e2.x === this.x && e2.y === this.y;
    }
    fromArray(e2, t2 = 0) {
      return this.x = e2[t2], this.y = e2[t2 + 1], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.x, e2[t2 + 1] = this.y, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this.x = e2.getX(t2), this.y = e2.getY(t2), this;
    }
    rotateAround(e2, t2) {
      const r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = this.x - e2.x, s2 = this.y - e2.y;
      return this.x = i2 * r2 - s2 * n2 + e2.x, this.y = i2 * n2 + s2 * r2 + e2.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  class Dr {
    constructor() {
      Dr.prototype.isMatrix3 = true, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    set(e2, t2, r2, n2, i2, s2, o2, a2, l2) {
      const c2 = this.elements;
      return c2[0] = e2, c2[1] = n2, c2[2] = o2, c2[3] = t2, c2[4] = i2, c2[5] = a2, c2[6] = r2, c2[7] = s2, c2[8] = l2, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e2) {
      const t2 = this.elements, r2 = e2.elements;
      return t2[0] = r2[0], t2[1] = r2[1], t2[2] = r2[2], t2[3] = r2[3], t2[4] = r2[4], t2[5] = r2[5], t2[6] = r2[6], t2[7] = r2[7], t2[8] = r2[8], this;
    }
    extractBasis(e2, t2, r2) {
      return e2.setFromMatrix3Column(this, 0), t2.setFromMatrix3Column(this, 1), r2.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(e2) {
      const t2 = e2.elements;
      return this.set(t2[0], t2[4], t2[8], t2[1], t2[5], t2[9], t2[2], t2[6], t2[10]), this;
    }
    multiply(e2) {
      return this.multiplyMatrices(this, e2);
    }
    premultiply(e2) {
      return this.multiplyMatrices(e2, this);
    }
    multiplyMatrices(e2, t2) {
      const r2 = e2.elements, n2 = t2.elements, i2 = this.elements, s2 = r2[0], o2 = r2[3], a2 = r2[6], l2 = r2[1], c2 = r2[4], u2 = r2[7], h2 = r2[2], p2 = r2[5], d2 = r2[8], f2 = n2[0], m2 = n2[3], _2 = n2[6], g2 = n2[1], v2 = n2[4], A2 = n2[7], b2 = n2[2], y2 = n2[5], x2 = n2[8];
      return i2[0] = s2 * f2 + o2 * g2 + a2 * b2, i2[3] = s2 * m2 + o2 * v2 + a2 * y2, i2[6] = s2 * _2 + o2 * A2 + a2 * x2, i2[1] = l2 * f2 + c2 * g2 + u2 * b2, i2[4] = l2 * m2 + c2 * v2 + u2 * y2, i2[7] = l2 * _2 + c2 * A2 + u2 * x2, i2[2] = h2 * f2 + p2 * g2 + d2 * b2, i2[5] = h2 * m2 + p2 * v2 + d2 * y2, i2[8] = h2 * _2 + p2 * A2 + d2 * x2, this;
    }
    multiplyScalar(e2) {
      const t2 = this.elements;
      return t2[0] *= e2, t2[3] *= e2, t2[6] *= e2, t2[1] *= e2, t2[4] *= e2, t2[7] *= e2, t2[2] *= e2, t2[5] *= e2, t2[8] *= e2, this;
    }
    determinant() {
      const e2 = this.elements, t2 = e2[0], r2 = e2[1], n2 = e2[2], i2 = e2[3], s2 = e2[4], o2 = e2[5], a2 = e2[6], l2 = e2[7], c2 = e2[8];
      return t2 * s2 * c2 - t2 * o2 * l2 - r2 * i2 * c2 + r2 * o2 * a2 + n2 * i2 * l2 - n2 * s2 * a2;
    }
    invert() {
      const e2 = this.elements, t2 = e2[0], r2 = e2[1], n2 = e2[2], i2 = e2[3], s2 = e2[4], o2 = e2[5], a2 = e2[6], l2 = e2[7], c2 = e2[8], u2 = c2 * s2 - o2 * l2, h2 = o2 * a2 - c2 * i2, p2 = l2 * i2 - s2 * a2, d2 = t2 * u2 + r2 * h2 + n2 * p2;
      if (0 === d2)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f2 = 1 / d2;
      return e2[0] = u2 * f2, e2[1] = (n2 * l2 - c2 * r2) * f2, e2[2] = (o2 * r2 - n2 * s2) * f2, e2[3] = h2 * f2, e2[4] = (c2 * t2 - n2 * a2) * f2, e2[5] = (n2 * i2 - o2 * t2) * f2, e2[6] = p2 * f2, e2[7] = (r2 * a2 - l2 * t2) * f2, e2[8] = (s2 * t2 - r2 * i2) * f2, this;
    }
    transpose() {
      let e2;
      const t2 = this.elements;
      return e2 = t2[1], t2[1] = t2[3], t2[3] = e2, e2 = t2[2], t2[2] = t2[6], t2[6] = e2, e2 = t2[5], t2[5] = t2[7], t2[7] = e2, this;
    }
    getNormalMatrix(e2) {
      return this.setFromMatrix4(e2).invert().transpose();
    }
    transposeIntoArray(e2) {
      const t2 = this.elements;
      return e2[0] = t2[0], e2[1] = t2[3], e2[2] = t2[6], e2[3] = t2[1], e2[4] = t2[4], e2[5] = t2[7], e2[6] = t2[2], e2[7] = t2[5], e2[8] = t2[8], this;
    }
    setUvTransform(e2, t2, r2, n2, i2, s2, o2) {
      const a2 = Math.cos(i2), l2 = Math.sin(i2);
      return this.set(r2 * a2, r2 * l2, -r2 * (a2 * s2 + l2 * o2) + s2 + e2, -n2 * l2, n2 * a2, -n2 * (-l2 * s2 + a2 * o2) + o2 + t2, 0, 0, 1), this;
    }
    scale(e2, t2) {
      const r2 = this.elements;
      return r2[0] *= e2, r2[3] *= e2, r2[6] *= e2, r2[1] *= t2, r2[4] *= t2, r2[7] *= t2, this;
    }
    rotate(e2) {
      const t2 = Math.cos(e2), r2 = Math.sin(e2), n2 = this.elements, i2 = n2[0], s2 = n2[3], o2 = n2[6], a2 = n2[1], l2 = n2[4], c2 = n2[7];
      return n2[0] = t2 * i2 + r2 * a2, n2[3] = t2 * s2 + r2 * l2, n2[6] = t2 * o2 + r2 * c2, n2[1] = -r2 * i2 + t2 * a2, n2[4] = -r2 * s2 + t2 * l2, n2[7] = -r2 * o2 + t2 * c2, this;
    }
    translate(e2, t2) {
      const r2 = this.elements;
      return r2[0] += e2 * r2[2], r2[3] += e2 * r2[5], r2[6] += e2 * r2[8], r2[1] += t2 * r2[2], r2[4] += t2 * r2[5], r2[7] += t2 * r2[8], this;
    }
    equals(e2) {
      const t2 = this.elements, r2 = e2.elements;
      for (let e3 = 0; e3 < 9; e3++)
        if (t2[e3] !== r2[e3])
          return false;
      return true;
    }
    fromArray(e2, t2 = 0) {
      for (let r2 = 0; r2 < 9; r2++)
        this.elements[r2] = e2[r2 + t2];
      return this;
    }
    toArray(e2 = [], t2 = 0) {
      const r2 = this.elements;
      return e2[t2] = r2[0], e2[t2 + 1] = r2[1], e2[t2 + 2] = r2[2], e2[t2 + 3] = r2[3], e2[t2 + 4] = r2[4], e2[t2 + 5] = r2[5], e2[t2 + 6] = r2[6], e2[t2 + 7] = r2[7], e2[t2 + 8] = r2[8], e2;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  function Pr(e2) {
    for (let t2 = e2.length - 1; t2 >= 0; --t2)
      if (e2[t2] > 65535)
        return true;
    return false;
  }
  const Br = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
  function Rr(e2, t2) {
    return new Br[e2](t2);
  }
  function Lr(e2) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", e2);
  }
  function Or(e2) {
    return e2 < 0.04045 ? 0.0773993808 * e2 : Math.pow(0.9478672986 * e2 + 0.0521327014, 2.4);
  }
  function Fr(e2) {
    return e2 < 31308e-7 ? 12.92 * e2 : 1.055 * Math.pow(e2, 0.41666) - 0.055;
  }
  const Ur = { [Nt]: { [jt]: Or }, [jt]: { [Nt]: Fr } }, Nr = { legacyMode: true, get workingColorSpace() {
    return jt;
  }, set workingColorSpace(e2) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  }, convert: function(e2, t2, r2) {
    if (this.legacyMode || t2 === r2 || !t2 || !r2)
      return e2;
    if (Ur[t2] && void 0 !== Ur[t2][r2]) {
      const n2 = Ur[t2][r2];
      return e2.r = n2(e2.r), e2.g = n2(e2.g), e2.b = n2(e2.b), e2;
    }
    throw new Error("Unsupported color space conversion.");
  }, fromWorkingColorSpace: function(e2, t2) {
    return this.convert(e2, this.workingColorSpace, t2);
  }, toWorkingColorSpace: function(e2, t2) {
    return this.convert(e2, t2, this.workingColorSpace);
  } }, jr = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, zr = { r: 0, g: 0, b: 0 }, Gr = { h: 0, s: 0, l: 0 }, Vr = { h: 0, s: 0, l: 0 };
  function Qr(e2, t2, r2) {
    return r2 < 0 && (r2 += 1), r2 > 1 && (r2 -= 1), r2 < 1 / 6 ? e2 + 6 * (t2 - e2) * r2 : r2 < 0.5 ? t2 : r2 < 2 / 3 ? e2 + 6 * (t2 - e2) * (2 / 3 - r2) : e2;
  }
  function Hr(e2, t2) {
    return t2.r = e2.r, t2.g = e2.g, t2.b = e2.b, t2;
  }
  class Wr {
    constructor(e2, t2, r2) {
      return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, void 0 === t2 && void 0 === r2 ? this.set(e2) : this.setRGB(e2, t2, r2);
    }
    set(e2) {
      return e2 && e2.isColor ? this.copy(e2) : "number" == typeof e2 ? this.setHex(e2) : "string" == typeof e2 && this.setStyle(e2), this;
    }
    setScalar(e2) {
      return this.r = e2, this.g = e2, this.b = e2, this;
    }
    setHex(e2, t2 = Nt) {
      return e2 = Math.floor(e2), this.r = (e2 >> 16 & 255) / 255, this.g = (e2 >> 8 & 255) / 255, this.b = (255 & e2) / 255, Nr.toWorkingColorSpace(this, t2), this;
    }
    setRGB(e2, t2, r2, n2 = jt) {
      return this.r = e2, this.g = t2, this.b = r2, Nr.toWorkingColorSpace(this, n2), this;
    }
    setHSL(e2, t2, r2, n2 = jt) {
      if (e2 = xr(e2, 1), t2 = yr(t2, 0, 1), r2 = yr(r2, 0, 1), 0 === t2)
        this.r = this.g = this.b = r2;
      else {
        const n3 = r2 <= 0.5 ? r2 * (1 + t2) : r2 + t2 - r2 * t2, i2 = 2 * r2 - n3;
        this.r = Qr(i2, n3, e2 + 1 / 3), this.g = Qr(i2, n3, e2), this.b = Qr(i2, n3, e2 - 1 / 3);
      }
      return Nr.toWorkingColorSpace(this, n2), this;
    }
    setStyle(e2, t2 = Nt) {
      function r2(t3) {
        void 0 !== t3 && parseFloat(t3) < 1 && console.warn("THREE.Color: Alpha component of " + e2 + " will be ignored.");
      }
      let n2;
      if (n2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e2)) {
        let e3;
        const i2 = n2[1], s2 = n2[2];
        switch (i2) {
          case "rgb":
          case "rgba":
            if (e3 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2))
              return this.r = Math.min(255, parseInt(e3[1], 10)) / 255, this.g = Math.min(255, parseInt(e3[2], 10)) / 255, this.b = Math.min(255, parseInt(e3[3], 10)) / 255, Nr.toWorkingColorSpace(this, t2), r2(e3[4]), this;
            if (e3 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2))
              return this.r = Math.min(100, parseInt(e3[1], 10)) / 100, this.g = Math.min(100, parseInt(e3[2], 10)) / 100, this.b = Math.min(100, parseInt(e3[3], 10)) / 100, Nr.toWorkingColorSpace(this, t2), r2(e3[4]), this;
            break;
          case "hsl":
          case "hsla":
            if (e3 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2)) {
              const n3 = parseFloat(e3[1]) / 360, i3 = parseFloat(e3[2]) / 100, s3 = parseFloat(e3[3]) / 100;
              return r2(e3[4]), this.setHSL(n3, i3, s3, t2);
            }
        }
      } else if (n2 = /^\#([A-Fa-f\d]+)$/.exec(e2)) {
        const e3 = n2[1], r3 = e3.length;
        if (3 === r3)
          return this.r = parseInt(e3.charAt(0) + e3.charAt(0), 16) / 255, this.g = parseInt(e3.charAt(1) + e3.charAt(1), 16) / 255, this.b = parseInt(e3.charAt(2) + e3.charAt(2), 16) / 255, Nr.toWorkingColorSpace(this, t2), this;
        if (6 === r3)
          return this.r = parseInt(e3.charAt(0) + e3.charAt(1), 16) / 255, this.g = parseInt(e3.charAt(2) + e3.charAt(3), 16) / 255, this.b = parseInt(e3.charAt(4) + e3.charAt(5), 16) / 255, Nr.toWorkingColorSpace(this, t2), this;
      }
      return e2 && e2.length > 0 ? this.setColorName(e2, t2) : this;
    }
    setColorName(e2, t2 = Nt) {
      const r2 = jr[e2.toLowerCase()];
      return void 0 !== r2 ? this.setHex(r2, t2) : console.warn("THREE.Color: Unknown color " + e2), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(e2) {
      return this.r = e2.r, this.g = e2.g, this.b = e2.b, this;
    }
    copySRGBToLinear(e2) {
      return this.r = Or(e2.r), this.g = Or(e2.g), this.b = Or(e2.b), this;
    }
    copyLinearToSRGB(e2) {
      return this.r = Fr(e2.r), this.g = Fr(e2.g), this.b = Fr(e2.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(e2 = Nt) {
      return Nr.fromWorkingColorSpace(Hr(this, zr), e2), yr(255 * zr.r, 0, 255) << 16 ^ yr(255 * zr.g, 0, 255) << 8 ^ yr(255 * zr.b, 0, 255) << 0;
    }
    getHexString(e2 = Nt) {
      return ("000000" + this.getHex(e2).toString(16)).slice(-6);
    }
    getHSL(e2, t2 = jt) {
      Nr.fromWorkingColorSpace(Hr(this, zr), t2);
      const r2 = zr.r, n2 = zr.g, i2 = zr.b, s2 = Math.max(r2, n2, i2), o2 = Math.min(r2, n2, i2);
      let a2, l2;
      const c2 = (o2 + s2) / 2;
      if (o2 === s2)
        a2 = 0, l2 = 0;
      else {
        const e3 = s2 - o2;
        switch (l2 = c2 <= 0.5 ? e3 / (s2 + o2) : e3 / (2 - s2 - o2), s2) {
          case r2:
            a2 = (n2 - i2) / e3 + (n2 < i2 ? 6 : 0);
            break;
          case n2:
            a2 = (i2 - r2) / e3 + 2;
            break;
          case i2:
            a2 = (r2 - n2) / e3 + 4;
        }
        a2 /= 6;
      }
      return e2.h = a2, e2.s = l2, e2.l = c2, e2;
    }
    getRGB(e2, t2 = jt) {
      return Nr.fromWorkingColorSpace(Hr(this, zr), t2), e2.r = zr.r, e2.g = zr.g, e2.b = zr.b, e2;
    }
    getStyle(e2 = Nt) {
      return Nr.fromWorkingColorSpace(Hr(this, zr), e2), e2 !== Nt ? `color(${e2} ${zr.r} ${zr.g} ${zr.b})` : `rgb(${255 * zr.r | 0},${255 * zr.g | 0},${255 * zr.b | 0})`;
    }
    offsetHSL(e2, t2, r2) {
      return this.getHSL(Gr), Gr.h += e2, Gr.s += t2, Gr.l += r2, this.setHSL(Gr.h, Gr.s, Gr.l), this;
    }
    add(e2) {
      return this.r += e2.r, this.g += e2.g, this.b += e2.b, this;
    }
    addColors(e2, t2) {
      return this.r = e2.r + t2.r, this.g = e2.g + t2.g, this.b = e2.b + t2.b, this;
    }
    addScalar(e2) {
      return this.r += e2, this.g += e2, this.b += e2, this;
    }
    sub(e2) {
      return this.r = Math.max(0, this.r - e2.r), this.g = Math.max(0, this.g - e2.g), this.b = Math.max(0, this.b - e2.b), this;
    }
    multiply(e2) {
      return this.r *= e2.r, this.g *= e2.g, this.b *= e2.b, this;
    }
    multiplyScalar(e2) {
      return this.r *= e2, this.g *= e2, this.b *= e2, this;
    }
    lerp(e2, t2) {
      return this.r += (e2.r - this.r) * t2, this.g += (e2.g - this.g) * t2, this.b += (e2.b - this.b) * t2, this;
    }
    lerpColors(e2, t2, r2) {
      return this.r = e2.r + (t2.r - e2.r) * r2, this.g = e2.g + (t2.g - e2.g) * r2, this.b = e2.b + (t2.b - e2.b) * r2, this;
    }
    lerpHSL(e2, t2) {
      this.getHSL(Gr), e2.getHSL(Vr);
      const r2 = wr(Gr.h, Vr.h, t2), n2 = wr(Gr.s, Vr.s, t2), i2 = wr(Gr.l, Vr.l, t2);
      return this.setHSL(r2, n2, i2), this;
    }
    equals(e2) {
      return e2.r === this.r && e2.g === this.g && e2.b === this.b;
    }
    fromArray(e2, t2 = 0) {
      return this.r = e2[t2], this.g = e2[t2 + 1], this.b = e2[t2 + 2], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.r, e2[t2 + 1] = this.g, e2[t2 + 2] = this.b, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this.r = e2.getX(t2), this.g = e2.getY(t2), this.b = e2.getZ(t2), this;
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  }
  let qr;
  Wr.NAMES = jr;
  class Xr {
    static getDataURL(e2, t2 = false) {
      if (/^data:/i.test(e2.src))
        return e2.src;
      if ("undefined" == typeof HTMLCanvasElement)
        return e2.src;
      let r2;
      if (e2 instanceof HTMLCanvasElement)
        r2 = e2;
      else {
        void 0 === qr && (qr = Lr("canvas")), qr.width = e2.width, qr.height = e2.height;
        const t3 = qr.getContext("2d");
        e2 instanceof ImageData ? t3.putImageData(e2, 0, 0) : t3.drawImage(e2, 0, 0, e2.width, e2.height), r2 = qr;
      }
      return !t2 && (r2.width > 2048 || r2.height > 2048) ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e2), r2.toDataURL("image/jpeg", 0.6)) : r2.toDataURL("image/png");
    }
    static sRGBToLinear(e2) {
      if ("undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e2 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap) {
        const t2 = Lr("canvas");
        t2.width = e2.width, t2.height = e2.height;
        const r2 = t2.getContext("2d");
        r2.drawImage(e2, 0, 0, e2.width, e2.height);
        const n2 = r2.getImageData(0, 0, e2.width, e2.height), i2 = n2.data;
        for (let e3 = 0; e3 < i2.length; e3++)
          i2[e3] = 255 * Or(i2[e3] / 255);
        return r2.putImageData(n2, 0, 0), t2;
      }
      if (e2.data) {
        const t2 = e2.data.slice(0);
        for (let e3 = 0; e3 < t2.length; e3++)
          t2 instanceof Uint8Array || t2 instanceof Uint8ClampedArray ? t2[e3] = Math.floor(255 * Or(t2[e3] / 255)) : t2[e3] = Or(t2[e3]);
        return { data: t2, width: e2.width, height: e2.height };
      }
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e2;
    }
  }
  class Yr {
    constructor(e2 = null) {
      this.isSource = true, this.uuid = br(), this.data = e2, this.version = 0;
    }
    set needsUpdate(e2) {
      true === e2 && this.version++;
    }
    toJSON(e2) {
      const t2 = void 0 === e2 || "string" == typeof e2;
      if (!t2 && void 0 !== e2.images[this.uuid])
        return e2.images[this.uuid];
      const r2 = { uuid: this.uuid, url: "" }, n2 = this.data;
      if (null !== n2) {
        let e3;
        if (Array.isArray(n2)) {
          e3 = [];
          for (let t3 = 0, r3 = n2.length; t3 < r3; t3++)
            n2[t3].isDataTexture ? e3.push(Kr(n2[t3].image)) : e3.push(Kr(n2[t3]));
        } else
          e3 = Kr(n2);
        r2.url = e3;
      }
      return t2 || (e2.images[this.uuid] = r2), r2;
    }
  }
  function Kr(e2) {
    if ("undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e2 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap)
      return Xr.getDataURL(e2);
    if (e2.data) {
      let t2 = [];
      try {
        t2 = Array.from(e2.data);
      } catch (r2) {
        r2.message.includes("Invalid array length") ? console.warn("Serializing large texture, might not be saved in JSON structure.") : console.error(r2), t2 = e2.data;
      }
      return { data: t2, width: e2.width, height: e2.height, type: e2.data.constructor.name };
    }
    return console.warn("THREE.Texture: Unable to serialize Texture."), {};
  }
  let Jr = 0;
  class Zr extends mr {
    constructor(e2 = Zr.DEFAULT_IMAGE, t2 = Zr.DEFAULT_MAPPING, r2 = ce, n2 = ce, i2 = _e, s2 = Ae, o2 = Re, a2 = ye, l2 = 1, c2 = kt) {
      super(), this.isTexture = true, Object.defineProperty(this, "id", { value: Jr++ }), this.uuid = br(), this.name = "", this.source = new Yr(e2), this.mipmaps = [], this.mapping = t2, this.wrapS = r2, this.wrapT = n2, this.magFilter = i2, this.minFilter = s2, this.anisotropy = l2, this.format = o2, this.internalFormat = null, this.type = a2, this.offset = new kr(0, 0), this.repeat = new kr(1, 1), this.center = new kr(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Dr(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = c2, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.needsPMREMUpdate = false;
    }
    get image() {
      return this.source.data;
    }
    set image(e2) {
      this.source.data = e2;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.name = e2.name, this.source = e2.source, this.mipmaps = e2.mipmaps.slice(0), this.mapping = e2.mapping, this.wrapS = e2.wrapS, this.wrapT = e2.wrapT, this.magFilter = e2.magFilter, this.minFilter = e2.minFilter, this.anisotropy = e2.anisotropy, this.format = e2.format, this.internalFormat = e2.internalFormat, this.type = e2.type, this.offset.copy(e2.offset), this.repeat.copy(e2.repeat), this.center.copy(e2.center), this.rotation = e2.rotation, this.matrixAutoUpdate = e2.matrixAutoUpdate, this.matrix.copy(e2.matrix), this.generateMipmaps = e2.generateMipmaps, this.premultiplyAlpha = e2.premultiplyAlpha, this.flipY = e2.flipY, this.unpackAlignment = e2.unpackAlignment, this.encoding = e2.encoding, this.userData = JSON.parse(JSON.stringify(e2.userData)), this.needsUpdate = true, this;
    }
    toJSON(e2) {
      const t2 = void 0 === e2 || "string" == typeof e2;
      if (!t2 && void 0 !== e2.textures[this.uuid])
        return e2.textures[this.uuid];
      const r2 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e2).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
      return "{}" !== JSON.stringify(this.userData) && (r2.userData = this.userData), t2 || (e2.textures[this.uuid] = r2), r2;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(e2) {
      if (this.mapping !== re)
        return e2;
      if (e2.applyMatrix3(this.matrix), e2.x < 0 || e2.x > 1)
        switch (this.wrapS) {
          case le:
            e2.x = e2.x - Math.floor(e2.x);
            break;
          case ce:
            e2.x = e2.x < 0 ? 0 : 1;
            break;
          case ue:
            1 === Math.abs(Math.floor(e2.x) % 2) ? e2.x = Math.ceil(e2.x) - e2.x : e2.x = e2.x - Math.floor(e2.x);
        }
      if (e2.y < 0 || e2.y > 1)
        switch (this.wrapT) {
          case le:
            e2.y = e2.y - Math.floor(e2.y);
            break;
          case ce:
            e2.y = e2.y < 0 ? 0 : 1;
            break;
          case ue:
            1 === Math.abs(Math.floor(e2.y) % 2) ? e2.y = Math.ceil(e2.y) - e2.y : e2.y = e2.y - Math.floor(e2.y);
        }
      return this.flipY && (e2.y = 1 - e2.y), e2;
    }
    set needsUpdate(e2) {
      true === e2 && (this.version++, this.source.needsUpdate = true);
    }
  }
  Zr.DEFAULT_IMAGE = null, Zr.DEFAULT_MAPPING = re;
  class $r {
    constructor(e2 = 0, t2 = 0, r2 = 0, n2 = 1) {
      $r.prototype.isVector4 = true, this.x = e2, this.y = t2, this.z = r2, this.w = n2;
    }
    get width() {
      return this.z;
    }
    set width(e2) {
      this.z = e2;
    }
    get height() {
      return this.w;
    }
    set height(e2) {
      this.w = e2;
    }
    set(e2, t2, r2, n2) {
      return this.x = e2, this.y = t2, this.z = r2, this.w = n2, this;
    }
    setScalar(e2) {
      return this.x = e2, this.y = e2, this.z = e2, this.w = e2, this;
    }
    setX(e2) {
      return this.x = e2, this;
    }
    setY(e2) {
      return this.y = e2, this;
    }
    setZ(e2) {
      return this.z = e2, this;
    }
    setW(e2) {
      return this.w = e2, this;
    }
    setComponent(e2, t2) {
      switch (e2) {
        case 0:
          this.x = t2;
          break;
        case 1:
          this.y = t2;
          break;
        case 2:
          this.z = t2;
          break;
        case 3:
          this.w = t2;
          break;
        default:
          throw new Error("index is out of range: " + e2);
      }
      return this;
    }
    getComponent(e2) {
      switch (e2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + e2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this.z = e2.z, this.w = void 0 !== e2.w ? e2.w : 1, this;
    }
    add(e2) {
      return this.x += e2.x, this.y += e2.y, this.z += e2.z, this.w += e2.w, this;
    }
    addScalar(e2) {
      return this.x += e2, this.y += e2, this.z += e2, this.w += e2, this;
    }
    addVectors(e2, t2) {
      return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this.z = e2.z + t2.z, this.w = e2.w + t2.w, this;
    }
    addScaledVector(e2, t2) {
      return this.x += e2.x * t2, this.y += e2.y * t2, this.z += e2.z * t2, this.w += e2.w * t2, this;
    }
    sub(e2) {
      return this.x -= e2.x, this.y -= e2.y, this.z -= e2.z, this.w -= e2.w, this;
    }
    subScalar(e2) {
      return this.x -= e2, this.y -= e2, this.z -= e2, this.w -= e2, this;
    }
    subVectors(e2, t2) {
      return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this.z = e2.z - t2.z, this.w = e2.w - t2.w, this;
    }
    multiply(e2) {
      return this.x *= e2.x, this.y *= e2.y, this.z *= e2.z, this.w *= e2.w, this;
    }
    multiplyScalar(e2) {
      return this.x *= e2, this.y *= e2, this.z *= e2, this.w *= e2, this;
    }
    applyMatrix4(e2) {
      const t2 = this.x, r2 = this.y, n2 = this.z, i2 = this.w, s2 = e2.elements;
      return this.x = s2[0] * t2 + s2[4] * r2 + s2[8] * n2 + s2[12] * i2, this.y = s2[1] * t2 + s2[5] * r2 + s2[9] * n2 + s2[13] * i2, this.z = s2[2] * t2 + s2[6] * r2 + s2[10] * n2 + s2[14] * i2, this.w = s2[3] * t2 + s2[7] * r2 + s2[11] * n2 + s2[15] * i2, this;
    }
    divideScalar(e2) {
      return this.multiplyScalar(1 / e2);
    }
    setAxisAngleFromQuaternion(e2) {
      this.w = 2 * Math.acos(e2.w);
      const t2 = Math.sqrt(1 - e2.w * e2.w);
      return t2 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e2.x / t2, this.y = e2.y / t2, this.z = e2.z / t2), this;
    }
    setAxisAngleFromRotationMatrix(e2) {
      let t2, r2, n2, i2;
      const s2 = 0.01, o2 = 0.1, a2 = e2.elements, l2 = a2[0], c2 = a2[4], u2 = a2[8], h2 = a2[1], p2 = a2[5], d2 = a2[9], f2 = a2[2], m2 = a2[6], _2 = a2[10];
      if (Math.abs(c2 - h2) < s2 && Math.abs(u2 - f2) < s2 && Math.abs(d2 - m2) < s2) {
        if (Math.abs(c2 + h2) < o2 && Math.abs(u2 + f2) < o2 && Math.abs(d2 + m2) < o2 && Math.abs(l2 + p2 + _2 - 3) < o2)
          return this.set(1, 0, 0, 0), this;
        t2 = Math.PI;
        const e3 = (l2 + 1) / 2, a3 = (p2 + 1) / 2, g3 = (_2 + 1) / 2, v2 = (c2 + h2) / 4, A2 = (u2 + f2) / 4, b2 = (d2 + m2) / 4;
        return e3 > a3 && e3 > g3 ? e3 < s2 ? (r2 = 0, n2 = 0.707106781, i2 = 0.707106781) : (r2 = Math.sqrt(e3), n2 = v2 / r2, i2 = A2 / r2) : a3 > g3 ? a3 < s2 ? (r2 = 0.707106781, n2 = 0, i2 = 0.707106781) : (n2 = Math.sqrt(a3), r2 = v2 / n2, i2 = b2 / n2) : g3 < s2 ? (r2 = 0.707106781, n2 = 0.707106781, i2 = 0) : (i2 = Math.sqrt(g3), r2 = A2 / i2, n2 = b2 / i2), this.set(r2, n2, i2, t2), this;
      }
      let g2 = Math.sqrt((m2 - d2) * (m2 - d2) + (u2 - f2) * (u2 - f2) + (h2 - c2) * (h2 - c2));
      return Math.abs(g2) < 1e-3 && (g2 = 1), this.x = (m2 - d2) / g2, this.y = (u2 - f2) / g2, this.z = (h2 - c2) / g2, this.w = Math.acos((l2 + p2 + _2 - 1) / 2), this;
    }
    min(e2) {
      return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this.z = Math.min(this.z, e2.z), this.w = Math.min(this.w, e2.w), this;
    }
    max(e2) {
      return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this.z = Math.max(this.z, e2.z), this.w = Math.max(this.w, e2.w), this;
    }
    clamp(e2, t2) {
      return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this.z = Math.max(e2.z, Math.min(t2.z, this.z)), this.w = Math.max(e2.w, Math.min(t2.w, this.w)), this;
    }
    clampScalar(e2, t2) {
      return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this.z = Math.max(e2, Math.min(t2, this.z)), this.w = Math.max(e2, Math.min(t2, this.w)), this;
    }
    clampLength(e2, t2) {
      const r2 = this.length();
      return this.divideScalar(r2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, r2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
    dot(e2) {
      return this.x * e2.x + this.y * e2.y + this.z * e2.z + this.w * e2.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e2) {
      return this.normalize().multiplyScalar(e2);
    }
    lerp(e2, t2) {
      return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this.z += (e2.z - this.z) * t2, this.w += (e2.w - this.w) * t2, this;
    }
    lerpVectors(e2, t2, r2) {
      return this.x = e2.x + (t2.x - e2.x) * r2, this.y = e2.y + (t2.y - e2.y) * r2, this.z = e2.z + (t2.z - e2.z) * r2, this.w = e2.w + (t2.w - e2.w) * r2, this;
    }
    equals(e2) {
      return e2.x === this.x && e2.y === this.y && e2.z === this.z && e2.w === this.w;
    }
    fromArray(e2, t2 = 0) {
      return this.x = e2[t2], this.y = e2[t2 + 1], this.z = e2[t2 + 2], this.w = e2[t2 + 3], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.x, e2[t2 + 1] = this.y, e2[t2 + 2] = this.z, e2[t2 + 3] = this.w, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this.x = e2.getX(t2), this.y = e2.getY(t2), this.z = e2.getZ(t2), this.w = e2.getW(t2), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  }
  class en extends mr {
    constructor(e2, t2, r2 = {}) {
      super(), this.isWebGLRenderTarget = true, this.width = e2, this.height = t2, this.depth = 1, this.scissor = new $r(0, 0, e2, t2), this.scissorTest = false, this.viewport = new $r(0, 0, e2, t2);
      const n2 = { width: e2, height: t2, depth: 1 };
      this.texture = new Zr(n2, r2.mapping, r2.wrapS, r2.wrapT, r2.magFilter, r2.minFilter, r2.format, r2.type, r2.anisotropy, r2.encoding), this.texture.isRenderTargetTexture = true, this.texture.flipY = false, this.texture.generateMipmaps = void 0 !== r2.generateMipmaps && r2.generateMipmaps, this.texture.internalFormat = void 0 !== r2.internalFormat ? r2.internalFormat : null, this.texture.minFilter = void 0 !== r2.minFilter ? r2.minFilter : _e, this.depthBuffer = void 0 === r2.depthBuffer || r2.depthBuffer, this.stencilBuffer = void 0 !== r2.stencilBuffer && r2.stencilBuffer, this.depthTexture = void 0 !== r2.depthTexture ? r2.depthTexture : null, this.samples = void 0 !== r2.samples ? r2.samples : 0;
    }
    setSize(e2, t2, r2 = 1) {
      this.width === e2 && this.height === t2 && this.depth === r2 || (this.width = e2, this.height = t2, this.depth = r2, this.texture.image.width = e2, this.texture.image.height = t2, this.texture.image.depth = r2, this.dispose()), this.viewport.set(0, 0, e2, t2), this.scissor.set(0, 0, e2, t2);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      this.width = e2.width, this.height = e2.height, this.depth = e2.depth, this.viewport.copy(e2.viewport), this.texture = e2.texture.clone(), this.texture.isRenderTargetTexture = true;
      const t2 = Object.assign({}, e2.texture.image);
      return this.texture.source = new Yr(t2), this.depthBuffer = e2.depthBuffer, this.stencilBuffer = e2.stencilBuffer, null !== e2.depthTexture && (this.depthTexture = e2.depthTexture.clone()), this.samples = e2.samples, this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  class tn extends Zr {
    constructor(e2 = null, t2 = 1, r2 = 1, n2 = 1) {
      super(null), this.isDataArrayTexture = true, this.image = { data: e2, width: t2, height: r2, depth: n2 }, this.magFilter = he, this.minFilter = he, this.wrapR = ce, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  class rn extends en {
    constructor(e2, t2, r2) {
      super(e2, t2), this.isWebGLArrayRenderTarget = true, this.depth = r2, this.texture = new tn(null, e2, t2, r2), this.texture.isRenderTargetTexture = true;
    }
  }
  class nn extends Zr {
    constructor(e2 = null, t2 = 1, r2 = 1, n2 = 1) {
      super(null), this.isData3DTexture = true, this.image = { data: e2, width: t2, height: r2, depth: n2 }, this.magFilter = he, this.minFilter = he, this.wrapR = ce, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  class sn extends en {
    constructor(e2, t2, r2) {
      super(e2, t2), this.isWebGL3DRenderTarget = true, this.depth = r2, this.texture = new nn(null, e2, t2, r2), this.texture.isRenderTargetTexture = true;
    }
  }
  class on extends en {
    constructor(e2, t2, r2, n2 = {}) {
      super(e2, t2, n2), this.isWebGLMultipleRenderTargets = true;
      const i2 = this.texture;
      this.texture = [];
      for (let e3 = 0; e3 < r2; e3++)
        this.texture[e3] = i2.clone(), this.texture[e3].isRenderTargetTexture = true;
    }
    setSize(e2, t2, r2 = 1) {
      if (this.width !== e2 || this.height !== t2 || this.depth !== r2) {
        this.width = e2, this.height = t2, this.depth = r2;
        for (let n2 = 0, i2 = this.texture.length; n2 < i2; n2++)
          this.texture[n2].image.width = e2, this.texture[n2].image.height = t2, this.texture[n2].image.depth = r2;
        this.dispose();
      }
      return this.viewport.set(0, 0, e2, t2), this.scissor.set(0, 0, e2, t2), this;
    }
    copy(e2) {
      this.dispose(), this.width = e2.width, this.height = e2.height, this.depth = e2.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e2.depthBuffer, this.stencilBuffer = e2.stencilBuffer, null !== e2.depthTexture && (this.depthTexture = e2.depthTexture.clone()), this.texture.length = 0;
      for (let t2 = 0, r2 = e2.texture.length; t2 < r2; t2++)
        this.texture[t2] = e2.texture[t2].clone(), this.texture[t2].isRenderTargetTexture = true;
      return this;
    }
  }
  class an {
    constructor(e2 = 0, t2 = 0, r2 = 0, n2 = 1) {
      this.isQuaternion = true, this._x = e2, this._y = t2, this._z = r2, this._w = n2;
    }
    static slerpFlat(e2, t2, r2, n2, i2, s2, o2) {
      let a2 = r2[n2 + 0], l2 = r2[n2 + 1], c2 = r2[n2 + 2], u2 = r2[n2 + 3];
      const h2 = i2[s2 + 0], p2 = i2[s2 + 1], d2 = i2[s2 + 2], f2 = i2[s2 + 3];
      if (0 === o2)
        return e2[t2 + 0] = a2, e2[t2 + 1] = l2, e2[t2 + 2] = c2, void (e2[t2 + 3] = u2);
      if (1 === o2)
        return e2[t2 + 0] = h2, e2[t2 + 1] = p2, e2[t2 + 2] = d2, void (e2[t2 + 3] = f2);
      if (u2 !== f2 || a2 !== h2 || l2 !== p2 || c2 !== d2) {
        let e3 = 1 - o2;
        const t3 = a2 * h2 + l2 * p2 + c2 * d2 + u2 * f2, r3 = t3 >= 0 ? 1 : -1, n3 = 1 - t3 * t3;
        if (n3 > Number.EPSILON) {
          const i4 = Math.sqrt(n3), s3 = Math.atan2(i4, t3 * r3);
          e3 = Math.sin(e3 * s3) / i4, o2 = Math.sin(o2 * s3) / i4;
        }
        const i3 = o2 * r3;
        if (a2 = a2 * e3 + h2 * i3, l2 = l2 * e3 + p2 * i3, c2 = c2 * e3 + d2 * i3, u2 = u2 * e3 + f2 * i3, e3 === 1 - o2) {
          const e4 = 1 / Math.sqrt(a2 * a2 + l2 * l2 + c2 * c2 + u2 * u2);
          a2 *= e4, l2 *= e4, c2 *= e4, u2 *= e4;
        }
      }
      e2[t2] = a2, e2[t2 + 1] = l2, e2[t2 + 2] = c2, e2[t2 + 3] = u2;
    }
    static multiplyQuaternionsFlat(e2, t2, r2, n2, i2, s2) {
      const o2 = r2[n2], a2 = r2[n2 + 1], l2 = r2[n2 + 2], c2 = r2[n2 + 3], u2 = i2[s2], h2 = i2[s2 + 1], p2 = i2[s2 + 2], d2 = i2[s2 + 3];
      return e2[t2] = o2 * d2 + c2 * u2 + a2 * p2 - l2 * h2, e2[t2 + 1] = a2 * d2 + c2 * h2 + l2 * u2 - o2 * p2, e2[t2 + 2] = l2 * d2 + c2 * p2 + o2 * h2 - a2 * u2, e2[t2 + 3] = c2 * d2 - o2 * u2 - a2 * h2 - l2 * p2, e2;
    }
    get x() {
      return this._x;
    }
    set x(e2) {
      this._x = e2, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e2) {
      this._y = e2, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e2) {
      this._z = e2, this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(e2) {
      this._w = e2, this._onChangeCallback();
    }
    set(e2, t2, r2, n2) {
      return this._x = e2, this._y = t2, this._z = r2, this._w = n2, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e2) {
      return this._x = e2.x, this._y = e2.y, this._z = e2.z, this._w = e2.w, this._onChangeCallback(), this;
    }
    setFromEuler(e2, t2) {
      const r2 = e2._x, n2 = e2._y, i2 = e2._z, s2 = e2._order, o2 = Math.cos, a2 = Math.sin, l2 = o2(r2 / 2), c2 = o2(n2 / 2), u2 = o2(i2 / 2), h2 = a2(r2 / 2), p2 = a2(n2 / 2), d2 = a2(i2 / 2);
      switch (s2) {
        case "XYZ":
          this._x = h2 * c2 * u2 + l2 * p2 * d2, this._y = l2 * p2 * u2 - h2 * c2 * d2, this._z = l2 * c2 * d2 + h2 * p2 * u2, this._w = l2 * c2 * u2 - h2 * p2 * d2;
          break;
        case "YXZ":
          this._x = h2 * c2 * u2 + l2 * p2 * d2, this._y = l2 * p2 * u2 - h2 * c2 * d2, this._z = l2 * c2 * d2 - h2 * p2 * u2, this._w = l2 * c2 * u2 + h2 * p2 * d2;
          break;
        case "ZXY":
          this._x = h2 * c2 * u2 - l2 * p2 * d2, this._y = l2 * p2 * u2 + h2 * c2 * d2, this._z = l2 * c2 * d2 + h2 * p2 * u2, this._w = l2 * c2 * u2 - h2 * p2 * d2;
          break;
        case "ZYX":
          this._x = h2 * c2 * u2 - l2 * p2 * d2, this._y = l2 * p2 * u2 + h2 * c2 * d2, this._z = l2 * c2 * d2 - h2 * p2 * u2, this._w = l2 * c2 * u2 + h2 * p2 * d2;
          break;
        case "YZX":
          this._x = h2 * c2 * u2 + l2 * p2 * d2, this._y = l2 * p2 * u2 + h2 * c2 * d2, this._z = l2 * c2 * d2 - h2 * p2 * u2, this._w = l2 * c2 * u2 - h2 * p2 * d2;
          break;
        case "XZY":
          this._x = h2 * c2 * u2 - l2 * p2 * d2, this._y = l2 * p2 * u2 - h2 * c2 * d2, this._z = l2 * c2 * d2 + h2 * p2 * u2, this._w = l2 * c2 * u2 + h2 * p2 * d2;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s2);
      }
      return false !== t2 && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e2, t2) {
      const r2 = t2 / 2, n2 = Math.sin(r2);
      return this._x = e2.x * n2, this._y = e2.y * n2, this._z = e2.z * n2, this._w = Math.cos(r2), this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e2) {
      const t2 = e2.elements, r2 = t2[0], n2 = t2[4], i2 = t2[8], s2 = t2[1], o2 = t2[5], a2 = t2[9], l2 = t2[2], c2 = t2[6], u2 = t2[10], h2 = r2 + o2 + u2;
      if (h2 > 0) {
        const e3 = 0.5 / Math.sqrt(h2 + 1);
        this._w = 0.25 / e3, this._x = (c2 - a2) * e3, this._y = (i2 - l2) * e3, this._z = (s2 - n2) * e3;
      } else if (r2 > o2 && r2 > u2) {
        const e3 = 2 * Math.sqrt(1 + r2 - o2 - u2);
        this._w = (c2 - a2) / e3, this._x = 0.25 * e3, this._y = (n2 + s2) / e3, this._z = (i2 + l2) / e3;
      } else if (o2 > u2) {
        const e3 = 2 * Math.sqrt(1 + o2 - r2 - u2);
        this._w = (i2 - l2) / e3, this._x = (n2 + s2) / e3, this._y = 0.25 * e3, this._z = (a2 + c2) / e3;
      } else {
        const e3 = 2 * Math.sqrt(1 + u2 - r2 - o2);
        this._w = (s2 - n2) / e3, this._x = (i2 + l2) / e3, this._y = (a2 + c2) / e3, this._z = 0.25 * e3;
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(e2, t2) {
      let r2 = e2.dot(t2) + 1;
      return r2 < Number.EPSILON ? (r2 = 0, Math.abs(e2.x) > Math.abs(e2.z) ? (this._x = -e2.y, this._y = e2.x, this._z = 0, this._w = r2) : (this._x = 0, this._y = -e2.z, this._z = e2.y, this._w = r2)) : (this._x = e2.y * t2.z - e2.z * t2.y, this._y = e2.z * t2.x - e2.x * t2.z, this._z = e2.x * t2.y - e2.y * t2.x, this._w = r2), this.normalize();
    }
    angleTo(e2) {
      return 2 * Math.acos(Math.abs(yr(this.dot(e2), -1, 1)));
    }
    rotateTowards(e2, t2) {
      const r2 = this.angleTo(e2);
      if (0 === r2)
        return this;
      const n2 = Math.min(1, t2 / r2);
      return this.slerp(e2, n2), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
    dot(e2) {
      return this._x * e2._x + this._y * e2._y + this._z * e2._z + this._w * e2._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let e2 = this.length();
      return 0 === e2 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e2 = 1 / e2, this._x = this._x * e2, this._y = this._y * e2, this._z = this._z * e2, this._w = this._w * e2), this._onChangeCallback(), this;
    }
    multiply(e2) {
      return this.multiplyQuaternions(this, e2);
    }
    premultiply(e2) {
      return this.multiplyQuaternions(e2, this);
    }
    multiplyQuaternions(e2, t2) {
      const r2 = e2._x, n2 = e2._y, i2 = e2._z, s2 = e2._w, o2 = t2._x, a2 = t2._y, l2 = t2._z, c2 = t2._w;
      return this._x = r2 * c2 + s2 * o2 + n2 * l2 - i2 * a2, this._y = n2 * c2 + s2 * a2 + i2 * o2 - r2 * l2, this._z = i2 * c2 + s2 * l2 + r2 * a2 - n2 * o2, this._w = s2 * c2 - r2 * o2 - n2 * a2 - i2 * l2, this._onChangeCallback(), this;
    }
    slerp(e2, t2) {
      if (0 === t2)
        return this;
      if (1 === t2)
        return this.copy(e2);
      const r2 = this._x, n2 = this._y, i2 = this._z, s2 = this._w;
      let o2 = s2 * e2._w + r2 * e2._x + n2 * e2._y + i2 * e2._z;
      if (o2 < 0 ? (this._w = -e2._w, this._x = -e2._x, this._y = -e2._y, this._z = -e2._z, o2 = -o2) : this.copy(e2), o2 >= 1)
        return this._w = s2, this._x = r2, this._y = n2, this._z = i2, this;
      const a2 = 1 - o2 * o2;
      if (a2 <= Number.EPSILON) {
        const e3 = 1 - t2;
        return this._w = e3 * s2 + t2 * this._w, this._x = e3 * r2 + t2 * this._x, this._y = e3 * n2 + t2 * this._y, this._z = e3 * i2 + t2 * this._z, this.normalize(), this._onChangeCallback(), this;
      }
      const l2 = Math.sqrt(a2), c2 = Math.atan2(l2, o2), u2 = Math.sin((1 - t2) * c2) / l2, h2 = Math.sin(t2 * c2) / l2;
      return this._w = s2 * u2 + this._w * h2, this._x = r2 * u2 + this._x * h2, this._y = n2 * u2 + this._y * h2, this._z = i2 * u2 + this._z * h2, this._onChangeCallback(), this;
    }
    slerpQuaternions(e2, t2, r2) {
      return this.copy(e2).slerp(t2, r2);
    }
    random() {
      const e2 = Math.random(), t2 = Math.sqrt(1 - e2), r2 = Math.sqrt(e2), n2 = 2 * Math.PI * Math.random(), i2 = 2 * Math.PI * Math.random();
      return this.set(t2 * Math.cos(n2), r2 * Math.sin(i2), r2 * Math.cos(i2), t2 * Math.sin(n2));
    }
    equals(e2) {
      return e2._x === this._x && e2._y === this._y && e2._z === this._z && e2._w === this._w;
    }
    fromArray(e2, t2 = 0) {
      return this._x = e2[t2], this._y = e2[t2 + 1], this._z = e2[t2 + 2], this._w = e2[t2 + 3], this._onChangeCallback(), this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this._x, e2[t2 + 1] = this._y, e2[t2 + 2] = this._z, e2[t2 + 3] = this._w, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this._x = e2.getX(t2), this._y = e2.getY(t2), this._z = e2.getZ(t2), this._w = e2.getW(t2), this;
    }
    _onChange(e2) {
      return this._onChangeCallback = e2, this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w;
    }
  }
  class ln {
    constructor(e2 = 0, t2 = 0, r2 = 0) {
      ln.prototype.isVector3 = true, this.x = e2, this.y = t2, this.z = r2;
    }
    set(e2, t2, r2) {
      return void 0 === r2 && (r2 = this.z), this.x = e2, this.y = t2, this.z = r2, this;
    }
    setScalar(e2) {
      return this.x = e2, this.y = e2, this.z = e2, this;
    }
    setX(e2) {
      return this.x = e2, this;
    }
    setY(e2) {
      return this.y = e2, this;
    }
    setZ(e2) {
      return this.z = e2, this;
    }
    setComponent(e2, t2) {
      switch (e2) {
        case 0:
          this.x = t2;
          break;
        case 1:
          this.y = t2;
          break;
        case 2:
          this.z = t2;
          break;
        default:
          throw new Error("index is out of range: " + e2);
      }
      return this;
    }
    getComponent(e2) {
      switch (e2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + e2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this.z = e2.z, this;
    }
    add(e2) {
      return this.x += e2.x, this.y += e2.y, this.z += e2.z, this;
    }
    addScalar(e2) {
      return this.x += e2, this.y += e2, this.z += e2, this;
    }
    addVectors(e2, t2) {
      return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this.z = e2.z + t2.z, this;
    }
    addScaledVector(e2, t2) {
      return this.x += e2.x * t2, this.y += e2.y * t2, this.z += e2.z * t2, this;
    }
    sub(e2) {
      return this.x -= e2.x, this.y -= e2.y, this.z -= e2.z, this;
    }
    subScalar(e2) {
      return this.x -= e2, this.y -= e2, this.z -= e2, this;
    }
    subVectors(e2, t2) {
      return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this.z = e2.z - t2.z, this;
    }
    multiply(e2) {
      return this.x *= e2.x, this.y *= e2.y, this.z *= e2.z, this;
    }
    multiplyScalar(e2) {
      return this.x *= e2, this.y *= e2, this.z *= e2, this;
    }
    multiplyVectors(e2, t2) {
      return this.x = e2.x * t2.x, this.y = e2.y * t2.y, this.z = e2.z * t2.z, this;
    }
    applyEuler(e2) {
      return this.applyQuaternion(un.setFromEuler(e2));
    }
    applyAxisAngle(e2, t2) {
      return this.applyQuaternion(un.setFromAxisAngle(e2, t2));
    }
    applyMatrix3(e2) {
      const t2 = this.x, r2 = this.y, n2 = this.z, i2 = e2.elements;
      return this.x = i2[0] * t2 + i2[3] * r2 + i2[6] * n2, this.y = i2[1] * t2 + i2[4] * r2 + i2[7] * n2, this.z = i2[2] * t2 + i2[5] * r2 + i2[8] * n2, this;
    }
    applyNormalMatrix(e2) {
      return this.applyMatrix3(e2).normalize();
    }
    applyMatrix4(e2) {
      const t2 = this.x, r2 = this.y, n2 = this.z, i2 = e2.elements, s2 = 1 / (i2[3] * t2 + i2[7] * r2 + i2[11] * n2 + i2[15]);
      return this.x = (i2[0] * t2 + i2[4] * r2 + i2[8] * n2 + i2[12]) * s2, this.y = (i2[1] * t2 + i2[5] * r2 + i2[9] * n2 + i2[13]) * s2, this.z = (i2[2] * t2 + i2[6] * r2 + i2[10] * n2 + i2[14]) * s2, this;
    }
    applyQuaternion(e2) {
      const t2 = this.x, r2 = this.y, n2 = this.z, i2 = e2.x, s2 = e2.y, o2 = e2.z, a2 = e2.w, l2 = a2 * t2 + s2 * n2 - o2 * r2, c2 = a2 * r2 + o2 * t2 - i2 * n2, u2 = a2 * n2 + i2 * r2 - s2 * t2, h2 = -i2 * t2 - s2 * r2 - o2 * n2;
      return this.x = l2 * a2 + h2 * -i2 + c2 * -o2 - u2 * -s2, this.y = c2 * a2 + h2 * -s2 + u2 * -i2 - l2 * -o2, this.z = u2 * a2 + h2 * -o2 + l2 * -s2 - c2 * -i2, this;
    }
    project(e2) {
      return this.applyMatrix4(e2.matrixWorldInverse).applyMatrix4(e2.projectionMatrix);
    }
    unproject(e2) {
      return this.applyMatrix4(e2.projectionMatrixInverse).applyMatrix4(e2.matrixWorld);
    }
    transformDirection(e2) {
      const t2 = this.x, r2 = this.y, n2 = this.z, i2 = e2.elements;
      return this.x = i2[0] * t2 + i2[4] * r2 + i2[8] * n2, this.y = i2[1] * t2 + i2[5] * r2 + i2[9] * n2, this.z = i2[2] * t2 + i2[6] * r2 + i2[10] * n2, this.normalize();
    }
    divide(e2) {
      return this.x /= e2.x, this.y /= e2.y, this.z /= e2.z, this;
    }
    divideScalar(e2) {
      return this.multiplyScalar(1 / e2);
    }
    min(e2) {
      return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this.z = Math.min(this.z, e2.z), this;
    }
    max(e2) {
      return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this.z = Math.max(this.z, e2.z), this;
    }
    clamp(e2, t2) {
      return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this.z = Math.max(e2.z, Math.min(t2.z, this.z)), this;
    }
    clampScalar(e2, t2) {
      return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this.z = Math.max(e2, Math.min(t2, this.z)), this;
    }
    clampLength(e2, t2) {
      const r2 = this.length();
      return this.divideScalar(r2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, r2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(e2) {
      return this.x * e2.x + this.y * e2.y + this.z * e2.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e2) {
      return this.normalize().multiplyScalar(e2);
    }
    lerp(e2, t2) {
      return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this.z += (e2.z - this.z) * t2, this;
    }
    lerpVectors(e2, t2, r2) {
      return this.x = e2.x + (t2.x - e2.x) * r2, this.y = e2.y + (t2.y - e2.y) * r2, this.z = e2.z + (t2.z - e2.z) * r2, this;
    }
    cross(e2) {
      return this.crossVectors(this, e2);
    }
    crossVectors(e2, t2) {
      const r2 = e2.x, n2 = e2.y, i2 = e2.z, s2 = t2.x, o2 = t2.y, a2 = t2.z;
      return this.x = n2 * a2 - i2 * o2, this.y = i2 * s2 - r2 * a2, this.z = r2 * o2 - n2 * s2, this;
    }
    projectOnVector(e2) {
      const t2 = e2.lengthSq();
      if (0 === t2)
        return this.set(0, 0, 0);
      const r2 = e2.dot(this) / t2;
      return this.copy(e2).multiplyScalar(r2);
    }
    projectOnPlane(e2) {
      return cn.copy(this).projectOnVector(e2), this.sub(cn);
    }
    reflect(e2) {
      return this.sub(cn.copy(e2).multiplyScalar(2 * this.dot(e2)));
    }
    angleTo(e2) {
      const t2 = Math.sqrt(this.lengthSq() * e2.lengthSq());
      if (0 === t2)
        return Math.PI / 2;
      const r2 = this.dot(e2) / t2;
      return Math.acos(yr(r2, -1, 1));
    }
    distanceTo(e2) {
      return Math.sqrt(this.distanceToSquared(e2));
    }
    distanceToSquared(e2) {
      const t2 = this.x - e2.x, r2 = this.y - e2.y, n2 = this.z - e2.z;
      return t2 * t2 + r2 * r2 + n2 * n2;
    }
    manhattanDistanceTo(e2) {
      return Math.abs(this.x - e2.x) + Math.abs(this.y - e2.y) + Math.abs(this.z - e2.z);
    }
    setFromSpherical(e2) {
      return this.setFromSphericalCoords(e2.radius, e2.phi, e2.theta);
    }
    setFromSphericalCoords(e2, t2, r2) {
      const n2 = Math.sin(t2) * e2;
      return this.x = n2 * Math.sin(r2), this.y = Math.cos(t2) * e2, this.z = n2 * Math.cos(r2), this;
    }
    setFromCylindrical(e2) {
      return this.setFromCylindricalCoords(e2.radius, e2.theta, e2.y);
    }
    setFromCylindricalCoords(e2, t2, r2) {
      return this.x = e2 * Math.sin(t2), this.y = r2, this.z = e2 * Math.cos(t2), this;
    }
    setFromMatrixPosition(e2) {
      const t2 = e2.elements;
      return this.x = t2[12], this.y = t2[13], this.z = t2[14], this;
    }
    setFromMatrixScale(e2) {
      const t2 = this.setFromMatrixColumn(e2, 0).length(), r2 = this.setFromMatrixColumn(e2, 1).length(), n2 = this.setFromMatrixColumn(e2, 2).length();
      return this.x = t2, this.y = r2, this.z = n2, this;
    }
    setFromMatrixColumn(e2, t2) {
      return this.fromArray(e2.elements, 4 * t2);
    }
    setFromMatrix3Column(e2, t2) {
      return this.fromArray(e2.elements, 3 * t2);
    }
    setFromEuler(e2) {
      return this.x = e2._x, this.y = e2._y, this.z = e2._z, this;
    }
    equals(e2) {
      return e2.x === this.x && e2.y === this.y && e2.z === this.z;
    }
    fromArray(e2, t2 = 0) {
      return this.x = e2[t2], this.y = e2[t2 + 1], this.z = e2[t2 + 2], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.x, e2[t2 + 1] = this.y, e2[t2 + 2] = this.z, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this.x = e2.getX(t2), this.y = e2.getY(t2), this.z = e2.getZ(t2), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
    randomDirection() {
      const e2 = 2 * (Math.random() - 0.5), t2 = Math.random() * Math.PI * 2, r2 = Math.sqrt(1 - e2 ** 2);
      return this.x = r2 * Math.cos(t2), this.y = r2 * Math.sin(t2), this.z = e2, this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  }
  const cn = new ln(), un = new an();
  class hn {
    constructor(e2 = new ln(1 / 0, 1 / 0, 1 / 0), t2 = new ln(-1 / 0, -1 / 0, -1 / 0)) {
      this.isBox3 = true, this.min = e2, this.max = t2;
    }
    set(e2, t2) {
      return this.min.copy(e2), this.max.copy(t2), this;
    }
    setFromArray(e2) {
      let t2 = 1 / 0, r2 = 1 / 0, n2 = 1 / 0, i2 = -1 / 0, s2 = -1 / 0, o2 = -1 / 0;
      for (let a2 = 0, l2 = e2.length; a2 < l2; a2 += 3) {
        const l3 = e2[a2], c2 = e2[a2 + 1], u2 = e2[a2 + 2];
        l3 < t2 && (t2 = l3), c2 < r2 && (r2 = c2), u2 < n2 && (n2 = u2), l3 > i2 && (i2 = l3), c2 > s2 && (s2 = c2), u2 > o2 && (o2 = u2);
      }
      return this.min.set(t2, r2, n2), this.max.set(i2, s2, o2), this;
    }
    setFromBufferAttribute(e2) {
      let t2 = 1 / 0, r2 = 1 / 0, n2 = 1 / 0, i2 = -1 / 0, s2 = -1 / 0, o2 = -1 / 0;
      for (let a2 = 0, l2 = e2.count; a2 < l2; a2++) {
        const l3 = e2.getX(a2), c2 = e2.getY(a2), u2 = e2.getZ(a2);
        l3 < t2 && (t2 = l3), c2 < r2 && (r2 = c2), u2 < n2 && (n2 = u2), l3 > i2 && (i2 = l3), c2 > s2 && (s2 = c2), u2 > o2 && (o2 = u2);
      }
      return this.min.set(t2, r2, n2), this.max.set(i2, s2, o2), this;
    }
    setFromPoints(e2) {
      this.makeEmpty();
      for (let t2 = 0, r2 = e2.length; t2 < r2; t2++)
        this.expandByPoint(e2[t2]);
      return this;
    }
    setFromCenterAndSize(e2, t2) {
      const r2 = dn.copy(t2).multiplyScalar(0.5);
      return this.min.copy(e2).sub(r2), this.max.copy(e2).add(r2), this;
    }
    setFromObject(e2, t2 = false) {
      return this.makeEmpty(), this.expandByObject(e2, t2);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.min.copy(e2.min), this.max.copy(e2.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(e2) {
      return this.isEmpty() ? e2.set(0, 0, 0) : e2.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e2) {
      return this.isEmpty() ? e2.set(0, 0, 0) : e2.subVectors(this.max, this.min);
    }
    expandByPoint(e2) {
      return this.min.min(e2), this.max.max(e2), this;
    }
    expandByVector(e2) {
      return this.min.sub(e2), this.max.add(e2), this;
    }
    expandByScalar(e2) {
      return this.min.addScalar(-e2), this.max.addScalar(e2), this;
    }
    expandByObject(e2, t2 = false) {
      e2.updateWorldMatrix(false, false);
      const r2 = e2.geometry;
      if (void 0 !== r2)
        if (t2 && null != r2.attributes && void 0 !== r2.attributes.position) {
          const t3 = r2.attributes.position;
          for (let r3 = 0, n3 = t3.count; r3 < n3; r3++)
            dn.fromBufferAttribute(t3, r3).applyMatrix4(e2.matrixWorld), this.expandByPoint(dn);
        } else
          null === r2.boundingBox && r2.computeBoundingBox(), fn.copy(r2.boundingBox), fn.applyMatrix4(e2.matrixWorld), this.union(fn);
      const n2 = e2.children;
      for (let e3 = 0, r3 = n2.length; e3 < r3; e3++)
        this.expandByObject(n2[e3], t2);
      return this;
    }
    containsPoint(e2) {
      return !(e2.x < this.min.x || e2.x > this.max.x || e2.y < this.min.y || e2.y > this.max.y || e2.z < this.min.z || e2.z > this.max.z);
    }
    containsBox(e2) {
      return this.min.x <= e2.min.x && e2.max.x <= this.max.x && this.min.y <= e2.min.y && e2.max.y <= this.max.y && this.min.z <= e2.min.z && e2.max.z <= this.max.z;
    }
    getParameter(e2, t2) {
      return t2.set((e2.x - this.min.x) / (this.max.x - this.min.x), (e2.y - this.min.y) / (this.max.y - this.min.y), (e2.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(e2) {
      return !(e2.max.x < this.min.x || e2.min.x > this.max.x || e2.max.y < this.min.y || e2.min.y > this.max.y || e2.max.z < this.min.z || e2.min.z > this.max.z);
    }
    intersectsSphere(e2) {
      return this.clampPoint(e2.center, dn), dn.distanceToSquared(e2.center) <= e2.radius * e2.radius;
    }
    intersectsPlane(e2) {
      let t2, r2;
      return e2.normal.x > 0 ? (t2 = e2.normal.x * this.min.x, r2 = e2.normal.x * this.max.x) : (t2 = e2.normal.x * this.max.x, r2 = e2.normal.x * this.min.x), e2.normal.y > 0 ? (t2 += e2.normal.y * this.min.y, r2 += e2.normal.y * this.max.y) : (t2 += e2.normal.y * this.max.y, r2 += e2.normal.y * this.min.y), e2.normal.z > 0 ? (t2 += e2.normal.z * this.min.z, r2 += e2.normal.z * this.max.z) : (t2 += e2.normal.z * this.max.z, r2 += e2.normal.z * this.min.z), t2 <= -e2.constant && r2 >= -e2.constant;
    }
    intersectsTriangle(e2) {
      if (this.isEmpty())
        return false;
      this.getCenter(yn), xn.subVectors(this.max, yn), mn.subVectors(e2.a, yn), _n.subVectors(e2.b, yn), gn.subVectors(e2.c, yn), vn.subVectors(_n, mn), An.subVectors(gn, _n), bn.subVectors(mn, gn);
      let t2 = [0, -vn.z, vn.y, 0, -An.z, An.y, 0, -bn.z, bn.y, vn.z, 0, -vn.x, An.z, 0, -An.x, bn.z, 0, -bn.x, -vn.y, vn.x, 0, -An.y, An.x, 0, -bn.y, bn.x, 0];
      return !!Sn(t2, mn, _n, gn, xn) && (t2 = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Sn(t2, mn, _n, gn, xn) && (wn.crossVectors(vn, An), t2 = [wn.x, wn.y, wn.z], Sn(t2, mn, _n, gn, xn)));
    }
    clampPoint(e2, t2) {
      return t2.copy(e2).clamp(this.min, this.max);
    }
    distanceToPoint(e2) {
      return dn.copy(e2).clamp(this.min, this.max).sub(e2).length();
    }
    getBoundingSphere(e2) {
      return this.getCenter(e2.center), e2.radius = 0.5 * this.getSize(dn).length(), e2;
    }
    intersect(e2) {
      return this.min.max(e2.min), this.max.min(e2.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(e2) {
      return this.min.min(e2.min), this.max.max(e2.max), this;
    }
    applyMatrix4(e2) {
      return this.isEmpty() || (pn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e2), pn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e2), pn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e2), pn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e2), pn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e2), pn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e2), pn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e2), pn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e2), this.setFromPoints(pn)), this;
    }
    translate(e2) {
      return this.min.add(e2), this.max.add(e2), this;
    }
    equals(e2) {
      return e2.min.equals(this.min) && e2.max.equals(this.max);
    }
  }
  const pn = [new ln(), new ln(), new ln(), new ln(), new ln(), new ln(), new ln(), new ln()], dn = new ln(), fn = new hn(), mn = new ln(), _n = new ln(), gn = new ln(), vn = new ln(), An = new ln(), bn = new ln(), yn = new ln(), xn = new ln(), wn = new ln(), En = new ln();
  function Sn(e2, t2, r2, n2, i2) {
    for (let s2 = 0, o2 = e2.length - 3; s2 <= o2; s2 += 3) {
      En.fromArray(e2, s2);
      const o3 = i2.x * Math.abs(En.x) + i2.y * Math.abs(En.y) + i2.z * Math.abs(En.z), a2 = t2.dot(En), l2 = r2.dot(En), c2 = n2.dot(En);
      if (Math.max(-Math.max(a2, l2, c2), Math.min(a2, l2, c2)) > o3)
        return false;
    }
    return true;
  }
  const Cn = new hn(), Mn = new ln(), Tn = new ln(), In = new ln();
  class kn {
    constructor(e2 = new ln(), t2 = -1) {
      this.center = e2, this.radius = t2;
    }
    set(e2, t2) {
      return this.center.copy(e2), this.radius = t2, this;
    }
    setFromPoints(e2, t2) {
      const r2 = this.center;
      void 0 !== t2 ? r2.copy(t2) : Cn.setFromPoints(e2).getCenter(r2);
      let n2 = 0;
      for (let t3 = 0, i2 = e2.length; t3 < i2; t3++)
        n2 = Math.max(n2, r2.distanceToSquared(e2[t3]));
      return this.radius = Math.sqrt(n2), this;
    }
    copy(e2) {
      return this.center.copy(e2.center), this.radius = e2.radius, this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(e2) {
      return e2.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e2) {
      return e2.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e2) {
      const t2 = this.radius + e2.radius;
      return e2.center.distanceToSquared(this.center) <= t2 * t2;
    }
    intersectsBox(e2) {
      return e2.intersectsSphere(this);
    }
    intersectsPlane(e2) {
      return Math.abs(e2.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e2, t2) {
      const r2 = this.center.distanceToSquared(e2);
      return t2.copy(e2), r2 > this.radius * this.radius && (t2.sub(this.center).normalize(), t2.multiplyScalar(this.radius).add(this.center)), t2;
    }
    getBoundingBox(e2) {
      return this.isEmpty() ? (e2.makeEmpty(), e2) : (e2.set(this.center, this.center), e2.expandByScalar(this.radius), e2);
    }
    applyMatrix4(e2) {
      return this.center.applyMatrix4(e2), this.radius = this.radius * e2.getMaxScaleOnAxis(), this;
    }
    translate(e2) {
      return this.center.add(e2), this;
    }
    expandByPoint(e2) {
      In.subVectors(e2, this.center);
      const t2 = In.lengthSq();
      if (t2 > this.radius * this.radius) {
        const e3 = Math.sqrt(t2), r2 = 0.5 * (e3 - this.radius);
        this.center.add(In.multiplyScalar(r2 / e3)), this.radius += r2;
      }
      return this;
    }
    union(e2) {
      return true === this.center.equals(e2.center) ? Tn.set(0, 0, 1).multiplyScalar(e2.radius) : Tn.subVectors(e2.center, this.center).normalize().multiplyScalar(e2.radius), this.expandByPoint(Mn.copy(e2.center).add(Tn)), this.expandByPoint(Mn.copy(e2.center).sub(Tn)), this;
    }
    equals(e2) {
      return e2.center.equals(this.center) && e2.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Dn = new ln(), Pn = new ln(), Bn = new ln(), Rn = new ln(), Ln = new ln(), On = new ln(), Fn = new ln();
  class Un {
    constructor(e2 = new ln(), t2 = new ln(0, 0, -1)) {
      this.origin = e2, this.direction = t2;
    }
    set(e2, t2) {
      return this.origin.copy(e2), this.direction.copy(t2), this;
    }
    copy(e2) {
      return this.origin.copy(e2.origin), this.direction.copy(e2.direction), this;
    }
    at(e2, t2) {
      return t2.copy(this.direction).multiplyScalar(e2).add(this.origin);
    }
    lookAt(e2) {
      return this.direction.copy(e2).sub(this.origin).normalize(), this;
    }
    recast(e2) {
      return this.origin.copy(this.at(e2, Dn)), this;
    }
    closestPointToPoint(e2, t2) {
      t2.subVectors(e2, this.origin);
      const r2 = t2.dot(this.direction);
      return r2 < 0 ? t2.copy(this.origin) : t2.copy(this.direction).multiplyScalar(r2).add(this.origin);
    }
    distanceToPoint(e2) {
      return Math.sqrt(this.distanceSqToPoint(e2));
    }
    distanceSqToPoint(e2) {
      const t2 = Dn.subVectors(e2, this.origin).dot(this.direction);
      return t2 < 0 ? this.origin.distanceToSquared(e2) : (Dn.copy(this.direction).multiplyScalar(t2).add(this.origin), Dn.distanceToSquared(e2));
    }
    distanceSqToSegment(e2, t2, r2, n2) {
      Pn.copy(e2).add(t2).multiplyScalar(0.5), Bn.copy(t2).sub(e2).normalize(), Rn.copy(this.origin).sub(Pn);
      const i2 = 0.5 * e2.distanceTo(t2), s2 = -this.direction.dot(Bn), o2 = Rn.dot(this.direction), a2 = -Rn.dot(Bn), l2 = Rn.lengthSq(), c2 = Math.abs(1 - s2 * s2);
      let u2, h2, p2, d2;
      if (c2 > 0)
        if (u2 = s2 * a2 - o2, h2 = s2 * o2 - a2, d2 = i2 * c2, u2 >= 0)
          if (h2 >= -d2)
            if (h2 <= d2) {
              const e3 = 1 / c2;
              u2 *= e3, h2 *= e3, p2 = u2 * (u2 + s2 * h2 + 2 * o2) + h2 * (s2 * u2 + h2 + 2 * a2) + l2;
            } else
              h2 = i2, u2 = Math.max(0, -(s2 * h2 + o2)), p2 = -u2 * u2 + h2 * (h2 + 2 * a2) + l2;
          else
            h2 = -i2, u2 = Math.max(0, -(s2 * h2 + o2)), p2 = -u2 * u2 + h2 * (h2 + 2 * a2) + l2;
        else
          h2 <= -d2 ? (u2 = Math.max(0, -(-s2 * i2 + o2)), h2 = u2 > 0 ? -i2 : Math.min(Math.max(-i2, -a2), i2), p2 = -u2 * u2 + h2 * (h2 + 2 * a2) + l2) : h2 <= d2 ? (u2 = 0, h2 = Math.min(Math.max(-i2, -a2), i2), p2 = h2 * (h2 + 2 * a2) + l2) : (u2 = Math.max(0, -(s2 * i2 + o2)), h2 = u2 > 0 ? i2 : Math.min(Math.max(-i2, -a2), i2), p2 = -u2 * u2 + h2 * (h2 + 2 * a2) + l2);
      else
        h2 = s2 > 0 ? -i2 : i2, u2 = Math.max(0, -(s2 * h2 + o2)), p2 = -u2 * u2 + h2 * (h2 + 2 * a2) + l2;
      return r2 && r2.copy(this.direction).multiplyScalar(u2).add(this.origin), n2 && n2.copy(Bn).multiplyScalar(h2).add(Pn), p2;
    }
    intersectSphere(e2, t2) {
      Dn.subVectors(e2.center, this.origin);
      const r2 = Dn.dot(this.direction), n2 = Dn.dot(Dn) - r2 * r2, i2 = e2.radius * e2.radius;
      if (n2 > i2)
        return null;
      const s2 = Math.sqrt(i2 - n2), o2 = r2 - s2, a2 = r2 + s2;
      return o2 < 0 && a2 < 0 ? null : o2 < 0 ? this.at(a2, t2) : this.at(o2, t2);
    }
    intersectsSphere(e2) {
      return this.distanceSqToPoint(e2.center) <= e2.radius * e2.radius;
    }
    distanceToPlane(e2) {
      const t2 = e2.normal.dot(this.direction);
      if (0 === t2)
        return 0 === e2.distanceToPoint(this.origin) ? 0 : null;
      const r2 = -(this.origin.dot(e2.normal) + e2.constant) / t2;
      return r2 >= 0 ? r2 : null;
    }
    intersectPlane(e2, t2) {
      const r2 = this.distanceToPlane(e2);
      return null === r2 ? null : this.at(r2, t2);
    }
    intersectsPlane(e2) {
      const t2 = e2.distanceToPoint(this.origin);
      return 0 === t2 || e2.normal.dot(this.direction) * t2 < 0;
    }
    intersectBox(e2, t2) {
      let r2, n2, i2, s2, o2, a2;
      const l2 = 1 / this.direction.x, c2 = 1 / this.direction.y, u2 = 1 / this.direction.z, h2 = this.origin;
      return l2 >= 0 ? (r2 = (e2.min.x - h2.x) * l2, n2 = (e2.max.x - h2.x) * l2) : (r2 = (e2.max.x - h2.x) * l2, n2 = (e2.min.x - h2.x) * l2), c2 >= 0 ? (i2 = (e2.min.y - h2.y) * c2, s2 = (e2.max.y - h2.y) * c2) : (i2 = (e2.max.y - h2.y) * c2, s2 = (e2.min.y - h2.y) * c2), r2 > s2 || i2 > n2 ? null : ((i2 > r2 || r2 != r2) && (r2 = i2), (s2 < n2 || n2 != n2) && (n2 = s2), u2 >= 0 ? (o2 = (e2.min.z - h2.z) * u2, a2 = (e2.max.z - h2.z) * u2) : (o2 = (e2.max.z - h2.z) * u2, a2 = (e2.min.z - h2.z) * u2), r2 > a2 || o2 > n2 ? null : ((o2 > r2 || r2 != r2) && (r2 = o2), (a2 < n2 || n2 != n2) && (n2 = a2), n2 < 0 ? null : this.at(r2 >= 0 ? r2 : n2, t2)));
    }
    intersectsBox(e2) {
      return null !== this.intersectBox(e2, Dn);
    }
    intersectTriangle(e2, t2, r2, n2, i2) {
      Ln.subVectors(t2, e2), On.subVectors(r2, e2), Fn.crossVectors(Ln, On);
      let s2, o2 = this.direction.dot(Fn);
      if (o2 > 0) {
        if (n2)
          return null;
        s2 = 1;
      } else {
        if (!(o2 < 0))
          return null;
        s2 = -1, o2 = -o2;
      }
      Rn.subVectors(this.origin, e2);
      const a2 = s2 * this.direction.dot(On.crossVectors(Rn, On));
      if (a2 < 0)
        return null;
      const l2 = s2 * this.direction.dot(Ln.cross(Rn));
      if (l2 < 0)
        return null;
      if (a2 + l2 > o2)
        return null;
      const c2 = -s2 * Rn.dot(Fn);
      return c2 < 0 ? null : this.at(c2 / o2, i2);
    }
    applyMatrix4(e2) {
      return this.origin.applyMatrix4(e2), this.direction.transformDirection(e2), this;
    }
    equals(e2) {
      return e2.origin.equals(this.origin) && e2.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Nn {
    constructor() {
      Nn.prototype.isMatrix4 = true, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }
    set(e2, t2, r2, n2, i2, s2, o2, a2, l2, c2, u2, h2, p2, d2, f2, m2) {
      const _2 = this.elements;
      return _2[0] = e2, _2[4] = t2, _2[8] = r2, _2[12] = n2, _2[1] = i2, _2[5] = s2, _2[9] = o2, _2[13] = a2, _2[2] = l2, _2[6] = c2, _2[10] = u2, _2[14] = h2, _2[3] = p2, _2[7] = d2, _2[11] = f2, _2[15] = m2, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new Nn().fromArray(this.elements);
    }
    copy(e2) {
      const t2 = this.elements, r2 = e2.elements;
      return t2[0] = r2[0], t2[1] = r2[1], t2[2] = r2[2], t2[3] = r2[3], t2[4] = r2[4], t2[5] = r2[5], t2[6] = r2[6], t2[7] = r2[7], t2[8] = r2[8], t2[9] = r2[9], t2[10] = r2[10], t2[11] = r2[11], t2[12] = r2[12], t2[13] = r2[13], t2[14] = r2[14], t2[15] = r2[15], this;
    }
    copyPosition(e2) {
      const t2 = this.elements, r2 = e2.elements;
      return t2[12] = r2[12], t2[13] = r2[13], t2[14] = r2[14], this;
    }
    setFromMatrix3(e2) {
      const t2 = e2.elements;
      return this.set(t2[0], t2[3], t2[6], 0, t2[1], t2[4], t2[7], 0, t2[2], t2[5], t2[8], 0, 0, 0, 0, 1), this;
    }
    extractBasis(e2, t2, r2) {
      return e2.setFromMatrixColumn(this, 0), t2.setFromMatrixColumn(this, 1), r2.setFromMatrixColumn(this, 2), this;
    }
    makeBasis(e2, t2, r2) {
      return this.set(e2.x, t2.x, r2.x, 0, e2.y, t2.y, r2.y, 0, e2.z, t2.z, r2.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(e2) {
      const t2 = this.elements, r2 = e2.elements, n2 = 1 / jn.setFromMatrixColumn(e2, 0).length(), i2 = 1 / jn.setFromMatrixColumn(e2, 1).length(), s2 = 1 / jn.setFromMatrixColumn(e2, 2).length();
      return t2[0] = r2[0] * n2, t2[1] = r2[1] * n2, t2[2] = r2[2] * n2, t2[3] = 0, t2[4] = r2[4] * i2, t2[5] = r2[5] * i2, t2[6] = r2[6] * i2, t2[7] = 0, t2[8] = r2[8] * s2, t2[9] = r2[9] * s2, t2[10] = r2[10] * s2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, this;
    }
    makeRotationFromEuler(e2) {
      const t2 = this.elements, r2 = e2.x, n2 = e2.y, i2 = e2.z, s2 = Math.cos(r2), o2 = Math.sin(r2), a2 = Math.cos(n2), l2 = Math.sin(n2), c2 = Math.cos(i2), u2 = Math.sin(i2);
      if ("XYZ" === e2.order) {
        const e3 = s2 * c2, r3 = s2 * u2, n3 = o2 * c2, i3 = o2 * u2;
        t2[0] = a2 * c2, t2[4] = -a2 * u2, t2[8] = l2, t2[1] = r3 + n3 * l2, t2[5] = e3 - i3 * l2, t2[9] = -o2 * a2, t2[2] = i3 - e3 * l2, t2[6] = n3 + r3 * l2, t2[10] = s2 * a2;
      } else if ("YXZ" === e2.order) {
        const e3 = a2 * c2, r3 = a2 * u2, n3 = l2 * c2, i3 = l2 * u2;
        t2[0] = e3 + i3 * o2, t2[4] = n3 * o2 - r3, t2[8] = s2 * l2, t2[1] = s2 * u2, t2[5] = s2 * c2, t2[9] = -o2, t2[2] = r3 * o2 - n3, t2[6] = i3 + e3 * o2, t2[10] = s2 * a2;
      } else if ("ZXY" === e2.order) {
        const e3 = a2 * c2, r3 = a2 * u2, n3 = l2 * c2, i3 = l2 * u2;
        t2[0] = e3 - i3 * o2, t2[4] = -s2 * u2, t2[8] = n3 + r3 * o2, t2[1] = r3 + n3 * o2, t2[5] = s2 * c2, t2[9] = i3 - e3 * o2, t2[2] = -s2 * l2, t2[6] = o2, t2[10] = s2 * a2;
      } else if ("ZYX" === e2.order) {
        const e3 = s2 * c2, r3 = s2 * u2, n3 = o2 * c2, i3 = o2 * u2;
        t2[0] = a2 * c2, t2[4] = n3 * l2 - r3, t2[8] = e3 * l2 + i3, t2[1] = a2 * u2, t2[5] = i3 * l2 + e3, t2[9] = r3 * l2 - n3, t2[2] = -l2, t2[6] = o2 * a2, t2[10] = s2 * a2;
      } else if ("YZX" === e2.order) {
        const e3 = s2 * a2, r3 = s2 * l2, n3 = o2 * a2, i3 = o2 * l2;
        t2[0] = a2 * c2, t2[4] = i3 - e3 * u2, t2[8] = n3 * u2 + r3, t2[1] = u2, t2[5] = s2 * c2, t2[9] = -o2 * c2, t2[2] = -l2 * c2, t2[6] = r3 * u2 + n3, t2[10] = e3 - i3 * u2;
      } else if ("XZY" === e2.order) {
        const e3 = s2 * a2, r3 = s2 * l2, n3 = o2 * a2, i3 = o2 * l2;
        t2[0] = a2 * c2, t2[4] = -u2, t2[8] = l2 * c2, t2[1] = e3 * u2 + i3, t2[5] = s2 * c2, t2[9] = r3 * u2 - n3, t2[2] = n3 * u2 - r3, t2[6] = o2 * c2, t2[10] = i3 * u2 + e3;
      }
      return t2[3] = 0, t2[7] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, this;
    }
    makeRotationFromQuaternion(e2) {
      return this.compose(Gn, e2, Vn);
    }
    lookAt(e2, t2, r2) {
      const n2 = this.elements;
      return Wn.subVectors(e2, t2), 0 === Wn.lengthSq() && (Wn.z = 1), Wn.normalize(), Qn.crossVectors(r2, Wn), 0 === Qn.lengthSq() && (1 === Math.abs(r2.z) ? Wn.x += 1e-4 : Wn.z += 1e-4, Wn.normalize(), Qn.crossVectors(r2, Wn)), Qn.normalize(), Hn.crossVectors(Wn, Qn), n2[0] = Qn.x, n2[4] = Hn.x, n2[8] = Wn.x, n2[1] = Qn.y, n2[5] = Hn.y, n2[9] = Wn.y, n2[2] = Qn.z, n2[6] = Hn.z, n2[10] = Wn.z, this;
    }
    multiply(e2) {
      return this.multiplyMatrices(this, e2);
    }
    premultiply(e2) {
      return this.multiplyMatrices(e2, this);
    }
    multiplyMatrices(e2, t2) {
      const r2 = e2.elements, n2 = t2.elements, i2 = this.elements, s2 = r2[0], o2 = r2[4], a2 = r2[8], l2 = r2[12], c2 = r2[1], u2 = r2[5], h2 = r2[9], p2 = r2[13], d2 = r2[2], f2 = r2[6], m2 = r2[10], _2 = r2[14], g2 = r2[3], v2 = r2[7], A2 = r2[11], b2 = r2[15], y2 = n2[0], x2 = n2[4], w2 = n2[8], E2 = n2[12], S2 = n2[1], C2 = n2[5], M2 = n2[9], T2 = n2[13], I2 = n2[2], k2 = n2[6], D2 = n2[10], P2 = n2[14], B2 = n2[3], R2 = n2[7], L2 = n2[11], O2 = n2[15];
      return i2[0] = s2 * y2 + o2 * S2 + a2 * I2 + l2 * B2, i2[4] = s2 * x2 + o2 * C2 + a2 * k2 + l2 * R2, i2[8] = s2 * w2 + o2 * M2 + a2 * D2 + l2 * L2, i2[12] = s2 * E2 + o2 * T2 + a2 * P2 + l2 * O2, i2[1] = c2 * y2 + u2 * S2 + h2 * I2 + p2 * B2, i2[5] = c2 * x2 + u2 * C2 + h2 * k2 + p2 * R2, i2[9] = c2 * w2 + u2 * M2 + h2 * D2 + p2 * L2, i2[13] = c2 * E2 + u2 * T2 + h2 * P2 + p2 * O2, i2[2] = d2 * y2 + f2 * S2 + m2 * I2 + _2 * B2, i2[6] = d2 * x2 + f2 * C2 + m2 * k2 + _2 * R2, i2[10] = d2 * w2 + f2 * M2 + m2 * D2 + _2 * L2, i2[14] = d2 * E2 + f2 * T2 + m2 * P2 + _2 * O2, i2[3] = g2 * y2 + v2 * S2 + A2 * I2 + b2 * B2, i2[7] = g2 * x2 + v2 * C2 + A2 * k2 + b2 * R2, i2[11] = g2 * w2 + v2 * M2 + A2 * D2 + b2 * L2, i2[15] = g2 * E2 + v2 * T2 + A2 * P2 + b2 * O2, this;
    }
    multiplyScalar(e2) {
      const t2 = this.elements;
      return t2[0] *= e2, t2[4] *= e2, t2[8] *= e2, t2[12] *= e2, t2[1] *= e2, t2[5] *= e2, t2[9] *= e2, t2[13] *= e2, t2[2] *= e2, t2[6] *= e2, t2[10] *= e2, t2[14] *= e2, t2[3] *= e2, t2[7] *= e2, t2[11] *= e2, t2[15] *= e2, this;
    }
    determinant() {
      const e2 = this.elements, t2 = e2[0], r2 = e2[4], n2 = e2[8], i2 = e2[12], s2 = e2[1], o2 = e2[5], a2 = e2[9], l2 = e2[13], c2 = e2[2], u2 = e2[6], h2 = e2[10], p2 = e2[14];
      return e2[3] * (+i2 * a2 * u2 - n2 * l2 * u2 - i2 * o2 * h2 + r2 * l2 * h2 + n2 * o2 * p2 - r2 * a2 * p2) + e2[7] * (+t2 * a2 * p2 - t2 * l2 * h2 + i2 * s2 * h2 - n2 * s2 * p2 + n2 * l2 * c2 - i2 * a2 * c2) + e2[11] * (+t2 * l2 * u2 - t2 * o2 * p2 - i2 * s2 * u2 + r2 * s2 * p2 + i2 * o2 * c2 - r2 * l2 * c2) + e2[15] * (-n2 * o2 * c2 - t2 * a2 * u2 + t2 * o2 * h2 + n2 * s2 * u2 - r2 * s2 * h2 + r2 * a2 * c2);
    }
    transpose() {
      const e2 = this.elements;
      let t2;
      return t2 = e2[1], e2[1] = e2[4], e2[4] = t2, t2 = e2[2], e2[2] = e2[8], e2[8] = t2, t2 = e2[6], e2[6] = e2[9], e2[9] = t2, t2 = e2[3], e2[3] = e2[12], e2[12] = t2, t2 = e2[7], e2[7] = e2[13], e2[13] = t2, t2 = e2[11], e2[11] = e2[14], e2[14] = t2, this;
    }
    setPosition(e2, t2, r2) {
      const n2 = this.elements;
      return e2.isVector3 ? (n2[12] = e2.x, n2[13] = e2.y, n2[14] = e2.z) : (n2[12] = e2, n2[13] = t2, n2[14] = r2), this;
    }
    invert() {
      const e2 = this.elements, t2 = e2[0], r2 = e2[1], n2 = e2[2], i2 = e2[3], s2 = e2[4], o2 = e2[5], a2 = e2[6], l2 = e2[7], c2 = e2[8], u2 = e2[9], h2 = e2[10], p2 = e2[11], d2 = e2[12], f2 = e2[13], m2 = e2[14], _2 = e2[15], g2 = u2 * m2 * l2 - f2 * h2 * l2 + f2 * a2 * p2 - o2 * m2 * p2 - u2 * a2 * _2 + o2 * h2 * _2, v2 = d2 * h2 * l2 - c2 * m2 * l2 - d2 * a2 * p2 + s2 * m2 * p2 + c2 * a2 * _2 - s2 * h2 * _2, A2 = c2 * f2 * l2 - d2 * u2 * l2 + d2 * o2 * p2 - s2 * f2 * p2 - c2 * o2 * _2 + s2 * u2 * _2, b2 = d2 * u2 * a2 - c2 * f2 * a2 - d2 * o2 * h2 + s2 * f2 * h2 + c2 * o2 * m2 - s2 * u2 * m2, y2 = t2 * g2 + r2 * v2 + n2 * A2 + i2 * b2;
      if (0 === y2)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const x2 = 1 / y2;
      return e2[0] = g2 * x2, e2[1] = (f2 * h2 * i2 - u2 * m2 * i2 - f2 * n2 * p2 + r2 * m2 * p2 + u2 * n2 * _2 - r2 * h2 * _2) * x2, e2[2] = (o2 * m2 * i2 - f2 * a2 * i2 + f2 * n2 * l2 - r2 * m2 * l2 - o2 * n2 * _2 + r2 * a2 * _2) * x2, e2[3] = (u2 * a2 * i2 - o2 * h2 * i2 - u2 * n2 * l2 + r2 * h2 * l2 + o2 * n2 * p2 - r2 * a2 * p2) * x2, e2[4] = v2 * x2, e2[5] = (c2 * m2 * i2 - d2 * h2 * i2 + d2 * n2 * p2 - t2 * m2 * p2 - c2 * n2 * _2 + t2 * h2 * _2) * x2, e2[6] = (d2 * a2 * i2 - s2 * m2 * i2 - d2 * n2 * l2 + t2 * m2 * l2 + s2 * n2 * _2 - t2 * a2 * _2) * x2, e2[7] = (s2 * h2 * i2 - c2 * a2 * i2 + c2 * n2 * l2 - t2 * h2 * l2 - s2 * n2 * p2 + t2 * a2 * p2) * x2, e2[8] = A2 * x2, e2[9] = (d2 * u2 * i2 - c2 * f2 * i2 - d2 * r2 * p2 + t2 * f2 * p2 + c2 * r2 * _2 - t2 * u2 * _2) * x2, e2[10] = (s2 * f2 * i2 - d2 * o2 * i2 + d2 * r2 * l2 - t2 * f2 * l2 - s2 * r2 * _2 + t2 * o2 * _2) * x2, e2[11] = (c2 * o2 * i2 - s2 * u2 * i2 - c2 * r2 * l2 + t2 * u2 * l2 + s2 * r2 * p2 - t2 * o2 * p2) * x2, e2[12] = b2 * x2, e2[13] = (c2 * f2 * n2 - d2 * u2 * n2 + d2 * r2 * h2 - t2 * f2 * h2 - c2 * r2 * m2 + t2 * u2 * m2) * x2, e2[14] = (d2 * o2 * n2 - s2 * f2 * n2 - d2 * r2 * a2 + t2 * f2 * a2 + s2 * r2 * m2 - t2 * o2 * m2) * x2, e2[15] = (s2 * u2 * n2 - c2 * o2 * n2 + c2 * r2 * a2 - t2 * u2 * a2 - s2 * r2 * h2 + t2 * o2 * h2) * x2, this;
    }
    scale(e2) {
      const t2 = this.elements, r2 = e2.x, n2 = e2.y, i2 = e2.z;
      return t2[0] *= r2, t2[4] *= n2, t2[8] *= i2, t2[1] *= r2, t2[5] *= n2, t2[9] *= i2, t2[2] *= r2, t2[6] *= n2, t2[10] *= i2, t2[3] *= r2, t2[7] *= n2, t2[11] *= i2, this;
    }
    getMaxScaleOnAxis() {
      const e2 = this.elements, t2 = e2[0] * e2[0] + e2[1] * e2[1] + e2[2] * e2[2], r2 = e2[4] * e2[4] + e2[5] * e2[5] + e2[6] * e2[6], n2 = e2[8] * e2[8] + e2[9] * e2[9] + e2[10] * e2[10];
      return Math.sqrt(Math.max(t2, r2, n2));
    }
    makeTranslation(e2, t2, r2) {
      return this.set(1, 0, 0, e2, 0, 1, 0, t2, 0, 0, 1, r2, 0, 0, 0, 1), this;
    }
    makeRotationX(e2) {
      const t2 = Math.cos(e2), r2 = Math.sin(e2);
      return this.set(1, 0, 0, 0, 0, t2, -r2, 0, 0, r2, t2, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(e2) {
      const t2 = Math.cos(e2), r2 = Math.sin(e2);
      return this.set(t2, 0, r2, 0, 0, 1, 0, 0, -r2, 0, t2, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(e2) {
      const t2 = Math.cos(e2), r2 = Math.sin(e2);
      return this.set(t2, -r2, 0, 0, r2, t2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(e2, t2) {
      const r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = 1 - r2, s2 = e2.x, o2 = e2.y, a2 = e2.z, l2 = i2 * s2, c2 = i2 * o2;
      return this.set(l2 * s2 + r2, l2 * o2 - n2 * a2, l2 * a2 + n2 * o2, 0, l2 * o2 + n2 * a2, c2 * o2 + r2, c2 * a2 - n2 * s2, 0, l2 * a2 - n2 * o2, c2 * a2 + n2 * s2, i2 * a2 * a2 + r2, 0, 0, 0, 0, 1), this;
    }
    makeScale(e2, t2, r2) {
      return this.set(e2, 0, 0, 0, 0, t2, 0, 0, 0, 0, r2, 0, 0, 0, 0, 1), this;
    }
    makeShear(e2, t2, r2, n2, i2, s2) {
      return this.set(1, r2, i2, 0, e2, 1, s2, 0, t2, n2, 1, 0, 0, 0, 0, 1), this;
    }
    compose(e2, t2, r2) {
      const n2 = this.elements, i2 = t2._x, s2 = t2._y, o2 = t2._z, a2 = t2._w, l2 = i2 + i2, c2 = s2 + s2, u2 = o2 + o2, h2 = i2 * l2, p2 = i2 * c2, d2 = i2 * u2, f2 = s2 * c2, m2 = s2 * u2, _2 = o2 * u2, g2 = a2 * l2, v2 = a2 * c2, A2 = a2 * u2, b2 = r2.x, y2 = r2.y, x2 = r2.z;
      return n2[0] = (1 - (f2 + _2)) * b2, n2[1] = (p2 + A2) * b2, n2[2] = (d2 - v2) * b2, n2[3] = 0, n2[4] = (p2 - A2) * y2, n2[5] = (1 - (h2 + _2)) * y2, n2[6] = (m2 + g2) * y2, n2[7] = 0, n2[8] = (d2 + v2) * x2, n2[9] = (m2 - g2) * x2, n2[10] = (1 - (h2 + f2)) * x2, n2[11] = 0, n2[12] = e2.x, n2[13] = e2.y, n2[14] = e2.z, n2[15] = 1, this;
    }
    decompose(e2, t2, r2) {
      const n2 = this.elements;
      let i2 = jn.set(n2[0], n2[1], n2[2]).length();
      const s2 = jn.set(n2[4], n2[5], n2[6]).length(), o2 = jn.set(n2[8], n2[9], n2[10]).length();
      this.determinant() < 0 && (i2 = -i2), e2.x = n2[12], e2.y = n2[13], e2.z = n2[14], zn.copy(this);
      const a2 = 1 / i2, l2 = 1 / s2, c2 = 1 / o2;
      return zn.elements[0] *= a2, zn.elements[1] *= a2, zn.elements[2] *= a2, zn.elements[4] *= l2, zn.elements[5] *= l2, zn.elements[6] *= l2, zn.elements[8] *= c2, zn.elements[9] *= c2, zn.elements[10] *= c2, t2.setFromRotationMatrix(zn), r2.x = i2, r2.y = s2, r2.z = o2, this;
    }
    makePerspective(e2, t2, r2, n2, i2, s2) {
      const o2 = this.elements, a2 = 2 * i2 / (t2 - e2), l2 = 2 * i2 / (r2 - n2), c2 = (t2 + e2) / (t2 - e2), u2 = (r2 + n2) / (r2 - n2), h2 = -(s2 + i2) / (s2 - i2), p2 = -2 * s2 * i2 / (s2 - i2);
      return o2[0] = a2, o2[4] = 0, o2[8] = c2, o2[12] = 0, o2[1] = 0, o2[5] = l2, o2[9] = u2, o2[13] = 0, o2[2] = 0, o2[6] = 0, o2[10] = h2, o2[14] = p2, o2[3] = 0, o2[7] = 0, o2[11] = -1, o2[15] = 0, this;
    }
    makeOrthographic(e2, t2, r2, n2, i2, s2) {
      const o2 = this.elements, a2 = 1 / (t2 - e2), l2 = 1 / (r2 - n2), c2 = 1 / (s2 - i2), u2 = (t2 + e2) * a2, h2 = (r2 + n2) * l2, p2 = (s2 + i2) * c2;
      return o2[0] = 2 * a2, o2[4] = 0, o2[8] = 0, o2[12] = -u2, o2[1] = 0, o2[5] = 2 * l2, o2[9] = 0, o2[13] = -h2, o2[2] = 0, o2[6] = 0, o2[10] = -2 * c2, o2[14] = -p2, o2[3] = 0, o2[7] = 0, o2[11] = 0, o2[15] = 1, this;
    }
    equals(e2) {
      const t2 = this.elements, r2 = e2.elements;
      for (let e3 = 0; e3 < 16; e3++)
        if (t2[e3] !== r2[e3])
          return false;
      return true;
    }
    fromArray(e2, t2 = 0) {
      for (let r2 = 0; r2 < 16; r2++)
        this.elements[r2] = e2[r2 + t2];
      return this;
    }
    toArray(e2 = [], t2 = 0) {
      const r2 = this.elements;
      return e2[t2] = r2[0], e2[t2 + 1] = r2[1], e2[t2 + 2] = r2[2], e2[t2 + 3] = r2[3], e2[t2 + 4] = r2[4], e2[t2 + 5] = r2[5], e2[t2 + 6] = r2[6], e2[t2 + 7] = r2[7], e2[t2 + 8] = r2[8], e2[t2 + 9] = r2[9], e2[t2 + 10] = r2[10], e2[t2 + 11] = r2[11], e2[t2 + 12] = r2[12], e2[t2 + 13] = r2[13], e2[t2 + 14] = r2[14], e2[t2 + 15] = r2[15], e2;
    }
  }
  const jn = new ln(), zn = new Nn(), Gn = new ln(0, 0, 0), Vn = new ln(1, 1, 1), Qn = new ln(), Hn = new ln(), Wn = new ln(), qn = new Nn(), Xn = new an();
  class Yn {
    constructor(e2 = 0, t2 = 0, r2 = 0, n2 = Yn.DefaultOrder) {
      this.isEuler = true, this._x = e2, this._y = t2, this._z = r2, this._order = n2;
    }
    get x() {
      return this._x;
    }
    set x(e2) {
      this._x = e2, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e2) {
      this._y = e2, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e2) {
      this._z = e2, this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(e2) {
      this._order = e2, this._onChangeCallback();
    }
    set(e2, t2, r2, n2 = this._order) {
      return this._x = e2, this._y = t2, this._z = r2, this._order = n2, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(e2) {
      return this._x = e2._x, this._y = e2._y, this._z = e2._z, this._order = e2._order, this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e2, t2 = this._order, r2 = true) {
      const n2 = e2.elements, i2 = n2[0], s2 = n2[4], o2 = n2[8], a2 = n2[1], l2 = n2[5], c2 = n2[9], u2 = n2[2], h2 = n2[6], p2 = n2[10];
      switch (t2) {
        case "XYZ":
          this._y = Math.asin(yr(o2, -1, 1)), Math.abs(o2) < 0.9999999 ? (this._x = Math.atan2(-c2, p2), this._z = Math.atan2(-s2, i2)) : (this._x = Math.atan2(h2, l2), this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-yr(c2, -1, 1)), Math.abs(c2) < 0.9999999 ? (this._y = Math.atan2(o2, p2), this._z = Math.atan2(a2, l2)) : (this._y = Math.atan2(-u2, i2), this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(yr(h2, -1, 1)), Math.abs(h2) < 0.9999999 ? (this._y = Math.atan2(-u2, p2), this._z = Math.atan2(-s2, l2)) : (this._y = 0, this._z = Math.atan2(a2, i2));
          break;
        case "ZYX":
          this._y = Math.asin(-yr(u2, -1, 1)), Math.abs(u2) < 0.9999999 ? (this._x = Math.atan2(h2, p2), this._z = Math.atan2(a2, i2)) : (this._x = 0, this._z = Math.atan2(-s2, l2));
          break;
        case "YZX":
          this._z = Math.asin(yr(a2, -1, 1)), Math.abs(a2) < 0.9999999 ? (this._x = Math.atan2(-c2, l2), this._y = Math.atan2(-u2, i2)) : (this._x = 0, this._y = Math.atan2(o2, p2));
          break;
        case "XZY":
          this._z = Math.asin(-yr(s2, -1, 1)), Math.abs(s2) < 0.9999999 ? (this._x = Math.atan2(h2, l2), this._y = Math.atan2(o2, i2)) : (this._x = Math.atan2(-c2, p2), this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t2);
      }
      return this._order = t2, true === r2 && this._onChangeCallback(), this;
    }
    setFromQuaternion(e2, t2, r2) {
      return qn.makeRotationFromQuaternion(e2), this.setFromRotationMatrix(qn, t2, r2);
    }
    setFromVector3(e2, t2 = this._order) {
      return this.set(e2.x, e2.y, e2.z, t2);
    }
    reorder(e2) {
      return Xn.setFromEuler(this), this.setFromQuaternion(Xn, e2);
    }
    equals(e2) {
      return e2._x === this._x && e2._y === this._y && e2._z === this._z && e2._order === this._order;
    }
    fromArray(e2) {
      return this._x = e2[0], this._y = e2[1], this._z = e2[2], void 0 !== e2[3] && (this._order = e2[3]), this._onChangeCallback(), this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this._x, e2[t2 + 1] = this._y, e2[t2 + 2] = this._z, e2[t2 + 3] = this._order, e2;
    }
    _onChange(e2) {
      return this._onChangeCallback = e2, this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order;
    }
    toVector3() {
      console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
    }
  }
  Yn.DefaultOrder = "XYZ", Yn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  class Kn {
    constructor() {
      this.mask = 1;
    }
    set(e2) {
      this.mask = (1 << e2 | 0) >>> 0;
    }
    enable(e2) {
      this.mask |= 1 << e2 | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(e2) {
      this.mask ^= 1 << e2 | 0;
    }
    disable(e2) {
      this.mask &= ~(1 << e2 | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(e2) {
      return 0 != (this.mask & e2.mask);
    }
    isEnabled(e2) {
      return 0 != (this.mask & (1 << e2 | 0));
    }
  }
  let Jn = 0;
  const Zn = new ln(), $n = new an(), ei = new Nn(), ti = new ln(), ri = new ln(), ni = new ln(), ii = new an(), si = new ln(1, 0, 0), oi = new ln(0, 1, 0), ai = new ln(0, 0, 1), li = { type: "added" }, ci = { type: "removed" };
  class ui extends mr {
    constructor() {
      super(), this.isObject3D = true, Object.defineProperty(this, "id", { value: Jn++ }), this.uuid = br(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ui.DefaultUp.clone();
      const e2 = new ln(), t2 = new Yn(), r2 = new an(), n2 = new ln(1, 1, 1);
      t2._onChange(function() {
        r2.setFromEuler(t2, false);
      }), r2._onChange(function() {
        t2.setFromQuaternion(r2, void 0, false);
      }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: e2 }, rotation: { configurable: true, enumerable: true, value: t2 }, quaternion: { configurable: true, enumerable: true, value: r2 }, scale: { configurable: true, enumerable: true, value: n2 }, modelViewMatrix: { value: new Nn() }, normalMatrix: { value: new Dr() } }), this.matrix = new Nn(), this.matrixWorld = new Nn(), this.matrixAutoUpdate = ui.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.matrixWorldAutoUpdate = ui.DefaultMatrixWorldAutoUpdate, this.layers = new Kn(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
    }
    onBeforeRender(e2, t2, r2, n2, i2, s2) {
      this.dispatchEvent({ type: "beforeRender", renderer: e2, scene: t2, camera: r2, geometry: n2, material: i2, group: s2 });
    }
    onAfterRender() {
    }
    applyMatrix4(e2) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e2), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(e2) {
      return this.quaternion.premultiply(e2), this;
    }
    setRotationFromAxisAngle(e2, t2) {
      this.quaternion.setFromAxisAngle(e2, t2);
    }
    setRotationFromEuler(e2) {
      this.quaternion.setFromEuler(e2, true);
    }
    setRotationFromMatrix(e2) {
      this.quaternion.setFromRotationMatrix(e2);
    }
    setRotationFromQuaternion(e2) {
      this.quaternion.copy(e2);
    }
    rotateOnAxis(e2, t2) {
      return $n.setFromAxisAngle(e2, t2), this.quaternion.multiply($n), this;
    }
    rotateOnWorldAxis(e2, t2) {
      return $n.setFromAxisAngle(e2, t2), this.quaternion.premultiply($n), this;
    }
    rotateX(e2) {
      return this.rotateOnAxis(si, e2);
    }
    rotateY(e2) {
      return this.rotateOnAxis(oi, e2);
    }
    rotateZ(e2) {
      return this.rotateOnAxis(ai, e2);
    }
    translateOnAxis(e2, t2) {
      return Zn.copy(e2).applyQuaternion(this.quaternion), this.position.add(Zn.multiplyScalar(t2)), this;
    }
    translateX(e2) {
      return this.translateOnAxis(si, e2);
    }
    translateY(e2) {
      return this.translateOnAxis(oi, e2);
    }
    translateZ(e2) {
      return this.translateOnAxis(ai, e2);
    }
    localToWorld(e2) {
      return e2.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(e2) {
      return e2.applyMatrix4(ei.copy(this.matrixWorld).invert());
    }
    lookAt(e2, t2, r2) {
      e2.isVector3 ? ti.copy(e2) : ti.set(e2, t2, r2);
      const n2 = this.parent;
      this.updateWorldMatrix(true, false), ri.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ei.lookAt(ri, ti, this.up) : ei.lookAt(ti, ri, this.up), this.quaternion.setFromRotationMatrix(ei), n2 && (ei.extractRotation(n2.matrixWorld), $n.setFromRotationMatrix(ei), this.quaternion.premultiply($n.invert()));
    }
    add(e2) {
      if (arguments.length > 1) {
        for (let e3 = 0; e3 < arguments.length; e3++)
          this.add(arguments[e3]);
        return this;
      }
      return e2 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e2), this) : (e2 && e2.isObject3D ? (null !== e2.parent && e2.parent.remove(e2), e2.parent = this, this.children.push(e2), e2.dispatchEvent(li)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e2), this);
    }
    remove(e2) {
      if (arguments.length > 1) {
        for (let e3 = 0; e3 < arguments.length; e3++)
          this.remove(arguments[e3]);
        return this;
      }
      const t2 = this.children.indexOf(e2);
      return -1 !== t2 && (e2.parent = null, this.children.splice(t2, 1), e2.dispatchEvent(ci)), this;
    }
    removeFromParent() {
      const e2 = this.parent;
      return null !== e2 && e2.remove(this), this;
    }
    clear() {
      for (let e2 = 0; e2 < this.children.length; e2++) {
        const t2 = this.children[e2];
        t2.parent = null, t2.dispatchEvent(ci);
      }
      return this.children.length = 0, this;
    }
    attach(e2) {
      return this.updateWorldMatrix(true, false), ei.copy(this.matrixWorld).invert(), null !== e2.parent && (e2.parent.updateWorldMatrix(true, false), ei.multiply(e2.parent.matrixWorld)), e2.applyMatrix4(ei), this.add(e2), e2.updateWorldMatrix(false, true), this;
    }
    getObjectById(e2) {
      return this.getObjectByProperty("id", e2);
    }
    getObjectByName(e2) {
      return this.getObjectByProperty("name", e2);
    }
    getObjectByProperty(e2, t2) {
      if (this[e2] === t2)
        return this;
      for (let r2 = 0, n2 = this.children.length; r2 < n2; r2++) {
        const n3 = this.children[r2].getObjectByProperty(e2, t2);
        if (void 0 !== n3)
          return n3;
      }
    }
    getWorldPosition(e2) {
      return this.updateWorldMatrix(true, false), e2.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(e2) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(ri, e2, ni), e2;
    }
    getWorldScale(e2) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(ri, ii, e2), e2;
    }
    getWorldDirection(e2) {
      this.updateWorldMatrix(true, false);
      const t2 = this.matrixWorld.elements;
      return e2.set(t2[8], t2[9], t2[10]).normalize();
    }
    raycast() {
    }
    traverse(e2) {
      e2(this);
      const t2 = this.children;
      for (let r2 = 0, n2 = t2.length; r2 < n2; r2++)
        t2[r2].traverse(e2);
    }
    traverseVisible(e2) {
      if (false === this.visible)
        return;
      e2(this);
      const t2 = this.children;
      for (let r2 = 0, n2 = t2.length; r2 < n2; r2++)
        t2[r2].traverseVisible(e2);
    }
    traverseAncestors(e2) {
      const t2 = this.parent;
      null !== t2 && (e2(t2), t2.traverseAncestors(e2));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(e2) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e2) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, e2 = true);
      const t2 = this.children;
      for (let r2 = 0, n2 = t2.length; r2 < n2; r2++) {
        const n3 = t2[r2];
        true !== n3.matrixWorldAutoUpdate && true !== e2 || n3.updateMatrixWorld(e2);
      }
    }
    updateWorldMatrix(e2, t2) {
      const r2 = this.parent;
      if (true === e2 && null !== r2 && true === r2.matrixWorldAutoUpdate && r2.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), true === t2) {
        const e3 = this.children;
        for (let t3 = 0, r3 = e3.length; t3 < r3; t3++) {
          const r4 = e3[t3];
          true === r4.matrixWorldAutoUpdate && r4.updateWorldMatrix(false, true);
        }
      }
    }
    toJSON(e2) {
      const t2 = void 0 === e2 || "string" == typeof e2, r2 = {};
      t2 && (e2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, r2.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
      const n2 = {};
      function i2(t3, r3) {
        return void 0 === t3[r3.uuid] && (t3[r3.uuid] = r3.toJSON(e2)), r3.uuid;
      }
      if (n2.uuid = this.uuid, n2.type = this.type, "" !== this.name && (n2.name = this.name), true === this.castShadow && (n2.castShadow = true), true === this.receiveShadow && (n2.receiveShadow = true), false === this.visible && (n2.visible = false), false === this.frustumCulled && (n2.frustumCulled = false), 0 !== this.renderOrder && (n2.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n2.userData = this.userData), n2.layers = this.layers.mask, n2.matrix = this.matrix.toArray(), false === this.matrixAutoUpdate && (n2.matrixAutoUpdate = false), this.isInstancedMesh && (n2.type = "InstancedMesh", n2.count = this.count, n2.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n2.instanceColor = this.instanceColor.toJSON())), this.isScene)
        this.background && (this.background.isColor ? n2.background = this.background.toJSON() : this.background.isTexture && (n2.background = this.background.toJSON(e2).uuid)), this.environment && this.environment.isTexture && true !== this.environment.isRenderTargetTexture && (n2.environment = this.environment.toJSON(e2).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        n2.geometry = i2(e2.geometries, this.geometry);
        const t3 = this.geometry.parameters;
        if (void 0 !== t3 && void 0 !== t3.shapes) {
          const r3 = t3.shapes;
          if (Array.isArray(r3))
            for (let t4 = 0, n3 = r3.length; t4 < n3; t4++) {
              const n4 = r3[t4];
              i2(e2.shapes, n4);
            }
          else
            i2(e2.shapes, r3);
        }
      }
      if (this.isSkinnedMesh && (n2.bindMode = this.bindMode, n2.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i2(e2.skeletons, this.skeleton), n2.skeleton = this.skeleton.uuid)), void 0 !== this.material)
        if (Array.isArray(this.material)) {
          const t3 = [];
          for (let r3 = 0, n3 = this.material.length; r3 < n3; r3++)
            t3.push(i2(e2.materials, this.material[r3]));
          n2.material = t3;
        } else
          n2.material = i2(e2.materials, this.material);
      if (this.children.length > 0) {
        n2.children = [];
        for (let t3 = 0; t3 < this.children.length; t3++)
          n2.children.push(this.children[t3].toJSON(e2).object);
      }
      if (this.animations.length > 0) {
        n2.animations = [];
        for (let t3 = 0; t3 < this.animations.length; t3++) {
          const r3 = this.animations[t3];
          n2.animations.push(i2(e2.animations, r3));
        }
      }
      if (t2) {
        const t3 = s2(e2.geometries), n3 = s2(e2.materials), i3 = s2(e2.textures), o2 = s2(e2.images), a2 = s2(e2.shapes), l2 = s2(e2.skeletons), c2 = s2(e2.animations), u2 = s2(e2.nodes);
        t3.length > 0 && (r2.geometries = t3), n3.length > 0 && (r2.materials = n3), i3.length > 0 && (r2.textures = i3), o2.length > 0 && (r2.images = o2), a2.length > 0 && (r2.shapes = a2), l2.length > 0 && (r2.skeletons = l2), c2.length > 0 && (r2.animations = c2), u2.length > 0 && (r2.nodes = u2);
      }
      return r2.object = n2, r2;
      function s2(e3) {
        const t3 = [];
        for (const r3 in e3) {
          const n3 = e3[r3];
          delete n3.metadata, t3.push(n3);
        }
        return t3;
      }
    }
    clone(e2) {
      return new this.constructor().copy(this, e2);
    }
    copy(e2, t2 = true) {
      this.name = e2.name, this.up.copy(e2.up), this.position.copy(e2.position), this.rotation.order = e2.rotation.order, this.quaternion.copy(e2.quaternion), this.scale.copy(e2.scale), this.matrix.copy(e2.matrix), this.matrixWorld.copy(e2.matrixWorld), this.matrixAutoUpdate = e2.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e2.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e2.matrixWorldAutoUpdate, this.layers.mask = e2.layers.mask, this.visible = e2.visible, this.castShadow = e2.castShadow, this.receiveShadow = e2.receiveShadow, this.frustumCulled = e2.frustumCulled, this.renderOrder = e2.renderOrder, this.userData = {};
      for (const [t3, r2] of Object.entries(e2.userData))
        this.userData[t3] = !r2 || r2 && (r2.isTexture || r2.isObject3D) ? r2 : JSON.parse(JSON.stringify(r2));
      if (true === t2)
        for (let t3 = 0; t3 < e2.children.length; t3++) {
          const r2 = e2.children[t3];
          this.add(r2.clone());
        }
      return this;
    }
  }
  ui.DefaultUp = new ln(0, 1, 0), ui.DefaultMatrixAutoUpdate = true, ui.DefaultMatrixWorldAutoUpdate = true;
  const hi = new ln(), pi = new ln(), di = new ln(), fi = new ln(), mi = new ln(), _i = new ln(), gi = new ln(), vi = new ln(), Ai = new ln(), bi = new ln();
  class yi {
    constructor(e2 = new ln(), t2 = new ln(), r2 = new ln()) {
      this.a = e2, this.b = t2, this.c = r2;
    }
    static getNormal(e2, t2, r2, n2) {
      n2.subVectors(r2, t2), hi.subVectors(e2, t2), n2.cross(hi);
      const i2 = n2.lengthSq();
      return i2 > 0 ? n2.multiplyScalar(1 / Math.sqrt(i2)) : n2.set(0, 0, 0);
    }
    static getBarycoord(e2, t2, r2, n2, i2) {
      hi.subVectors(n2, t2), pi.subVectors(r2, t2), di.subVectors(e2, t2);
      const s2 = hi.dot(hi), o2 = hi.dot(pi), a2 = hi.dot(di), l2 = pi.dot(pi), c2 = pi.dot(di), u2 = s2 * l2 - o2 * o2;
      if (0 === u2)
        return i2.set(-2, -1, -1);
      const h2 = 1 / u2, p2 = (l2 * a2 - o2 * c2) * h2, d2 = (s2 * c2 - o2 * a2) * h2;
      return i2.set(1 - p2 - d2, d2, p2);
    }
    static containsPoint(e2, t2, r2, n2) {
      return this.getBarycoord(e2, t2, r2, n2, fi), fi.x >= 0 && fi.y >= 0 && fi.x + fi.y <= 1;
    }
    static getUV(e2, t2, r2, n2, i2, s2, o2, a2) {
      return this.getBarycoord(e2, t2, r2, n2, fi), a2.set(0, 0), a2.addScaledVector(i2, fi.x), a2.addScaledVector(s2, fi.y), a2.addScaledVector(o2, fi.z), a2;
    }
    static isFrontFacing(e2, t2, r2, n2) {
      return hi.subVectors(r2, t2), pi.subVectors(e2, t2), hi.cross(pi).dot(n2) < 0;
    }
    set(e2, t2, r2) {
      return this.a.copy(e2), this.b.copy(t2), this.c.copy(r2), this;
    }
    setFromPointsAndIndices(e2, t2, r2, n2) {
      return this.a.copy(e2[t2]), this.b.copy(e2[r2]), this.c.copy(e2[n2]), this;
    }
    setFromAttributeAndIndices(e2, t2, r2, n2) {
      return this.a.fromBufferAttribute(e2, t2), this.b.fromBufferAttribute(e2, r2), this.c.fromBufferAttribute(e2, n2), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.a.copy(e2.a), this.b.copy(e2.b), this.c.copy(e2.c), this;
    }
    getArea() {
      return hi.subVectors(this.c, this.b), pi.subVectors(this.a, this.b), 0.5 * hi.cross(pi).length();
    }
    getMidpoint(e2) {
      return e2.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(e2) {
      return yi.getNormal(this.a, this.b, this.c, e2);
    }
    getPlane(e2) {
      return e2.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(e2, t2) {
      return yi.getBarycoord(e2, this.a, this.b, this.c, t2);
    }
    getUV(e2, t2, r2, n2, i2) {
      return yi.getUV(e2, this.a, this.b, this.c, t2, r2, n2, i2);
    }
    containsPoint(e2) {
      return yi.containsPoint(e2, this.a, this.b, this.c);
    }
    isFrontFacing(e2) {
      return yi.isFrontFacing(this.a, this.b, this.c, e2);
    }
    intersectsBox(e2) {
      return e2.intersectsTriangle(this);
    }
    closestPointToPoint(e2, t2) {
      const r2 = this.a, n2 = this.b, i2 = this.c;
      let s2, o2;
      mi.subVectors(n2, r2), _i.subVectors(i2, r2), vi.subVectors(e2, r2);
      const a2 = mi.dot(vi), l2 = _i.dot(vi);
      if (a2 <= 0 && l2 <= 0)
        return t2.copy(r2);
      Ai.subVectors(e2, n2);
      const c2 = mi.dot(Ai), u2 = _i.dot(Ai);
      if (c2 >= 0 && u2 <= c2)
        return t2.copy(n2);
      const h2 = a2 * u2 - c2 * l2;
      if (h2 <= 0 && a2 >= 0 && c2 <= 0)
        return s2 = a2 / (a2 - c2), t2.copy(r2).addScaledVector(mi, s2);
      bi.subVectors(e2, i2);
      const p2 = mi.dot(bi), d2 = _i.dot(bi);
      if (d2 >= 0 && p2 <= d2)
        return t2.copy(i2);
      const f2 = p2 * l2 - a2 * d2;
      if (f2 <= 0 && l2 >= 0 && d2 <= 0)
        return o2 = l2 / (l2 - d2), t2.copy(r2).addScaledVector(_i, o2);
      const m2 = c2 * d2 - p2 * u2;
      if (m2 <= 0 && u2 - c2 >= 0 && p2 - d2 >= 0)
        return gi.subVectors(i2, n2), o2 = (u2 - c2) / (u2 - c2 + (p2 - d2)), t2.copy(n2).addScaledVector(gi, o2);
      const _2 = 1 / (m2 + f2 + h2);
      return s2 = f2 * _2, o2 = h2 * _2, t2.copy(r2).addScaledVector(mi, s2).addScaledVector(_i, o2);
    }
    equals(e2) {
      return e2.a.equals(this.a) && e2.b.equals(this.b) && e2.c.equals(this.c);
    }
  }
  let xi = 0;
  class wi extends mr {
    constructor() {
      super(), this.isMaterial = true, Object.defineProperty(this, "id", { value: xi++ }), this.uuid = br(), this.name = "", this.type = "Material", this.blending = v, this.side = f, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = P, this.blendDst = B, this.blendEquation = w, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = G, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = rr, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Gt, this.stencilZFail = Gt, this.stencilZPass = Gt, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(e2) {
      this._alphaTest > 0 != e2 > 0 && this.version++, this._alphaTest = e2;
    }
    onBuild() {
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(e2) {
      if (void 0 !== e2)
        for (const t2 in e2) {
          const r2 = e2[t2];
          if (void 0 === r2) {
            console.warn("THREE.Material: '" + t2 + "' parameter is undefined.");
            continue;
          }
          const n2 = this[t2];
          void 0 !== n2 && (n2 && n2.isColor ? n2.set(r2) : n2 && n2.isVector3 && r2 && r2.isVector3 ? n2.copy(r2) : this[t2] = r2);
        }
    }
    toJSON(e2) {
      const t2 = void 0 === e2 || "string" == typeof e2;
      t2 && (e2 = { textures: {}, images: {} });
      const r2 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
      function n2(e3) {
        const t3 = [];
        for (const r3 in e3) {
          const n3 = e3[r3];
          delete n3.metadata, t3.push(n3);
        }
        return t3;
      }
      if (r2.uuid = this.uuid, r2.type = this.type, "" !== this.name && (r2.name = this.name), this.color && this.color.isColor && (r2.color = this.color.getHex()), void 0 !== this.roughness && (r2.roughness = this.roughness), void 0 !== this.metalness && (r2.metalness = this.metalness), void 0 !== this.sheen && (r2.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r2.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (r2.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r2.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (r2.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r2.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (r2.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r2.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (r2.shininess = this.shininess), void 0 !== this.clearcoat && (r2.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (r2.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r2.clearcoatMap = this.clearcoatMap.toJSON(e2).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e2).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e2).uuid, r2.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (r2.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (r2.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (r2.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (r2.iridescenceMap = this.iridescenceMap.toJSON(e2).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r2.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e2).uuid), this.map && this.map.isTexture && (r2.map = this.map.toJSON(e2).uuid), this.matcap && this.matcap.isTexture && (r2.matcap = this.matcap.toJSON(e2).uuid), this.alphaMap && this.alphaMap.isTexture && (r2.alphaMap = this.alphaMap.toJSON(e2).uuid), this.lightMap && this.lightMap.isTexture && (r2.lightMap = this.lightMap.toJSON(e2).uuid, r2.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r2.aoMap = this.aoMap.toJSON(e2).uuid, r2.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r2.bumpMap = this.bumpMap.toJSON(e2).uuid, r2.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r2.normalMap = this.normalMap.toJSON(e2).uuid, r2.normalMapType = this.normalMapType, r2.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r2.displacementMap = this.displacementMap.toJSON(e2).uuid, r2.displacementScale = this.displacementScale, r2.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r2.roughnessMap = this.roughnessMap.toJSON(e2).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r2.metalnessMap = this.metalnessMap.toJSON(e2).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r2.emissiveMap = this.emissiveMap.toJSON(e2).uuid), this.specularMap && this.specularMap.isTexture && (r2.specularMap = this.specularMap.toJSON(e2).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r2.specularIntensityMap = this.specularIntensityMap.toJSON(e2).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r2.specularColorMap = this.specularColorMap.toJSON(e2).uuid), this.envMap && this.envMap.isTexture && (r2.envMap = this.envMap.toJSON(e2).uuid, void 0 !== this.combine && (r2.combine = this.combine)), void 0 !== this.envMapIntensity && (r2.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (r2.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (r2.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r2.gradientMap = this.gradientMap.toJSON(e2).uuid), void 0 !== this.transmission && (r2.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r2.transmissionMap = this.transmissionMap.toJSON(e2).uuid), void 0 !== this.thickness && (r2.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r2.thicknessMap = this.thicknessMap.toJSON(e2).uuid), void 0 !== this.attenuationDistance && (r2.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (r2.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (r2.size = this.size), null !== this.shadowSide && (r2.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (r2.sizeAttenuation = this.sizeAttenuation), this.blending !== v && (r2.blending = this.blending), this.side !== f && (r2.side = this.side), this.vertexColors && (r2.vertexColors = true), this.opacity < 1 && (r2.opacity = this.opacity), true === this.transparent && (r2.transparent = this.transparent), r2.depthFunc = this.depthFunc, r2.depthTest = this.depthTest, r2.depthWrite = this.depthWrite, r2.colorWrite = this.colorWrite, r2.stencilWrite = this.stencilWrite, r2.stencilWriteMask = this.stencilWriteMask, r2.stencilFunc = this.stencilFunc, r2.stencilRef = this.stencilRef, r2.stencilFuncMask = this.stencilFuncMask, r2.stencilFail = this.stencilFail, r2.stencilZFail = this.stencilZFail, r2.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (r2.rotation = this.rotation), true === this.polygonOffset && (r2.polygonOffset = true), 0 !== this.polygonOffsetFactor && (r2.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (r2.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (r2.linewidth = this.linewidth), void 0 !== this.dashSize && (r2.dashSize = this.dashSize), void 0 !== this.gapSize && (r2.gapSize = this.gapSize), void 0 !== this.scale && (r2.scale = this.scale), true === this.dithering && (r2.dithering = true), this.alphaTest > 0 && (r2.alphaTest = this.alphaTest), true === this.alphaToCoverage && (r2.alphaToCoverage = this.alphaToCoverage), true === this.premultipliedAlpha && (r2.premultipliedAlpha = this.premultipliedAlpha), true === this.wireframe && (r2.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r2.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (r2.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (r2.wireframeLinejoin = this.wireframeLinejoin), true === this.flatShading && (r2.flatShading = this.flatShading), false === this.visible && (r2.visible = false), false === this.toneMapped && (r2.toneMapped = false), false === this.fog && (r2.fog = false), "{}" !== JSON.stringify(this.userData) && (r2.userData = this.userData), t2) {
        const t3 = n2(e2.textures), i2 = n2(e2.images);
        t3.length > 0 && (r2.textures = t3), i2.length > 0 && (r2.images = i2);
      }
      return r2;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      this.name = e2.name, this.blending = e2.blending, this.side = e2.side, this.vertexColors = e2.vertexColors, this.opacity = e2.opacity, this.transparent = e2.transparent, this.blendSrc = e2.blendSrc, this.blendDst = e2.blendDst, this.blendEquation = e2.blendEquation, this.blendSrcAlpha = e2.blendSrcAlpha, this.blendDstAlpha = e2.blendDstAlpha, this.blendEquationAlpha = e2.blendEquationAlpha, this.depthFunc = e2.depthFunc, this.depthTest = e2.depthTest, this.depthWrite = e2.depthWrite, this.stencilWriteMask = e2.stencilWriteMask, this.stencilFunc = e2.stencilFunc, this.stencilRef = e2.stencilRef, this.stencilFuncMask = e2.stencilFuncMask, this.stencilFail = e2.stencilFail, this.stencilZFail = e2.stencilZFail, this.stencilZPass = e2.stencilZPass, this.stencilWrite = e2.stencilWrite;
      const t2 = e2.clippingPlanes;
      let r2 = null;
      if (null !== t2) {
        const e3 = t2.length;
        r2 = new Array(e3);
        for (let n2 = 0; n2 !== e3; ++n2)
          r2[n2] = t2[n2].clone();
      }
      this.clippingPlanes = r2, this.clipIntersection = e2.clipIntersection, this.clipShadows = e2.clipShadows, this.shadowSide = e2.shadowSide, this.colorWrite = e2.colorWrite, this.precision = e2.precision, this.polygonOffset = e2.polygonOffset, this.polygonOffsetFactor = e2.polygonOffsetFactor, this.polygonOffsetUnits = e2.polygonOffsetUnits, this.dithering = e2.dithering, this.alphaTest = e2.alphaTest, this.alphaToCoverage = e2.alphaToCoverage, this.premultipliedAlpha = e2.premultipliedAlpha, this.visible = e2.visible, this.toneMapped = e2.toneMapped, this.userData = {};
      for (const [t3, r3] of Object.entries(e2.userData))
        this.userData[t3] = !r3 || r3 && (r3.isTexture || r3.isObject3D) ? r3 : JSON.parse(JSON.stringify(r3));
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(e2) {
      true === e2 && this.version++;
    }
  }
  class Ei extends wi {
    constructor(e2) {
      super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new Wr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = q, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.specularMap = e2.specularMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.combine = e2.combine, this.reflectivity = e2.reflectivity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.fog = e2.fog, this;
    }
  }
  const Si = new ln(), Ci = new kr();
  class Mi {
    constructor(e2, t2, r2) {
      if (Array.isArray(e2))
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.isBufferAttribute = true, this.name = "", this.array = e2, this.itemSize = t2, this.count = void 0 !== e2 ? e2.length / t2 : 0, this.normalized = true === r2, this.usage = nr, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(e2) {
      true === e2 && this.version++;
    }
    setUsage(e2) {
      return this.usage = e2, this;
    }
    copy(e2) {
      return this.name = e2.name, this.array = new e2.array.constructor(e2.array), this.itemSize = e2.itemSize, this.count = e2.count, this.normalized = e2.normalized, this.usage = e2.usage, this;
    }
    copyAt(e2, t2, r2) {
      e2 *= this.itemSize, r2 *= t2.itemSize;
      for (let n2 = 0, i2 = this.itemSize; n2 < i2; n2++)
        this.array[e2 + n2] = t2.array[r2 + n2];
      return this;
    }
    copyArray(e2) {
      return this.array.set(e2), this;
    }
    applyMatrix3(e2) {
      if (2 === this.itemSize)
        for (let t2 = 0, r2 = this.count; t2 < r2; t2++)
          Ci.fromBufferAttribute(this, t2), Ci.applyMatrix3(e2), this.setXY(t2, Ci.x, Ci.y);
      else if (3 === this.itemSize)
        for (let t2 = 0, r2 = this.count; t2 < r2; t2++)
          Si.fromBufferAttribute(this, t2), Si.applyMatrix3(e2), this.setXYZ(t2, Si.x, Si.y, Si.z);
      return this;
    }
    applyMatrix4(e2) {
      for (let t2 = 0, r2 = this.count; t2 < r2; t2++)
        Si.fromBufferAttribute(this, t2), Si.applyMatrix4(e2), this.setXYZ(t2, Si.x, Si.y, Si.z);
      return this;
    }
    applyNormalMatrix(e2) {
      for (let t2 = 0, r2 = this.count; t2 < r2; t2++)
        Si.fromBufferAttribute(this, t2), Si.applyNormalMatrix(e2), this.setXYZ(t2, Si.x, Si.y, Si.z);
      return this;
    }
    transformDirection(e2) {
      for (let t2 = 0, r2 = this.count; t2 < r2; t2++)
        Si.fromBufferAttribute(this, t2), Si.transformDirection(e2), this.setXYZ(t2, Si.x, Si.y, Si.z);
      return this;
    }
    set(e2, t2 = 0) {
      return this.array.set(e2, t2), this;
    }
    getX(e2) {
      let t2 = this.array[e2 * this.itemSize];
      return this.normalized && (t2 = Mr(t2, this.array)), t2;
    }
    setX(e2, t2) {
      return this.normalized && (t2 = Tr(t2, this.array)), this.array[e2 * this.itemSize] = t2, this;
    }
    getY(e2) {
      let t2 = this.array[e2 * this.itemSize + 1];
      return this.normalized && (t2 = Mr(t2, this.array)), t2;
    }
    setY(e2, t2) {
      return this.normalized && (t2 = Tr(t2, this.array)), this.array[e2 * this.itemSize + 1] = t2, this;
    }
    getZ(e2) {
      let t2 = this.array[e2 * this.itemSize + 2];
      return this.normalized && (t2 = Mr(t2, this.array)), t2;
    }
    setZ(e2, t2) {
      return this.normalized && (t2 = Tr(t2, this.array)), this.array[e2 * this.itemSize + 2] = t2, this;
    }
    getW(e2) {
      let t2 = this.array[e2 * this.itemSize + 3];
      return this.normalized && (t2 = Mr(t2, this.array)), t2;
    }
    setW(e2, t2) {
      return this.normalized && (t2 = Tr(t2, this.array)), this.array[e2 * this.itemSize + 3] = t2, this;
    }
    setXY(e2, t2, r2) {
      return e2 *= this.itemSize, this.normalized && (t2 = Tr(t2, this.array), r2 = Tr(r2, this.array)), this.array[e2 + 0] = t2, this.array[e2 + 1] = r2, this;
    }
    setXYZ(e2, t2, r2, n2) {
      return e2 *= this.itemSize, this.normalized && (t2 = Tr(t2, this.array), r2 = Tr(r2, this.array), n2 = Tr(n2, this.array)), this.array[e2 + 0] = t2, this.array[e2 + 1] = r2, this.array[e2 + 2] = n2, this;
    }
    setXYZW(e2, t2, r2, n2, i2) {
      return e2 *= this.itemSize, this.normalized && (t2 = Tr(t2, this.array), r2 = Tr(r2, this.array), n2 = Tr(n2, this.array), i2 = Tr(i2, this.array)), this.array[e2 + 0] = t2, this.array[e2 + 1] = r2, this.array[e2 + 2] = n2, this.array[e2 + 3] = i2, this;
    }
    onUpload(e2) {
      return this.onUploadCallback = e2, this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const e2 = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
      return "" !== this.name && (e2.name = this.name), this.usage !== nr && (e2.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e2.updateRange = this.updateRange), e2;
    }
    copyColorsArray() {
      console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
    }
    copyVector2sArray() {
      console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
    }
    copyVector3sArray() {
      console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
    }
    copyVector4sArray() {
      console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
    }
  }
  class Ti extends Mi {
    constructor(e2, t2, r2) {
      super(new Int8Array(e2), t2, r2);
    }
  }
  class Ii extends Mi {
    constructor(e2, t2, r2) {
      super(new Uint8Array(e2), t2, r2);
    }
  }
  class ki extends Mi {
    constructor(e2, t2, r2) {
      super(new Uint8ClampedArray(e2), t2, r2);
    }
  }
  class Di extends Mi {
    constructor(e2, t2, r2) {
      super(new Int16Array(e2), t2, r2);
    }
  }
  class Pi extends Mi {
    constructor(e2, t2, r2) {
      super(new Uint16Array(e2), t2, r2);
    }
  }
  class Bi extends Mi {
    constructor(e2, t2, r2) {
      super(new Int32Array(e2), t2, r2);
    }
  }
  class Ri extends Mi {
    constructor(e2, t2, r2) {
      super(new Uint32Array(e2), t2, r2);
    }
  }
  class Li extends Mi {
    constructor(e2, t2, r2) {
      super(new Uint16Array(e2), t2, r2), this.isFloat16BufferAttribute = true;
    }
  }
  class Oi extends Mi {
    constructor(e2, t2, r2) {
      super(new Float32Array(e2), t2, r2);
    }
  }
  class Fi extends Mi {
    constructor(e2, t2, r2) {
      super(new Float64Array(e2), t2, r2);
    }
  }
  let Ui = 0;
  const Ni = new Nn(), ji = new ui(), zi = new ln(), Gi = new hn(), Vi = new hn(), Qi = new ln();
  class Hi extends mr {
    constructor() {
      super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", { value: Ui++ }), this.uuid = br(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(e2) {
      return Array.isArray(e2) ? this.index = new (Pr(e2) ? Ri : Pi)(e2, 1) : this.index = e2, this;
    }
    getAttribute(e2) {
      return this.attributes[e2];
    }
    setAttribute(e2, t2) {
      return this.attributes[e2] = t2, this;
    }
    deleteAttribute(e2) {
      return delete this.attributes[e2], this;
    }
    hasAttribute(e2) {
      return void 0 !== this.attributes[e2];
    }
    addGroup(e2, t2, r2 = 0) {
      this.groups.push({ start: e2, count: t2, materialIndex: r2 });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(e2, t2) {
      this.drawRange.start = e2, this.drawRange.count = t2;
    }
    applyMatrix4(e2) {
      const t2 = this.attributes.position;
      void 0 !== t2 && (t2.applyMatrix4(e2), t2.needsUpdate = true);
      const r2 = this.attributes.normal;
      if (void 0 !== r2) {
        const t3 = new Dr().getNormalMatrix(e2);
        r2.applyNormalMatrix(t3), r2.needsUpdate = true;
      }
      const n2 = this.attributes.tangent;
      return void 0 !== n2 && (n2.transformDirection(e2), n2.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
    }
    applyQuaternion(e2) {
      return Ni.makeRotationFromQuaternion(e2), this.applyMatrix4(Ni), this;
    }
    rotateX(e2) {
      return Ni.makeRotationX(e2), this.applyMatrix4(Ni), this;
    }
    rotateY(e2) {
      return Ni.makeRotationY(e2), this.applyMatrix4(Ni), this;
    }
    rotateZ(e2) {
      return Ni.makeRotationZ(e2), this.applyMatrix4(Ni), this;
    }
    translate(e2, t2, r2) {
      return Ni.makeTranslation(e2, t2, r2), this.applyMatrix4(Ni), this;
    }
    scale(e2, t2, r2) {
      return Ni.makeScale(e2, t2, r2), this.applyMatrix4(Ni), this;
    }
    lookAt(e2) {
      return ji.lookAt(e2), ji.updateMatrix(), this.applyMatrix4(ji.matrix), this;
    }
    center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(zi).negate(), this.translate(zi.x, zi.y, zi.z), this;
    }
    setFromPoints(e2) {
      const t2 = [];
      for (let r2 = 0, n2 = e2.length; r2 < n2; r2++) {
        const n3 = e2[r2];
        t2.push(n3.x, n3.y, n3.z || 0);
      }
      return this.setAttribute("position", new Oi(t2, 3)), this;
    }
    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new hn());
      const e2 = this.attributes.position, t2 = this.morphAttributes.position;
      if (e2 && e2.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new ln(-1 / 0, -1 / 0, -1 / 0), new ln(1 / 0, 1 / 0, 1 / 0));
      if (void 0 !== e2) {
        if (this.boundingBox.setFromBufferAttribute(e2), t2)
          for (let e3 = 0, r2 = t2.length; e3 < r2; e3++) {
            const r3 = t2[e3];
            Gi.setFromBufferAttribute(r3), this.morphTargetsRelative ? (Qi.addVectors(this.boundingBox.min, Gi.min), this.boundingBox.expandByPoint(Qi), Qi.addVectors(this.boundingBox.max, Gi.max), this.boundingBox.expandByPoint(Qi)) : (this.boundingBox.expandByPoint(Gi.min), this.boundingBox.expandByPoint(Gi.max));
          }
      } else
        this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new kn());
      const e2 = this.attributes.position, t2 = this.morphAttributes.position;
      if (e2 && e2.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new ln(), 1 / 0);
      if (e2) {
        const r2 = this.boundingSphere.center;
        if (Gi.setFromBufferAttribute(e2), t2)
          for (let e3 = 0, r3 = t2.length; e3 < r3; e3++) {
            const r4 = t2[e3];
            Vi.setFromBufferAttribute(r4), this.morphTargetsRelative ? (Qi.addVectors(Gi.min, Vi.min), Gi.expandByPoint(Qi), Qi.addVectors(Gi.max, Vi.max), Gi.expandByPoint(Qi)) : (Gi.expandByPoint(Vi.min), Gi.expandByPoint(Vi.max));
          }
        Gi.getCenter(r2);
        let n2 = 0;
        for (let t3 = 0, i2 = e2.count; t3 < i2; t3++)
          Qi.fromBufferAttribute(e2, t3), n2 = Math.max(n2, r2.distanceToSquared(Qi));
        if (t2)
          for (let i2 = 0, s2 = t2.length; i2 < s2; i2++) {
            const s3 = t2[i2], o2 = this.morphTargetsRelative;
            for (let t3 = 0, i3 = s3.count; t3 < i3; t3++)
              Qi.fromBufferAttribute(s3, t3), o2 && (zi.fromBufferAttribute(e2, t3), Qi.add(zi)), n2 = Math.max(n2, r2.distanceToSquared(Qi));
          }
        this.boundingSphere.radius = Math.sqrt(n2), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeTangents() {
      const e2 = this.index, t2 = this.attributes;
      if (null === e2 || void 0 === t2.position || void 0 === t2.normal || void 0 === t2.uv)
        return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      const r2 = e2.array, n2 = t2.position.array, i2 = t2.normal.array, s2 = t2.uv.array, o2 = n2.length / 3;
      false === this.hasAttribute("tangent") && this.setAttribute("tangent", new Mi(new Float32Array(4 * o2), 4));
      const a2 = this.getAttribute("tangent").array, l2 = [], c2 = [];
      for (let e3 = 0; e3 < o2; e3++)
        l2[e3] = new ln(), c2[e3] = new ln();
      const u2 = new ln(), h2 = new ln(), p2 = new ln(), d2 = new kr(), f2 = new kr(), m2 = new kr(), _2 = new ln(), g2 = new ln();
      function v2(e3, t3, r3) {
        u2.fromArray(n2, 3 * e3), h2.fromArray(n2, 3 * t3), p2.fromArray(n2, 3 * r3), d2.fromArray(s2, 2 * e3), f2.fromArray(s2, 2 * t3), m2.fromArray(s2, 2 * r3), h2.sub(u2), p2.sub(u2), f2.sub(d2), m2.sub(d2);
        const i3 = 1 / (f2.x * m2.y - m2.x * f2.y);
        isFinite(i3) && (_2.copy(h2).multiplyScalar(m2.y).addScaledVector(p2, -f2.y).multiplyScalar(i3), g2.copy(p2).multiplyScalar(f2.x).addScaledVector(h2, -m2.x).multiplyScalar(i3), l2[e3].add(_2), l2[t3].add(_2), l2[r3].add(_2), c2[e3].add(g2), c2[t3].add(g2), c2[r3].add(g2));
      }
      let A2 = this.groups;
      0 === A2.length && (A2 = [{ start: 0, count: r2.length }]);
      for (let e3 = 0, t3 = A2.length; e3 < t3; ++e3) {
        const t4 = A2[e3], n3 = t4.start;
        for (let e4 = n3, i3 = n3 + t4.count; e4 < i3; e4 += 3)
          v2(r2[e4 + 0], r2[e4 + 1], r2[e4 + 2]);
      }
      const b2 = new ln(), y2 = new ln(), x2 = new ln(), w2 = new ln();
      function E2(e3) {
        x2.fromArray(i2, 3 * e3), w2.copy(x2);
        const t3 = l2[e3];
        b2.copy(t3), b2.sub(x2.multiplyScalar(x2.dot(t3))).normalize(), y2.crossVectors(w2, t3);
        const r3 = y2.dot(c2[e3]) < 0 ? -1 : 1;
        a2[4 * e3] = b2.x, a2[4 * e3 + 1] = b2.y, a2[4 * e3 + 2] = b2.z, a2[4 * e3 + 3] = r3;
      }
      for (let e3 = 0, t3 = A2.length; e3 < t3; ++e3) {
        const t4 = A2[e3], n3 = t4.start;
        for (let e4 = n3, i3 = n3 + t4.count; e4 < i3; e4 += 3)
          E2(r2[e4 + 0]), E2(r2[e4 + 1]), E2(r2[e4 + 2]);
      }
    }
    computeVertexNormals() {
      const e2 = this.index, t2 = this.getAttribute("position");
      if (void 0 !== t2) {
        let r2 = this.getAttribute("normal");
        if (void 0 === r2)
          r2 = new Mi(new Float32Array(3 * t2.count), 3), this.setAttribute("normal", r2);
        else
          for (let e3 = 0, t3 = r2.count; e3 < t3; e3++)
            r2.setXYZ(e3, 0, 0, 0);
        const n2 = new ln(), i2 = new ln(), s2 = new ln(), o2 = new ln(), a2 = new ln(), l2 = new ln(), c2 = new ln(), u2 = new ln();
        if (e2)
          for (let h2 = 0, p2 = e2.count; h2 < p2; h2 += 3) {
            const p3 = e2.getX(h2 + 0), d2 = e2.getX(h2 + 1), f2 = e2.getX(h2 + 2);
            n2.fromBufferAttribute(t2, p3), i2.fromBufferAttribute(t2, d2), s2.fromBufferAttribute(t2, f2), c2.subVectors(s2, i2), u2.subVectors(n2, i2), c2.cross(u2), o2.fromBufferAttribute(r2, p3), a2.fromBufferAttribute(r2, d2), l2.fromBufferAttribute(r2, f2), o2.add(c2), a2.add(c2), l2.add(c2), r2.setXYZ(p3, o2.x, o2.y, o2.z), r2.setXYZ(d2, a2.x, a2.y, a2.z), r2.setXYZ(f2, l2.x, l2.y, l2.z);
          }
        else
          for (let e3 = 0, o3 = t2.count; e3 < o3; e3 += 3)
            n2.fromBufferAttribute(t2, e3 + 0), i2.fromBufferAttribute(t2, e3 + 1), s2.fromBufferAttribute(t2, e3 + 2), c2.subVectors(s2, i2), u2.subVectors(n2, i2), c2.cross(u2), r2.setXYZ(e3 + 0, c2.x, c2.y, c2.z), r2.setXYZ(e3 + 1, c2.x, c2.y, c2.z), r2.setXYZ(e3 + 2, c2.x, c2.y, c2.z);
        this.normalizeNormals(), r2.needsUpdate = true;
      }
    }
    merge() {
      return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this;
    }
    normalizeNormals() {
      const e2 = this.attributes.normal;
      for (let t2 = 0, r2 = e2.count; t2 < r2; t2++)
        Qi.fromBufferAttribute(e2, t2), Qi.normalize(), e2.setXYZ(t2, Qi.x, Qi.y, Qi.z);
    }
    toNonIndexed() {
      function e2(e3, t3) {
        const r3 = e3.array, n3 = e3.itemSize, i3 = e3.normalized, s3 = new r3.constructor(t3.length * n3);
        let o2 = 0, a2 = 0;
        for (let i4 = 0, l2 = t3.length; i4 < l2; i4++) {
          o2 = e3.isInterleavedBufferAttribute ? t3[i4] * e3.data.stride + e3.offset : t3[i4] * n3;
          for (let e4 = 0; e4 < n3; e4++)
            s3[a2++] = r3[o2++];
        }
        return new Mi(s3, n3, i3);
      }
      if (null === this.index)
        return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      const t2 = new Hi(), r2 = this.index.array, n2 = this.attributes;
      for (const i3 in n2) {
        const s3 = e2(n2[i3], r2);
        t2.setAttribute(i3, s3);
      }
      const i2 = this.morphAttributes;
      for (const n3 in i2) {
        const s3 = [], o2 = i2[n3];
        for (let t3 = 0, n4 = o2.length; t3 < n4; t3++) {
          const n5 = e2(o2[t3], r2);
          s3.push(n5);
        }
        t2.morphAttributes[n3] = s3;
      }
      t2.morphTargetsRelative = this.morphTargetsRelative;
      const s2 = this.groups;
      for (let e3 = 0, r3 = s2.length; e3 < r3; e3++) {
        const r4 = s2[e3];
        t2.addGroup(r4.start, r4.count, r4.materialIndex);
      }
      return t2;
    }
    toJSON() {
      const e2 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
      if (e2.uuid = this.uuid, e2.type = this.type, "" !== this.name && (e2.name = this.name), Object.keys(this.userData).length > 0 && (e2.userData = this.userData), void 0 !== this.parameters) {
        const t3 = this.parameters;
        for (const r3 in t3)
          void 0 !== t3[r3] && (e2[r3] = t3[r3]);
        return e2;
      }
      e2.data = { attributes: {} };
      const t2 = this.index;
      null !== t2 && (e2.data.index = { type: t2.array.constructor.name, array: Array.prototype.slice.call(t2.array) });
      const r2 = this.attributes;
      for (const t3 in r2) {
        const n3 = r2[t3];
        e2.data.attributes[t3] = n3.toJSON(e2.data);
      }
      const n2 = {};
      let i2 = false;
      for (const t3 in this.morphAttributes) {
        const r3 = this.morphAttributes[t3], s3 = [];
        for (let t4 = 0, n3 = r3.length; t4 < n3; t4++) {
          const n4 = r3[t4];
          s3.push(n4.toJSON(e2.data));
        }
        s3.length > 0 && (n2[t3] = s3, i2 = true);
      }
      i2 && (e2.data.morphAttributes = n2, e2.data.morphTargetsRelative = this.morphTargetsRelative);
      const s2 = this.groups;
      s2.length > 0 && (e2.data.groups = JSON.parse(JSON.stringify(s2)));
      const o2 = this.boundingSphere;
      return null !== o2 && (e2.data.boundingSphere = { center: o2.center.toArray(), radius: o2.radius }), e2;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      const t2 = {};
      this.name = e2.name;
      const r2 = e2.index;
      null !== r2 && this.setIndex(r2.clone(t2));
      const n2 = e2.attributes;
      for (const e3 in n2) {
        const r3 = n2[e3];
        this.setAttribute(e3, r3.clone(t2));
      }
      const i2 = e2.morphAttributes;
      for (const e3 in i2) {
        const r3 = [], n3 = i2[e3];
        for (let e4 = 0, i3 = n3.length; e4 < i3; e4++)
          r3.push(n3[e4].clone(t2));
        this.morphAttributes[e3] = r3;
      }
      this.morphTargetsRelative = e2.morphTargetsRelative;
      const s2 = e2.groups;
      for (let e3 = 0, t3 = s2.length; e3 < t3; e3++) {
        const t4 = s2[e3];
        this.addGroup(t4.start, t4.count, t4.materialIndex);
      }
      const o2 = e2.boundingBox;
      null !== o2 && (this.boundingBox = o2.clone());
      const a2 = e2.boundingSphere;
      return null !== a2 && (this.boundingSphere = a2.clone()), this.drawRange.start = e2.drawRange.start, this.drawRange.count = e2.drawRange.count, this.userData = e2.userData, void 0 !== e2.parameters && (this.parameters = Object.assign({}, e2.parameters)), this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  const Wi = new Nn(), qi = new Un(), Xi = new kn(), Yi = new ln(), Ki = new ln(), Ji = new ln(), Zi = new ln(), $i = new ln(), es = new ln(), ts = new ln(), rs = new ln(), ns = new ln(), is = new kr(), ss = new kr(), os = new kr(), as = new ln(), ls = new ln();
  class cs extends ui {
    constructor(e2 = new Hi(), t2 = new Ei()) {
      super(), this.isMesh = true, this.type = "Mesh", this.geometry = e2, this.material = t2, this.updateMorphTargets();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), void 0 !== e2.morphTargetInfluences && (this.morphTargetInfluences = e2.morphTargetInfluences.slice()), void 0 !== e2.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e2.morphTargetDictionary)), this.material = e2.material, this.geometry = e2.geometry, this;
    }
    updateMorphTargets() {
      const e2 = this.geometry.morphAttributes, t2 = Object.keys(e2);
      if (t2.length > 0) {
        const r2 = e2[t2[0]];
        if (void 0 !== r2) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let e3 = 0, t3 = r2.length; e3 < t3; e3++) {
            const t4 = r2[e3].name || String(e3);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t4] = e3;
          }
        }
      }
    }
    raycast(e2, t2) {
      const r2 = this.geometry, n2 = this.material, i2 = this.matrixWorld;
      if (void 0 === n2)
        return;
      if (null === r2.boundingSphere && r2.computeBoundingSphere(), Xi.copy(r2.boundingSphere), Xi.applyMatrix4(i2), false === e2.ray.intersectsSphere(Xi))
        return;
      if (Wi.copy(i2).invert(), qi.copy(e2.ray).applyMatrix4(Wi), null !== r2.boundingBox && false === qi.intersectsBox(r2.boundingBox))
        return;
      let s2;
      const o2 = r2.index, a2 = r2.attributes.position, l2 = r2.morphAttributes.position, c2 = r2.morphTargetsRelative, u2 = r2.attributes.uv, h2 = r2.attributes.uv2, p2 = r2.groups, d2 = r2.drawRange;
      if (null !== o2)
        if (Array.isArray(n2))
          for (let r3 = 0, i3 = p2.length; r3 < i3; r3++) {
            const i4 = p2[r3], f2 = n2[i4.materialIndex];
            for (let r4 = Math.max(i4.start, d2.start), n3 = Math.min(o2.count, Math.min(i4.start + i4.count, d2.start + d2.count)); r4 < n3; r4 += 3) {
              const n4 = o2.getX(r4), p3 = o2.getX(r4 + 1), d3 = o2.getX(r4 + 2);
              s2 = us(this, f2, e2, qi, a2, l2, c2, u2, h2, n4, p3, d3), s2 && (s2.faceIndex = Math.floor(r4 / 3), s2.face.materialIndex = i4.materialIndex, t2.push(s2));
            }
          }
        else
          for (let r3 = Math.max(0, d2.start), i3 = Math.min(o2.count, d2.start + d2.count); r3 < i3; r3 += 3) {
            const i4 = o2.getX(r3), p3 = o2.getX(r3 + 1), d3 = o2.getX(r3 + 2);
            s2 = us(this, n2, e2, qi, a2, l2, c2, u2, h2, i4, p3, d3), s2 && (s2.faceIndex = Math.floor(r3 / 3), t2.push(s2));
          }
      else if (void 0 !== a2)
        if (Array.isArray(n2))
          for (let r3 = 0, i3 = p2.length; r3 < i3; r3++) {
            const i4 = p2[r3], o3 = n2[i4.materialIndex];
            for (let r4 = Math.max(i4.start, d2.start), n3 = Math.min(a2.count, Math.min(i4.start + i4.count, d2.start + d2.count)); r4 < n3; r4 += 3)
              s2 = us(this, o3, e2, qi, a2, l2, c2, u2, h2, r4, r4 + 1, r4 + 2), s2 && (s2.faceIndex = Math.floor(r4 / 3), s2.face.materialIndex = i4.materialIndex, t2.push(s2));
          }
        else
          for (let r3 = Math.max(0, d2.start), i3 = Math.min(a2.count, d2.start + d2.count); r3 < i3; r3 += 3)
            s2 = us(this, n2, e2, qi, a2, l2, c2, u2, h2, r3, r3 + 1, r3 + 2), s2 && (s2.faceIndex = Math.floor(r3 / 3), t2.push(s2));
    }
  }
  function us(e2, t2, r2, n2, i2, s2, o2, a2, l2, c2, u2, h2) {
    Yi.fromBufferAttribute(i2, c2), Ki.fromBufferAttribute(i2, u2), Ji.fromBufferAttribute(i2, h2);
    const p2 = e2.morphTargetInfluences;
    if (s2 && p2) {
      ts.set(0, 0, 0), rs.set(0, 0, 0), ns.set(0, 0, 0);
      for (let e3 = 0, t3 = s2.length; e3 < t3; e3++) {
        const t4 = p2[e3], r3 = s2[e3];
        0 !== t4 && (Zi.fromBufferAttribute(r3, c2), $i.fromBufferAttribute(r3, u2), es.fromBufferAttribute(r3, h2), o2 ? (ts.addScaledVector(Zi, t4), rs.addScaledVector($i, t4), ns.addScaledVector(es, t4)) : (ts.addScaledVector(Zi.sub(Yi), t4), rs.addScaledVector($i.sub(Ki), t4), ns.addScaledVector(es.sub(Ji), t4)));
      }
      Yi.add(ts), Ki.add(rs), Ji.add(ns);
    }
    e2.isSkinnedMesh && (e2.boneTransform(c2, Yi), e2.boneTransform(u2, Ki), e2.boneTransform(h2, Ji));
    const d2 = function(e3, t3, r3, n3, i3, s3, o3, a3) {
      let l3;
      if (l3 = t3.side === m ? n3.intersectTriangle(o3, s3, i3, true, a3) : n3.intersectTriangle(i3, s3, o3, t3.side !== _, a3), null === l3)
        return null;
      ls.copy(a3), ls.applyMatrix4(e3.matrixWorld);
      const c3 = r3.ray.origin.distanceTo(ls);
      return c3 < r3.near || c3 > r3.far ? null : { distance: c3, point: ls.clone(), object: e3 };
    }(e2, t2, r2, n2, Yi, Ki, Ji, as);
    if (d2) {
      a2 && (is.fromBufferAttribute(a2, c2), ss.fromBufferAttribute(a2, u2), os.fromBufferAttribute(a2, h2), d2.uv = yi.getUV(as, Yi, Ki, Ji, is, ss, os, new kr())), l2 && (is.fromBufferAttribute(l2, c2), ss.fromBufferAttribute(l2, u2), os.fromBufferAttribute(l2, h2), d2.uv2 = yi.getUV(as, Yi, Ki, Ji, is, ss, os, new kr()));
      const e3 = { a: c2, b: u2, c: h2, normal: new ln(), materialIndex: 0 };
      yi.getNormal(Yi, Ki, Ji, e3.normal), d2.face = e3;
    }
    return d2;
  }
  class hs extends Hi {
    constructor(e2 = 1, t2 = 1, r2 = 1, n2 = 1, i2 = 1, s2 = 1) {
      super(), this.type = "BoxGeometry", this.parameters = { width: e2, height: t2, depth: r2, widthSegments: n2, heightSegments: i2, depthSegments: s2 };
      const o2 = this;
      n2 = Math.floor(n2), i2 = Math.floor(i2), s2 = Math.floor(s2);
      const a2 = [], l2 = [], c2 = [], u2 = [];
      let h2 = 0, p2 = 0;
      function d2(e3, t3, r3, n3, i3, s3, d3, f2, m2, _2, g2) {
        const v2 = s3 / m2, A2 = d3 / _2, b2 = s3 / 2, y2 = d3 / 2, x2 = f2 / 2, w2 = m2 + 1, E2 = _2 + 1;
        let S2 = 0, C2 = 0;
        const M2 = new ln();
        for (let s4 = 0; s4 < E2; s4++) {
          const o3 = s4 * A2 - y2;
          for (let a3 = 0; a3 < w2; a3++) {
            const h3 = a3 * v2 - b2;
            M2[e3] = h3 * n3, M2[t3] = o3 * i3, M2[r3] = x2, l2.push(M2.x, M2.y, M2.z), M2[e3] = 0, M2[t3] = 0, M2[r3] = f2 > 0 ? 1 : -1, c2.push(M2.x, M2.y, M2.z), u2.push(a3 / m2), u2.push(1 - s4 / _2), S2 += 1;
          }
        }
        for (let e4 = 0; e4 < _2; e4++)
          for (let t4 = 0; t4 < m2; t4++) {
            const r4 = h2 + t4 + w2 * e4, n4 = h2 + t4 + w2 * (e4 + 1), i4 = h2 + (t4 + 1) + w2 * (e4 + 1), s4 = h2 + (t4 + 1) + w2 * e4;
            a2.push(r4, n4, s4), a2.push(n4, i4, s4), C2 += 6;
          }
        o2.addGroup(p2, C2, g2), p2 += C2, h2 += S2;
      }
      d2("z", "y", "x", -1, -1, r2, t2, e2, s2, i2, 0), d2("z", "y", "x", 1, -1, r2, t2, -e2, s2, i2, 1), d2("x", "z", "y", 1, 1, e2, r2, t2, n2, s2, 2), d2("x", "z", "y", 1, -1, e2, r2, -t2, n2, s2, 3), d2("x", "y", "z", 1, -1, e2, t2, r2, n2, i2, 4), d2("x", "y", "z", -1, -1, e2, t2, -r2, n2, i2, 5), this.setIndex(a2), this.setAttribute("position", new Oi(l2, 3)), this.setAttribute("normal", new Oi(c2, 3)), this.setAttribute("uv", new Oi(u2, 2));
    }
    static fromJSON(e2) {
      return new hs(e2.width, e2.height, e2.depth, e2.widthSegments, e2.heightSegments, e2.depthSegments);
    }
  }
  function ps(e2) {
    const t2 = {};
    for (const r2 in e2) {
      t2[r2] = {};
      for (const n2 in e2[r2]) {
        const i2 = e2[r2][n2];
        i2 && (i2.isColor || i2.isMatrix3 || i2.isMatrix4 || i2.isVector2 || i2.isVector3 || i2.isVector4 || i2.isTexture || i2.isQuaternion) ? t2[r2][n2] = i2.clone() : Array.isArray(i2) ? t2[r2][n2] = i2.slice() : t2[r2][n2] = i2;
      }
    }
    return t2;
  }
  function ds(e2) {
    const t2 = {};
    for (let r2 = 0; r2 < e2.length; r2++) {
      const n2 = ps(e2[r2]);
      for (const e3 in n2)
        t2[e3] = n2[e3];
    }
    return t2;
  }
  const fs = { clone: ps, merge: ds };
  class ms extends wi {
    constructor(e2) {
      super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, void 0 !== e2 && this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.fragmentShader = e2.fragmentShader, this.vertexShader = e2.vertexShader, this.uniforms = ps(e2.uniforms), this.uniformsGroups = function(e3) {
        const t2 = [];
        for (let r2 = 0; r2 < e3.length; r2++)
          t2.push(e3[r2].clone());
        return t2;
      }(e2.uniformsGroups), this.defines = Object.assign({}, e2.defines), this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.fog = e2.fog, this.lights = e2.lights, this.clipping = e2.clipping, this.extensions = Object.assign({}, e2.extensions), this.glslVersion = e2.glslVersion, this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      t2.glslVersion = this.glslVersion, t2.uniforms = {};
      for (const r3 in this.uniforms) {
        const n2 = this.uniforms[r3].value;
        n2 && n2.isTexture ? t2.uniforms[r3] = { type: "t", value: n2.toJSON(e2).uuid } : n2 && n2.isColor ? t2.uniforms[r3] = { type: "c", value: n2.getHex() } : n2 && n2.isVector2 ? t2.uniforms[r3] = { type: "v2", value: n2.toArray() } : n2 && n2.isVector3 ? t2.uniforms[r3] = { type: "v3", value: n2.toArray() } : n2 && n2.isVector4 ? t2.uniforms[r3] = { type: "v4", value: n2.toArray() } : n2 && n2.isMatrix3 ? t2.uniforms[r3] = { type: "m3", value: n2.toArray() } : n2 && n2.isMatrix4 ? t2.uniforms[r3] = { type: "m4", value: n2.toArray() } : t2.uniforms[r3] = { value: n2 };
      }
      Object.keys(this.defines).length > 0 && (t2.defines = this.defines), t2.vertexShader = this.vertexShader, t2.fragmentShader = this.fragmentShader;
      const r2 = {};
      for (const e3 in this.extensions)
        true === this.extensions[e3] && (r2[e3] = true);
      return Object.keys(r2).length > 0 && (t2.extensions = r2), t2;
    }
  }
  class _s extends ui {
    constructor() {
      super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new Nn(), this.projectionMatrix = new Nn(), this.projectionMatrixInverse = new Nn();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.matrixWorldInverse.copy(e2.matrixWorldInverse), this.projectionMatrix.copy(e2.projectionMatrix), this.projectionMatrixInverse.copy(e2.projectionMatrixInverse), this;
    }
    getWorldDirection(e2) {
      this.updateWorldMatrix(true, false);
      const t2 = this.matrixWorld.elements;
      return e2.set(-t2[8], -t2[9], -t2[10]).normalize();
    }
    updateMatrixWorld(e2) {
      super.updateMatrixWorld(e2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e2, t2) {
      super.updateWorldMatrix(e2, t2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class gs extends _s {
    constructor(e2 = 50, t2 = 1, r2 = 0.1, n2 = 2e3) {
      super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e2, this.zoom = 1, this.near = r2, this.far = n2, this.focus = 10, this.aspect = t2, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.fov = e2.fov, this.zoom = e2.zoom, this.near = e2.near, this.far = e2.far, this.focus = e2.focus, this.aspect = e2.aspect, this.view = null === e2.view ? null : Object.assign({}, e2.view), this.filmGauge = e2.filmGauge, this.filmOffset = e2.filmOffset, this;
    }
    setFocalLength(e2) {
      const t2 = 0.5 * this.getFilmHeight() / e2;
      this.fov = 2 * Ar * Math.atan(t2), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const e2 = Math.tan(0.5 * vr * this.fov);
      return 0.5 * this.getFilmHeight() / e2;
    }
    getEffectiveFOV() {
      return 2 * Ar * Math.atan(Math.tan(0.5 * vr * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(e2, t2, r2, n2, i2, s2) {
      this.aspect = e2 / t2, null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e2, this.view.fullHeight = t2, this.view.offsetX = r2, this.view.offsetY = n2, this.view.width = i2, this.view.height = s2, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const e2 = this.near;
      let t2 = e2 * Math.tan(0.5 * vr * this.fov) / this.zoom, r2 = 2 * t2, n2 = this.aspect * r2, i2 = -0.5 * n2;
      const s2 = this.view;
      if (null !== this.view && this.view.enabled) {
        const e3 = s2.fullWidth, o3 = s2.fullHeight;
        i2 += s2.offsetX * n2 / e3, t2 -= s2.offsetY * r2 / o3, n2 *= s2.width / e3, r2 *= s2.height / o3;
      }
      const o2 = this.filmOffset;
      0 !== o2 && (i2 += e2 * o2 / this.getFilmWidth()), this.projectionMatrix.makePerspective(i2, i2 + n2, t2, t2 - r2, e2, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.fov = this.fov, t2.object.zoom = this.zoom, t2.object.near = this.near, t2.object.far = this.far, t2.object.focus = this.focus, t2.object.aspect = this.aspect, null !== this.view && (t2.object.view = Object.assign({}, this.view)), t2.object.filmGauge = this.filmGauge, t2.object.filmOffset = this.filmOffset, t2;
    }
  }
  const vs = 90;
  class As extends ui {
    constructor(e2, t2, r2) {
      super(), this.type = "CubeCamera", this.renderTarget = r2;
      const n2 = new gs(vs, 1, e2, t2);
      n2.layers = this.layers, n2.up.set(0, -1, 0), n2.lookAt(new ln(1, 0, 0)), this.add(n2);
      const i2 = new gs(vs, 1, e2, t2);
      i2.layers = this.layers, i2.up.set(0, -1, 0), i2.lookAt(new ln(-1, 0, 0)), this.add(i2);
      const s2 = new gs(vs, 1, e2, t2);
      s2.layers = this.layers, s2.up.set(0, 0, 1), s2.lookAt(new ln(0, 1, 0)), this.add(s2);
      const o2 = new gs(vs, 1, e2, t2);
      o2.layers = this.layers, o2.up.set(0, 0, -1), o2.lookAt(new ln(0, -1, 0)), this.add(o2);
      const a2 = new gs(vs, 1, e2, t2);
      a2.layers = this.layers, a2.up.set(0, -1, 0), a2.lookAt(new ln(0, 0, 1)), this.add(a2);
      const l2 = new gs(vs, 1, e2, t2);
      l2.layers = this.layers, l2.up.set(0, -1, 0), l2.lookAt(new ln(0, 0, -1)), this.add(l2);
    }
    update(e2, t2) {
      null === this.parent && this.updateMatrixWorld();
      const r2 = this.renderTarget, [n2, i2, s2, o2, a2, l2] = this.children, c2 = e2.getRenderTarget(), u2 = e2.toneMapping, h2 = e2.xr.enabled;
      e2.toneMapping = K, e2.xr.enabled = false;
      const p2 = r2.texture.generateMipmaps;
      r2.texture.generateMipmaps = false, e2.setRenderTarget(r2, 0), e2.render(t2, n2), e2.setRenderTarget(r2, 1), e2.render(t2, i2), e2.setRenderTarget(r2, 2), e2.render(t2, s2), e2.setRenderTarget(r2, 3), e2.render(t2, o2), e2.setRenderTarget(r2, 4), e2.render(t2, a2), r2.texture.generateMipmaps = p2, e2.setRenderTarget(r2, 5), e2.render(t2, l2), e2.setRenderTarget(c2), e2.toneMapping = u2, e2.xr.enabled = h2, r2.texture.needsPMREMUpdate = true;
    }
  }
  class bs extends Zr {
    constructor(e2, t2, r2, n2, i2, s2, o2, a2, l2, c2) {
      super(e2 = void 0 !== e2 ? e2 : [], t2 = void 0 !== t2 ? t2 : ne, r2, n2, i2, s2, o2, a2, l2, c2), this.isCubeTexture = true, this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(e2) {
      this.image = e2;
    }
  }
  class ys extends en {
    constructor(e2, t2 = {}) {
      super(e2, e2, t2), this.isWebGLCubeRenderTarget = true;
      const r2 = { width: e2, height: e2, depth: 1 }, n2 = [r2, r2, r2, r2, r2, r2];
      this.texture = new bs(n2, t2.mapping, t2.wrapS, t2.wrapT, t2.magFilter, t2.minFilter, t2.format, t2.type, t2.anisotropy, t2.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = void 0 !== t2.generateMipmaps && t2.generateMipmaps, this.texture.minFilter = void 0 !== t2.minFilter ? t2.minFilter : _e;
    }
    fromEquirectangularTexture(e2, t2) {
      this.texture.type = t2.type, this.texture.encoding = t2.encoding, this.texture.generateMipmaps = t2.generateMipmaps, this.texture.minFilter = t2.minFilter, this.texture.magFilter = t2.magFilter;
      const r2 = { tEquirect: { value: null } }, n2 = "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", i2 = "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			", s2 = new hs(5, 5, 5), o2 = new ms({ name: "CubemapFromEquirect", uniforms: ps(r2), vertexShader: n2, fragmentShader: i2, side: m, blending: g });
      o2.uniforms.tEquirect.value = t2;
      const a2 = new cs(s2, o2), l2 = t2.minFilter;
      return t2.minFilter === Ae && (t2.minFilter = _e), new As(1, 10, this).update(e2, a2), t2.minFilter = l2, a2.geometry.dispose(), a2.material.dispose(), this;
    }
    clear(e2, t2, r2, n2) {
      const i2 = e2.getRenderTarget();
      for (let i3 = 0; i3 < 6; i3++)
        e2.setRenderTarget(this, i3), e2.clear(t2, r2, n2);
      e2.setRenderTarget(i2);
    }
  }
  const xs = new ln(), ws = new ln(), Es = new Dr();
  class Ss {
    constructor(e2 = new ln(1, 0, 0), t2 = 0) {
      this.isPlane = true, this.normal = e2, this.constant = t2;
    }
    set(e2, t2) {
      return this.normal.copy(e2), this.constant = t2, this;
    }
    setComponents(e2, t2, r2, n2) {
      return this.normal.set(e2, t2, r2), this.constant = n2, this;
    }
    setFromNormalAndCoplanarPoint(e2, t2) {
      return this.normal.copy(e2), this.constant = -t2.dot(this.normal), this;
    }
    setFromCoplanarPoints(e2, t2, r2) {
      const n2 = xs.subVectors(r2, t2).cross(ws.subVectors(e2, t2)).normalize();
      return this.setFromNormalAndCoplanarPoint(n2, e2), this;
    }
    copy(e2) {
      return this.normal.copy(e2.normal), this.constant = e2.constant, this;
    }
    normalize() {
      const e2 = 1 / this.normal.length();
      return this.normal.multiplyScalar(e2), this.constant *= e2, this;
    }
    negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(e2) {
      return this.normal.dot(e2) + this.constant;
    }
    distanceToSphere(e2) {
      return this.distanceToPoint(e2.center) - e2.radius;
    }
    projectPoint(e2, t2) {
      return t2.copy(this.normal).multiplyScalar(-this.distanceToPoint(e2)).add(e2);
    }
    intersectLine(e2, t2) {
      const r2 = e2.delta(xs), n2 = this.normal.dot(r2);
      if (0 === n2)
        return 0 === this.distanceToPoint(e2.start) ? t2.copy(e2.start) : null;
      const i2 = -(e2.start.dot(this.normal) + this.constant) / n2;
      return i2 < 0 || i2 > 1 ? null : t2.copy(r2).multiplyScalar(i2).add(e2.start);
    }
    intersectsLine(e2) {
      const t2 = this.distanceToPoint(e2.start), r2 = this.distanceToPoint(e2.end);
      return t2 < 0 && r2 > 0 || r2 < 0 && t2 > 0;
    }
    intersectsBox(e2) {
      return e2.intersectsPlane(this);
    }
    intersectsSphere(e2) {
      return e2.intersectsPlane(this);
    }
    coplanarPoint(e2) {
      return e2.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(e2, t2) {
      const r2 = t2 || Es.getNormalMatrix(e2), n2 = this.coplanarPoint(xs).applyMatrix4(e2), i2 = this.normal.applyMatrix3(r2).normalize();
      return this.constant = -n2.dot(i2), this;
    }
    translate(e2) {
      return this.constant -= e2.dot(this.normal), this;
    }
    equals(e2) {
      return e2.normal.equals(this.normal) && e2.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Cs = new kn(), Ms = new ln();
  class Ts {
    constructor(e2 = new Ss(), t2 = new Ss(), r2 = new Ss(), n2 = new Ss(), i2 = new Ss(), s2 = new Ss()) {
      this.planes = [e2, t2, r2, n2, i2, s2];
    }
    set(e2, t2, r2, n2, i2, s2) {
      const o2 = this.planes;
      return o2[0].copy(e2), o2[1].copy(t2), o2[2].copy(r2), o2[3].copy(n2), o2[4].copy(i2), o2[5].copy(s2), this;
    }
    copy(e2) {
      const t2 = this.planes;
      for (let r2 = 0; r2 < 6; r2++)
        t2[r2].copy(e2.planes[r2]);
      return this;
    }
    setFromProjectionMatrix(e2) {
      const t2 = this.planes, r2 = e2.elements, n2 = r2[0], i2 = r2[1], s2 = r2[2], o2 = r2[3], a2 = r2[4], l2 = r2[5], c2 = r2[6], u2 = r2[7], h2 = r2[8], p2 = r2[9], d2 = r2[10], f2 = r2[11], m2 = r2[12], _2 = r2[13], g2 = r2[14], v2 = r2[15];
      return t2[0].setComponents(o2 - n2, u2 - a2, f2 - h2, v2 - m2).normalize(), t2[1].setComponents(o2 + n2, u2 + a2, f2 + h2, v2 + m2).normalize(), t2[2].setComponents(o2 + i2, u2 + l2, f2 + p2, v2 + _2).normalize(), t2[3].setComponents(o2 - i2, u2 - l2, f2 - p2, v2 - _2).normalize(), t2[4].setComponents(o2 - s2, u2 - c2, f2 - d2, v2 - g2).normalize(), t2[5].setComponents(o2 + s2, u2 + c2, f2 + d2, v2 + g2).normalize(), this;
    }
    intersectsObject(e2) {
      const t2 = e2.geometry;
      return null === t2.boundingSphere && t2.computeBoundingSphere(), Cs.copy(t2.boundingSphere).applyMatrix4(e2.matrixWorld), this.intersectsSphere(Cs);
    }
    intersectsSprite(e2) {
      return Cs.center.set(0, 0, 0), Cs.radius = 0.7071067811865476, Cs.applyMatrix4(e2.matrixWorld), this.intersectsSphere(Cs);
    }
    intersectsSphere(e2) {
      const t2 = this.planes, r2 = e2.center, n2 = -e2.radius;
      for (let e3 = 0; e3 < 6; e3++)
        if (t2[e3].distanceToPoint(r2) < n2)
          return false;
      return true;
    }
    intersectsBox(e2) {
      const t2 = this.planes;
      for (let r2 = 0; r2 < 6; r2++) {
        const n2 = t2[r2];
        if (Ms.x = n2.normal.x > 0 ? e2.max.x : e2.min.x, Ms.y = n2.normal.y > 0 ? e2.max.y : e2.min.y, Ms.z = n2.normal.z > 0 ? e2.max.z : e2.min.z, n2.distanceToPoint(Ms) < 0)
          return false;
      }
      return true;
    }
    containsPoint(e2) {
      const t2 = this.planes;
      for (let r2 = 0; r2 < 6; r2++)
        if (t2[r2].distanceToPoint(e2) < 0)
          return false;
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  function Is() {
    let e2 = null, t2 = false, r2 = null, n2 = null;
    function i2(t3, s2) {
      r2(t3, s2), n2 = e2.requestAnimationFrame(i2);
    }
    return { start: function() {
      true !== t2 && null !== r2 && (n2 = e2.requestAnimationFrame(i2), t2 = true);
    }, stop: function() {
      e2.cancelAnimationFrame(n2), t2 = false;
    }, setAnimationLoop: function(e3) {
      r2 = e3;
    }, setContext: function(t3) {
      e2 = t3;
    } };
  }
  function ks(e2, t2) {
    const r2 = t2.isWebGL2, n2 = /* @__PURE__ */ new WeakMap();
    return { get: function(e3) {
      return e3.isInterleavedBufferAttribute && (e3 = e3.data), n2.get(e3);
    }, remove: function(t3) {
      t3.isInterleavedBufferAttribute && (t3 = t3.data);
      const r3 = n2.get(t3);
      r3 && (e2.deleteBuffer(r3.buffer), n2.delete(t3));
    }, update: function(t3, i2) {
      if (t3.isGLBufferAttribute) {
        const e3 = n2.get(t3);
        return void ((!e3 || e3.version < t3.version) && n2.set(t3, { buffer: t3.buffer, type: t3.type, bytesPerElement: t3.elementSize, version: t3.version }));
      }
      t3.isInterleavedBufferAttribute && (t3 = t3.data);
      const s2 = n2.get(t3);
      void 0 === s2 ? n2.set(t3, function(t4, n3) {
        const i3 = t4.array, s3 = t4.usage, o2 = e2.createBuffer();
        let a2;
        if (e2.bindBuffer(n3, o2), e2.bufferData(n3, i3, s3), t4.onUploadCallback(), i3 instanceof Float32Array)
          a2 = 5126;
        else if (i3 instanceof Uint16Array)
          if (t4.isFloat16BufferAttribute) {
            if (!r2)
              throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            a2 = 5131;
          } else
            a2 = 5123;
        else if (i3 instanceof Int16Array)
          a2 = 5122;
        else if (i3 instanceof Uint32Array)
          a2 = 5125;
        else if (i3 instanceof Int32Array)
          a2 = 5124;
        else if (i3 instanceof Int8Array)
          a2 = 5120;
        else if (i3 instanceof Uint8Array)
          a2 = 5121;
        else {
          if (!(i3 instanceof Uint8ClampedArray))
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i3);
          a2 = 5121;
        }
        return { buffer: o2, type: a2, bytesPerElement: i3.BYTES_PER_ELEMENT, version: t4.version };
      }(t3, i2)) : s2.version < t3.version && (function(t4, n3, i3) {
        const s3 = n3.array, o2 = n3.updateRange;
        e2.bindBuffer(i3, t4), -1 === o2.count ? e2.bufferSubData(i3, 0, s3) : (r2 ? e2.bufferSubData(i3, o2.offset * s3.BYTES_PER_ELEMENT, s3, o2.offset, o2.count) : e2.bufferSubData(i3, o2.offset * s3.BYTES_PER_ELEMENT, s3.subarray(o2.offset, o2.offset + o2.count)), o2.count = -1);
      }(s2.buffer, t3, i2), s2.version = t3.version);
    } };
  }
  class Ds extends Hi {
    constructor(e2 = 1, t2 = 1, r2 = 1, n2 = 1) {
      super(), this.type = "PlaneGeometry", this.parameters = { width: e2, height: t2, widthSegments: r2, heightSegments: n2 };
      const i2 = e2 / 2, s2 = t2 / 2, o2 = Math.floor(r2), a2 = Math.floor(n2), l2 = o2 + 1, c2 = a2 + 1, u2 = e2 / o2, h2 = t2 / a2, p2 = [], d2 = [], f2 = [], m2 = [];
      for (let e3 = 0; e3 < c2; e3++) {
        const t3 = e3 * h2 - s2;
        for (let r3 = 0; r3 < l2; r3++) {
          const n3 = r3 * u2 - i2;
          d2.push(n3, -t3, 0), f2.push(0, 0, 1), m2.push(r3 / o2), m2.push(1 - e3 / a2);
        }
      }
      for (let e3 = 0; e3 < a2; e3++)
        for (let t3 = 0; t3 < o2; t3++) {
          const r3 = t3 + l2 * e3, n3 = t3 + l2 * (e3 + 1), i3 = t3 + 1 + l2 * (e3 + 1), s3 = t3 + 1 + l2 * e3;
          p2.push(r3, n3, s3), p2.push(n3, i3, s3);
        }
      this.setIndex(p2), this.setAttribute("position", new Oi(d2, 3)), this.setAttribute("normal", new Oi(f2, 3)), this.setAttribute("uv", new Oi(m2, 2));
    }
    static fromJSON(e2) {
      return new Ds(e2.width, e2.height, e2.widthSegments, e2.heightSegments);
    }
  }
  const Ps = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	#if defined(INVERSE_ALPHAMAP) && INVERSE_ALPHAMAP >= 1\n	diffuseColor.a *= 1.0-texture2D( alphaMap, vUv ).g;\n	#else\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n	#endif\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif", iridescence_fragment: "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			 return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float R21 = R12;\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = dFdx( surf_pos.xyz );\n		vec3 vSigmaY = dFdy( surf_pos.xyz );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_v0 0.339\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_v1 0.276\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_v4 0.046\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_v5 0.016\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_v6 0.0038\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	reflectVec = transformDirection1(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	vec3 transformDirection1( in vec3 dir, in mat4 matrix ) {\n		return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n	}\n	mat4 rotationMatrix(vec3 axis, float angle) {\n		axis = normalize(axis);\n		float s = sin(angle);\n		float c = cos(angle);\n		float oc = 1.0 - c;\n		return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n					oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n					oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n					0.0,                                0.0,                                0.0,                                1.0);\n	}\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform float envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			worldNormal = transformDirection1(worldNormal, rotationMatrix(vec3(0,1,0), envMapRotation));\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			reflectVec = transformDirection1(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;", lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )	(0)", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	#ifdef USE_IRIDESCENCE\n		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometry.viewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\ndiffuseColor.a = min(max(diffuseColor.a, 0.), 1.);\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return transmissionSamplerMapTexelToLinear ( texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod ) );\n		#else\n			return transmissionSamplerMapTexelToLinear ( texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod ) );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nuniform bool flipX;\nuniform bool flipY;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n    vUv = flipX ? vec2( 1.0 - vUv.x, vUv.y ) : vUv;\n    vUv = flipY ? vec2( vUv.x, 1.0 - vUv.y ) : vUv;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}" }, Bs = { common: { diffuse: { value: new Wr(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Dr() }, uv2Transform: { value: new Dr() }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, envMapRotation: { value: 0 }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new kr(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Wr(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Wr(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Dr() } }, sprite: { diffuse: { value: new Wr(16777215) }, opacity: { value: 1 }, center: { value: new kr(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Dr() } } }, Rs = { basic: { uniforms: ds([Bs.common, Bs.specularmap, Bs.envmap, Bs.aomap, Bs.lightmap, Bs.fog]), vertexShader: Ps.meshbasic_vert, fragmentShader: Ps.meshbasic_frag }, lambert: { uniforms: ds([Bs.common, Bs.specularmap, Bs.envmap, Bs.aomap, Bs.lightmap, Bs.emissivemap, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.fog, Bs.lights, { emissive: { value: new Wr(0) } }]), vertexShader: Ps.meshlambert_vert, fragmentShader: Ps.meshlambert_frag }, phong: { uniforms: ds([Bs.common, Bs.specularmap, Bs.envmap, Bs.aomap, Bs.lightmap, Bs.emissivemap, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.fog, Bs.lights, { emissive: { value: new Wr(0) }, specular: { value: new Wr(1118481) }, shininess: { value: 30 } }]), vertexShader: Ps.meshphong_vert, fragmentShader: Ps.meshphong_frag }, standard: { uniforms: ds([Bs.common, Bs.envmap, Bs.aomap, Bs.lightmap, Bs.emissivemap, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.roughnessmap, Bs.metalnessmap, Bs.fog, Bs.lights, { emissive: { value: new Wr(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Ps.meshphysical_vert, fragmentShader: Ps.meshphysical_frag }, toon: { uniforms: ds([Bs.common, Bs.aomap, Bs.lightmap, Bs.emissivemap, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.gradientmap, Bs.fog, Bs.lights, { emissive: { value: new Wr(0) } }]), vertexShader: Ps.meshtoon_vert, fragmentShader: Ps.meshtoon_frag }, matcap: { uniforms: ds([Bs.common, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.fog, { matcap: { value: null } }]), vertexShader: Ps.meshmatcap_vert, fragmentShader: Ps.meshmatcap_frag }, points: { uniforms: ds([Bs.points, Bs.fog]), vertexShader: Ps.points_vert, fragmentShader: Ps.points_frag }, dashed: { uniforms: ds([Bs.common, Bs.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Ps.linedashed_vert, fragmentShader: Ps.linedashed_frag }, depth: { uniforms: ds([Bs.common, Bs.displacementmap]), vertexShader: Ps.depth_vert, fragmentShader: Ps.depth_frag }, normal: { uniforms: ds([Bs.common, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, { opacity: { value: 1 } }]), vertexShader: Ps.meshnormal_vert, fragmentShader: Ps.meshnormal_frag }, sprite: { uniforms: ds([Bs.sprite, Bs.fog]), vertexShader: Ps.sprite_vert, fragmentShader: Ps.sprite_frag }, background: { uniforms: { uvTransform: { value: new Dr() }, t2D: { value: null }, flipX: { value: false }, flipY: { value: false } }, vertexShader: Ps.background_vert, fragmentShader: Ps.background_frag }, cube: { uniforms: ds([Bs.envmap, { opacity: { value: 1 } }]), vertexShader: Ps.cube_vert, fragmentShader: Ps.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Ps.equirect_vert, fragmentShader: Ps.equirect_frag }, distanceRGBA: { uniforms: ds([Bs.common, Bs.displacementmap, { referencePosition: { value: new ln() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Ps.distanceRGBA_vert, fragmentShader: Ps.distanceRGBA_frag }, shadow: { uniforms: ds([Bs.lights, Bs.fog, { color: { value: new Wr(0) }, opacity: { value: 1 } }]), vertexShader: Ps.shadow_vert, fragmentShader: Ps.shadow_frag } };
  function Ls(e2, t2, r2, n2, i2, s2) {
    const o2 = new Wr(0);
    let a2, l2, c2 = true === i2 ? 0 : 1, u2 = null, h2 = 0, p2 = null;
    function d2(e3, t3) {
      r2.buffers.color.setClear(e3.r, e3.g, e3.b, t3, s2);
    }
    return { getClearColor: function() {
      return o2;
    }, setClearColor: function(e3, t3 = 1) {
      o2.set(e3), c2 = t3, d2(o2, c2);
    }, getClearAlpha: function() {
      return c2;
    }, setClearAlpha: function(e3) {
      c2 = e3, d2(o2, c2);
    }, getPlaneMesh: function() {
      return a2;
    }, getBoxMesh: function() {
      return l2;
    }, getBoxMesh2: function() {
      return void 0 === l2 && (l2 = new cs(new hs(1, 1, 1), new ms({ name: "BackgroundCubeMaterial", uniforms: ps(Rs.cube.uniforms), vertexShader: Rs.cube.vertexShader, fragmentShader: Rs.cube.fragmentShader, side: m, depthTest: false, depthWrite: false, fog: false })), l2.geometry.deleteAttribute("normal"), l2.geometry.deleteAttribute("uv"), l2.onBeforeRender = function(e3, t3, r3) {
        this.matrixWorld.copyPosition(r3.matrixWorld);
      }, Object.defineProperty(l2.material, "envMap", { get: function() {
        return this.uniforms.envMap.value;
      } }), n2.update(l2)), l2;
    }, render: function(r3, i3) {
      let s3 = false, _2 = true === i3.isScene ? i3.background : null;
      _2 && _2.isTexture && (_2 = t2.get(_2));
      const g2 = e2.xr, v2 = g2.getSession && g2.getSession();
      v2 && "additive" === v2.environmentBlendMode && (_2 = null), null === _2 ? d2(o2, c2) : _2 && _2.isColor && (d2(_2, 1), s3 = true), (e2.autoClear || s3) && e2.clear(e2.autoClearColor, e2.autoClearDepth, e2.autoClearStencil), _2 && (_2.isCubeTexture || _2.mapping === ae) ? (void 0 === l2 && (l2 = new cs(new hs(1, 1, 1), new ms({ name: "BackgroundCubeMaterial", uniforms: ps(Rs.cube.uniforms), vertexShader: Rs.cube.vertexShader, fragmentShader: Rs.cube.fragmentShader, side: m, depthTest: false, depthWrite: false, fog: false })), l2.geometry.deleteAttribute("normal"), l2.geometry.deleteAttribute("uv"), l2.onBeforeRender = function(e3, t3, r4) {
        this.matrixWorld.copyPosition(r4.matrixWorld);
      }, Object.defineProperty(l2.material, "envMap", { get: function() {
        return this.uniforms.envMap.value;
      } }), n2.update(l2)), l2.material.uniforms.envMap.value = _2, l2.material.uniforms.envMapRotation.value = _2.rotation || 0, l2.material.uniforms.flipEnvMap.value = _2.isCubeTexture && false === _2.isRenderTargetTexture ? -1 : 1, u2 === _2 && h2 === _2.version && p2 === e2.toneMapping || (l2.material.needsUpdate = true, u2 = _2, h2 = _2.version, p2 = e2.toneMapping), l2.layers.enableAll(), r3.unshift(l2, l2.geometry, l2.material, 0, 0, null)) : _2 && _2.isTexture && (void 0 === a2 && (a2 = new cs(new Ds(2, 2), new ms({ name: "BackgroundMaterial", uniforms: ps(Rs.background.uniforms), vertexShader: Rs.background.vertexShader, fragmentShader: Rs.background.fragmentShader, side: f, depthTest: false, depthWrite: false, fog: false })), a2.geometry.deleteAttribute("normal"), Object.defineProperty(a2.material, "map", { get: function() {
        return this.uniforms.t2D.value;
      } }), n2.update(a2)), a2.material.uniforms.t2D.value = _2, a2.material.uniforms.flipX.value = _2.userData.flipX || false, a2.material.uniforms.flipY.value = _2.userData.flipY || false, true === _2.matrixAutoUpdate && _2.updateMatrix(), a2.material.uniforms.uvTransform.value.copy(_2.matrix), u2 === _2 && h2 === _2.version && p2 === e2.toneMapping || (a2.material.needsUpdate = true, u2 = _2, h2 = _2.version, p2 = e2.toneMapping), a2.layers.enableAll(), r3.unshift(a2, a2.geometry, a2.material, 0, 0, null));
    } };
  }
  function Os(e2, t2, r2, n2) {
    const i2 = e2.getParameter(34921), s2 = n2.isWebGL2 ? null : t2.get("OES_vertex_array_object"), o2 = n2.isWebGL2 || null !== s2, a2 = {}, l2 = d2(null);
    let c2 = l2, u2 = false;
    function h2(t3) {
      return n2.isWebGL2 ? e2.bindVertexArray(t3) : s2.bindVertexArrayOES(t3);
    }
    function p2(t3) {
      return n2.isWebGL2 ? e2.deleteVertexArray(t3) : s2.deleteVertexArrayOES(t3);
    }
    function d2(e3) {
      const t3 = [], r3 = [], n3 = [];
      for (let e4 = 0; e4 < i2; e4++)
        t3[e4] = 0, r3[e4] = 0, n3[e4] = 0;
      return { geometry: null, program: null, wireframe: false, newAttributes: t3, enabledAttributes: r3, attributeDivisors: n3, object: e3, attributes: {}, index: null };
    }
    function f2() {
      const e3 = c2.newAttributes;
      for (let t3 = 0, r3 = e3.length; t3 < r3; t3++)
        e3[t3] = 0;
    }
    function m2(e3) {
      _2(e3, 0);
    }
    function _2(r3, i3) {
      const s3 = c2.newAttributes, o3 = c2.enabledAttributes, a3 = c2.attributeDivisors;
      s3[r3] = 1, 0 === o3[r3] && (e2.enableVertexAttribArray(r3), o3[r3] = 1), a3[r3] !== i3 && ((n2.isWebGL2 ? e2 : t2.get("ANGLE_instanced_arrays"))[n2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](r3, i3), a3[r3] = i3);
    }
    function g2() {
      const t3 = c2.newAttributes, r3 = c2.enabledAttributes;
      for (let n3 = 0, i3 = r3.length; n3 < i3; n3++)
        r3[n3] !== t3[n3] && (e2.disableVertexAttribArray(n3), r3[n3] = 0);
    }
    function v2(t3, r3, i3, s3, o3, a3) {
      true !== n2.isWebGL2 || 5124 !== i3 && 5125 !== i3 ? e2.vertexAttribPointer(t3, r3, i3, s3, o3, a3) : e2.vertexAttribIPointer(t3, r3, i3, o3, a3);
    }
    function A2() {
      b2(), u2 = true, c2 !== l2 && (c2 = l2, h2(c2.object));
    }
    function b2() {
      l2.geometry = null, l2.program = null, l2.wireframe = false;
    }
    return { setup: function(i3, l3, p3, A3, b3) {
      let y2 = false;
      if (o2) {
        const t3 = function(t4, r3, i4) {
          const o3 = true === i4.wireframe;
          let l4 = a2[t4.id];
          void 0 === l4 && (l4 = {}, a2[t4.id] = l4);
          let c3 = l4[r3.id];
          void 0 === c3 && (c3 = {}, l4[r3.id] = c3);
          let u3 = c3[o3];
          return void 0 === u3 && (u3 = d2(n2.isWebGL2 ? e2.createVertexArray() : s2.createVertexArrayOES()), c3[o3] = u3), u3;
        }(A3, p3, l3);
        c2 !== t3 && (c2 = t3, h2(c2.object)), y2 = function(e3, t4, r3, n3) {
          const i4 = c2.attributes, s3 = t4.attributes;
          let o3 = 0;
          const a3 = r3.getAttributes();
          for (const t5 in a3)
            if (a3[t5].location >= 0) {
              const r4 = i4[t5];
              let n4 = s3[t5];
              if (void 0 === n4 && ("instanceMatrix" === t5 && e3.instanceMatrix && (n4 = e3.instanceMatrix), "instanceColor" === t5 && e3.instanceColor && (n4 = e3.instanceColor)), void 0 === r4)
                return true;
              if (r4.attribute !== n4)
                return true;
              if (n4 && r4.data !== n4.data)
                return true;
              o3++;
            }
          return c2.attributesNum !== o3 || c2.index !== n3;
        }(i3, A3, p3, b3), y2 && function(e3, t4, r3, n3) {
          const i4 = {}, s3 = t4.attributes;
          let o3 = 0;
          const a3 = r3.getAttributes();
          for (const t5 in a3)
            if (a3[t5].location >= 0) {
              let r4 = s3[t5];
              void 0 === r4 && ("instanceMatrix" === t5 && e3.instanceMatrix && (r4 = e3.instanceMatrix), "instanceColor" === t5 && e3.instanceColor && (r4 = e3.instanceColor));
              const n4 = {};
              n4.attribute = r4, r4 && r4.data && (n4.data = r4.data), i4[t5] = n4, o3++;
            }
          c2.attributes = i4, c2.attributesNum = o3, c2.index = n3;
        }(i3, A3, p3, b3);
      } else {
        const e3 = true === l3.wireframe;
        c2.geometry === A3.id && c2.program === p3.id && c2.wireframe === e3 || (c2.geometry = A3.id, c2.program = p3.id, c2.wireframe = e3, y2 = true);
      }
      null !== b3 && r2.update(b3, 34963), (y2 || u2) && (u2 = false, function(i4, s3, o3, a3) {
        if (false === n2.isWebGL2 && (i4.isInstancedMesh || a3.isInstancedBufferGeometry) && null === t2.get("ANGLE_instanced_arrays"))
          return;
        f2();
        const l4 = a3.attributes, c3 = o3.getAttributes(), u3 = s3.defaultAttributeValues;
        for (const t3 in c3) {
          const n3 = c3[t3];
          if (n3.location >= 0) {
            let s4 = l4[t3];
            if (void 0 === s4 && ("instanceMatrix" === t3 && i4.instanceMatrix && (s4 = i4.instanceMatrix), "instanceColor" === t3 && i4.instanceColor && (s4 = i4.instanceColor)), void 0 !== s4) {
              const t4 = s4.normalized, o4 = s4.itemSize, l5 = r2.get(s4);
              if (void 0 === l5)
                continue;
              const c4 = l5.buffer, u4 = l5.type, h3 = l5.bytesPerElement;
              if (s4.isInterleavedBufferAttribute) {
                const r3 = s4.data, l6 = r3.stride, p4 = s4.offset;
                if (r3.isInstancedInterleavedBuffer) {
                  for (let e3 = 0; e3 < n3.locationSize; e3++)
                    _2(n3.location + e3, r3.meshPerAttribute);
                  true !== i4.isInstancedMesh && void 0 === a3._maxInstanceCount && (a3._maxInstanceCount = r3.meshPerAttribute * r3.count);
                } else
                  for (let e3 = 0; e3 < n3.locationSize; e3++)
                    m2(n3.location + e3);
                e2.bindBuffer(34962, c4);
                for (let e3 = 0; e3 < n3.locationSize; e3++)
                  v2(n3.location + e3, o4 / n3.locationSize, u4, t4, l6 * h3, (p4 + o4 / n3.locationSize * e3) * h3);
              } else {
                if (s4.isInstancedBufferAttribute) {
                  for (let e3 = 0; e3 < n3.locationSize; e3++)
                    _2(n3.location + e3, s4.meshPerAttribute);
                  true !== i4.isInstancedMesh && void 0 === a3._maxInstanceCount && (a3._maxInstanceCount = s4.meshPerAttribute * s4.count);
                } else
                  for (let e3 = 0; e3 < n3.locationSize; e3++)
                    m2(n3.location + e3);
                e2.bindBuffer(34962, c4);
                for (let e3 = 0; e3 < n3.locationSize; e3++)
                  v2(n3.location + e3, o4 / n3.locationSize, u4, t4, o4 * h3, o4 / n3.locationSize * e3 * h3);
              }
            } else if (void 0 !== u3) {
              const r3 = u3[t3];
              if (void 0 !== r3)
                switch (r3.length) {
                  case 2:
                    e2.vertexAttrib2fv(n3.location, r3);
                    break;
                  case 3:
                    e2.vertexAttrib3fv(n3.location, r3);
                    break;
                  case 4:
                    e2.vertexAttrib4fv(n3.location, r3);
                    break;
                  default:
                    e2.vertexAttrib1fv(n3.location, r3);
                }
            }
          }
        }
        g2();
      }(i3, l3, p3, A3), null !== b3 && e2.bindBuffer(34963, r2.get(b3).buffer));
    }, reset: A2, resetDefaultState: b2, dispose: function() {
      A2();
      for (const e3 in a2) {
        const t3 = a2[e3];
        for (const e4 in t3) {
          const r3 = t3[e4];
          for (const e5 in r3)
            p2(r3[e5].object), delete r3[e5];
          delete t3[e4];
        }
        delete a2[e3];
      }
    }, releaseStatesOfGeometry: function(e3) {
      if (void 0 === a2[e3.id])
        return;
      const t3 = a2[e3.id];
      for (const e4 in t3) {
        const r3 = t3[e4];
        for (const e5 in r3)
          p2(r3[e5].object), delete r3[e5];
        delete t3[e4];
      }
      delete a2[e3.id];
    }, releaseStatesOfProgram: function(e3) {
      for (const t3 in a2) {
        const r3 = a2[t3];
        if (void 0 === r3[e3.id])
          continue;
        const n3 = r3[e3.id];
        for (const e4 in n3)
          p2(n3[e4].object), delete n3[e4];
        delete r3[e3.id];
      }
    }, initAttributes: f2, enableAttribute: m2, disableUnusedAttributes: g2 };
  }
  function Fs(e2, t2, r2, n2) {
    const i2 = n2.isWebGL2;
    let s2;
    this.setMode = function(e3) {
      s2 = e3;
    }, this.render = function(t3, n3) {
      e2.drawArrays(s2, t3, n3), r2.update(n3, s2, 1);
    }, this.renderInstances = function(n3, o2, a2) {
      if (0 === a2)
        return;
      let l2, c2;
      if (i2)
        l2 = e2, c2 = "drawArraysInstanced";
      else if (l2 = t2.get("ANGLE_instanced_arrays"), c2 = "drawArraysInstancedANGLE", null === l2)
        return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      l2[c2](s2, n3, o2, a2), r2.update(o2, s2, a2);
    };
  }
  function Us(e2, t2, r2) {
    let n2;
    function i2(t3) {
      if ("highp" === t3) {
        if (e2.getShaderPrecisionFormat(35633, 36338).precision > 0 && e2.getShaderPrecisionFormat(35632, 36338).precision > 0)
          return "highp";
        t3 = "mediump";
      }
      return "mediump" === t3 && e2.getShaderPrecisionFormat(35633, 36337).precision > 0 && e2.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
    }
    const s2 = "undefined" != typeof WebGL2RenderingContext && e2 instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e2 instanceof WebGL2ComputeRenderingContext;
    let o2 = void 0 !== r2.precision ? r2.precision : "highp";
    const a2 = i2(o2);
    a2 !== o2 && (console.warn("THREE.WebGLRenderer:", o2, "not supported, using", a2, "instead."), o2 = a2);
    const l2 = s2 || t2.has("WEBGL_draw_buffers"), c2 = true === r2.logarithmicDepthBuffer, u2 = e2.getParameter(34930), h2 = e2.getParameter(35660), p2 = e2.getParameter(3379), d2 = e2.getParameter(34076), f2 = e2.getParameter(34921), m2 = e2.getParameter(36347), _2 = e2.getParameter(36348), g2 = e2.getParameter(36349), v2 = h2 > 0, A2 = s2 || t2.has("OES_texture_float");
    return { isWebGL2: s2, drawBuffers: l2, getMaxAnisotropy: function() {
      if (void 0 !== n2)
        return n2;
      if (true === t2.has("EXT_texture_filter_anisotropic")) {
        const r3 = t2.get("EXT_texture_filter_anisotropic");
        n2 = e2.getParameter(r3.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else
        n2 = 0;
      return n2;
    }, getMaxPrecision: i2, precision: o2, logarithmicDepthBuffer: c2, maxTextures: u2, maxVertexTextures: h2, maxTextureSize: p2, maxCubemapSize: d2, maxAttributes: f2, maxVertexUniforms: m2, maxVaryings: _2, maxFragmentUniforms: g2, vertexTextures: v2, floatFragmentTextures: A2, floatVertexTextures: v2 && A2, maxSamples: s2 ? e2.getParameter(36183) : 0 };
  }
  function Ns(e2) {
    const t2 = this;
    let r2 = null, n2 = 0, i2 = false, s2 = false;
    const o2 = new Ss(), a2 = new Dr(), l2 = { value: null, needsUpdate: false };
    function c2() {
      l2.value !== r2 && (l2.value = r2, l2.needsUpdate = n2 > 0), t2.numPlanes = n2, t2.numIntersection = 0;
    }
    function u2(e3, r3, n3, i3) {
      const s3 = null !== e3 ? e3.length : 0;
      let c3 = null;
      if (0 !== s3) {
        if (c3 = l2.value, true !== i3 || null === c3) {
          const t3 = n3 + 4 * s3, i4 = r3.matrixWorldInverse;
          a2.getNormalMatrix(i4), (null === c3 || c3.length < t3) && (c3 = new Float32Array(t3));
          for (let t4 = 0, r4 = n3; t4 !== s3; ++t4, r4 += 4)
            o2.copy(e3[t4]).applyMatrix4(i4, a2), o2.normal.toArray(c3, r4), c3[r4 + 3] = o2.constant;
        }
        l2.value = c3, l2.needsUpdate = true;
      }
      return t2.numPlanes = s3, t2.numIntersection = 0, c3;
    }
    this.uniform = l2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e3, t3, s3) {
      const o3 = 0 !== e3.length || t3 || 0 !== n2 || i2;
      return i2 = t3, r2 = u2(e3, s3, 0), n2 = e3.length, o3;
    }, this.beginShadows = function() {
      s2 = true, u2(null);
    }, this.endShadows = function() {
      s2 = false, c2();
    }, this.setState = function(t3, o3, a3) {
      const h2 = t3.clippingPlanes, p2 = t3.clipIntersection, d2 = t3.clipShadows, f2 = e2.get(t3);
      if (!i2 || null === h2 || 0 === h2.length || s2 && !d2)
        s2 ? u2(null) : c2();
      else {
        const e3 = s2 ? 0 : n2, t4 = 4 * e3;
        let i3 = f2.clippingState || null;
        l2.value = i3, i3 = u2(h2, o3, t4, a3);
        for (let e4 = 0; e4 !== t4; ++e4)
          i3[e4] = r2[e4];
        f2.clippingState = i3, this.numIntersection = p2 ? this.numPlanes : 0, this.numPlanes += e3;
      }
    };
  }
  function js(e2) {
    let t2 = /* @__PURE__ */ new WeakMap();
    function r2(e3, t3) {
      return t3 === se ? e3.mapping = ne : t3 === oe && (e3.mapping = ie), e3;
    }
    function n2(e3) {
      const r3 = e3.target;
      r3.removeEventListener("dispose", n2);
      const i2 = t2.get(r3);
      void 0 !== i2 && (t2.delete(r3), i2.dispose());
    }
    return { get: function(i2) {
      if (i2 && i2.isTexture && false === i2.isRenderTargetTexture) {
        const s2 = i2.mapping;
        if (s2 === se || s2 === oe) {
          if (t2.has(i2)) {
            const e3 = t2.get(i2).texture;
            return e3.rotation = i2.rotation, r2(e3, i2.mapping);
          }
          {
            const s3 = i2.image;
            if (s3 && s3.height > 0) {
              const o2 = new ys(s3.height / 2);
              return o2.fromEquirectangularTexture(e2, i2), o2.texture.rotation = i2.rotation, t2.set(i2, o2), i2.addEventListener("dispose", n2), r2(o2.texture, i2.mapping);
            }
            return null;
          }
        }
      }
      return i2;
    }, dispose: function() {
      t2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  Rs.physical = { uniforms: ds([Rs.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new kr(1, 1) }, clearcoatNormalMap: { value: null }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new Wr(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new kr() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Wr(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new Wr(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: Ps.meshphysical_vert, fragmentShader: Ps.meshphysical_frag };
  class zs extends _s {
    constructor(e2 = -1, t2 = 1, r2 = 1, n2 = -1, i2 = 0.1, s2 = 2e3) {
      super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e2, this.right = t2, this.top = r2, this.bottom = n2, this.near = i2, this.far = s2, this.updateProjectionMatrix();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.left = e2.left, this.right = e2.right, this.top = e2.top, this.bottom = e2.bottom, this.near = e2.near, this.far = e2.far, this.zoom = e2.zoom, this.view = null === e2.view ? null : Object.assign({}, e2.view), this;
    }
    setViewOffset(e2, t2, r2, n2, i2, s2) {
      null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e2, this.view.fullHeight = t2, this.view.offsetX = r2, this.view.offsetY = n2, this.view.width = i2, this.view.height = s2, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const e2 = (this.right - this.left) / (2 * this.zoom), t2 = (this.top - this.bottom) / (2 * this.zoom), r2 = (this.right + this.left) / 2, n2 = (this.top + this.bottom) / 2;
      let i2 = r2 - e2, s2 = r2 + e2, o2 = n2 + t2, a2 = n2 - t2;
      if (null !== this.view && this.view.enabled) {
        const e3 = (this.right - this.left) / this.view.fullWidth / this.zoom, t3 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        i2 += e3 * this.view.offsetX, s2 = i2 + e3 * this.view.width, o2 -= t3 * this.view.offsetY, a2 = o2 - t3 * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(i2, s2, o2, a2, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.zoom = this.zoom, t2.object.left = this.left, t2.object.right = this.right, t2.object.top = this.top, t2.object.bottom = this.bottom, t2.object.near = this.near, t2.object.far = this.far, null !== this.view && (t2.object.view = Object.assign({}, this.view)), t2;
    }
  }
  const Gs = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Vs = new zs(), Qs = new Wr();
  let Hs = null;
  const Ws = (1 + Math.sqrt(5)) / 2, qs = 1 / Ws, Xs = [new ln(1, 1, 1), new ln(-1, 1, 1), new ln(1, 1, -1), new ln(-1, 1, -1), new ln(0, Ws, qs), new ln(0, Ws, -qs), new ln(qs, 0, Ws), new ln(-qs, 0, Ws), new ln(Ws, qs, 0), new ln(-Ws, qs, 0)];
  class Ys {
    constructor(e2) {
      this._renderer = e2, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
    }
    fromScene(e2, t2 = 0, r2 = 0.1, n2 = 100) {
      Hs = this._renderer.getRenderTarget(), this._setSize(256);
      const i2 = this._allocateTargets();
      return i2.depthBuffer = true, this._sceneToCubeUV(e2, r2, n2, i2), t2 > 0 && this._blur(i2, 0, 0, t2), this._applyPMREM(i2), this._cleanup(i2), i2;
    }
    fromEquirectangular(e2, t2 = null) {
      return this._fromTexture(e2, t2);
    }
    fromCubemap(e2, t2 = null) {
      return this._fromTexture(e2, t2);
    }
    compileCubemapShader() {
      null === this._cubemapMaterial && (this._cubemapMaterial = $s(), this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      null === this._equirectMaterial && (this._equirectMaterial = Zs(), this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose();
    }
    _setSize(e2) {
      this._lodMax = Math.floor(Math.log2(e2)), this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
      null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
      for (let e2 = 0; e2 < this._lodPlanes.length; e2++)
        this._lodPlanes[e2].dispose();
    }
    _cleanup(e2) {
      this._renderer.setRenderTarget(Hs), e2.scissorTest = false, Js(e2, 0, 0, e2.width, e2.height);
    }
    _fromTexture(e2, t2) {
      e2.mapping === ne || e2.mapping === ie ? this._setSize(0 === e2.image.length ? 16 : e2.image[0].width || e2.image[0].image.width) : this._setSize(e2.image.width / 4), Hs = this._renderer.getRenderTarget();
      const r2 = t2 || this._allocateTargets();
      return this._textureToCubeUV(e2, r2), this._applyPMREM(r2), this._cleanup(r2), r2;
    }
    _allocateTargets() {
      const e2 = 3 * Math.max(this._cubeSize, 112), t2 = 4 * this._cubeSize, r2 = { magFilter: _e, minFilter: _e, generateMipmaps: false, type: Te, format: Re, encoding: kt, depthBuffer: false }, n2 = Ks(e2, t2, r2);
      if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e2) {
        null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Ks(e2, t2, r2);
        const { _lodMax: n3 } = this;
        ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function(e3) {
          const t3 = [], r3 = [], n4 = [];
          let i2 = e3;
          const s2 = e3 - 4 + 1 + Gs.length;
          for (let o2 = 0; o2 < s2; o2++) {
            const s3 = Math.pow(2, i2);
            r3.push(s3);
            let a2 = 1 / s3;
            o2 > e3 - 4 ? a2 = Gs[o2 - e3 + 4 - 1] : 0 === o2 && (a2 = 0), n4.push(a2);
            const l2 = 1 / (s3 - 2), c2 = -l2, u2 = 1 + l2, h2 = [c2, c2, u2, c2, u2, u2, c2, c2, u2, u2, c2, u2], p2 = 6, d2 = 6, f2 = 3, m2 = 2, _2 = 1, g2 = new Float32Array(f2 * d2 * p2), v2 = new Float32Array(m2 * d2 * p2), A2 = new Float32Array(_2 * d2 * p2);
            for (let e4 = 0; e4 < p2; e4++) {
              const t4 = e4 % 3 * 2 / 3 - 1, r4 = e4 > 2 ? 0 : -1, n5 = [t4, r4, 0, t4 + 2 / 3, r4, 0, t4 + 2 / 3, r4 + 1, 0, t4, r4, 0, t4 + 2 / 3, r4 + 1, 0, t4, r4 + 1, 0];
              g2.set(n5, f2 * d2 * e4), v2.set(h2, m2 * d2 * e4);
              const i3 = [e4, e4, e4, e4, e4, e4];
              A2.set(i3, _2 * d2 * e4);
            }
            const b2 = new Hi();
            b2.setAttribute("position", new Mi(g2, f2)), b2.setAttribute("uv", new Mi(v2, m2)), b2.setAttribute("faceIndex", new Mi(A2, _2)), t3.push(b2), i2 > 4 && i2--;
          }
          return { lodPlanes: t3, sizeLods: r3, sigmas: n4 };
        }(n3)), this._blurMaterial = function(e3, t3, r3) {
          const n4 = new Float32Array(20), i2 = new ln(0, 1, 0);
          return new ms({ name: "SphericalGaussianBlur", defines: { n: 20, CUBEUV_TEXEL_WIDTH: 1 / t3, CUBEUV_TEXEL_HEIGHT: 1 / r3, CUBEUV_MAX_MIP: `${e3}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: n4 }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: i2 } }, vertexShader: "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	", fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n			}\n		", blending: g, depthTest: false, depthWrite: false });
        }(n3, e2, t2);
      }
      return n2;
    }
    _compileMaterial(e2) {
      const t2 = new cs(this._lodPlanes[0], e2);
      this._renderer.compile(t2, Vs);
    }
    _sceneToCubeUV(e2, t2, r2, n2) {
      const i2 = new gs(90, 1, t2, r2), s2 = [1, -1, 1, 1, 1, 1], o2 = [1, 1, 1, -1, -1, -1], a2 = this._renderer, l2 = a2.autoClear, c2 = a2.toneMapping;
      a2.getClearColor(Qs), a2.toneMapping = K, a2.autoClear = false;
      const u2 = new Ei({ name: "PMREM.Background", side: m, depthWrite: false, depthTest: false }), h2 = new cs(new hs(), u2);
      let p2 = false;
      const d2 = e2.background;
      d2 ? d2.isColor && (u2.color.copy(d2), e2.background = null, p2 = true) : (u2.color.copy(Qs), p2 = true);
      for (let t3 = 0; t3 < 6; t3++) {
        const r3 = t3 % 3;
        0 === r3 ? (i2.up.set(0, s2[t3], 0), i2.lookAt(o2[t3], 0, 0)) : 1 === r3 ? (i2.up.set(0, 0, s2[t3]), i2.lookAt(0, o2[t3], 0)) : (i2.up.set(0, s2[t3], 0), i2.lookAt(0, 0, o2[t3]));
        const l3 = this._cubeSize;
        Js(n2, r3 * l3, t3 > 2 ? l3 : 0, l3, l3), a2.setRenderTarget(n2), p2 && a2.render(h2, i2), a2.render(e2, i2);
      }
      h2.geometry.dispose(), h2.material.dispose(), a2.toneMapping = c2, a2.autoClear = l2, e2.background = d2;
    }
    _textureToCubeUV(e2, t2) {
      const r2 = this._renderer, n2 = e2.mapping === ne || e2.mapping === ie;
      n2 ? (null === this._cubemapMaterial && (this._cubemapMaterial = $s()), this._cubemapMaterial.uniforms.flipEnvMap.value = false === e2.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Zs());
      const i2 = n2 ? this._cubemapMaterial : this._equirectMaterial, s2 = new cs(this._lodPlanes[0], i2);
      i2.uniforms.envMap.value = e2;
      const o2 = this._cubeSize;
      Js(t2, 0, 0, 3 * o2, 2 * o2), r2.setRenderTarget(t2), r2.render(s2, Vs);
    }
    _applyPMREM(e2) {
      const t2 = this._renderer, r2 = t2.autoClear;
      t2.autoClear = false;
      for (let t3 = 1; t3 < this._lodPlanes.length; t3++) {
        const r3 = Math.sqrt(this._sigmas[t3] * this._sigmas[t3] - this._sigmas[t3 - 1] * this._sigmas[t3 - 1]), n2 = Xs[(t3 - 1) % Xs.length];
        this._blur(e2, t3 - 1, t3, r3, n2);
      }
      t2.autoClear = r2;
    }
    _blur(e2, t2, r2, n2, i2) {
      const s2 = this._pingPongRenderTarget;
      this._halfBlur(e2, s2, t2, r2, n2, "latitudinal", i2), this._halfBlur(s2, e2, r2, r2, n2, "longitudinal", i2);
    }
    _halfBlur(e2, t2, r2, n2, i2, s2, o2) {
      const a2 = this._renderer, l2 = this._blurMaterial;
      "latitudinal" !== s2 && "longitudinal" !== s2 && console.error("blur direction must be either latitudinal or longitudinal!");
      const c2 = new cs(this._lodPlanes[n2], l2), u2 = l2.uniforms, h2 = this._sizeLods[r2] - 1, p2 = isFinite(i2) ? Math.PI / (2 * h2) : 2 * Math.PI / 39, d2 = i2 / p2, f2 = isFinite(i2) ? 1 + Math.floor(3 * d2) : 20;
      f2 > 20 && console.warn(`sigmaRadians, ${i2}, is too large and will clip, as it requested ${f2} samples when the maximum is set to 20`);
      const m2 = [];
      let _2 = 0;
      for (let e3 = 0; e3 < 20; ++e3) {
        const t3 = e3 / d2, r3 = Math.exp(-t3 * t3 / 2);
        m2.push(r3), 0 === e3 ? _2 += r3 : e3 < f2 && (_2 += 2 * r3);
      }
      for (let e3 = 0; e3 < m2.length; e3++)
        m2[e3] = m2[e3] / _2;
      u2.envMap.value = e2.texture, u2.samples.value = f2, u2.weights.value = m2, u2.latitudinal.value = "latitudinal" === s2, o2 && (u2.poleAxis.value = o2);
      const { _lodMax: g2 } = this;
      u2.dTheta.value = p2, u2.mipInt.value = g2 - r2;
      const v2 = this._sizeLods[n2];
      Js(t2, 3 * v2 * (n2 > g2 - 4 ? n2 - g2 + 4 : 0), 4 * (this._cubeSize - v2), 3 * v2, 2 * v2), a2.setRenderTarget(t2), a2.render(c2, Vs);
    }
  }
  function Ks(e2, t2, r2) {
    const n2 = new en(e2, t2, r2);
    return n2.texture.mapping = ae, n2.texture.name = "PMREM.cubeUv", n2.scissorTest = true, n2;
  }
  function Js(e2, t2, r2, n2, i2) {
    e2.viewport.set(t2, r2, n2, i2), e2.scissor.set(t2, r2, n2, i2);
  }
  function Zs() {
    return new ms({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	", fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n\n			#include <common>\n\n			void main() {\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n			}\n		", blending: g, depthTest: false, depthWrite: false });
  }
  function $s() {
    return new ms({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	", fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			uniform float flipEnvMap;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			void main() {\n\n				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n			}\n		", blending: g, depthTest: false, depthWrite: false });
  }
  function eo(e2) {
    let t2 = /* @__PURE__ */ new WeakMap(), r2 = null;
    function n2(e3) {
      const r3 = e3.target;
      r3.removeEventListener("dispose", n2);
      const i2 = t2.get(r3);
      void 0 !== i2 && (t2.delete(r3), i2.dispose());
    }
    return { get: function(i2) {
      if (i2 && i2.isTexture) {
        const s2 = i2.mapping, o2 = s2 === se || s2 === oe, a2 = s2 === ne || s2 === ie;
        if (o2 || a2) {
          if (i2.isRenderTargetTexture && true === i2.needsPMREMUpdate) {
            i2.needsPMREMUpdate = false;
            let n3 = t2.get(i2);
            return null === r2 && (r2 = new Ys(e2)), n3 = o2 ? r2.fromEquirectangular(i2, n3) : r2.fromCubemap(i2, n3), t2.set(i2, n3), n3.texture;
          }
          if (t2.has(i2))
            return t2.get(i2).texture;
          {
            const s3 = i2.image;
            if (o2 && s3 && s3.height > 0 || a2 && s3 && function(e3) {
              let t3 = 0;
              for (let r3 = 0; r3 < 6; r3++)
                void 0 !== e3[r3] && t3++;
              return 6 === t3;
            }(s3)) {
              null === r2 && (r2 = new Ys(e2));
              const s4 = o2 ? r2.fromEquirectangular(i2) : r2.fromCubemap(i2);
              return t2.set(i2, s4), i2.addEventListener("dispose", n2), s4.texture;
            }
            return null;
          }
        }
      }
      return i2;
    }, dispose: function() {
      t2 = /* @__PURE__ */ new WeakMap(), null !== r2 && (r2.dispose(), r2 = null);
    } };
  }
  function to(e2) {
    const t2 = {};
    function r2(r3) {
      if (void 0 !== t2[r3])
        return t2[r3];
      let n2;
      switch (r3) {
        case "WEBGL_depth_texture":
          n2 = e2.getExtension("WEBGL_depth_texture") || e2.getExtension("MOZ_WEBGL_depth_texture") || e2.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          n2 = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          n2 = e2.getExtension("WEBGL_compressed_texture_s3tc") || e2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          n2 = e2.getExtension("WEBGL_compressed_texture_pvrtc") || e2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          n2 = e2.getExtension(r3);
      }
      return t2[r3] = n2, n2;
    }
    return { has: function(e3) {
      return null !== r2(e3);
    }, init: function(e3) {
      e3.isWebGL2 ? r2("EXT_color_buffer_float") : (r2("WEBGL_depth_texture"), r2("OES_texture_float"), r2("OES_texture_half_float"), r2("OES_texture_half_float_linear"), r2("OES_standard_derivatives"), r2("OES_element_index_uint"), r2("OES_vertex_array_object"), r2("ANGLE_instanced_arrays")), r2("OES_texture_float_linear"), r2("EXT_color_buffer_half_float"), r2("WEBGL_multisampled_render_to_texture");
    }, get: function(e3) {
      const t3 = r2(e3);
      return null === t3 && console.warn("THREE.WebGLRenderer: " + e3 + " extension not supported."), t3;
    } };
  }
  function ro(e2, t2, r2, n2) {
    const i2 = {}, s2 = /* @__PURE__ */ new WeakMap();
    function o2(e3) {
      const a3 = e3.target;
      null !== a3.index && t2.remove(a3.index);
      for (const e4 in a3.attributes)
        t2.remove(a3.attributes[e4]);
      a3.removeEventListener("dispose", o2), delete i2[a3.id];
      const l2 = s2.get(a3);
      l2 && (t2.remove(l2), s2.delete(a3)), n2.releaseStatesOfGeometry(a3), true === a3.isInstancedBufferGeometry && delete a3._maxInstanceCount, r2.memory.geometries--;
    }
    function a2(e3) {
      const r3 = [], n3 = e3.index, i3 = e3.attributes.position;
      let o3 = 0;
      if (null !== n3) {
        const e4 = n3.array;
        o3 = n3.version;
        for (let t3 = 0, n4 = e4.length; t3 < n4; t3 += 3) {
          const n5 = e4[t3 + 0], i4 = e4[t3 + 1], s3 = e4[t3 + 2];
          r3.push(n5, i4, i4, s3, s3, n5);
        }
      } else {
        const e4 = i3.array;
        o3 = i3.version;
        for (let t3 = 0, n4 = e4.length / 3 - 1; t3 < n4; t3 += 3) {
          const e5 = t3 + 0, n5 = t3 + 1, i4 = t3 + 2;
          r3.push(e5, n5, n5, i4, i4, e5);
        }
      }
      const a3 = new (Pr(r3) ? Ri : Pi)(r3, 1);
      a3.version = o3;
      const l2 = s2.get(e3);
      l2 && t2.remove(l2), s2.set(e3, a3);
    }
    return { get: function(e3, t3) {
      return true === i2[t3.id] || (t3.addEventListener("dispose", o2), i2[t3.id] = true, r2.memory.geometries++), t3;
    }, update: function(e3) {
      const r3 = e3.attributes;
      for (const e4 in r3)
        t2.update(r3[e4], 34962);
      const n3 = e3.morphAttributes;
      for (const e4 in n3) {
        const r4 = n3[e4];
        for (let e5 = 0, n4 = r4.length; e5 < n4; e5++)
          t2.update(r4[e5], 34962);
      }
    }, getWireframeAttribute: function(e3) {
      const t3 = s2.get(e3);
      if (t3) {
        const r3 = e3.index;
        null !== r3 && t3.version < r3.version && a2(e3);
      } else
        a2(e3);
      return s2.get(e3);
    } };
  }
  function no(e2, t2, r2, n2) {
    const i2 = n2.isWebGL2;
    let s2, o2, a2;
    this.setMode = function(e3) {
      s2 = e3;
    }, this.setIndex = function(e3) {
      o2 = e3.type, a2 = e3.bytesPerElement;
    }, this.render = function(t3, n3) {
      e2.drawElements(s2, n3, o2, t3 * a2), r2.update(n3, s2, 1);
    }, this.renderInstances = function(n3, l2, c2) {
      if (0 === c2)
        return;
      let u2, h2;
      if (i2)
        u2 = e2, h2 = "drawElementsInstanced";
      else if (u2 = t2.get("ANGLE_instanced_arrays"), h2 = "drawElementsInstancedANGLE", null === u2)
        return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      u2[h2](s2, l2, o2, n3 * a2, c2), r2.update(l2, s2, c2);
    };
  }
  function io(e2) {
    const t2 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return { memory: { geometries: 0, textures: 0 }, render: t2, programs: null, autoReset: true, reset: function() {
      t2.frame++, t2.calls = 0, t2.triangles = 0, t2.points = 0, t2.lines = 0;
    }, update: function(e3, r2, n2) {
      switch (t2.calls++, r2) {
        case 4:
          t2.triangles += n2 * (e3 / 3);
          break;
        case 1:
          t2.lines += n2 * (e3 / 2);
          break;
        case 3:
          t2.lines += n2 * (e3 - 1);
          break;
        case 2:
          t2.lines += n2 * e3;
          break;
        case 0:
          t2.points += n2 * e3;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", r2);
      }
    } };
  }
  function so(e2, t2) {
    return e2[0] - t2[0];
  }
  function oo(e2, t2) {
    return Math.abs(t2[1]) - Math.abs(e2[1]);
  }
  function ao(e2, t2, r2) {
    const n2 = {}, i2 = new Float32Array(8), s2 = /* @__PURE__ */ new WeakMap(), o2 = new $r(), a2 = [];
    for (let e3 = 0; e3 < 8; e3++)
      a2[e3] = [e3, 0];
    return { update: function(l2, c2, u2, h2) {
      const p2 = l2.morphTargetInfluences;
      if (true === t2.isWebGL2) {
        const n3 = c2.morphAttributes.position || c2.morphAttributes.normal || c2.morphAttributes.color, i3 = void 0 !== n3 ? n3.length : 0;
        let a3 = s2.get(c2);
        if (void 0 === a3 || a3.count !== i3) {
          void 0 !== a3 && a3.texture.dispose();
          const e3 = void 0 !== c2.morphAttributes.position, r3 = void 0 !== c2.morphAttributes.normal, n4 = void 0 !== c2.morphAttributes.color, l4 = c2.morphAttributes.position || [], u4 = c2.morphAttributes.normal || [], h3 = c2.morphAttributes.color || [];
          let p3 = 0;
          true === e3 && (p3 = 1), true === r3 && (p3 = 2), true === n4 && (p3 = 3);
          let d2 = c2.attributes.position.count * p3, f2 = 1;
          d2 > t2.maxTextureSize && (f2 = Math.ceil(d2 / t2.maxTextureSize), d2 = t2.maxTextureSize);
          const m2 = new Float32Array(d2 * f2 * 4 * i3), _2 = new tn(m2, d2, f2, i3);
          _2.type = Me, _2.needsUpdate = true;
          const g2 = 4 * p3;
          for (let t3 = 0; t3 < i3; t3++) {
            const i4 = l4[t3], s3 = u4[t3], a4 = h3[t3], c3 = d2 * f2 * 4 * t3;
            for (let t4 = 0; t4 < i4.count; t4++) {
              const l5 = t4 * g2;
              true === e3 && (o2.fromBufferAttribute(i4, t4), m2[c3 + l5 + 0] = o2.x, m2[c3 + l5 + 1] = o2.y, m2[c3 + l5 + 2] = o2.z, m2[c3 + l5 + 3] = 0), true === r3 && (o2.fromBufferAttribute(s3, t4), m2[c3 + l5 + 4] = o2.x, m2[c3 + l5 + 5] = o2.y, m2[c3 + l5 + 6] = o2.z, m2[c3 + l5 + 7] = 0), true === n4 && (o2.fromBufferAttribute(a4, t4), m2[c3 + l5 + 8] = o2.x, m2[c3 + l5 + 9] = o2.y, m2[c3 + l5 + 10] = o2.z, m2[c3 + l5 + 11] = 4 === a4.itemSize ? o2.w : 1);
            }
          }
          a3 = { count: i3, texture: _2, size: new kr(d2, f2) }, s2.set(c2, a3), c2.addEventListener("dispose", function e4() {
            _2.dispose(), s2.delete(c2), c2.removeEventListener("dispose", e4);
          });
        }
        let l3 = 0;
        for (let e3 = 0; e3 < p2.length; e3++)
          l3 += p2[e3];
        const u3 = c2.morphTargetsRelative ? 1 : 1 - l3;
        h2.getUniforms().setValue(e2, "morphTargetBaseInfluence", u3), h2.getUniforms().setValue(e2, "morphTargetInfluences", p2), h2.getUniforms().setValue(e2, "morphTargetsTexture", a3.texture, r2), h2.getUniforms().setValue(e2, "morphTargetsTextureSize", a3.size);
      } else {
        const t3 = void 0 === p2 ? 0 : p2.length;
        let r3 = n2[c2.id];
        if (void 0 === r3 || r3.length !== t3) {
          r3 = [];
          for (let e3 = 0; e3 < t3; e3++)
            r3[e3] = [e3, 0];
          n2[c2.id] = r3;
        }
        for (let e3 = 0; e3 < t3; e3++) {
          const t4 = r3[e3];
          t4[0] = e3, t4[1] = p2[e3];
        }
        r3.sort(oo);
        for (let e3 = 0; e3 < 8; e3++)
          e3 < t3 && r3[e3][1] ? (a2[e3][0] = r3[e3][0], a2[e3][1] = r3[e3][1]) : (a2[e3][0] = Number.MAX_SAFE_INTEGER, a2[e3][1] = 0);
        a2.sort(so);
        const s3 = c2.morphAttributes.position, o3 = c2.morphAttributes.normal;
        let l3 = 0;
        for (let e3 = 0; e3 < 8; e3++) {
          const t4 = a2[e3], r4 = t4[0], n3 = t4[1];
          r4 !== Number.MAX_SAFE_INTEGER && n3 ? (s3 && c2.getAttribute("morphTarget" + e3) !== s3[r4] && c2.setAttribute("morphTarget" + e3, s3[r4]), o3 && c2.getAttribute("morphNormal" + e3) !== o3[r4] && c2.setAttribute("morphNormal" + e3, o3[r4]), i2[e3] = n3, l3 += n3) : (s3 && true === c2.hasAttribute("morphTarget" + e3) && c2.deleteAttribute("morphTarget" + e3), o3 && true === c2.hasAttribute("morphNormal" + e3) && c2.deleteAttribute("morphNormal" + e3), i2[e3] = 0);
        }
        const u3 = c2.morphTargetsRelative ? 1 : 1 - l3;
        h2.getUniforms().setValue(e2, "morphTargetBaseInfluence", u3), h2.getUniforms().setValue(e2, "morphTargetInfluences", i2);
      }
    } };
  }
  function lo(e2, t2, r2, n2) {
    let i2 = /* @__PURE__ */ new WeakMap();
    function s2(e3) {
      const t3 = e3.target;
      t3.removeEventListener("dispose", s2), r2.remove(t3.instanceMatrix), null !== t3.instanceColor && r2.remove(t3.instanceColor);
    }
    return { update: function(e3) {
      const o2 = n2.render.frame, a2 = e3.geometry, l2 = t2.get(e3, a2);
      return i2.get(l2) !== o2 && (t2.update(l2), i2.set(l2, o2)), e3.isInstancedMesh && (false === e3.hasEventListener("dispose", s2) && e3.addEventListener("dispose", s2), r2.update(e3.instanceMatrix, 34962), null !== e3.instanceColor && r2.update(e3.instanceColor, 34962)), l2;
    }, dispose: function() {
      i2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  const co = new Zr(), uo = new tn(), ho = new nn(), po = new bs(), fo = [], mo = [], _o = new Float32Array(16), go = new Float32Array(9), vo = new Float32Array(4);
  function Ao(e2, t2, r2) {
    const n2 = e2[0];
    if (n2 <= 0 || n2 > 0)
      return e2;
    const i2 = t2 * r2;
    let s2 = fo[i2];
    if (void 0 === s2 && (s2 = new Float32Array(i2), fo[i2] = s2), 0 !== t2) {
      n2.toArray(s2, 0);
      for (let n3 = 1, i3 = 0; n3 !== t2; ++n3)
        i3 += r2, e2[n3].toArray(s2, i3);
    }
    return s2;
  }
  function bo(e2, t2) {
    if (e2.length !== t2.length)
      return false;
    for (let r2 = 0, n2 = e2.length; r2 < n2; r2++)
      if (e2[r2] !== t2[r2])
        return false;
    return true;
  }
  function yo(e2, t2) {
    for (let r2 = 0, n2 = t2.length; r2 < n2; r2++)
      e2[r2] = t2[r2];
  }
  function xo(e2, t2) {
    let r2 = mo[t2];
    void 0 === r2 && (r2 = new Int32Array(t2), mo[t2] = r2);
    for (let n2 = 0; n2 !== t2; ++n2)
      r2[n2] = e2.allocateTextureUnit();
    return r2;
  }
  function wo(e2, t2) {
    const r2 = this.cache;
    r2[0] !== t2 && (e2.uniform1f(this.addr, t2), r2[0] = t2);
  }
  function Eo(e2, t2) {
    const r2 = this.cache;
    if (void 0 !== t2.x)
      r2[0] === t2.x && r2[1] === t2.y || (e2.uniform2f(this.addr, t2.x, t2.y), r2[0] = t2.x, r2[1] = t2.y);
    else {
      if (bo(r2, t2))
        return;
      e2.uniform2fv(this.addr, t2), yo(r2, t2);
    }
  }
  function So(e2, t2) {
    const r2 = this.cache;
    if (void 0 !== t2.x)
      r2[0] === t2.x && r2[1] === t2.y && r2[2] === t2.z || (e2.uniform3f(this.addr, t2.x, t2.y, t2.z), r2[0] = t2.x, r2[1] = t2.y, r2[2] = t2.z);
    else if (void 0 !== t2.r)
      r2[0] === t2.r && r2[1] === t2.g && r2[2] === t2.b || (e2.uniform3f(this.addr, t2.r, t2.g, t2.b), r2[0] = t2.r, r2[1] = t2.g, r2[2] = t2.b);
    else {
      if (bo(r2, t2))
        return;
      e2.uniform3fv(this.addr, t2), yo(r2, t2);
    }
  }
  function Co(e2, t2) {
    const r2 = this.cache;
    if (void 0 !== t2.x)
      r2[0] === t2.x && r2[1] === t2.y && r2[2] === t2.z && r2[3] === t2.w || (e2.uniform4f(this.addr, t2.x, t2.y, t2.z, t2.w), r2[0] = t2.x, r2[1] = t2.y, r2[2] = t2.z, r2[3] = t2.w);
    else {
      if (bo(r2, t2))
        return;
      e2.uniform4fv(this.addr, t2), yo(r2, t2);
    }
  }
  function Mo(e2, t2) {
    const r2 = this.cache, n2 = t2.elements;
    if (void 0 === n2) {
      if (bo(r2, t2))
        return;
      e2.uniformMatrix2fv(this.addr, false, t2), yo(r2, t2);
    } else {
      if (bo(r2, n2))
        return;
      vo.set(n2), e2.uniformMatrix2fv(this.addr, false, vo), yo(r2, n2);
    }
  }
  function To(e2, t2) {
    const r2 = this.cache, n2 = t2.elements;
    if (void 0 === n2) {
      if (bo(r2, t2))
        return;
      e2.uniformMatrix3fv(this.addr, false, t2), yo(r2, t2);
    } else {
      if (bo(r2, n2))
        return;
      go.set(n2), e2.uniformMatrix3fv(this.addr, false, go), yo(r2, n2);
    }
  }
  function Io(e2, t2) {
    const r2 = this.cache, n2 = t2.elements;
    if (void 0 === n2) {
      if (bo(r2, t2))
        return;
      e2.uniformMatrix4fv(this.addr, false, t2), yo(r2, t2);
    } else {
      if (bo(r2, n2))
        return;
      _o.set(n2), e2.uniformMatrix4fv(this.addr, false, _o), yo(r2, n2);
    }
  }
  function ko(e2, t2) {
    const r2 = this.cache;
    r2[0] !== t2 && (e2.uniform1i(this.addr, t2), r2[0] = t2);
  }
  function Do(e2, t2) {
    const r2 = this.cache;
    bo(r2, t2) || (e2.uniform2iv(this.addr, t2), yo(r2, t2));
  }
  function Po(e2, t2) {
    const r2 = this.cache;
    bo(r2, t2) || (e2.uniform3iv(this.addr, t2), yo(r2, t2));
  }
  function Bo(e2, t2) {
    const r2 = this.cache;
    bo(r2, t2) || (e2.uniform4iv(this.addr, t2), yo(r2, t2));
  }
  function Ro(e2, t2) {
    const r2 = this.cache;
    r2[0] !== t2 && (e2.uniform1ui(this.addr, t2), r2[0] = t2);
  }
  function Lo(e2, t2) {
    const r2 = this.cache;
    bo(r2, t2) || (e2.uniform2uiv(this.addr, t2), yo(r2, t2));
  }
  function Oo(e2, t2) {
    const r2 = this.cache;
    bo(r2, t2) || (e2.uniform3uiv(this.addr, t2), yo(r2, t2));
  }
  function Fo(e2, t2) {
    const r2 = this.cache;
    bo(r2, t2) || (e2.uniform4uiv(this.addr, t2), yo(r2, t2));
  }
  function Uo(e2, t2, r2) {
    const n2 = this.cache, i2 = r2.allocateTextureUnit();
    n2[0] !== i2 && (e2.uniform1i(this.addr, i2), n2[0] = i2), r2.setTexture2D(t2 || co, i2);
  }
  function No(e2, t2, r2) {
    const n2 = this.cache, i2 = r2.allocateTextureUnit();
    n2[0] !== i2 && (e2.uniform1i(this.addr, i2), n2[0] = i2), r2.setTexture3D(t2 || ho, i2);
  }
  function jo(e2, t2, r2) {
    const n2 = this.cache, i2 = r2.allocateTextureUnit();
    n2[0] !== i2 && (e2.uniform1i(this.addr, i2), n2[0] = i2), r2.setTextureCube(t2 || po, i2);
  }
  function zo(e2, t2, r2) {
    const n2 = this.cache, i2 = r2.allocateTextureUnit();
    n2[0] !== i2 && (e2.uniform1i(this.addr, i2), n2[0] = i2), r2.setTexture2DArray(t2 || uo, i2);
  }
  function Go(e2, t2) {
    e2.uniform1fv(this.addr, t2);
  }
  function Vo(e2, t2) {
    const r2 = Ao(t2, this.size, 2);
    e2.uniform2fv(this.addr, r2);
  }
  function Qo(e2, t2) {
    const r2 = Ao(t2, this.size, 3);
    e2.uniform3fv(this.addr, r2);
  }
  function Ho(e2, t2) {
    const r2 = Ao(t2, this.size, 4);
    e2.uniform4fv(this.addr, r2);
  }
  function Wo(e2, t2) {
    const r2 = Ao(t2, this.size, 4);
    e2.uniformMatrix2fv(this.addr, false, r2);
  }
  function qo(e2, t2) {
    const r2 = Ao(t2, this.size, 9);
    e2.uniformMatrix3fv(this.addr, false, r2);
  }
  function Xo(e2, t2) {
    const r2 = Ao(t2, this.size, 16);
    e2.uniformMatrix4fv(this.addr, false, r2);
  }
  function Yo(e2, t2) {
    e2.uniform1iv(this.addr, t2);
  }
  function Ko(e2, t2) {
    e2.uniform2iv(this.addr, t2);
  }
  function Jo(e2, t2) {
    e2.uniform3iv(this.addr, t2);
  }
  function Zo(e2, t2) {
    e2.uniform4iv(this.addr, t2);
  }
  function $o(e2, t2) {
    e2.uniform1uiv(this.addr, t2);
  }
  function ea(e2, t2) {
    e2.uniform2uiv(this.addr, t2);
  }
  function ta(e2, t2) {
    e2.uniform3uiv(this.addr, t2);
  }
  function ra(e2, t2) {
    e2.uniform4uiv(this.addr, t2);
  }
  function na(e2, t2, r2) {
    const n2 = t2.length, i2 = xo(r2, n2);
    e2.uniform1iv(this.addr, i2);
    for (let e3 = 0; e3 !== n2; ++e3)
      r2.setTexture2D(t2[e3] || co, i2[e3]);
  }
  function ia(e2, t2, r2) {
    const n2 = t2.length, i2 = xo(r2, n2);
    e2.uniform1iv(this.addr, i2);
    for (let e3 = 0; e3 !== n2; ++e3)
      r2.setTexture3D(t2[e3] || ho, i2[e3]);
  }
  function sa(e2, t2, r2) {
    const n2 = t2.length, i2 = xo(r2, n2);
    e2.uniform1iv(this.addr, i2);
    for (let e3 = 0; e3 !== n2; ++e3)
      r2.setTextureCube(t2[e3] || po, i2[e3]);
  }
  function oa(e2, t2, r2) {
    const n2 = t2.length, i2 = xo(r2, n2);
    e2.uniform1iv(this.addr, i2);
    for (let e3 = 0; e3 !== n2; ++e3)
      r2.setTexture2DArray(t2[e3] || uo, i2[e3]);
  }
  class aa {
    constructor(e2, t2, r2) {
      this.id = e2, this.addr = r2, this.cache = [], this.setValue = function(e3) {
        switch (e3) {
          case 5126:
            return wo;
          case 35664:
            return Eo;
          case 35665:
            return So;
          case 35666:
            return Co;
          case 35674:
            return Mo;
          case 35675:
            return To;
          case 35676:
            return Io;
          case 5124:
          case 35670:
            return ko;
          case 35667:
          case 35671:
            return Do;
          case 35668:
          case 35672:
            return Po;
          case 35669:
          case 35673:
            return Bo;
          case 5125:
            return Ro;
          case 36294:
            return Lo;
          case 36295:
            return Oo;
          case 36296:
            return Fo;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return Uo;
          case 35679:
          case 36299:
          case 36307:
            return No;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return jo;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return zo;
        }
      }(t2.type);
    }
  }
  class la {
    constructor(e2, t2, r2) {
      this.id = e2, this.addr = r2, this.cache = [], this.size = t2.size, this.setValue = function(e3) {
        switch (e3) {
          case 5126:
            return Go;
          case 35664:
            return Vo;
          case 35665:
            return Qo;
          case 35666:
            return Ho;
          case 35674:
            return Wo;
          case 35675:
            return qo;
          case 35676:
            return Xo;
          case 5124:
          case 35670:
            return Yo;
          case 35667:
          case 35671:
            return Ko;
          case 35668:
          case 35672:
            return Jo;
          case 35669:
          case 35673:
            return Zo;
          case 5125:
            return $o;
          case 36294:
            return ea;
          case 36295:
            return ta;
          case 36296:
            return ra;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return na;
          case 35679:
          case 36299:
          case 36307:
            return ia;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return sa;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return oa;
        }
      }(t2.type);
    }
  }
  class ca {
    constructor(e2) {
      this.id = e2, this.seq = [], this.map = {};
    }
    setValue(e2, t2, r2) {
      const n2 = this.seq;
      for (let i2 = 0, s2 = n2.length; i2 !== s2; ++i2) {
        const s3 = n2[i2];
        s3.setValue(e2, t2[s3.id], r2);
      }
    }
  }
  const ua = /(\w+)(\])?(\[|\.)?/g;
  function ha(e2, t2) {
    e2.seq.push(t2), e2.map[t2.id] = t2;
  }
  function pa(e2, t2, r2) {
    const n2 = e2.name, i2 = n2.length;
    for (ua.lastIndex = 0; ; ) {
      const s2 = ua.exec(n2), o2 = ua.lastIndex;
      let a2 = s2[1];
      const l2 = "]" === s2[2], c2 = s2[3];
      if (l2 && (a2 |= 0), void 0 === c2 || "[" === c2 && o2 + 2 === i2) {
        ha(r2, void 0 === c2 ? new aa(a2, e2, t2) : new la(a2, e2, t2));
        break;
      }
      {
        let e3 = r2.map[a2];
        void 0 === e3 && (e3 = new ca(a2), ha(r2, e3)), r2 = e3;
      }
    }
  }
  class da {
    constructor(e2, t2) {
      this.seq = [], this.map = {};
      const r2 = e2.getProgramParameter(t2, 35718);
      for (let n2 = 0; n2 < r2; ++n2) {
        const r3 = e2.getActiveUniform(t2, n2);
        pa(r3, e2.getUniformLocation(t2, r3.name), this);
      }
    }
    setValue(e2, t2, r2, n2) {
      const i2 = this.map[t2];
      void 0 !== i2 && i2.setValue(e2, r2, n2);
    }
    setOptional(e2, t2, r2) {
      const n2 = t2[r2];
      void 0 !== n2 && this.setValue(e2, r2, n2);
    }
    static upload(e2, t2, r2, n2) {
      for (let i2 = 0, s2 = t2.length; i2 !== s2; ++i2) {
        const s3 = t2[i2], o2 = r2[s3.id];
        false !== o2.needsUpdate && s3.setValue(e2, o2.value, n2);
      }
    }
    static seqWithValue(e2, t2) {
      const r2 = [];
      for (let n2 = 0, i2 = e2.length; n2 !== i2; ++n2) {
        const i3 = e2[n2];
        i3.id in t2 && r2.push(i3);
      }
      return r2;
    }
  }
  function fa(e2, t2, r2) {
    const n2 = e2.createShader(t2);
    return e2.shaderSource(n2, r2), e2.compileShader(n2), n2;
  }
  let ma = 0;
  function _a2(e2) {
    switch (e2) {
      case kt:
        return ["Linear", "( value )"];
      case Dt:
        return ["sRGB", "( value )"];
      case Bt:
        return ["RGBM", "( value, 16.0 )"];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", e2), ["Linear", "( value )"];
    }
  }
  function ga(e2, t2, r2) {
    const n2 = e2.getShaderParameter(t2, 35713), i2 = e2.getShaderInfoLog(t2).trim();
    if (n2 && "" === i2)
      return "";
    const s2 = /ERROR: 0:(\d+)/.exec(i2);
    if (s2) {
      const n3 = parseInt(s2[1]);
      return r2.toUpperCase() + "\n\n" + i2 + "\n\n" + function(e3, t3) {
        const r3 = e3.split("\n"), n4 = [], i3 = Math.max(t3 - 6, 0), s3 = Math.min(t3 + 6, r3.length);
        for (let e4 = i3; e4 < s3; e4++) {
          const i4 = e4 + 1;
          n4.push(`${i4 === t3 ? ">" : " "} ${i4}: ${r3[e4]}`);
        }
        return n4.join("\n");
      }(e2.getShaderSource(t2), n3);
    }
    return i2;
  }
  function va(e2, t2) {
    const r2 = _a2(t2);
    return "vec4 " + e2 + "( vec4 value ) { return " + r2[0] + "ToLinear" + r2[1] + "; }";
  }
  function Aa(e2, t2) {
    const r2 = _a2(t2);
    return "vec4 " + e2 + "( vec4 value ) { return LinearTo" + r2[0] + r2[1] + "; }";
  }
  function ba(e2, t2) {
    let r2;
    switch (t2) {
      case J:
        r2 = "Linear";
        break;
      case Z:
        r2 = "Reinhard";
        break;
      case $:
        r2 = "OptimizedCineon";
        break;
      case ee:
        r2 = "ACESFilmic";
        break;
      case te:
        r2 = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t2), r2 = "Linear";
    }
    return "vec3 " + e2 + "( vec3 color ) { return " + r2 + "ToneMapping( color ); }";
  }
  function ya(e2) {
    return "" !== e2;
  }
  function xa(e2, t2) {
    const r2 = t2.numSpotLightShadows + t2.numSpotLightMaps - t2.numSpotLightShadowsWithMaps;
    return e2.replace(/NUM_DIR_LIGHTS/g, t2.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t2.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t2.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, r2).replace(/NUM_RECT_AREA_LIGHTS/g, t2.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t2.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t2.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t2.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t2.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t2.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t2.numPointLightShadows);
  }
  function wa(e2, t2) {
    return e2.replace(/NUM_CLIPPING_PLANES/g, t2.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t2.numClippingPlanes - t2.numClipIntersection);
  }
  const Ea = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function Sa(e2) {
    return e2.replace(Ea, Ca);
  }
  function Ca(e2, t2) {
    const r2 = Ps[t2];
    if (void 0 === r2)
      throw new Error("Can not resolve #include <" + t2 + ">");
    return Sa(r2);
  }
  const Ma = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function Ta(e2) {
    return e2.replace(Ma, Ia);
  }
  function Ia(e2, t2, r2, n2) {
    let i2 = "";
    for (let e3 = parseInt(t2); e3 < parseInt(r2); e3++)
      i2 += n2.replace(/\[\s*i\s*\]/g, "[ " + e3 + " ]").replace(/UNROLLED_LOOP_INDEX/g, e3);
    return i2;
  }
  function ka(e2) {
    let t2 = "precision " + e2.precision + " float;\nprecision " + e2.precision + " int;";
    return "highp" === e2.precision ? t2 += "\n#define HIGH_PRECISION" : "mediump" === e2.precision ? t2 += "\n#define MEDIUM_PRECISION" : "lowp" === e2.precision && (t2 += "\n#define LOW_PRECISION"), t2;
  }
  function Da(e2, t2, r2, n2) {
    const i2 = e2.getContext(), s2 = r2.defines;
    let o2 = r2.vertexShader, a2 = r2.fragmentShader;
    const l2 = function(e3) {
      let t3 = "SHADOWMAP_TYPE_BASIC";
      return e3.shadowMapType === h ? t3 = "SHADOWMAP_TYPE_PCF" : e3.shadowMapType === p ? t3 = "SHADOWMAP_TYPE_PCF_SOFT" : e3.shadowMapType === d && (t3 = "SHADOWMAP_TYPE_VSM"), t3;
    }(r2), c2 = function(e3) {
      let t3 = "ENVMAP_TYPE_CUBE";
      if (e3.envMap)
        switch (e3.envMapMode) {
          case ne:
          case ie:
            t3 = "ENVMAP_TYPE_CUBE";
            break;
          case ae:
            t3 = "ENVMAP_TYPE_CUBE_UV";
        }
      return t3;
    }(r2), u2 = function(e3) {
      let t3 = "ENVMAP_MODE_REFLECTION";
      return e3.envMap && e3.envMapMode === ie && (t3 = "ENVMAP_MODE_REFRACTION"), t3;
    }(r2), f2 = function(e3) {
      let t3 = "ENVMAP_BLENDING_NONE";
      if (e3.envMap)
        switch (e3.combine) {
          case q:
            t3 = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case X:
            t3 = "ENVMAP_BLENDING_MIX";
            break;
          case Y:
            t3 = "ENVMAP_BLENDING_ADD";
        }
      return t3;
    }(r2), m2 = function(e3) {
      const t3 = e3.envMapCubeUVHeight;
      if (null === t3)
        return null;
      const r3 = Math.log2(t3) - 2, n3 = 1 / t3;
      return { texelWidth: 1 / (3 * Math.max(Math.pow(2, r3), 112)), texelHeight: n3, maxMip: r3 };
    }(r2), _2 = r2.isWebGL2 ? "" : function(e3) {
      return [e3.extensionDerivatives || e3.envMapCubeUVHeight || e3.bumpMap || e3.tangentSpaceNormalMap || e3.clearcoatNormalMap || e3.flatShading || "physical" === e3.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e3.extensionFragDepth || e3.logarithmicDepthBuffer) && e3.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e3.extensionDrawBuffers && e3.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e3.extensionShaderTextureLOD || e3.envMap || e3.transmission) && e3.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ya).join("\n");
    }(r2), g2 = function(e3) {
      const t3 = [];
      for (const r3 in e3) {
        const n3 = e3[r3];
        false !== n3 && t3.push("#define " + r3 + " " + n3);
      }
      return t3.join("\n");
    }(s2), v2 = i2.createProgram();
    let A2, b2, y2 = r2.glslVersion ? "#version " + r2.glslVersion + "\n" : "";
    r2.isRawShaderMaterial ? (A2 = [g2].filter(ya).join("\n"), A2.length > 0 && (A2 += "\n"), b2 = [_2, g2].filter(ya).join("\n"), b2.length > 0 && (b2 += "\n")) : (A2 = [ka(r2), "#define SHADER_NAME " + r2.shaderName, g2, r2.instancing ? "#define USE_INSTANCING" : "", r2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", r2.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", r2.useFog && r2.fog ? "#define USE_FOG" : "", r2.useFog && r2.fogExp2 ? "#define FOG_EXP2" : "", r2.map ? "#define USE_MAP" : "", r2.envMap ? "#define USE_ENVMAP" : "", r2.envMap ? "#define " + u2 : "", r2.lightMap ? "#define USE_LIGHTMAP" : "", r2.aoMap ? "#define USE_AOMAP" : "", r2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r2.bumpMap ? "#define USE_BUMPMAP" : "", r2.normalMap ? "#define USE_NORMALMAP" : "", r2.normalMap && r2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r2.normalMap && r2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r2.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", r2.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", r2.displacementMap && r2.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", r2.specularMap ? "#define USE_SPECULARMAP" : "", r2.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", r2.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", r2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r2.metalnessMap ? "#define USE_METALNESSMAP" : "", r2.alphaMap ? "#define USE_ALPHAMAP" : "", r2.transmission ? "#define USE_TRANSMISSION" : "", r2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r2.thicknessMap ? "#define USE_THICKNESSMAP" : "", r2.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", r2.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", r2.vertexTangents ? "#define USE_TANGENT" : "", r2.vertexColors ? "#define USE_COLOR" : "", r2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r2.vertexUvs ? "#define USE_UV" : "", r2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r2.flatShading ? "#define FLAT_SHADED" : "", r2.skinning ? "#define USE_SKINNING" : "", r2.morphTargets ? "#define USE_MORPHTARGETS" : "", r2.morphNormals && false === r2.flatShading ? "#define USE_MORPHNORMALS" : "", r2.morphColors && r2.isWebGL2 ? "#define USE_MORPHCOLORS" : "", r2.morphTargetsCount > 0 && r2.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", r2.morphTargetsCount > 0 && r2.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + r2.morphTextureStride : "", r2.morphTargetsCount > 0 && r2.isWebGL2 ? "#define MORPHTARGETS_COUNT " + r2.morphTargetsCount : "", r2.doubleSided ? "#define DOUBLE_SIDED" : "", r2.flipSided ? "#define FLIP_SIDED" : "", r2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r2.shadowMapEnabled ? "#define " + l2 : "", r2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", r2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r2.logarithmicDepthBuffer && r2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(ya).join("\n"), b2 = [_2, ka(r2), "#define SHADER_NAME " + r2.shaderName, g2, r2.useFog && r2.fog ? "#define USE_FOG" : "", r2.useFog && r2.fogExp2 ? "#define FOG_EXP2" : "", r2.map ? "#define USE_MAP" : "", r2.matcap ? "#define USE_MATCAP" : "", r2.envMap ? "#define USE_ENVMAP" : "", r2.envMap ? "#define " + c2 : "", r2.envMap ? "#define " + u2 : "", r2.envMap ? "#define " + f2 : "", m2 ? "#define CUBEUV_TEXEL_WIDTH " + m2.texelWidth : "", m2 ? "#define CUBEUV_TEXEL_HEIGHT " + m2.texelHeight : "", m2 ? "#define CUBEUV_MAX_MIP " + m2.maxMip + ".0" : "", r2.lightMap ? "#define USE_LIGHTMAP" : "", r2.aoMap ? "#define USE_AOMAP" : "", r2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r2.bumpMap ? "#define USE_BUMPMAP" : "", r2.normalMap ? "#define USE_NORMALMAP" : "", r2.normalMap && r2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r2.normalMap && r2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r2.clearcoat ? "#define USE_CLEARCOAT" : "", r2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r2.iridescence ? "#define USE_IRIDESCENCE" : "", r2.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", r2.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", r2.specularMap ? "#define USE_SPECULARMAP" : "", r2.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", r2.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", r2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r2.metalnessMap ? "#define USE_METALNESSMAP" : "", r2.alphaMap ? "#define USE_ALPHAMAP" : "", r2.alphaTest ? "#define USE_ALPHATEST" : "", r2.sheen ? "#define USE_SHEEN" : "", r2.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", r2.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", r2.transmission ? "#define USE_TRANSMISSION" : "", r2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r2.thicknessMap ? "#define USE_THICKNESSMAP" : "", r2.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", r2.vertexTangents ? "#define USE_TANGENT" : "", r2.vertexColors || r2.instancingColor ? "#define USE_COLOR" : "", r2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r2.vertexUvs ? "#define USE_UV" : "", r2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r2.gradientMap ? "#define USE_GRADIENTMAP" : "", r2.flatShading ? "#define FLAT_SHADED" : "", r2.doubleSided ? "#define DOUBLE_SIDED" : "", r2.flipSided ? "#define FLIP_SIDED" : "", r2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r2.shadowMapEnabled ? "#define " + l2 : "", r2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", r2.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", r2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r2.logarithmicDepthBuffer && r2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", r2.toneMapping !== K ? "#define TONE_MAPPING" : "", r2.toneMapping !== K ? Ps.tonemapping_pars_fragment : "", r2.toneMapping !== K ? ba("toneMapping", r2.toneMapping) : "", r2.dithering ? "#define DITHERING" : "", r2.opaque ? "#define OPAQUE" : "", Ps.encodings_pars_fragment, Aa("linearToOutputTexel", r2.outputEncoding), r2.transmissionSamplerMapEncoding ? va("transmissionSamplerMapTexelToLinear", r2.transmissionSamplerMapEncoding) : "", r2.useDepthPacking ? "#define DEPTH_PACKING " + r2.depthPacking : "", "\n"].filter(ya).join("\n")), o2 = Sa(o2), o2 = xa(o2, r2), o2 = wa(o2, r2), a2 = Sa(a2), a2 = xa(a2, r2), a2 = wa(a2, r2), o2 = Ta(o2), a2 = Ta(a2), r2.isWebGL2 && true !== r2.isRawShaderMaterial && (y2 = "#version 300 es\n", A2 = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + A2, b2 = ["#define varying in", r2.glslVersion === dr ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", r2.glslVersion === dr ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b2);
    const x2 = y2 + b2 + a2, w2 = fa(i2, 35633, y2 + A2 + o2), E2 = fa(i2, 35632, x2);
    if (i2.attachShader(v2, w2), i2.attachShader(v2, E2), void 0 !== r2.index0AttributeName ? i2.bindAttribLocation(v2, 0, r2.index0AttributeName) : true === r2.morphTargets && i2.bindAttribLocation(v2, 0, "position"), i2.linkProgram(v2), e2.debug.checkShaderErrors) {
      const e3 = i2.getProgramInfoLog(v2).trim(), t3 = i2.getShaderInfoLog(w2).trim(), r3 = i2.getShaderInfoLog(E2).trim();
      let n3 = true, s3 = true;
      if (false === i2.getProgramParameter(v2, 35714)) {
        n3 = false;
        const t4 = ga(i2, w2, "vertex"), r4 = ga(i2, E2, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + i2.getError() + " - VALIDATE_STATUS " + i2.getProgramParameter(v2, 35715) + "\n\nProgram Info Log: " + e3 + "\n" + t4 + "\n" + r4);
      } else
        "" !== e3 ? console.warn("THREE.WebGLProgram: Program Info Log:", e3) : "" !== t3 && "" !== r3 || (s3 = false);
      s3 && (this.diagnostics = { runnable: n3, programLog: e3, vertexShader: { log: t3, prefix: A2 }, fragmentShader: { log: r3, prefix: b2 } });
    }
    let S2, C2;
    return i2.deleteShader(w2), i2.deleteShader(E2), this.getUniforms = function() {
      return void 0 === S2 && (S2 = new da(i2, v2)), S2;
    }, this.getAttributes = function() {
      return void 0 === C2 && (C2 = function(e3, t3) {
        const r3 = {}, n3 = e3.getProgramParameter(t3, 35721);
        for (let i3 = 0; i3 < n3; i3++) {
          const n4 = e3.getActiveAttrib(t3, i3), s3 = n4.name;
          let o3 = 1;
          35674 === n4.type && (o3 = 2), 35675 === n4.type && (o3 = 3), 35676 === n4.type && (o3 = 4), r3[s3] = { type: n4.type, location: e3.getAttribLocation(t3, s3), locationSize: o3 };
        }
        return r3;
      }(i2, v2)), C2;
    }, this.destroy = function() {
      n2.releaseStatesOfProgram(this), i2.deleteProgram(v2), this.program = void 0;
    }, this.name = r2.shaderName, this.id = ma++, this.cacheKey = t2, this.usedTimes = 1, this.program = v2, this.vertexShader = w2, this.fragmentShader = E2, this;
  }
  let Pa = 0;
  class Ba {
    constructor() {
      this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
    }
    update(e2) {
      const t2 = e2.vertexShader, r2 = e2.fragmentShader, n2 = this._getShaderStage(t2), i2 = this._getShaderStage(r2), s2 = this._getShaderCacheForMaterial(e2);
      return false === s2.has(n2) && (s2.add(n2), n2.usedTimes++), false === s2.has(i2) && (s2.add(i2), i2.usedTimes++), this;
    }
    remove(e2) {
      const t2 = this.materialCache.get(e2);
      for (const e3 of t2)
        e3.usedTimes--, 0 === e3.usedTimes && this.shaderCache.delete(e3.code);
      return this.materialCache.delete(e2), this;
    }
    getVertexShaderID(e2) {
      return this._getShaderStage(e2.vertexShader).id;
    }
    getFragmentShaderID(e2) {
      return this._getShaderStage(e2.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(e2) {
      const t2 = this.materialCache;
      let r2 = t2.get(e2);
      return void 0 === r2 && (r2 = /* @__PURE__ */ new Set(), t2.set(e2, r2)), r2;
    }
    _getShaderStage(e2) {
      const t2 = this.shaderCache;
      let r2 = t2.get(e2);
      return void 0 === r2 && (r2 = new Ra(e2), t2.set(e2, r2)), r2;
    }
  }
  class Ra {
    constructor(e2) {
      this.id = Pa++, this.code = e2, this.usedTimes = 0;
    }
  }
  function La(e2, t2, r2, n2, i2, s2, o2) {
    const a2 = new Kn(), l2 = new Ba(), c2 = [], u2 = i2.isWebGL2, h2 = i2.logarithmicDepthBuffer, p2 = i2.vertexTextures;
    let d2 = i2.precision;
    const f2 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
    return { getParameters: function(s3, a3, c3, g2, A2) {
      const b2 = g2.fog, y2 = A2.geometry, x2 = s3.isMeshStandardMaterial ? g2.environment : null, w2 = (s3.isMeshStandardMaterial ? r2 : t2).get(s3.envMap || x2), E2 = w2 && w2.mapping === ae ? w2.image.height : null, S2 = f2[s3.type];
      null !== s3.precision && (d2 = i2.getMaxPrecision(s3.precision), d2 !== s3.precision && console.warn("THREE.WebGLProgram.getParameters:", s3.precision, "not supported, using", d2, "instead."));
      const C2 = y2.morphAttributes.position || y2.morphAttributes.normal || y2.morphAttributes.color, M2 = void 0 !== C2 ? C2.length : 0;
      let T2, I2, k2, D2, P2 = 0;
      if (void 0 !== y2.morphAttributes.position && (P2 = 1), void 0 !== y2.morphAttributes.normal && (P2 = 2), void 0 !== y2.morphAttributes.color && (P2 = 3), S2) {
        const e3 = Rs[S2];
        T2 = e3.vertexShader, I2 = e3.fragmentShader;
      } else
        T2 = s3.vertexShader, I2 = s3.fragmentShader, l2.update(s3), k2 = l2.getVertexShaderID(s3), D2 = l2.getFragmentShaderID(s3);
      const B2 = e2.getRenderTarget(), R2 = e2.userData && e2.userData.transmissionRenderTarget, L2 = s3.alphaTest > 0, O2 = s3.clearcoat > 0, F2 = s3.iridescence > 0;
      return { isWebGL2: u2, shaderID: S2, shaderName: s3.type, vertexShader: T2, fragmentShader: I2, defines: s3.defines, customVertexShaderID: k2, customFragmentShaderID: D2, isRawShaderMaterial: true === s3.isRawShaderMaterial, glslVersion: s3.glslVersion, precision: d2, instancing: true === A2.isInstancedMesh, instancingColor: true === A2.isInstancedMesh && null !== A2.instanceColor, supportsVertexTextures: p2, outputEncoding: null === B2 ? e2.outputEncoding : true === B2.isXRRenderTarget || B2.texture.encoding !== Dt ? B2.texture.encoding : kt, map: !!s3.map, matcap: !!s3.matcap, envMap: !!w2, envMapMode: w2 && w2.mapping, envMapCubeUVHeight: E2, lightMap: !!s3.lightMap, aoMap: !!s3.aoMap, emissiveMap: !!s3.emissiveMap, bumpMap: !!s3.bumpMap, normalMap: !!s3.normalMap, objectSpaceNormalMap: s3.normalMapType === Ft, tangentSpaceNormalMap: s3.normalMapType === Ot, decodeVideoTexture: !!s3.map && true === s3.map.isVideoTexture && s3.map.encoding === Dt, clearcoat: O2, clearcoatMap: O2 && !!s3.clearcoatMap, clearcoatRoughnessMap: O2 && !!s3.clearcoatRoughnessMap, clearcoatNormalMap: O2 && !!s3.clearcoatNormalMap, iridescence: F2, iridescenceMap: F2 && !!s3.iridescenceMap, iridescenceThicknessMap: F2 && !!s3.iridescenceThicknessMap, displacementMap: !!s3.displacementMap, roughnessMap: !!s3.roughnessMap, metalnessMap: !!s3.metalnessMap, specularMap: !!s3.specularMap, specularIntensityMap: !!s3.specularIntensityMap, specularColorMap: !!s3.specularColorMap, opaque: false === s3.transparent && s3.blending === v && !(s3.transmission > 0), alphaMap: !!s3.alphaMap, alphaTest: L2, gradientMap: !!s3.gradientMap, sheen: s3.sheen > 0, sheenColorMap: !!s3.sheenColorMap, sheenRoughnessMap: !!s3.sheenRoughnessMap, transmission: s3.transmission > 0, transmissionMap: !!s3.transmissionMap, transmissionSamplerMapEncoding: R2 ? R2.texture.encoding : kt, thicknessMap: !!s3.thicknessMap, combine: s3.combine, vertexTangents: !!s3.normalMap && !!y2.attributes.tangent, vertexColors: s3.vertexColors, vertexAlphas: true === s3.vertexColors && !!y2.attributes.color && 4 === y2.attributes.color.itemSize, vertexUvs: !!(s3.map || s3.bumpMap || s3.normalMap || s3.specularMap || s3.alphaMap || s3.emissiveMap || s3.roughnessMap || s3.metalnessMap || s3.clearcoatMap || s3.clearcoatRoughnessMap || s3.clearcoatNormalMap || s3.iridescenceMap || s3.iridescenceThicknessMap || s3.displacementMap || s3.transmissionMap || s3.thicknessMap || s3.specularIntensityMap || s3.specularColorMap || s3.sheenColorMap || s3.sheenRoughnessMap), uvsVertexOnly: !(s3.map || s3.bumpMap || s3.normalMap || s3.specularMap || s3.alphaMap || s3.emissiveMap || s3.roughnessMap || s3.metalnessMap || s3.clearcoatNormalMap || s3.iridescenceMap || s3.iridescenceThicknessMap || s3.transmission > 0 || s3.transmissionMap || s3.thicknessMap || s3.specularIntensityMap || s3.specularColorMap || s3.sheen > 0 || s3.sheenColorMap || s3.sheenRoughnessMap || !s3.displacementMap), fog: !!b2, useFog: true === s3.fog, fogExp2: b2 && b2.isFogExp2, flatShading: !!s3.flatShading, sizeAttenuation: s3.sizeAttenuation, logarithmicDepthBuffer: h2, skinning: true === A2.isSkinnedMesh, morphTargets: void 0 !== y2.morphAttributes.position, morphNormals: void 0 !== y2.morphAttributes.normal, morphColors: void 0 !== y2.morphAttributes.color, morphTargetsCount: M2, morphTextureStride: P2, numDirLights: a3.directional.length, numPointLights: a3.point.length, numSpotLights: a3.spot.length, numSpotLightMaps: a3.spotLightMap.length, numRectAreaLights: a3.rectArea.length, numHemiLights: a3.hemi.length, numDirLightShadows: a3.directionalShadowMap.length, numPointLightShadows: a3.pointShadowMap.length, numSpotLightShadows: a3.spotShadowMap.length, numSpotLightShadowsWithMaps: a3.numSpotLightShadowsWithMaps, numClippingPlanes: o2.numPlanes, numClipIntersection: o2.numIntersection, dithering: s3.dithering, shadowMapEnabled: e2.shadowMap.enabled && c3.length > 0, shadowMapType: e2.shadowMap.type, toneMapping: s3.toneMapped ? e2.toneMapping : K, physicallyCorrectLights: e2.physicallyCorrectLights, premultipliedAlpha: s3.premultipliedAlpha, doubleSided: s3.side === _, flipSided: s3.side === m, useDepthPacking: !!s3.depthPacking, depthPacking: s3.depthPacking || 0, index0AttributeName: s3.index0AttributeName, extensionDerivatives: s3.extensions && s3.extensions.derivatives, extensionFragDepth: s3.extensions && s3.extensions.fragDepth, extensionDrawBuffers: s3.extensions && s3.extensions.drawBuffers, extensionShaderTextureLOD: s3.extensions && s3.extensions.shaderTextureLOD, rendererExtensionFragDepth: u2 || n2.has("EXT_frag_depth"), rendererExtensionDrawBuffers: u2 || n2.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: u2 || n2.has("EXT_shader_texture_lod"), customProgramCacheKey: s3.customProgramCacheKey() };
    }, getProgramCacheKey: function(t3) {
      const r3 = [];
      if (t3.shaderID ? r3.push(t3.shaderID) : (r3.push(t3.customVertexShaderID), r3.push(t3.customFragmentShaderID)), void 0 !== t3.defines)
        for (const e3 in t3.defines)
          r3.push(e3), r3.push(t3.defines[e3]);
      return false === t3.isRawShaderMaterial && (function(e3, t4) {
        e3.push(t4.precision), e3.push(t4.outputEncoding), e3.push(t4.envMapMode), e3.push(t4.envMapCubeUVHeight), e3.push(t4.combine), e3.push(t4.vertexUvs), e3.push(t4.fogExp2), e3.push(t4.sizeAttenuation), e3.push(t4.morphTargetsCount), e3.push(t4.morphAttributeCount), e3.push(t4.numDirLights), e3.push(t4.numPointLights), e3.push(t4.numSpotLights), e3.push(t4.numSpotLightMaps), e3.push(t4.numHemiLights), e3.push(t4.numRectAreaLights), e3.push(t4.numDirLightShadows), e3.push(t4.numPointLightShadows), e3.push(t4.numSpotLightShadows), e3.push(t4.numSpotLightShadowsWithMaps), e3.push(t4.shadowMapType), e3.push(t4.toneMapping), e3.push(t4.numClippingPlanes), e3.push(t4.numClipIntersection), e3.push(t4.depthPacking);
      }(r3, t3), function(e3, t4) {
        a2.disableAll(), t4.isWebGL2 && a2.enable(0), t4.supportsVertexTextures && a2.enable(1), t4.instancing && a2.enable(2), t4.instancingColor && a2.enable(3), t4.map && a2.enable(4), t4.matcap && a2.enable(5), t4.envMap && a2.enable(6), t4.lightMap && a2.enable(7), t4.aoMap && a2.enable(8), t4.emissiveMap && a2.enable(9), t4.bumpMap && a2.enable(10), t4.normalMap && a2.enable(11), t4.objectSpaceNormalMap && a2.enable(12), t4.tangentSpaceNormalMap && a2.enable(13), t4.clearcoat && a2.enable(14), t4.clearcoatMap && a2.enable(15), t4.clearcoatRoughnessMap && a2.enable(16), t4.clearcoatNormalMap && a2.enable(17), t4.iridescence && a2.enable(18), t4.iridescenceMap && a2.enable(19), t4.iridescenceThicknessMap && a2.enable(20), t4.displacementMap && a2.enable(21), t4.specularMap && a2.enable(22), t4.roughnessMap && a2.enable(23), t4.metalnessMap && a2.enable(24), t4.gradientMap && a2.enable(25), t4.alphaMap && a2.enable(26), t4.alphaTest && a2.enable(27), t4.vertexColors && a2.enable(28), t4.vertexAlphas && a2.enable(29), t4.vertexUvs && a2.enable(30), t4.vertexTangents && a2.enable(31), t4.uvsVertexOnly && a2.enable(32), e3.push(a2.mask), a2.disableAll(), t4.fog && a2.enable(0), t4.useFog && a2.enable(1), t4.flatShading && a2.enable(2), t4.logarithmicDepthBuffer && a2.enable(3), t4.skinning && a2.enable(4), t4.morphTargets && a2.enable(5), t4.morphNormals && a2.enable(6), t4.morphColors && a2.enable(7), t4.premultipliedAlpha && a2.enable(8), t4.shadowMapEnabled && a2.enable(9), t4.physicallyCorrectLights && a2.enable(10), t4.doubleSided && a2.enable(11), t4.flipSided && a2.enable(12), t4.useDepthPacking && a2.enable(13), t4.dithering && a2.enable(14), t4.specularIntensityMap && a2.enable(15), t4.specularColorMap && a2.enable(16), t4.transmission && a2.enable(17), t4.transmissionMap && a2.enable(18), t4.thicknessMap && a2.enable(19), t4.sheen && a2.enable(20), t4.sheenColorMap && a2.enable(21), t4.sheenRoughnessMap && a2.enable(22), t4.decodeVideoTexture && a2.enable(23), t4.opaque && a2.enable(24), e3.push(a2.mask);
      }(r3, t3), r3.push(e2.outputEncoding)), r3.push(t3.customProgramCacheKey), r3.join();
    }, getUniforms: function(e3) {
      const t3 = f2[e3.type];
      let r3;
      if (t3) {
        const e4 = Rs[t3];
        r3 = fs.clone(e4.uniforms);
      } else
        r3 = e3.uniforms;
      return r3;
    }, acquireProgram: function(t3, r3) {
      let n3;
      for (let e3 = 0, t4 = c2.length; e3 < t4; e3++) {
        const t5 = c2[e3];
        if (t5.cacheKey === r3) {
          n3 = t5, ++n3.usedTimes;
          break;
        }
      }
      return void 0 === n3 && (n3 = new Da(e2, r3, t3, s2), c2.push(n3)), n3;
    }, releaseProgram: function(e3) {
      if (0 == --e3.usedTimes) {
        const t3 = c2.indexOf(e3);
        c2[t3] = c2[c2.length - 1], c2.pop(), e3.destroy();
      }
    }, releaseShaderCache: function(e3) {
      l2.remove(e3);
    }, programs: c2, dispose: function() {
      l2.dispose();
    } };
  }
  function Oa() {
    let e2 = /* @__PURE__ */ new WeakMap();
    return { get: function(t2) {
      let r2 = e2.get(t2);
      return void 0 === r2 && (r2 = {}, e2.set(t2, r2)), r2;
    }, remove: function(t2) {
      e2.delete(t2);
    }, update: function(t2, r2, n2) {
      e2.get(t2)[r2] = n2;
    }, dispose: function() {
      e2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  function Fa(e2, t2) {
    return e2.groupOrder !== t2.groupOrder ? e2.groupOrder - t2.groupOrder : e2.renderOrder !== t2.renderOrder ? e2.renderOrder - t2.renderOrder : e2.material.id !== t2.material.id ? e2.material.id - t2.material.id : e2.z !== t2.z ? e2.z - t2.z : e2.id - t2.id;
  }
  function Ua(e2, t2) {
    return e2.groupOrder !== t2.groupOrder ? e2.groupOrder - t2.groupOrder : e2.renderOrder !== t2.renderOrder ? e2.renderOrder - t2.renderOrder : e2.z !== t2.z ? t2.z - e2.z : e2.id - t2.id;
  }
  function Na() {
    const e2 = [];
    let t2 = 0;
    const r2 = [], n2 = [], i2 = [];
    function s2(r3, n3, i3, s3, o2, a2) {
      let l2 = e2[t2];
      return void 0 === l2 ? (l2 = { id: r3.id, object: r3, geometry: n3, material: i3, groupOrder: s3, renderOrder: r3.renderOrder, z: o2, group: a2 }, e2[t2] = l2) : (l2.id = r3.id, l2.object = r3, l2.geometry = n3, l2.material = i3, l2.groupOrder = s3, l2.renderOrder = r3.renderOrder, l2.z = o2, l2.group = a2), t2++, l2;
    }
    return { opaque: r2, transmissive: n2, transparent: i2, init: function() {
      t2 = 0, r2.length = 0, n2.length = 0, i2.length = 0;
    }, push: function(e3, t3, o2, a2, l2, c2) {
      const u2 = s2(e3, t3, o2, a2, l2, c2);
      o2.transmission > 0 ? n2.push(u2) : true === o2.transparent ? i2.push(u2) : r2.push(u2);
    }, unshift: function(e3, t3, o2, a2, l2, c2) {
      const u2 = s2(e3, t3, o2, a2, l2, c2);
      o2.transmission > 0 ? n2.unshift(u2) : true === o2.transparent ? i2.unshift(u2) : r2.unshift(u2);
    }, finish: function() {
      for (let r3 = t2, n3 = e2.length; r3 < n3; r3++) {
        const t3 = e2[r3];
        if (null === t3.id)
          break;
        t3.id = null, t3.object = null, t3.geometry = null, t3.material = null, t3.group = null;
      }
    }, sort: function(e3, t3) {
      r2.length > 1 && r2.sort(e3 || Fa), n2.length > 1 && n2.sort(t3 || Ua), i2.length > 1 && i2.sort(t3 || Ua);
    } };
  }
  function ja() {
    let e2 = /* @__PURE__ */ new WeakMap();
    return { get: function(t2, r2) {
      const n2 = e2.get(t2);
      let i2;
      return void 0 === n2 ? (i2 = new Na(), e2.set(t2, [i2])) : r2 >= n2.length ? (i2 = new Na(), n2.push(i2)) : i2 = n2[r2], i2;
    }, dispose: function() {
      e2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  function za() {
    const e2 = {};
    return { get: function(t2) {
      if (void 0 !== e2[t2.id])
        return e2[t2.id];
      let r2;
      switch (t2.type) {
        case "DirectionalLight":
          r2 = { direction: new ln(), color: new Wr() };
          break;
        case "SpotLight":
          r2 = { position: new ln(), direction: new ln(), color: new Wr(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
          break;
        case "PointLight":
          r2 = { position: new ln(), color: new Wr(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          r2 = { direction: new ln(), skyColor: new Wr(), groundColor: new Wr() };
          break;
        case "RectAreaLight":
          r2 = { color: new Wr(), position: new ln(), halfWidth: new ln(), halfHeight: new ln() };
      }
      return e2[t2.id] = r2, r2;
    } };
  }
  let Ga = 0;
  function Va(e2, t2) {
    return (t2.castShadow ? 2 : 0) - (e2.castShadow ? 2 : 0) + (t2.map ? 1 : 0) - (e2.map ? 1 : 0);
  }
  function Qa(e2, t2) {
    const r2 = new za(), n2 = function() {
      const e3 = {};
      return { get: function(t3) {
        if (void 0 !== e3[t3.id])
          return e3[t3.id];
        let r3;
        switch (t3.type) {
          case "DirectionalLight":
          case "SpotLight":
            r3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new kr() };
            break;
          case "PointLight":
            r3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new kr(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
        }
        return e3[t3.id] = r3, r3;
      } };
    }(), i2 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0 };
    for (let e3 = 0; e3 < 9; e3++)
      i2.probe.push(new ln());
    const s2 = new ln(), o2 = new Nn(), a2 = new Nn();
    return { setup: function(s3, o3) {
      let a3 = 0, l2 = 0, c2 = 0;
      for (let e3 = 0; e3 < 9; e3++)
        i2.probe[e3].set(0, 0, 0);
      let u2 = 0, h2 = 0, p2 = 0, d2 = 0, f2 = 0, m2 = 0, _2 = 0, g2 = 0, v2 = 0, A2 = 0;
      s3.sort(Va);
      const b2 = true !== o3 ? Math.PI : 1;
      for (let e3 = 0, t3 = s3.length; e3 < t3; e3++) {
        const t4 = s3[e3], o4 = t4.color, y3 = t4.intensity, x2 = t4.distance, w2 = t4.shadow && t4.shadow.map ? t4.shadow.map.texture : null;
        if (t4.isAmbientLight)
          a3 += o4.r * y3 * b2, l2 += o4.g * y3 * b2, c2 += o4.b * y3 * b2;
        else if (t4.isLightProbe)
          for (let e4 = 0; e4 < 9; e4++)
            i2.probe[e4].addScaledVector(t4.sh.coefficients[e4], y3);
        else if (t4.isDirectionalLight) {
          const e4 = r2.get(t4);
          if (e4.color.copy(t4.color).multiplyScalar(t4.intensity * b2), t4.castShadow) {
            const e5 = t4.shadow, r3 = n2.get(t4);
            r3.shadowBias = e5.bias, r3.shadowNormalBias = e5.normalBias, r3.shadowRadius = e5.radius, r3.shadowMapSize = e5.mapSize, i2.directionalShadow[u2] = r3, i2.directionalShadowMap[u2] = w2, i2.directionalShadowMatrix[u2] = t4.shadow.matrix, m2++;
          }
          i2.directional[u2] = e4, u2++;
        } else if (t4.isSpotLight) {
          const e4 = r2.get(t4);
          e4.position.setFromMatrixPosition(t4.matrixWorld), e4.color.copy(o4).multiplyScalar(y3 * b2), e4.distance = x2, e4.coneCos = Math.cos(t4.angle), e4.penumbraCos = Math.cos(t4.angle * (1 - t4.penumbra)), e4.decay = t4.decay, i2.spot[p2] = e4;
          const s4 = t4.shadow;
          if (t4.map && (i2.spotLightMap[v2] = t4.map, v2++, s4.updateMatrices(t4), t4.castShadow && A2++), i2.spotLightMatrix[p2] = s4.matrix, t4.castShadow) {
            const e5 = n2.get(t4);
            e5.shadowBias = s4.bias, e5.shadowNormalBias = s4.normalBias, e5.shadowRadius = s4.radius, e5.shadowMapSize = s4.mapSize, i2.spotShadow[p2] = e5, i2.spotShadowMap[p2] = w2, g2++;
          }
          p2++;
        } else if (t4.isRectAreaLight) {
          const e4 = r2.get(t4);
          e4.color.copy(o4).multiplyScalar(y3), e4.halfWidth.set(0.5 * t4.width, 0, 0), e4.halfHeight.set(0, 0.5 * t4.height, 0), i2.rectArea[d2] = e4, d2++;
        } else if (t4.isPointLight) {
          const e4 = r2.get(t4);
          if (e4.color.copy(t4.color).multiplyScalar(t4.intensity * b2), e4.distance = t4.distance, e4.decay = t4.decay, t4.castShadow) {
            const e5 = t4.shadow, r3 = n2.get(t4);
            r3.shadowBias = e5.bias, r3.shadowNormalBias = e5.normalBias, r3.shadowRadius = e5.radius, r3.shadowMapSize = e5.mapSize, r3.shadowCameraNear = e5.camera.near, r3.shadowCameraFar = e5.camera.far, i2.pointShadow[h2] = r3, i2.pointShadowMap[h2] = w2, i2.pointShadowMatrix[h2] = t4.shadow.matrix, _2++;
          }
          i2.point[h2] = e4, h2++;
        } else if (t4.isHemisphereLight) {
          const e4 = r2.get(t4);
          e4.skyColor.copy(t4.color).multiplyScalar(y3 * b2), e4.groundColor.copy(t4.groundColor).multiplyScalar(y3 * b2), i2.hemi[f2] = e4, f2++;
        }
      }
      d2 > 0 && (t2.isWebGL2 || true === e2.has("OES_texture_float_linear") ? (i2.rectAreaLTC1 = Bs.LTC_FLOAT_1, i2.rectAreaLTC2 = Bs.LTC_FLOAT_2) : true === e2.has("OES_texture_half_float_linear") ? (i2.rectAreaLTC1 = Bs.LTC_HALF_1, i2.rectAreaLTC2 = Bs.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i2.ambient[0] = a3, i2.ambient[1] = l2, i2.ambient[2] = c2;
      const y2 = i2.hash;
      y2.directionalLength === u2 && y2.pointLength === h2 && y2.spotLength === p2 && y2.rectAreaLength === d2 && y2.hemiLength === f2 && y2.numDirectionalShadows === m2 && y2.numPointShadows === _2 && y2.numSpotShadows === g2 && y2.numSpotMaps === v2 || (i2.directional.length = u2, i2.spot.length = p2, i2.rectArea.length = d2, i2.point.length = h2, i2.hemi.length = f2, i2.directionalShadow.length = m2, i2.directionalShadowMap.length = m2, i2.pointShadow.length = _2, i2.pointShadowMap.length = _2, i2.spotShadow.length = g2, i2.spotShadowMap.length = g2, i2.directionalShadowMatrix.length = m2, i2.pointShadowMatrix.length = _2, i2.spotLightMatrix.length = g2 + v2 - A2, i2.spotLightMap.length = v2, i2.numSpotLightShadowsWithMaps = A2, y2.directionalLength = u2, y2.pointLength = h2, y2.spotLength = p2, y2.rectAreaLength = d2, y2.hemiLength = f2, y2.numDirectionalShadows = m2, y2.numPointShadows = _2, y2.numSpotShadows = g2, y2.numSpotMaps = v2, i2.version = Ga++);
    }, setupView: function(e3, t3) {
      let r3 = 0, n3 = 0, l2 = 0, c2 = 0, u2 = 0;
      const h2 = t3.matrixWorldInverse;
      for (let t4 = 0, p2 = e3.length; t4 < p2; t4++) {
        const p3 = e3[t4];
        if (p3.isDirectionalLight) {
          const e4 = i2.directional[r3];
          e4.direction.setFromMatrixPosition(p3.matrixWorld), s2.setFromMatrixPosition(p3.target.matrixWorld), e4.direction.sub(s2), e4.direction.transformDirection(h2), r3++;
        } else if (p3.isSpotLight) {
          const e4 = i2.spot[l2];
          e4.position.setFromMatrixPosition(p3.matrixWorld), e4.position.applyMatrix4(h2), e4.direction.setFromMatrixPosition(p3.matrixWorld), s2.setFromMatrixPosition(p3.target.matrixWorld), e4.direction.sub(s2), e4.direction.transformDirection(h2), l2++;
        } else if (p3.isRectAreaLight) {
          const e4 = i2.rectArea[c2];
          e4.position.setFromMatrixPosition(p3.matrixWorld), e4.position.applyMatrix4(h2), a2.identity(), o2.copy(p3.matrixWorld), o2.premultiply(h2), a2.extractRotation(o2), e4.halfWidth.set(0.5 * p3.width, 0, 0), e4.halfHeight.set(0, 0.5 * p3.height, 0), e4.halfWidth.applyMatrix4(a2), e4.halfHeight.applyMatrix4(a2), c2++;
        } else if (p3.isPointLight) {
          const e4 = i2.point[n3];
          e4.position.setFromMatrixPosition(p3.matrixWorld), e4.position.applyMatrix4(h2), n3++;
        } else if (p3.isHemisphereLight) {
          const e4 = i2.hemi[u2];
          e4.direction.setFromMatrixPosition(p3.matrixWorld), e4.direction.transformDirection(h2), u2++;
        }
      }
    }, state: i2 };
  }
  function Ha(e2, t2) {
    const r2 = new Qa(e2, t2), n2 = [], i2 = [];
    return { init: function() {
      n2.length = 0, i2.length = 0;
    }, state: { lightsArray: n2, shadowsArray: i2, lights: r2 }, setupLights: function(e3) {
      r2.setup(n2, e3);
    }, setupLightsView: function(e3) {
      r2.setupView(n2, e3);
    }, pushLight: function(e3) {
      n2.push(e3);
    }, pushShadow: function(e3) {
      i2.push(e3);
    } };
  }
  function Wa(e2, t2) {
    let r2 = /* @__PURE__ */ new WeakMap();
    return { get: function(n2, i2 = 0) {
      const s2 = r2.get(n2);
      let o2;
      return void 0 === s2 ? (o2 = new Ha(e2, t2), r2.set(n2, [o2])) : i2 >= s2.length ? (o2 = new Ha(e2, t2), s2.push(o2)) : o2 = s2[i2], o2;
    }, dispose: function() {
      r2 = /* @__PURE__ */ new WeakMap();
    } };
  }
  class qa extends wi {
    constructor(e2) {
      super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = Rt, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.depthPacking = e2.depthPacking, this.map = e2.map, this.alphaMap = e2.alphaMap, this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this;
    }
  }
  class Xa extends wi {
    constructor(e2) {
      super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.referencePosition = new ln(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.referencePosition.copy(e2.referencePosition), this.nearDistance = e2.nearDistance, this.farDistance = e2.farDistance, this.map = e2.map, this.alphaMap = e2.alphaMap, this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this;
    }
  }
  function Ya(e2, t2, r2) {
    let n2 = new Ts();
    const i2 = new kr(), s2 = new kr(), o2 = new $r(), a2 = new qa({ depthPacking: Lt }), l2 = new Xa(), c2 = {}, u2 = r2.maxTextureSize, p2 = { 0: m, 1: f, 2: _ }, v2 = new ms({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new kr() }, radius: { value: 4 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), A2 = v2.clone();
    A2.defines.HORIZONTAL_PASS = 1;
    const b2 = new Hi();
    b2.setAttribute("position", new Mi(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    const y2 = new cs(b2, v2), x2 = this;
    function w2(r3, n3) {
      const s3 = t2.update(y2);
      v2.defines.VSM_SAMPLES !== r3.blurSamples && (v2.defines.VSM_SAMPLES = r3.blurSamples, A2.defines.VSM_SAMPLES = r3.blurSamples, v2.needsUpdate = true, A2.needsUpdate = true), null === r3.mapPass && (r3.mapPass = new en(i2.x, i2.y)), v2.uniforms.shadow_pass.value = r3.map.texture, v2.uniforms.resolution.value = r3.mapSize, v2.uniforms.radius.value = r3.radius, e2.setRenderTarget(r3.mapPass), e2.clear(), e2.renderBufferDirect(n3, null, s3, v2, y2, null), A2.uniforms.shadow_pass.value = r3.mapPass.texture, A2.uniforms.resolution.value = r3.mapSize, A2.uniforms.radius.value = r3.radius, e2.setRenderTarget(r3.map), e2.clear(), e2.renderBufferDirect(n3, null, s3, A2, y2, null);
    }
    function E2(t3, r3, n3, i3, s3, o3) {
      let u3 = null;
      const h2 = true === n3.isPointLight ? t3.customDistanceMaterial : t3.customDepthMaterial;
      if (u3 = void 0 !== h2 ? h2 : true === n3.isPointLight ? l2 : a2, e2.localClippingEnabled && true === r3.clipShadows && Array.isArray(r3.clippingPlanes) && 0 !== r3.clippingPlanes.length || r3.displacementMap && 0 !== r3.displacementScale || r3.alphaMap && r3.alphaTest > 0) {
        const e3 = u3.uuid, t4 = r3.uuid;
        let n4 = c2[e3];
        void 0 === n4 && (n4 = {}, c2[e3] = n4);
        let i4 = n4[t4];
        void 0 === i4 && (i4 = u3.clone(), n4[t4] = i4), u3 = i4;
      }
      return u3.visible = r3.visible, u3.wireframe = r3.wireframe, u3.side = o3 === d ? null !== r3.shadowSide ? r3.shadowSide : r3.side : null !== r3.shadowSide ? r3.shadowSide : p2[r3.side], u3.alphaMap = r3.alphaMap, u3.alphaTest = r3.alphaTest, u3.clipShadows = r3.clipShadows, u3.clippingPlanes = r3.clippingPlanes, u3.clipIntersection = r3.clipIntersection, u3.displacementMap = r3.displacementMap, u3.displacementScale = r3.displacementScale, u3.displacementBias = r3.displacementBias, u3.wireframeLinewidth = r3.wireframeLinewidth, u3.linewidth = r3.linewidth, true === n3.isPointLight && true === u3.isMeshDistanceMaterial && (u3.referencePosition.setFromMatrixPosition(n3.matrixWorld), u3.nearDistance = i3, u3.farDistance = s3), u3;
    }
    function S2(r3, i3, s3, o3, a3) {
      if (false === r3.visible)
        return;
      if (r3.layers.test(i3.layers) && (r3.isMesh || r3.isLine || r3.isPoints) && (r3.castShadow || r3.receiveShadow && a3 === d) && (!r3.frustumCulled || n2.intersectsObject(r3))) {
        r3.modelViewMatrix.multiplyMatrices(s3.matrixWorldInverse, r3.matrixWorld);
        const n3 = t2.update(r3), i4 = r3.material;
        if (Array.isArray(i4)) {
          const t3 = n3.groups;
          for (let l4 = 0, c3 = t3.length; l4 < c3; l4++) {
            const c4 = t3[l4], u3 = i4[c4.materialIndex];
            if (u3 && u3.visible) {
              const t4 = E2(r3, u3, o3, s3.near, s3.far, a3);
              e2.renderBufferDirect(s3, null, n3, t4, r3, c4);
            }
          }
        } else if (i4.visible) {
          const t3 = E2(r3, i4, o3, s3.near, s3.far, a3);
          e2.renderBufferDirect(s3, null, n3, t3, r3, null);
        }
      }
      const l3 = r3.children;
      for (let e3 = 0, t3 = l3.length; e3 < t3; e3++)
        S2(l3[e3], i3, s3, o3, a3);
    }
    this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = h, this.render = function(t3, r3, a3) {
      if (false === x2.enabled)
        return;
      if (false === x2.autoUpdate && false === x2.needsUpdate)
        return;
      if (0 === t3.length)
        return;
      const l3 = e2.getRenderTarget(), c3 = e2.getActiveCubeFace(), h2 = e2.getActiveMipmapLevel(), p3 = e2.state;
      p3.setBlending(g), p3.buffers.color.setClear(1, 1, 1, 1), p3.buffers.depth.setTest(true), p3.setScissorTest(false);
      for (let l4 = 0, c4 = t3.length; l4 < c4; l4++) {
        const c5 = t3[l4], h3 = c5.shadow;
        if (void 0 === h3) {
          console.warn("THREE.WebGLShadowMap:", c5, "has no shadow.");
          continue;
        }
        if (false === h3.autoUpdate && false === h3.needsUpdate)
          continue;
        i2.copy(h3.mapSize);
        const f2 = h3.getFrameExtents();
        if (i2.multiply(f2), s2.copy(h3.mapSize), (i2.x > u2 || i2.y > u2) && (i2.x > u2 && (s2.x = Math.floor(u2 / f2.x), i2.x = s2.x * f2.x, h3.mapSize.x = s2.x), i2.y > u2 && (s2.y = Math.floor(u2 / f2.y), i2.y = s2.y * f2.y, h3.mapSize.y = s2.y)), null === h3.map) {
          const e3 = this.type !== d ? { minFilter: he, magFilter: he } : {};
          h3.map = new en(i2.x, i2.y, e3), h3.map.texture.name = c5.name + ".shadowMap", h3.camera.updateProjectionMatrix();
        }
        e2.setRenderTarget(h3.map), e2.clear();
        const m2 = h3.getViewportCount();
        for (let e3 = 0; e3 < m2; e3++) {
          const t4 = h3.getViewport(e3);
          o2.set(s2.x * t4.x, s2.y * t4.y, s2.x * t4.z, s2.y * t4.w), p3.viewport(o2), h3.updateMatrices(c5, e3), n2 = h3.getFrustum(), S2(r3, a3, h3.camera, c5, this.type);
        }
        true !== h3.isPointLightShadow && this.type === d && w2(h3, a3), h3.needsUpdate = false;
      }
      x2.needsUpdate = false, e2.setRenderTarget(l3, c3, h2);
    };
  }
  function Ka(e2, t2, r2) {
    const n2 = r2.isWebGL2, i2 = new function() {
      let t3 = false;
      const r3 = new $r();
      let n3 = null;
      const i3 = new $r(0, 0, 0, 0);
      return { setMask: function(r4) {
        n3 === r4 || t3 || (e2.colorMask(r4, r4, r4, r4), n3 = r4);
      }, setLocked: function(e3) {
        t3 = e3;
      }, setClear: function(t4, n4, s3, o2, a2) {
        true === a2 && (t4 *= o2, n4 *= o2, s3 *= o2), r3.set(t4, n4, s3, o2), false === i3.equals(r3) && (e2.clearColor(t4, n4, s3, o2), i3.copy(r3));
      }, reset: function() {
        t3 = false, n3 = null, i3.set(-1, 0, 0, 0);
      } };
    }(), s2 = new function() {
      let t3 = false, r3 = null, n3 = null, i3 = null;
      return { setTest: function(e3) {
        e3 ? ye2(2929) : xe2(2929);
      }, setMask: function(n4) {
        r3 === n4 || t3 || (e2.depthMask(n4), r3 = n4);
      }, setFunc: function(t4) {
        if (n3 !== t4) {
          if (t4)
            switch (t4) {
              case N:
                e2.depthFunc(512);
                break;
              case j:
                e2.depthFunc(519);
                break;
              case z:
                e2.depthFunc(513);
                break;
              case G:
                e2.depthFunc(515);
                break;
              case V:
                e2.depthFunc(514);
                break;
              case Q:
                e2.depthFunc(518);
                break;
              case H:
                e2.depthFunc(516);
                break;
              case W:
                e2.depthFunc(517);
                break;
              default:
                e2.depthFunc(515);
            }
          else
            e2.depthFunc(515);
          n3 = t4;
        }
      }, setLocked: function(e3) {
        t3 = e3;
      }, setClear: function(t4) {
        i3 !== t4 && (e2.clearDepth(t4), i3 = t4);
      }, reset: function() {
        t3 = false, r3 = null, n3 = null, i3 = null;
      } };
    }(), c2 = new function() {
      let t3 = false, r3 = null, n3 = null, i3 = null, s3 = null, o2 = null, a2 = null, l2 = null, c3 = null;
      return { setTest: function(e3) {
        t3 || (e3 ? ye2(2960) : xe2(2960));
      }, setMask: function(n4) {
        r3 === n4 || t3 || (e2.stencilMask(n4), r3 = n4);
      }, setFunc: function(t4, r4, o3) {
        n3 === t4 && i3 === r4 && s3 === o3 || (e2.stencilFunc(t4, r4, o3), n3 = t4, i3 = r4, s3 = o3);
      }, setOp: function(t4, r4, n4) {
        o2 === t4 && a2 === r4 && l2 === n4 || (e2.stencilOp(t4, r4, n4), o2 = t4, a2 = r4, l2 = n4);
      }, setLocked: function(e3) {
        t3 = e3;
      }, setClear: function(t4) {
        c3 !== t4 && (e2.clearStencil(t4), c3 = t4);
      }, reset: function() {
        t3 = false, r3 = null, n3 = null, i3 = null, s3 = null, o2 = null, a2 = null, l2 = null, c3 = null;
      } };
    }(), u2 = /* @__PURE__ */ new WeakMap(), h2 = /* @__PURE__ */ new WeakMap();
    let p2 = {}, d2 = {}, f2 = /* @__PURE__ */ new WeakMap(), q2 = [], X2 = null, Y2 = false, K2 = null, J2 = null, Z2 = null, $2 = null, ee2 = null, te2 = null, re2 = null, ne2 = false, ie2 = null, se2 = null, oe2 = null, ae2 = null, le2 = null;
    const ce2 = e2.getParameter(35661);
    let ue2 = false, he2 = 0;
    const pe2 = e2.getParameter(7938);
    -1 !== pe2.indexOf("WebGL") ? (he2 = parseFloat(/^WebGL (\d)/.exec(pe2)[1]), ue2 = he2 >= 1) : -1 !== pe2.indexOf("OpenGL ES") && (he2 = parseFloat(/^OpenGL ES (\d)/.exec(pe2)[1]), ue2 = he2 >= 2);
    let de2 = null, fe2 = {};
    const me2 = e2.getParameter(3088), _e2 = e2.getParameter(2978), ge2 = new $r().fromArray(me2), ve2 = new $r().fromArray(_e2);
    function Ae2(t3, r3, n3) {
      const i3 = new Uint8Array(4), s3 = e2.createTexture();
      e2.bindTexture(t3, s3), e2.texParameteri(t3, 10241, 9728), e2.texParameteri(t3, 10240, 9728);
      for (let t4 = 0; t4 < n3; t4++)
        e2.texImage2D(r3 + t4, 0, 6408, 1, 1, 0, 6408, 5121, i3);
      return s3;
    }
    const be2 = {};
    function ye2(t3) {
      true !== p2[t3] && (e2.enable(t3), p2[t3] = true);
    }
    function xe2(t3) {
      false !== p2[t3] && (e2.disable(t3), p2[t3] = false);
    }
    be2[3553] = Ae2(3553, 3553, 1), be2[34067] = Ae2(34067, 34069, 6), i2.setClear(0, 0, 0, 1), s2.setClear(1), c2.setClear(0), ye2(2929), s2.setFunc(G), Ce2(false), Me2(a), ye2(2884), Se2(g);
    const we2 = { [w]: 32774, [E]: 32778, [S]: 32779 };
    if (n2)
      we2[C] = 32775, we2[M] = 32776;
    else {
      const e3 = t2.get("EXT_blend_minmax");
      null !== e3 && (we2[C] = e3.MIN_EXT, we2[M] = e3.MAX_EXT);
    }
    const Ee2 = { [T]: 0, [I]: 1, [k]: 768, [P]: 770, [U]: 776, [O]: 774, [R]: 772, [D]: 769, [B]: 771, [F]: 775, [L]: 773 };
    function Se2(t3, r3, n3, i3, s3, o2, a2, l2) {
      if (t3 !== g) {
        if (false === Y2 && (ye2(3042), Y2 = true), t3 === x)
          s3 = s3 || r3, o2 = o2 || n3, a2 = a2 || i3, r3 === J2 && s3 === ee2 || (e2.blendEquationSeparate(we2[r3], we2[s3]), J2 = r3, ee2 = s3), n3 === Z2 && i3 === $2 && o2 === te2 && a2 === re2 || (e2.blendFuncSeparate(Ee2[n3], Ee2[i3], Ee2[o2], Ee2[a2]), Z2 = n3, $2 = i3, te2 = o2, re2 = a2), K2 = t3, ne2 = null;
        else if (t3 !== K2 || l2 !== ne2) {
          if (J2 === w && ee2 === w || (e2.blendEquation(32774), J2 = w, ee2 = w), l2)
            switch (t3) {
              case v:
                e2.blendFuncSeparate(1, 771, 1, 771);
                break;
              case A:
                e2.blendFunc(1, 1);
                break;
              case b:
                e2.blendFuncSeparate(0, 769, 0, 1);
                break;
              case y:
                e2.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", t3);
            }
          else
            switch (t3) {
              case v:
                e2.blendFuncSeparate(770, 771, 1, 771);
                break;
              case A:
                e2.blendFunc(770, 1);
                break;
              case b:
                e2.blendFuncSeparate(0, 769, 0, 1);
                break;
              case y:
                e2.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", t3);
            }
          Z2 = null, $2 = null, te2 = null, re2 = null, K2 = t3, ne2 = l2;
        }
      } else
        true === Y2 && (xe2(3042), Y2 = false);
    }
    function Ce2(t3) {
      ie2 !== t3 && (t3 ? e2.frontFace(2304) : e2.frontFace(2305), ie2 = t3);
    }
    function Me2(t3) {
      t3 !== o ? (ye2(2884), t3 !== se2 && (t3 === a ? e2.cullFace(1029) : t3 === l ? e2.cullFace(1028) : e2.cullFace(1032))) : xe2(2884), se2 = t3;
    }
    function Te2(t3, r3, n3) {
      t3 ? (ye2(32823), ae2 === r3 && le2 === n3 || (e2.polygonOffset(r3, n3), ae2 = r3, le2 = n3)) : xe2(32823);
    }
    function Ie2(t3) {
      void 0 === t3 && (t3 = 33984 + ce2 - 1), de2 !== t3 && (e2.activeTexture(t3), de2 = t3);
    }
    return { buffers: { color: i2, depth: s2, stencil: c2 }, enable: ye2, disable: xe2, bindFramebuffer: function(t3, r3) {
      return d2[t3] !== r3 && (e2.bindFramebuffer(t3, r3), d2[t3] = r3, n2 && (36009 === t3 && (d2[36160] = r3), 36160 === t3 && (d2[36009] = r3)), true);
    }, drawBuffers: function(n3, i3) {
      let s3 = q2, o2 = false;
      if (n3)
        if (s3 = f2.get(i3), void 0 === s3 && (s3 = [], f2.set(i3, s3)), n3.isWebGLMultipleRenderTargets) {
          const e3 = n3.texture;
          if (s3.length !== e3.length || 36064 !== s3[0]) {
            for (let t3 = 0, r3 = e3.length; t3 < r3; t3++)
              s3[t3] = 36064 + t3;
            s3.length = e3.length, o2 = true;
          }
        } else
          36064 !== s3[0] && (s3[0] = 36064, o2 = true);
      else
        1029 !== s3[0] && (s3[0] = 1029, o2 = true);
      o2 && (r2.isWebGL2 ? e2.drawBuffers(s3) : t2.get("WEBGL_draw_buffers").drawBuffersWEBGL(s3));
    }, useProgram: function(t3) {
      return X2 !== t3 && (e2.useProgram(t3), X2 = t3, true);
    }, setBlending: Se2, setMaterial: function(e3, t3) {
      e3.side === _ ? xe2(2884) : ye2(2884);
      let r3 = e3.side === m;
      t3 && (r3 = !r3), Ce2(r3), e3.blending === v && false === e3.transparent ? Se2(g) : Se2(e3.blending, e3.blendEquation, e3.blendSrc, e3.blendDst, e3.blendEquationAlpha, e3.blendSrcAlpha, e3.blendDstAlpha, e3.premultipliedAlpha), s2.setFunc(e3.depthFunc), s2.setTest(e3.depthTest), s2.setMask(e3.depthWrite), i2.setMask(e3.colorWrite);
      const n3 = e3.stencilWrite;
      c2.setTest(n3), n3 && (c2.setMask(e3.stencilWriteMask), c2.setFunc(e3.stencilFunc, e3.stencilRef, e3.stencilFuncMask), c2.setOp(e3.stencilFail, e3.stencilZFail, e3.stencilZPass)), Te2(e3.polygonOffset, e3.polygonOffsetFactor, e3.polygonOffsetUnits), true === e3.alphaToCoverage ? ye2(32926) : xe2(32926);
    }, setFlipSided: Ce2, setCullFace: Me2, setLineWidth: function(t3) {
      t3 !== oe2 && (ue2 && e2.lineWidth(t3), oe2 = t3);
    }, setPolygonOffset: Te2, setScissorTest: function(e3) {
      e3 ? ye2(3089) : xe2(3089);
    }, activeTexture: Ie2, bindTexture: function(t3, r3) {
      null === de2 && Ie2();
      let n3 = fe2[de2];
      void 0 === n3 && (n3 = { type: void 0, texture: void 0 }, fe2[de2] = n3), n3.type === t3 && n3.texture === r3 || (e2.bindTexture(t3, r3 || be2[t3]), n3.type = t3, n3.texture = r3);
    }, unbindTexture: function() {
      const t3 = fe2[de2];
      void 0 !== t3 && void 0 !== t3.type && (e2.bindTexture(t3.type, null), t3.type = void 0, t3.texture = void 0);
    }, compressedTexImage2D: function() {
      try {
        e2.compressedTexImage2D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, texImage2D: function() {
      try {
        e2.texImage2D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, texImage3D: function() {
      try {
        e2.texImage3D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, updateUBOMapping: function(t3, r3) {
      let n3 = h2.get(r3);
      void 0 === n3 && (n3 = /* @__PURE__ */ new WeakMap(), h2.set(r3, n3));
      let i3 = n3.get(t3);
      void 0 === i3 && (i3 = e2.getUniformBlockIndex(r3, t3.name), n3.set(t3, i3));
    }, uniformBlockBinding: function(t3, r3) {
      const n3 = h2.get(r3).get(t3);
      u2.get(t3) !== n3 && (e2.uniformBlockBinding(r3, n3, t3.__bindingPointIndex), u2.set(t3, n3));
    }, texStorage2D: function() {
      try {
        e2.texStorage2D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, texStorage3D: function() {
      try {
        e2.texStorage3D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, texSubImage2D: function() {
      try {
        e2.texSubImage2D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, texSubImage3D: function() {
      try {
        e2.texSubImage3D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, compressedTexSubImage2D: function() {
      try {
        e2.compressedTexSubImage2D.apply(e2, arguments);
      } catch (e3) {
        console.error("THREE.WebGLState:", e3);
      }
    }, scissor: function(t3) {
      false === ge2.equals(t3) && (e2.scissor(t3.x, t3.y, t3.z, t3.w), ge2.copy(t3));
    }, viewport: function(t3) {
      false === ve2.equals(t3) && (e2.viewport(t3.x, t3.y, t3.z, t3.w), ve2.copy(t3));
    }, reset: function() {
      e2.disable(3042), e2.disable(2884), e2.disable(2929), e2.disable(32823), e2.disable(3089), e2.disable(2960), e2.disable(32926), e2.blendEquation(32774), e2.blendFunc(1, 0), e2.blendFuncSeparate(1, 0, 1, 0), e2.colorMask(true, true, true, true), e2.clearColor(0, 0, 0, 0), e2.depthMask(true), e2.depthFunc(513), e2.clearDepth(1), e2.stencilMask(4294967295), e2.stencilFunc(519, 0, 4294967295), e2.stencilOp(7680, 7680, 7680), e2.clearStencil(0), e2.cullFace(1029), e2.frontFace(2305), e2.polygonOffset(0, 0), e2.activeTexture(33984), e2.bindFramebuffer(36160, null), true === n2 && (e2.bindFramebuffer(36009, null), e2.bindFramebuffer(36008, null)), e2.useProgram(null), e2.lineWidth(1), e2.scissor(0, 0, e2.canvas.width, e2.canvas.height), e2.viewport(0, 0, e2.canvas.width, e2.canvas.height), p2 = {}, de2 = null, fe2 = {}, d2 = {}, f2 = /* @__PURE__ */ new WeakMap(), q2 = [], X2 = null, Y2 = false, K2 = null, J2 = null, Z2 = null, $2 = null, ee2 = null, te2 = null, re2 = null, ne2 = false, ie2 = null, se2 = null, oe2 = null, ae2 = null, le2 = null, ge2.set(0, 0, e2.canvas.width, e2.canvas.height), ve2.set(0, 0, e2.canvas.width, e2.canvas.height), i2.reset(), s2.reset(), c2.reset();
    } };
  }
  function Ja(e2, t2, r2, n2, i2, s2, o2) {
    const a2 = i2.isWebGL2, l2 = i2.maxTextures, c2 = i2.maxCubemapSize, u2 = i2.maxTextureSize, h2 = i2.maxSamples, p2 = t2.has("WEBGL_multisampled_render_to_texture") ? t2.get("WEBGL_multisampled_render_to_texture") : null, d2 = /OculusBrowser/g.test(navigator.userAgent), f2 = /* @__PURE__ */ new WeakMap();
    let m2;
    const _2 = /* @__PURE__ */ new WeakMap();
    let g2 = false;
    try {
      g2 = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
    } catch (e3) {
    }
    function v2(e3, t3) {
      return g2 ? new OffscreenCanvas(e3, t3) : Lr("canvas");
    }
    function A2(e3, t3, r3, n3) {
      let i3 = 1;
      if ((e3.width > n3 || e3.height > n3) && (i3 = n3 / Math.max(e3.width, e3.height)), i3 < 1 || true === t3) {
        if ("undefined" != typeof HTMLImageElement && e3 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e3 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e3 instanceof ImageBitmap) {
          const n4 = t3 ? Cr : Math.floor, s3 = n4(i3 * e3.width), o3 = n4(i3 * e3.height);
          void 0 === m2 && (m2 = v2(s3, o3));
          const a3 = r3 ? v2(s3, o3) : m2;
          return a3.width = s3, a3.height = o3, a3.getContext("2d").drawImage(e3, 0, 0, s3, o3), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e3.width + "x" + e3.height + ") to (" + s3 + "x" + o3 + ")."), a3;
        }
        return "data" in e3 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e3.width + "x" + e3.height + ")."), e3;
      }
      return e3;
    }
    function b2(e3) {
      return Er(e3.width) && Er(e3.height);
    }
    function y2(e3, t3) {
      return e3.generateMipmaps && t3 && e3.minFilter !== he && e3.minFilter !== _e;
    }
    function x2(t3) {
      e2.generateMipmap(t3);
    }
    function w2(r3, n3, i3, s3, o3 = false) {
      if (false === a2)
        return n3;
      if (null !== r3) {
        if (void 0 !== e2[r3])
          return e2[r3];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + r3 + "'");
      }
      let l3 = n3;
      return 6403 === n3 && (5126 === i3 && (l3 = 33326), 5131 === i3 && (l3 = 33325), 5121 === i3 && (l3 = 33321)), 33319 === n3 && (5126 === i3 && (l3 = 33328), 5131 === i3 && (l3 = 33327), 5121 === i3 && (l3 = 33323)), 6408 === n3 && (5126 === i3 && (l3 = 34836), 5131 === i3 && (l3 = 34842), 5121 === i3 && (l3 = s3 === Dt && false === o3 ? 35907 : 32856), 32819 === i3 && (l3 = 32854), 32820 === i3 && (l3 = 32855)), 33325 !== l3 && 33326 !== l3 && 33327 !== l3 && 33328 !== l3 && 34842 !== l3 && 34836 !== l3 || t2.get("EXT_color_buffer_float"), l3;
    }
    function E2(e3, t3, r3) {
      return true === y2(e3, r3) || e3.isFramebufferTexture && e3.minFilter !== he && e3.minFilter !== _e ? Math.log2(Math.max(t3.width, t3.height)) + 1 : void 0 !== e3.mipmaps && e3.mipmaps.length > 0 ? e3.mipmaps.length : e3.isCompressedTexture && Array.isArray(e3.image) ? t3.mipmaps.length : 1;
    }
    function S2(e3) {
      return e3 === he || e3 === pe || e3 === fe ? 9728 : 9729;
    }
    function C2(e3) {
      const t3 = e3.target;
      t3.removeEventListener("dispose", C2), function(e4) {
        const t4 = n2.get(e4);
        if (void 0 === t4.__webglInit)
          return;
        const r3 = e4.source, i3 = _2.get(r3);
        if (i3) {
          const n3 = i3[t4.__cacheKey];
          n3.usedTimes--, 0 === n3.usedTimes && T2(e4), 0 === Object.keys(i3).length && _2.delete(r3);
        }
        n2.remove(e4);
      }(t3), t3.isVideoTexture && f2.delete(t3);
    }
    function M2(t3) {
      const r3 = t3.target;
      r3.removeEventListener("dispose", M2), function(t4) {
        const r4 = t4.texture, i3 = n2.get(t4), s3 = n2.get(r4);
        if (void 0 !== s3.__webglTexture && (e2.deleteTexture(s3.__webglTexture), o2.memory.textures--), t4.depthTexture && t4.depthTexture.dispose(), t4.isWebGLCubeRenderTarget)
          for (let t5 = 0; t5 < 6; t5++)
            e2.deleteFramebuffer(i3.__webglFramebuffer[t5]), i3.__webglDepthbuffer && e2.deleteRenderbuffer(i3.__webglDepthbuffer[t5]);
        else {
          if (e2.deleteFramebuffer(i3.__webglFramebuffer), i3.__webglDepthbuffer && e2.deleteRenderbuffer(i3.__webglDepthbuffer), i3.__webglMultisampledFramebuffer && e2.deleteFramebuffer(i3.__webglMultisampledFramebuffer), i3.__webglColorRenderbuffer)
            for (let t5 = 0; t5 < i3.__webglColorRenderbuffer.length; t5++)
              i3.__webglColorRenderbuffer[t5] && e2.deleteRenderbuffer(i3.__webglColorRenderbuffer[t5]);
          i3.__webglDepthRenderbuffer && e2.deleteRenderbuffer(i3.__webglDepthRenderbuffer);
        }
        if (t4.isWebGLMultipleRenderTargets)
          for (let t5 = 0, i4 = r4.length; t5 < i4; t5++) {
            const i5 = n2.get(r4[t5]);
            i5.__webglTexture && (e2.deleteTexture(i5.__webglTexture), o2.memory.textures--), n2.remove(r4[t5]);
          }
        n2.remove(r4), n2.remove(t4);
      }(r3);
    }
    function T2(t3) {
      const r3 = n2.get(t3);
      e2.deleteTexture(r3.__webglTexture);
      const i3 = t3.source;
      delete _2.get(i3)[r3.__cacheKey], o2.memory.textures--;
    }
    let I2 = 0;
    function k2(e3, t3) {
      const i3 = n2.get(e3);
      if (e3.isVideoTexture && function(e4) {
        const t4 = o2.render.frame;
        f2.get(e4) !== t4 && (f2.set(e4, t4), e4.update());
      }(e3), false === e3.isRenderTargetTexture && e3.version > 0 && i3.__version !== e3.version) {
        const r3 = e3.image;
        if (null === r3)
          console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        else {
          if (false !== r3.complete)
            return void L2(i3, e3, t3);
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        }
      }
      r2.activeTexture(33984 + t3), r2.bindTexture(3553, i3.__webglTexture);
    }
    const D2 = { [le]: 10497, [ce]: 33071, [ue]: 33648 }, P2 = { [he]: 9728, [pe]: 9984, [fe]: 9986, [_e]: 9729, [ge]: 9985, [Ae]: 9987 };
    function B2(r3, s3, o3) {
      if (o3 ? (e2.texParameteri(r3, 10242, D2[s3.wrapS]), e2.texParameteri(r3, 10243, D2[s3.wrapT]), 32879 !== r3 && 35866 !== r3 || e2.texParameteri(r3, 32882, D2[s3.wrapR]), e2.texParameteri(r3, 10240, P2[s3.magFilter]), e2.texParameteri(r3, 10241, P2[s3.minFilter])) : (e2.texParameteri(r3, 10242, 33071), e2.texParameteri(r3, 10243, 33071), 32879 !== r3 && 35866 !== r3 || e2.texParameteri(r3, 32882, 33071), s3.wrapS === ce && s3.wrapT === ce || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e2.texParameteri(r3, 10240, S2(s3.magFilter)), e2.texParameteri(r3, 10241, S2(s3.minFilter)), s3.minFilter !== he && s3.minFilter !== _e && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), true === t2.has("EXT_texture_filter_anisotropic")) {
        const o4 = t2.get("EXT_texture_filter_anisotropic");
        if (s3.type === Me && false === t2.has("OES_texture_float_linear"))
          return;
        if (false === a2 && s3.type === Te && false === t2.has("OES_texture_half_float_linear"))
          return;
        (s3.anisotropy > 1 || n2.get(s3).__currentAnisotropy) && (e2.texParameterf(r3, o4.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s3.anisotropy, i2.getMaxAnisotropy())), n2.get(s3).__currentAnisotropy = s3.anisotropy);
      }
    }
    function R2(t3, r3) {
      let n3 = false;
      void 0 === t3.__webglInit && (t3.__webglInit = true, r3.addEventListener("dispose", C2));
      const i3 = r3.source;
      let s3 = _2.get(i3);
      void 0 === s3 && (s3 = {}, _2.set(i3, s3));
      const a3 = function(e3) {
        const t4 = [];
        return t4.push(e3.wrapS), t4.push(e3.wrapT), t4.push(e3.magFilter), t4.push(e3.minFilter), t4.push(e3.anisotropy), t4.push(e3.internalFormat), t4.push(e3.format), t4.push(e3.type), t4.push(e3.generateMipmaps), t4.push(e3.premultiplyAlpha), t4.push(e3.flipY), t4.push(e3.unpackAlignment), t4.push(e3.encoding), t4.join();
      }(r3);
      if (a3 !== t3.__cacheKey) {
        void 0 === s3[a3] && (s3[a3] = { texture: e2.createTexture(), usedTimes: 0 }, o2.memory.textures++, n3 = true), s3[a3].usedTimes++;
        const i4 = s3[t3.__cacheKey];
        void 0 !== i4 && (s3[t3.__cacheKey].usedTimes--, 0 === i4.usedTimes && T2(r3)), t3.__cacheKey = a3, t3.__webglTexture = s3[a3].texture;
      }
      return n3;
    }
    function L2(t3, n3, i3) {
      let o3 = 3553;
      n3.isDataArrayTexture && (o3 = 35866), n3.isData3DTexture && (o3 = 32879);
      const l3 = R2(t3, n3), c3 = n3.source;
      if (r2.activeTexture(33984 + i3), r2.bindTexture(o3, t3.__webglTexture), c3.version !== c3.__currentVersion || true === l3) {
        e2.pixelStorei(37440, n3.flipY), e2.pixelStorei(37441, n3.premultiplyAlpha), e2.pixelStorei(3317, n3.unpackAlignment), e2.pixelStorei(37443, 0);
        const t4 = function(e3) {
          return !a2 && (e3.wrapS !== ce || e3.wrapT !== ce || e3.minFilter !== he && e3.minFilter !== _e);
        }(n3) && false === b2(n3.image);
        let i4 = A2(n3.image, t4, false, u2);
        i4 = z2(n3, i4);
        const h3 = b2(i4) || a2, p3 = s2.convert(n3.format, n3.encoding);
        let d3, f3 = s2.convert(n3.type), m3 = w2(n3.internalFormat, p3, f3, n3.encoding, n3.isVideoTexture);
        B2(o3, n3, h3);
        const _3 = n3.mipmaps, g3 = a2 && true !== n3.isVideoTexture, v3 = void 0 === c3.__currentVersion || true === l3, S3 = E2(n3, i4, h3);
        if (n3.isDepthTexture)
          m3 = 6402, a2 ? m3 = n3.type === Me ? 36012 : n3.type === Ce ? 33190 : n3.type === De ? 35056 : 33189 : n3.type === Me && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), n3.format === Fe && 6402 === m3 && n3.type !== Ee && n3.type !== Ce && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n3.type = Ce, f3 = s2.convert(n3.type)), n3.format === Ue && 6402 === m3 && (m3 = 34041, n3.type !== De && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n3.type = De, f3 = s2.convert(n3.type))), v3 && (g3 ? r2.texStorage2D(3553, 1, m3, i4.width, i4.height) : r2.texImage2D(3553, 0, m3, i4.width, i4.height, 0, p3, f3, null));
        else if (n3.isDataTexture)
          if (_3.length > 0 && h3) {
            g3 && v3 && r2.texStorage2D(3553, S3, m3, _3[0].width, _3[0].height);
            for (let e3 = 0, t5 = _3.length; e3 < t5; e3++)
              d3 = _3[e3], g3 ? r2.texSubImage2D(3553, e3, 0, 0, d3.width, d3.height, p3, f3, d3.data) : r2.texImage2D(3553, e3, m3, d3.width, d3.height, 0, p3, f3, d3.data);
            n3.generateMipmaps = false;
          } else
            g3 ? (v3 && r2.texStorage2D(3553, S3, m3, i4.width, i4.height), r2.texSubImage2D(3553, 0, 0, 0, i4.width, i4.height, p3, f3, i4.data)) : r2.texImage2D(3553, 0, m3, i4.width, i4.height, 0, p3, f3, i4.data);
        else if (n3.isCompressedTexture) {
          g3 && v3 && r2.texStorage2D(3553, S3, m3, _3[0].width, _3[0].height);
          for (let e3 = 0, t5 = _3.length; e3 < t5; e3++)
            d3 = _3[e3], n3.format !== Re ? null !== p3 ? g3 ? r2.compressedTexSubImage2D(3553, e3, 0, 0, d3.width, d3.height, p3, d3.data) : r2.compressedTexImage2D(3553, e3, m3, d3.width, d3.height, 0, d3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : g3 ? r2.texSubImage2D(3553, e3, 0, 0, d3.width, d3.height, p3, f3, d3.data) : r2.texImage2D(3553, e3, m3, d3.width, d3.height, 0, p3, f3, d3.data);
        } else if (n3.isDataArrayTexture)
          g3 ? (v3 && r2.texStorage3D(35866, S3, m3, i4.width, i4.height, i4.depth), r2.texSubImage3D(35866, 0, 0, 0, 0, i4.width, i4.height, i4.depth, p3, f3, i4.data)) : r2.texImage3D(35866, 0, m3, i4.width, i4.height, i4.depth, 0, p3, f3, i4.data);
        else if (n3.isData3DTexture)
          g3 ? (v3 && r2.texStorage3D(32879, S3, m3, i4.width, i4.height, i4.depth), r2.texSubImage3D(32879, 0, 0, 0, 0, i4.width, i4.height, i4.depth, p3, f3, i4.data)) : r2.texImage3D(32879, 0, m3, i4.width, i4.height, i4.depth, 0, p3, f3, i4.data);
        else if (n3.isFramebufferTexture) {
          if (v3)
            if (g3)
              r2.texStorage2D(3553, S3, m3, i4.width, i4.height);
            else {
              let e3 = i4.width, t5 = i4.height;
              for (let n4 = 0; n4 < S3; n4++)
                r2.texImage2D(3553, n4, m3, e3, t5, 0, p3, f3, null), e3 >>= 1, t5 >>= 1;
            }
        } else if (_3.length > 0 && h3) {
          g3 && v3 && r2.texStorage2D(3553, S3, m3, _3[0].width, _3[0].height);
          for (let e3 = 0, t5 = _3.length; e3 < t5; e3++)
            d3 = _3[e3], g3 ? r2.texSubImage2D(3553, e3, 0, 0, p3, f3, d3) : r2.texImage2D(3553, e3, m3, p3, f3, d3);
          n3.generateMipmaps = false;
        } else
          g3 ? (v3 && r2.texStorage2D(3553, S3, m3, i4.width, i4.height), r2.texSubImage2D(3553, 0, 0, 0, p3, f3, i4)) : r2.texImage2D(3553, 0, m3, p3, f3, i4);
        y2(n3, h3) && x2(o3), c3.__currentVersion = c3.version, n3.onUpdate && n3.onUpdate(n3);
      }
      t3.__version = n3.version;
    }
    function O2(t3, i3, o3, a3, l3) {
      const c3 = s2.convert(o3.format, o3.encoding), u3 = s2.convert(o3.type), h3 = w2(o3.internalFormat, c3, u3, o3.encoding);
      n2.get(i3).__hasExternalTextures || (32879 === l3 || 35866 === l3 ? r2.texImage3D(l3, 0, h3, i3.width, i3.height, i3.depth, 0, c3, u3, null) : r2.texImage2D(l3, 0, h3, i3.width, i3.height, 0, c3, u3, null)), r2.bindFramebuffer(36160, t3), j2(i3) ? p2.framebufferTexture2DMultisampleEXT(36160, a3, l3, n2.get(o3).__webglTexture, 0, N2(i3)) : e2.framebufferTexture2D(36160, a3, l3, n2.get(o3).__webglTexture, 0), r2.bindFramebuffer(36160, null);
    }
    function F2(t3, r3, n3) {
      if (e2.bindRenderbuffer(36161, t3), r3.depthBuffer && !r3.stencilBuffer) {
        let i3 = 33189;
        if (n3 || j2(r3)) {
          const t4 = r3.depthTexture;
          t4 && t4.isDepthTexture && (t4.type === Me ? i3 = 36012 : t4.type === Ce && (i3 = 33190));
          const n4 = N2(r3);
          j2(r3) ? p2.renderbufferStorageMultisampleEXT(36161, n4, i3, r3.width, r3.height) : e2.renderbufferStorageMultisample(36161, n4, i3, r3.width, r3.height);
        } else
          e2.renderbufferStorage(36161, i3, r3.width, r3.height);
        e2.framebufferRenderbuffer(36160, 36096, 36161, t3);
      } else if (r3.depthBuffer && r3.stencilBuffer) {
        const i3 = N2(r3);
        n3 && false === j2(r3) ? e2.renderbufferStorageMultisample(36161, i3, 35056, r3.width, r3.height) : j2(r3) ? p2.renderbufferStorageMultisampleEXT(36161, i3, 35056, r3.width, r3.height) : e2.renderbufferStorage(36161, 34041, r3.width, r3.height), e2.framebufferRenderbuffer(36160, 33306, 36161, t3);
      } else {
        const t4 = true === r3.isWebGLMultipleRenderTargets ? r3.texture : [r3.texture];
        for (let i3 = 0; i3 < t4.length; i3++) {
          const o3 = t4[i3], a3 = s2.convert(o3.format, o3.encoding), l3 = s2.convert(o3.type), c3 = w2(o3.internalFormat, a3, l3, o3.encoding), u3 = N2(r3);
          n3 && false === j2(r3) ? e2.renderbufferStorageMultisample(36161, u3, c3, r3.width, r3.height) : j2(r3) ? p2.renderbufferStorageMultisampleEXT(36161, u3, c3, r3.width, r3.height) : e2.renderbufferStorage(36161, c3, r3.width, r3.height);
        }
      }
      e2.bindRenderbuffer(36161, null);
    }
    function U2(t3) {
      const i3 = n2.get(t3), s3 = true === t3.isWebGLCubeRenderTarget;
      if (t3.depthTexture && !i3.__autoAllocateDepthBuffer) {
        if (s3)
          throw new Error("target.depthTexture not supported in Cube render targets");
        !function(t4, i4) {
          if (i4 && i4.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
          if (r2.bindFramebuffer(36160, t4), !i4.depthTexture || !i4.depthTexture.isDepthTexture)
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          n2.get(i4.depthTexture).__webglTexture && i4.depthTexture.image.width === i4.width && i4.depthTexture.image.height === i4.height || (i4.depthTexture.image.width = i4.width, i4.depthTexture.image.height = i4.height, i4.depthTexture.needsUpdate = true), k2(i4.depthTexture, 0);
          const s4 = n2.get(i4.depthTexture).__webglTexture, o3 = N2(i4);
          if (i4.depthTexture.format === Fe)
            j2(i4) ? p2.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s4, 0, o3) : e2.framebufferTexture2D(36160, 36096, 3553, s4, 0);
          else {
            if (i4.depthTexture.format !== Ue)
              throw new Error("Unknown depthTexture format");
            j2(i4) ? p2.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s4, 0, o3) : e2.framebufferTexture2D(36160, 33306, 3553, s4, 0);
          }
        }(i3.__webglFramebuffer, t3);
      } else if (s3) {
        i3.__webglDepthbuffer = [];
        for (let n3 = 0; n3 < 6; n3++)
          r2.bindFramebuffer(36160, i3.__webglFramebuffer[n3]), i3.__webglDepthbuffer[n3] = e2.createRenderbuffer(), F2(i3.__webglDepthbuffer[n3], t3, false);
      } else
        r2.bindFramebuffer(36160, i3.__webglFramebuffer), i3.__webglDepthbuffer = e2.createRenderbuffer(), F2(i3.__webglDepthbuffer, t3, false);
      r2.bindFramebuffer(36160, null);
    }
    function N2(e3) {
      return Math.min(h2, e3.samples);
    }
    function j2(e3) {
      const r3 = n2.get(e3);
      return a2 && e3.samples > 0 && true === t2.has("WEBGL_multisampled_render_to_texture") && false !== r3.__useRenderToTexture;
    }
    function z2(e3, r3) {
      const n3 = e3.encoding, i3 = e3.format, s3 = e3.type;
      return true === e3.isCompressedTexture || true === e3.isVideoTexture || e3.format === fr || n3 !== kt && (n3 === Dt ? false === a2 ? true === t2.has("EXT_sRGB") && i3 === Re ? (e3.format = fr, e3.minFilter = _e, e3.generateMipmaps = false) : r3 = Xr.sRGBToLinear(r3) : i3 === Re && s3 === ye || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : n3 === RGBM16Encoding || console.error("THREE.WebGLTextures: Unsupported texture encoding:", n3)), r3;
    }
    this.allocateTextureUnit = function() {
      const e3 = I2;
      return e3 >= l2 && console.warn("THREE.WebGLTextures: Trying to use " + e3 + " texture units while this GPU supports only " + l2), I2 += 1, e3;
    }, this.resetTextureUnits = function() {
      I2 = 0;
    }, this.setTexture2D = k2, this.setTexture2DArray = function(e3, t3) {
      const i3 = n2.get(e3);
      e3.version > 0 && i3.__version !== e3.version ? L2(i3, e3, t3) : (r2.activeTexture(33984 + t3), r2.bindTexture(35866, i3.__webglTexture));
    }, this.setTexture3D = function(e3, t3) {
      const i3 = n2.get(e3);
      e3.version > 0 && i3.__version !== e3.version ? L2(i3, e3, t3) : (r2.activeTexture(33984 + t3), r2.bindTexture(32879, i3.__webglTexture));
    }, this.setTextureCube = function(t3, i3) {
      const o3 = n2.get(t3);
      t3.version > 0 && o3.__version !== t3.version ? function(t4, n3, i4) {
        if (6 !== n3.image.length)
          return;
        const o4 = R2(t4, n3), l3 = n3.source;
        if (r2.activeTexture(33984 + i4), r2.bindTexture(34067, t4.__webglTexture), l3.version !== l3.__currentVersion || true === o4) {
          e2.pixelStorei(37440, n3.flipY), e2.pixelStorei(37441, n3.premultiplyAlpha), e2.pixelStorei(3317, n3.unpackAlignment), e2.pixelStorei(37443, 0);
          const t5 = n3.isCompressedTexture || n3.image[0].isCompressedTexture, i5 = n3.image[0] && n3.image[0].isDataTexture, u3 = [];
          for (let e3 = 0; e3 < 6; e3++)
            u3[e3] = t5 || i5 ? i5 ? n3.image[e3].image : n3.image[e3] : A2(n3.image[e3], false, true, c2), u3[e3] = z2(n3, u3[e3]);
          const h3 = u3[0], p3 = b2(h3) || a2, d3 = s2.convert(n3.format, n3.encoding), f3 = s2.convert(n3.type), m3 = w2(n3.internalFormat, d3, f3, n3.encoding), _3 = a2 && true !== n3.isVideoTexture, g3 = void 0 === l3.__currentVersion || true === o4;
          let v3, S3 = E2(n3, h3, p3);
          if (B2(34067, n3, p3), t5) {
            _3 && g3 && r2.texStorage2D(34067, S3, m3, h3.width, h3.height);
            for (let e3 = 0; e3 < 6; e3++) {
              v3 = u3[e3].mipmaps;
              for (let t6 = 0; t6 < v3.length; t6++) {
                const i6 = v3[t6];
                n3.format !== Re ? null !== d3 ? _3 ? r2.compressedTexSubImage2D(34069 + e3, t6, 0, 0, i6.width, i6.height, d3, i6.data) : r2.compressedTexImage2D(34069 + e3, t6, m3, i6.width, i6.height, 0, i6.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : _3 ? r2.texSubImage2D(34069 + e3, t6, 0, 0, i6.width, i6.height, d3, f3, i6.data) : r2.texImage2D(34069 + e3, t6, m3, i6.width, i6.height, 0, d3, f3, i6.data);
              }
            }
          } else {
            v3 = n3.mipmaps, _3 && g3 && (v3.length > 0 && S3++, r2.texStorage2D(34067, S3, m3, u3[0].width, u3[0].height));
            for (let e3 = 0; e3 < 6; e3++)
              if (i5) {
                _3 ? r2.texSubImage2D(34069 + e3, 0, 0, 0, u3[e3].width, u3[e3].height, d3, f3, u3[e3].data) : r2.texImage2D(34069 + e3, 0, m3, u3[e3].width, u3[e3].height, 0, d3, f3, u3[e3].data);
                for (let t6 = 0; t6 < v3.length; t6++) {
                  const n4 = v3[t6].image[e3].image;
                  _3 ? r2.texSubImage2D(34069 + e3, t6 + 1, 0, 0, n4.width, n4.height, d3, f3, n4.data) : r2.texImage2D(34069 + e3, t6 + 1, m3, n4.width, n4.height, 0, d3, f3, n4.data);
                }
              } else {
                _3 ? r2.texSubImage2D(34069 + e3, 0, 0, 0, d3, f3, u3[e3]) : r2.texImage2D(34069 + e3, 0, m3, d3, f3, u3[e3]);
                for (let t6 = 0; t6 < v3.length; t6++) {
                  const n4 = v3[t6];
                  _3 ? r2.texSubImage2D(34069 + e3, t6 + 1, 0, 0, d3, f3, n4.image[e3]) : r2.texImage2D(34069 + e3, t6 + 1, m3, d3, f3, n4.image[e3]);
                }
              }
          }
          y2(n3, p3) && x2(34067), l3.__currentVersion = l3.version, n3.onUpdate && n3.onUpdate(n3);
        }
        t4.__version = n3.version;
      }(o3, t3, i3) : (r2.activeTexture(33984 + i3), r2.bindTexture(34067, o3.__webglTexture));
    }, this.rebindTextures = function(e3, t3, r3) {
      const i3 = n2.get(e3);
      void 0 !== t3 && O2(i3.__webglFramebuffer, e3, e3.texture, 36064, 3553), void 0 !== r3 && U2(e3);
    }, this.setupRenderTarget = function(t3) {
      const l3 = t3.texture, c3 = n2.get(t3), u3 = n2.get(l3);
      t3.addEventListener("dispose", M2), true !== t3.isWebGLMultipleRenderTargets && (void 0 === u3.__webglTexture && (u3.__webglTexture = e2.createTexture()), u3.__version = l3.version, o2.memory.textures++);
      const h3 = true === t3.isWebGLCubeRenderTarget, p3 = true === t3.isWebGLMultipleRenderTargets, d3 = b2(t3) || a2;
      if (h3) {
        c3.__webglFramebuffer = [];
        for (let t4 = 0; t4 < 6; t4++)
          c3.__webglFramebuffer[t4] = e2.createFramebuffer();
      } else {
        if (c3.__webglFramebuffer = e2.createFramebuffer(), p3)
          if (i2.drawBuffers) {
            const r3 = t3.texture;
            for (let t4 = 0, i3 = r3.length; t4 < i3; t4++) {
              const i4 = n2.get(r3[t4]);
              void 0 === i4.__webglTexture && (i4.__webglTexture = e2.createTexture(), o2.memory.textures++);
            }
          } else
            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        if (a2 && t3.samples > 0 && false === j2(t3)) {
          const n3 = p3 ? l3 : [l3];
          c3.__webglMultisampledFramebuffer = e2.createFramebuffer(), c3.__webglColorRenderbuffer = [], r2.bindFramebuffer(36160, c3.__webglMultisampledFramebuffer);
          for (let r3 = 0; r3 < n3.length; r3++) {
            const i3 = n3[r3];
            c3.__webglColorRenderbuffer[r3] = e2.createRenderbuffer(), e2.bindRenderbuffer(36161, c3.__webglColorRenderbuffer[r3]);
            const o3 = s2.convert(i3.format, i3.encoding), a3 = s2.convert(i3.type), l4 = w2(i3.internalFormat, o3, a3, i3.encoding), u4 = N2(t3);
            e2.renderbufferStorageMultisample(36161, u4, l4, t3.width, t3.height), e2.framebufferRenderbuffer(36160, 36064 + r3, 36161, c3.__webglColorRenderbuffer[r3]);
          }
          e2.bindRenderbuffer(36161, null), t3.depthBuffer && (c3.__webglDepthRenderbuffer = e2.createRenderbuffer(), F2(c3.__webglDepthRenderbuffer, t3, true)), r2.bindFramebuffer(36160, null);
        }
      }
      if (h3) {
        r2.bindTexture(34067, u3.__webglTexture), B2(34067, l3, d3);
        for (let e3 = 0; e3 < 6; e3++)
          O2(c3.__webglFramebuffer[e3], t3, l3, 36064, 34069 + e3);
        y2(l3, d3) && x2(34067), r2.unbindTexture();
      } else if (p3) {
        const e3 = t3.texture;
        for (let i3 = 0, s3 = e3.length; i3 < s3; i3++) {
          const s4 = e3[i3], o3 = n2.get(s4);
          r2.bindTexture(3553, o3.__webglTexture), B2(3553, s4, d3), O2(c3.__webglFramebuffer, t3, s4, 36064 + i3, 3553), y2(s4, d3) && x2(3553);
        }
        r2.unbindTexture();
      } else {
        let e3 = 3553;
        (t3.isWebGL3DRenderTarget || t3.isWebGLArrayRenderTarget) && (a2 ? e3 = t3.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), r2.bindTexture(e3, u3.__webglTexture), B2(e3, l3, d3), O2(c3.__webglFramebuffer, t3, l3, 36064, e3), y2(l3, d3) && x2(e3), r2.unbindTexture();
      }
      t3.depthBuffer && U2(t3);
    }, this.updateRenderTargetMipmap = function(e3) {
      const t3 = b2(e3) || a2, i3 = true === e3.isWebGLMultipleRenderTargets ? e3.texture : [e3.texture], s3 = e3.isWebGLCubeRenderTarget ? 34067 : 3553;
      for (let e4 = 0, o3 = i3.length; e4 < o3; e4++) {
        const o4 = i3[e4], a3 = n2.get(o4), l3 = a3.__webglTexture;
        a3.__version !== o4.version && (r2.bindTexture(s3, l3), B2(s3, o4, t3), r2.unbindTexture(), a3.__version = o4.version), y2(o4, t3) && (r2.bindTexture(s3, l3), x2(s3), r2.unbindTexture());
      }
    }, this.updateMultisampleRenderTarget = function(t3) {
      if (a2 && t3.samples > 0 && false === j2(t3)) {
        const i3 = t3.isWebGLMultipleRenderTargets ? t3.texture : [t3.texture], s3 = t3.width, o3 = t3.height;
        let a3 = 16384;
        const l3 = [], c3 = t3.stencilBuffer ? 33306 : 36096, u3 = n2.get(t3), h3 = true === t3.isWebGLMultipleRenderTargets;
        if (h3)
          for (let t4 = 0; t4 < i3.length; t4++)
            r2.bindFramebuffer(36160, u3.__webglMultisampledFramebuffer), e2.framebufferRenderbuffer(36160, 36064 + t4, 36161, null), r2.bindFramebuffer(36160, u3.__webglFramebuffer), e2.framebufferTexture2D(36009, 36064 + t4, 3553, null, 0);
        r2.bindFramebuffer(36008, u3.__webglMultisampledFramebuffer), r2.bindFramebuffer(36009, u3.__webglFramebuffer);
        for (let r3 = 0; r3 < i3.length; r3++) {
          l3.push(36064 + r3), t3.depthBuffer && l3.push(c3);
          const p3 = void 0 !== u3.__ignoreDepthValues && u3.__ignoreDepthValues;
          if (false === p3 && (t3.depthBuffer && (a3 |= 256), t3.stencilBuffer && (a3 |= 1024)), h3 && e2.framebufferRenderbuffer(36008, 36064, 36161, u3.__webglColorRenderbuffer[r3]), true === p3 && (e2.invalidateFramebuffer(36008, [c3]), e2.invalidateFramebuffer(36009, [c3])), h3) {
            const t4 = n2.get(i3[r3]).__webglTexture;
            e2.framebufferTexture2D(36009, 36064, 3553, t4, 0);
          }
          e2.blitFramebuffer(0, 0, s3, o3, 0, 0, s3, o3, a3, 9728), d2 && e2.invalidateFramebuffer(36008, l3);
        }
        if (r2.bindFramebuffer(36008, null), r2.bindFramebuffer(36009, null), h3)
          for (let t4 = 0; t4 < i3.length; t4++) {
            r2.bindFramebuffer(36160, u3.__webglMultisampledFramebuffer), e2.framebufferRenderbuffer(36160, 36064 + t4, 36161, u3.__webglColorRenderbuffer[t4]);
            const s4 = n2.get(i3[t4]).__webglTexture;
            r2.bindFramebuffer(36160, u3.__webglFramebuffer), e2.framebufferTexture2D(36009, 36064 + t4, 3553, s4, 0);
          }
        r2.bindFramebuffer(36009, u3.__webglMultisampledFramebuffer);
      }
    }, this.setupDepthRenderbuffer = U2, this.setupFrameBufferTexture = O2, this.useMultisampledRTT = j2;
  }
  function Za(e2, t2, r2) {
    const n2 = r2.isWebGL2;
    return { convert: function(r3, i2 = null) {
      let s2;
      if (r3 === ye)
        return 5121;
      if (r3 === Ie)
        return 32819;
      if (r3 === ke)
        return 32820;
      if (r3 === xe)
        return 5120;
      if (r3 === we)
        return 5122;
      if (r3 === Ee)
        return 5123;
      if (r3 === Se)
        return 5124;
      if (r3 === Ce)
        return 5125;
      if (r3 === Me)
        return 5126;
      if (r3 === Te)
        return n2 ? 5131 : (s2 = t2.get("OES_texture_half_float"), null !== s2 ? s2.HALF_FLOAT_OES : null);
      if (r3 === Pe)
        return 6406;
      if (r3 === Re)
        return 6408;
      if (r3 === Le)
        return 6409;
      if (r3 === Oe)
        return 6410;
      if (r3 === Fe)
        return 6402;
      if (r3 === Ue)
        return 34041;
      if (r3 === Ne)
        return 6403;
      if (r3 === Be)
        return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
      if (r3 === fr)
        return s2 = t2.get("EXT_sRGB"), null !== s2 ? s2.SRGB_ALPHA_EXT : null;
      if (r3 === je)
        return 36244;
      if (r3 === ze)
        return 33319;
      if (r3 === Ge)
        return 33320;
      if (r3 === Ve)
        return 36249;
      if (r3 === Qe || r3 === He || r3 === We || r3 === qe)
        if (i2 === Dt) {
          if (s2 = t2.get("WEBGL_compressed_texture_s3tc_srgb"), null === s2)
            return null;
          if (r3 === Qe)
            return s2.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r3 === He)
            return s2.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r3 === We)
            return s2.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r3 === qe)
            return s2.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          if (s2 = t2.get("WEBGL_compressed_texture_s3tc"), null === s2)
            return null;
          if (r3 === Qe)
            return s2.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (r3 === He)
            return s2.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (r3 === We)
            return s2.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (r3 === qe)
            return s2.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
      if (r3 === Xe || r3 === Ye || r3 === Ke || r3 === Je) {
        if (s2 = t2.get("WEBGL_compressed_texture_pvrtc"), null === s2)
          return null;
        if (r3 === Xe)
          return s2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r3 === Ye)
          return s2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r3 === Ke)
          return s2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r3 === Je)
          return s2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
      if (r3 === Ze)
        return s2 = t2.get("WEBGL_compressed_texture_etc1"), null !== s2 ? s2.COMPRESSED_RGB_ETC1_WEBGL : null;
      if (r3 === $e || r3 === et) {
        if (s2 = t2.get("WEBGL_compressed_texture_etc"), null === s2)
          return null;
        if (r3 === $e)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ETC2 : s2.COMPRESSED_RGB8_ETC2;
        if (r3 === et)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s2.COMPRESSED_RGBA8_ETC2_EAC;
      }
      if (r3 === tt || r3 === rt || r3 === nt || r3 === it || r3 === st || r3 === ot || r3 === at || r3 === lt || r3 === ct || r3 === ut || r3 === ht || r3 === pt || r3 === dt || r3 === ft) {
        if (s2 = t2.get("WEBGL_compressed_texture_astc"), null === s2)
          return null;
        if (r3 === tt)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s2.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r3 === rt)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s2.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r3 === nt)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s2.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r3 === it)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s2.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r3 === st)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s2.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r3 === ot)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s2.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r3 === at)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s2.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r3 === lt)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s2.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r3 === ct)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s2.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r3 === ut)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s2.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r3 === ht)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s2.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r3 === pt)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s2.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r3 === dt)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s2.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r3 === ft)
          return i2 === Dt ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s2.COMPRESSED_RGBA_ASTC_12x12_KHR;
      }
      if (r3 === mt) {
        if (s2 = t2.get("EXT_texture_compression_bptc"), null === s2)
          return null;
        if (r3 === mt)
          return i2 === Dt ? s2.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s2.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      }
      return r3 === De ? n2 ? 34042 : (s2 = t2.get("WEBGL_depth_texture"), null !== s2 ? s2.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e2[r3] ? e2[r3] : null;
    } };
  }
  class $a extends gs {
    constructor(e2 = []) {
      super(), this.isArrayCamera = true, this.cameras = e2;
    }
  }
  class el extends ui {
    constructor() {
      super(), this.isGroup = true, this.type = "Group";
    }
  }
  const tl = { type: "move" };
  class rl {
    constructor() {
      this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
      return null === this._hand && (this._hand = new el(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
    }
    getTargetRaySpace() {
      return null === this._targetRay && (this._targetRay = new el(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new ln(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new ln()), this._targetRay;
    }
    getGripSpace() {
      return null === this._grip && (this._grip = new el(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new ln(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new ln()), this._grip;
    }
    dispatchEvent(e2) {
      return null !== this._targetRay && this._targetRay.dispatchEvent(e2), null !== this._grip && this._grip.dispatchEvent(e2), null !== this._hand && this._hand.dispatchEvent(e2), this;
    }
    disconnect(e2) {
      return this.dispatchEvent({ type: "disconnected", data: e2 }), null !== this._targetRay && (this._targetRay.visible = false), null !== this._grip && (this._grip.visible = false), null !== this._hand && (this._hand.visible = false), this;
    }
    update(e2, t2, r2) {
      let n2 = null, i2 = null, s2 = null;
      const o2 = this._targetRay, a2 = this._grip, l2 = this._hand;
      if (e2 && "visible-blurred" !== t2.session.visibilityState) {
        if (l2 && e2.hand) {
          s2 = true;
          for (const n4 of e2.hand.values()) {
            const e3 = t2.getJointPose(n4, r2);
            if (void 0 === l2.joints[n4.jointName]) {
              const e4 = new el();
              e4.matrixAutoUpdate = false, e4.visible = false, l2.joints[n4.jointName] = e4, l2.add(e4);
            }
            const i4 = l2.joints[n4.jointName];
            null !== e3 && (i4.matrix.fromArray(e3.transform.matrix), i4.matrix.decompose(i4.position, i4.rotation, i4.scale), i4.jointRadius = e3.radius), i4.visible = null !== e3;
          }
          const n3 = l2.joints["index-finger-tip"], i3 = l2.joints["thumb-tip"], o3 = n3.position.distanceTo(i3.position), a3 = 0.02, c2 = 5e-3;
          l2.inputState.pinching && o3 > a3 + c2 ? (l2.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: e2.handedness, target: this })) : !l2.inputState.pinching && o3 <= a3 - c2 && (l2.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: e2.handedness, target: this }));
        } else
          null !== a2 && e2.gripSpace && (i2 = t2.getPose(e2.gripSpace, r2), null !== i2 && (a2.matrix.fromArray(i2.transform.matrix), a2.matrix.decompose(a2.position, a2.rotation, a2.scale), i2.linearVelocity ? (a2.hasLinearVelocity = true, a2.linearVelocity.copy(i2.linearVelocity)) : a2.hasLinearVelocity = false, i2.angularVelocity ? (a2.hasAngularVelocity = true, a2.angularVelocity.copy(i2.angularVelocity)) : a2.hasAngularVelocity = false));
        null !== o2 && (n2 = t2.getPose(e2.targetRaySpace, r2), null === n2 && null !== i2 && (n2 = i2), null !== n2 && (o2.matrix.fromArray(n2.transform.matrix), o2.matrix.decompose(o2.position, o2.rotation, o2.scale), n2.linearVelocity ? (o2.hasLinearVelocity = true, o2.linearVelocity.copy(n2.linearVelocity)) : o2.hasLinearVelocity = false, n2.angularVelocity ? (o2.hasAngularVelocity = true, o2.angularVelocity.copy(n2.angularVelocity)) : o2.hasAngularVelocity = false, this.dispatchEvent(tl)));
      }
      return null !== o2 && (o2.visible = null !== n2), null !== a2 && (a2.visible = null !== i2), null !== l2 && (l2.visible = null !== s2), this;
    }
  }
  class nl extends Zr {
    constructor(e2, t2, r2, n2, i2, s2, o2, a2, l2, c2) {
      if ((c2 = void 0 !== c2 ? c2 : Fe) !== Fe && c2 !== Ue)
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      void 0 === r2 && c2 === Fe && (r2 = Ce), void 0 === r2 && c2 === Ue && (r2 = De), super(null, n2, i2, s2, o2, a2, c2, r2, l2), this.isDepthTexture = true, this.image = { width: e2, height: t2 }, this.magFilter = void 0 !== o2 ? o2 : he, this.minFilter = void 0 !== a2 ? a2 : he, this.flipY = false, this.generateMipmaps = false;
    }
  }
  class il extends mr {
    constructor(e2, t2) {
      super();
      const r2 = this;
      let n2 = null, i2 = 1, s2 = null, o2 = "local-floor", a2 = null, l2 = null, c2 = null, u2 = null, h2 = null, p2 = null;
      const d2 = t2.getContextAttributes();
      let f2 = null, m2 = null;
      const _2 = [], g2 = [], v2 = new gs();
      v2.layers.enable(1), v2.viewport = new $r();
      const A2 = new gs();
      A2.layers.enable(2), A2.viewport = new $r();
      const b2 = [v2, A2], y2 = new $a();
      y2.layers.enable(1), y2.layers.enable(2);
      let x2 = null, w2 = null;
      function E2(e3) {
        const t3 = g2.indexOf(e3.inputSource);
        if (-1 === t3)
          return;
        const r3 = _2[t3];
        void 0 !== r3 && r3.dispatchEvent({ type: e3.type, data: e3.inputSource });
      }
      function S2() {
        n2.removeEventListener("select", E2), n2.removeEventListener("selectstart", E2), n2.removeEventListener("selectend", E2), n2.removeEventListener("squeeze", E2), n2.removeEventListener("squeezestart", E2), n2.removeEventListener("squeezeend", E2), n2.removeEventListener("end", S2), n2.removeEventListener("inputsourceschange", C2);
        for (let e3 = 0; e3 < _2.length; e3++) {
          const t3 = g2[e3];
          null !== t3 && (g2[e3] = null, _2[e3].disconnect(t3));
        }
        x2 = null, w2 = null, e2.setRenderTarget(f2), h2 = null, u2 = null, c2 = null, n2 = null, m2 = null, D2.stop(), r2.isPresenting = false, r2.dispatchEvent({ type: "sessionend" });
      }
      function C2(e3) {
        for (let t3 = 0; t3 < e3.removed.length; t3++) {
          const r3 = e3.removed[t3], n3 = g2.indexOf(r3);
          n3 >= 0 && (g2[n3] = null, _2[n3].dispatchEvent({ type: "disconnected", data: r3 }));
        }
        for (let t3 = 0; t3 < e3.added.length; t3++) {
          const r3 = e3.added[t3];
          let n3 = g2.indexOf(r3);
          if (-1 === n3) {
            for (let e4 = 0; e4 < _2.length; e4++) {
              if (e4 >= g2.length) {
                g2.push(r3), n3 = e4;
                break;
              }
              if (null === g2[e4]) {
                g2[e4] = r3, n3 = e4;
                break;
              }
            }
            if (-1 === n3)
              break;
          }
          const i3 = _2[n3];
          i3 && i3.dispatchEvent({ type: "connected", data: r3 });
        }
      }
      this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(e3) {
        let t3 = _2[e3];
        return void 0 === t3 && (t3 = new rl(), _2[e3] = t3), t3.getTargetRaySpace();
      }, this.getControllerGrip = function(e3) {
        let t3 = _2[e3];
        return void 0 === t3 && (t3 = new rl(), _2[e3] = t3), t3.getGripSpace();
      }, this.getHand = function(e3) {
        let t3 = _2[e3];
        return void 0 === t3 && (t3 = new rl(), _2[e3] = t3), t3.getHandSpace();
      }, this.setFramebufferScaleFactor = function(e3) {
        i2 = e3, true === r2.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }, this.setReferenceSpaceType = function(e3) {
        o2 = e3, true === r2.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }, this.getReferenceSpace = function() {
        return a2 || s2;
      }, this.setReferenceSpace = function(e3) {
        a2 = e3;
      }, this.getBaseLayer = function() {
        return null !== u2 ? u2 : h2;
      }, this.getBinding = function() {
        return c2;
      }, this.getFrame = function() {
        return p2;
      }, this.getSession = function() {
        return n2;
      }, this.setSession = async function(l3) {
        if (n2 = l3, null !== n2) {
          if (f2 = e2.getRenderTarget(), n2.addEventListener("select", E2), n2.addEventListener("selectstart", E2), n2.addEventListener("selectend", E2), n2.addEventListener("squeeze", E2), n2.addEventListener("squeezestart", E2), n2.addEventListener("squeezeend", E2), n2.addEventListener("end", S2), n2.addEventListener("inputsourceschange", C2), true !== d2.xrCompatible && await t2.makeXRCompatible(), void 0 === n2.renderState.layers || false === e2.capabilities.isWebGL2) {
            const r3 = { antialias: void 0 !== n2.renderState.layers || d2.antialias, alpha: d2.alpha, depth: d2.depth, stencil: d2.stencil, framebufferScaleFactor: i2 };
            h2 = new XRWebGLLayer(n2, t2, r3), n2.updateRenderState({ baseLayer: h2 }), m2 = new en(h2.framebufferWidth, h2.framebufferHeight, { format: Re, type: ye, encoding: e2.outputEncoding, stencilBuffer: d2.stencil });
          } else {
            let r3 = null, s3 = null, o3 = null;
            d2.depth && (o3 = d2.stencil ? 35056 : 33190, r3 = d2.stencil ? Ue : Fe, s3 = d2.stencil ? De : Ce);
            const a3 = { colorFormat: 32856, depthFormat: o3, scaleFactor: i2 };
            c2 = new XRWebGLBinding(n2, t2), u2 = c2.createProjectionLayer(a3), n2.updateRenderState({ layers: [u2] }), m2 = new en(u2.textureWidth, u2.textureHeight, { format: Re, type: ye, depthTexture: new nl(u2.textureWidth, u2.textureHeight, s3, void 0, void 0, void 0, void 0, void 0, void 0, r3), stencilBuffer: d2.stencil, encoding: e2.outputEncoding, samples: d2.antialias ? 4 : 0 }), e2.properties.get(m2).__ignoreDepthValues = u2.ignoreDepthValues;
          }
          m2.isXRRenderTarget = true, this.setFoveation(1), a2 = null, s2 = await n2.requestReferenceSpace(o2), D2.setContext(n2), D2.start(), r2.isPresenting = true, r2.dispatchEvent({ type: "sessionstart" });
        }
      };
      const M2 = new ln(), T2 = new ln();
      function I2(e3, t3) {
        null === t3 ? e3.matrixWorld.copy(e3.matrix) : e3.matrixWorld.multiplyMatrices(t3.matrixWorld, e3.matrix), e3.matrixWorldInverse.copy(e3.matrixWorld).invert();
      }
      this.updateCamera = function(e3) {
        if (null === n2)
          return;
        y2.near = A2.near = v2.near = e3.near, y2.far = A2.far = v2.far = e3.far, x2 === y2.near && w2 === y2.far || (n2.updateRenderState({ depthNear: y2.near, depthFar: y2.far }), x2 = y2.near, w2 = y2.far);
        const t3 = e3.parent, r3 = y2.cameras;
        I2(y2, t3);
        for (let e4 = 0; e4 < r3.length; e4++)
          I2(r3[e4], t3);
        y2.matrixWorld.decompose(y2.position, y2.quaternion, y2.scale), e3.matrix.copy(y2.matrix), e3.matrix.decompose(e3.position, e3.quaternion, e3.scale);
        const i3 = e3.children;
        for (let e4 = 0, t4 = i3.length; e4 < t4; e4++)
          i3[e4].updateMatrixWorld(true);
        2 === r3.length ? function(e4, t4, r4) {
          M2.setFromMatrixPosition(t4.matrixWorld), T2.setFromMatrixPosition(r4.matrixWorld);
          const n3 = M2.distanceTo(T2), i4 = t4.projectionMatrix.elements, s3 = r4.projectionMatrix.elements, o3 = i4[14] / (i4[10] - 1), a3 = i4[14] / (i4[10] + 1), l3 = (i4[9] + 1) / i4[5], c3 = (i4[9] - 1) / i4[5], u3 = (i4[8] - 1) / i4[0], h3 = (s3[8] + 1) / s3[0], p3 = o3 * u3, d3 = o3 * h3, f3 = n3 / (-u3 + h3), m3 = f3 * -u3;
          t4.matrixWorld.decompose(e4.position, e4.quaternion, e4.scale), e4.translateX(m3), e4.translateZ(f3), e4.matrixWorld.compose(e4.position, e4.quaternion, e4.scale), e4.matrixWorldInverse.copy(e4.matrixWorld).invert();
          const _3 = o3 + f3, g3 = a3 + f3, v3 = p3 - m3, A3 = d3 + (n3 - m3), b3 = l3 * a3 / g3 * _3, y3 = c3 * a3 / g3 * _3;
          e4.projectionMatrix.makePerspective(v3, A3, b3, y3, _3, g3);
        }(y2, v2, A2) : y2.projectionMatrix.copy(v2.projectionMatrix);
      }, this.getCamera = function() {
        return y2;
      }, this.getFoveation = function() {
        return null !== u2 ? u2.fixedFoveation : null !== h2 ? h2.fixedFoveation : void 0;
      }, this.setFoveation = function(e3) {
        null !== u2 && (u2.fixedFoveation = e3), null !== h2 && void 0 !== h2.fixedFoveation && (h2.fixedFoveation = e3);
      };
      let k2 = null;
      this.onPreAnimationFrameCallback = null;
      const D2 = new Is();
      D2.setAnimationLoop(function(t3, n3) {
        if (r2.onPreAnimationFrameCallback && r2.onPreAnimationFrameCallback(t3, n3), l2 = n3.getViewerPose(a2 || s2), p2 = n3, null !== l2) {
          const t4 = l2.views;
          null !== h2 && (e2.setRenderTargetFramebuffer(m2, h2.framebuffer), e2.setRenderTarget(m2));
          let r3 = false;
          t4.length !== y2.cameras.length && (y2.cameras.length = 0, r3 = true);
          for (let n4 = 0; n4 < t4.length; n4++) {
            const i3 = t4[n4];
            let s3 = null;
            if (null !== h2)
              s3 = h2.getViewport(i3);
            else {
              const t5 = c2.getViewSubImage(u2, i3);
              s3 = t5.viewport, 0 === n4 && (e2.setRenderTargetTextures(m2, t5.colorTexture, u2.ignoreDepthValues ? void 0 : t5.depthStencilTexture), e2.setRenderTarget(m2));
            }
            let o3 = b2[n4];
            void 0 === o3 && (o3 = new gs(), o3.layers.enable(n4), o3.viewport = new $r(), b2[n4] = o3), o3.matrix.fromArray(i3.transform.matrix), o3.projectionMatrix.fromArray(i3.projectionMatrix), o3.viewport.set(s3.x, s3.y, s3.width, s3.height), 0 === n4 && y2.matrix.copy(o3.matrix), true === r3 && y2.cameras.push(o3);
          }
        }
        for (let e3 = 0; e3 < _2.length; e3++) {
          const t4 = g2[e3], r3 = _2[e3];
          null !== t4 && void 0 !== r3 && r3.update(t4, n3, a2 || s2);
        }
        k2 && k2(t3, n3), p2 = null;
      }), this.setAnimationLoop = function(e3) {
        k2 = e3;
      }, this.dispose = function() {
      };
    }
  }
  function sl(e2, t2) {
    function r2(r3, n2) {
      r3.opacity.value = n2.opacity, n2.color && r3.diffuse.value.copy(n2.color), n2.emissive && r3.emissive.value.copy(n2.emissive).multiplyScalar(n2.emissiveIntensity), n2.map && (r3.map.value = n2.map), n2.alphaMap && (r3.alphaMap.value = n2.alphaMap), n2.bumpMap && (r3.bumpMap.value = n2.bumpMap, r3.bumpScale.value = n2.bumpScale, n2.side === m && (r3.bumpScale.value *= -1)), n2.displacementMap && (r3.displacementMap.value = n2.displacementMap, r3.displacementScale.value = n2.displacementScale, r3.displacementBias.value = n2.displacementBias), n2.emissiveMap && (r3.emissiveMap.value = n2.emissiveMap), n2.normalMap && (r3.normalMap.value = n2.normalMap, r3.normalScale.value.copy(n2.normalScale), n2.side === m && r3.normalScale.value.negate()), n2.specularMap && (r3.specularMap.value = n2.specularMap), n2.alphaTest > 0 && (r3.alphaTest.value = n2.alphaTest);
      const i2 = t2.get(n2).envMap;
      if (i2) {
        r3.envMap.value = i2;
        const e3 = t2.get(n2).environment || i2;
        r3.envMapRotation.value = e3 ? e3.rotation : 0, r3.flipEnvMap.value = i2.isCubeTexture && false === i2.isRenderTargetTexture ? -1 : 1, r3.reflectivity.value = n2.reflectivity, r3.ior.value = n2.ior, r3.refractionRatio.value = n2.refractionRatio;
      }
      if (n2.lightMap) {
        r3.lightMap.value = n2.lightMap;
        const t3 = true !== e2.physicallyCorrectLights ? Math.PI : 1;
        r3.lightMapIntensity.value = n2.lightMapIntensity * t3;
      }
      let s2, o2;
      n2.aoMap && (r3.aoMap.value = n2.aoMap, r3.aoMapIntensity.value = n2.aoMapIntensity), n2.map ? s2 = n2.map : n2.specularMap ? s2 = n2.specularMap : n2.displacementMap ? s2 = n2.displacementMap : n2.normalMap ? s2 = n2.normalMap : n2.bumpMap ? s2 = n2.bumpMap : n2.roughnessMap ? s2 = n2.roughnessMap : n2.metalnessMap ? s2 = n2.metalnessMap : n2.alphaMap ? s2 = n2.alphaMap : n2.emissiveMap ? s2 = n2.emissiveMap : n2.clearcoatMap ? s2 = n2.clearcoatMap : n2.clearcoatNormalMap ? s2 = n2.clearcoatNormalMap : n2.clearcoatRoughnessMap ? s2 = n2.clearcoatRoughnessMap : n2.iridescenceMap ? s2 = n2.iridescenceMap : n2.iridescenceThicknessMap ? s2 = n2.iridescenceThicknessMap : n2.specularIntensityMap ? s2 = n2.specularIntensityMap : n2.specularColorMap ? s2 = n2.specularColorMap : n2.transmissionMap ? s2 = n2.transmissionMap : n2.thicknessMap ? s2 = n2.thicknessMap : n2.sheenColorMap ? s2 = n2.sheenColorMap : n2.sheenRoughnessMap && (s2 = n2.sheenRoughnessMap), void 0 !== s2 && (s2.isWebGLRenderTarget && (s2 = s2.texture), true === s2.matrixAutoUpdate && s2.updateMatrix(), r3.uvTransform.value.copy(s2.matrix)), n2.aoMap ? o2 = n2.aoMap : n2.lightMap && (o2 = n2.lightMap), void 0 !== o2 && (o2.isWebGLRenderTarget && (o2 = o2.texture), true === o2.matrixAutoUpdate && o2.updateMatrix(), r3.uv2Transform.value.copy(o2.matrix));
    }
    return { refreshFogUniforms: function(e3, t3) {
      e3.fogColor.value.copy(t3.color), t3.isFog ? (e3.fogNear.value = t3.near, e3.fogFar.value = t3.far) : t3.isFogExp2 && (e3.fogDensity.value = t3.density);
    }, refreshMaterialUniforms: function(e3, n2, i2, s2, o2) {
      n2.isMeshBasicMaterial || n2.isMeshLambertMaterial ? r2(e3, n2) : n2.isMeshToonMaterial ? (r2(e3, n2), function(e4, t3) {
        t3.gradientMap && (e4.gradientMap.value = t3.gradientMap);
      }(e3, n2)) : n2.isMeshPhongMaterial ? (r2(e3, n2), function(e4, t3) {
        e4.specular.value.copy(t3.specular), e4.shininess.value = Math.max(t3.shininess, 1e-4);
      }(e3, n2)) : n2.isMeshStandardMaterial ? (r2(e3, n2), function(e4, r3) {
        e4.roughness.value = r3.roughness, e4.metalness.value = r3.metalness, r3.roughnessMap && (e4.roughnessMap.value = r3.roughnessMap), r3.metalnessMap && (e4.metalnessMap.value = r3.metalnessMap), t2.get(r3).envMap && (e4.envMapIntensity.value = r3.envMapIntensity);
      }(e3, n2), n2.isMeshPhysicalMaterial && function(e4, t3, r3) {
        e4.ior.value = t3.ior, t3.sheen > 0 && (e4.sheenColor.value.copy(t3.sheenColor).multiplyScalar(t3.sheen), e4.sheenRoughness.value = t3.sheenRoughness, t3.sheenColorMap && (e4.sheenColorMap.value = t3.sheenColorMap), t3.sheenRoughnessMap && (e4.sheenRoughnessMap.value = t3.sheenRoughnessMap)), t3.clearcoat > 0 && (e4.clearcoat.value = t3.clearcoat, e4.clearcoatRoughness.value = t3.clearcoatRoughness, t3.clearcoatMap && (e4.clearcoatMap.value = t3.clearcoatMap), t3.clearcoatRoughnessMap && (e4.clearcoatRoughnessMap.value = t3.clearcoatRoughnessMap), t3.clearcoatNormalMap && (e4.clearcoatNormalScale.value.copy(t3.clearcoatNormalScale), e4.clearcoatNormalMap.value = t3.clearcoatNormalMap, t3.side === m && e4.clearcoatNormalScale.value.negate())), t3.iridescence > 0 && (e4.iridescence.value = t3.iridescence, e4.iridescenceIOR.value = t3.iridescenceIOR, e4.iridescenceThicknessMinimum.value = t3.iridescenceThicknessRange[0], e4.iridescenceThicknessMaximum.value = t3.iridescenceThicknessRange[1], t3.iridescenceMap && (e4.iridescenceMap.value = t3.iridescenceMap), t3.iridescenceThicknessMap && (e4.iridescenceThicknessMap.value = t3.iridescenceThicknessMap)), t3.transmission > 0 && (e4.transmission.value = t3.transmission, e4.transmissionSamplerMap.value = r3.texture, e4.transmissionSamplerSize.value.set(r3.width, r3.height), t3.transmissionMap && (e4.transmissionMap.value = t3.transmissionMap), e4.thickness.value = t3.thickness, t3.thicknessMap && (e4.thicknessMap.value = t3.thicknessMap), e4.attenuationDistance.value = t3.attenuationDistance, e4.attenuationColor.value.copy(t3.attenuationColor)), e4.specularIntensity.value = t3.specularIntensity, e4.specularColor.value.copy(t3.specularColor), t3.specularIntensityMap && (e4.specularIntensityMap.value = t3.specularIntensityMap), t3.specularColorMap && (e4.specularColorMap.value = t3.specularColorMap);
      }(e3, n2, o2)) : n2.isMeshMatcapMaterial ? (r2(e3, n2), function(e4, t3) {
        t3.matcap && (e4.matcap.value = t3.matcap);
      }(e3, n2)) : n2.isMeshDepthMaterial ? r2(e3, n2) : n2.isMeshDistanceMaterial ? (r2(e3, n2), function(e4, t3) {
        e4.referencePosition.value.copy(t3.referencePosition), e4.nearDistance.value = t3.nearDistance, e4.farDistance.value = t3.farDistance;
      }(e3, n2)) : n2.isMeshNormalMaterial ? r2(e3, n2) : n2.isLineBasicMaterial ? (function(e4, t3) {
        e4.diffuse.value.copy(t3.color), e4.opacity.value = t3.opacity;
      }(e3, n2), n2.isLineDashedMaterial && function(e4, t3) {
        e4.dashSize.value = t3.dashSize, e4.totalSize.value = t3.dashSize + t3.gapSize, e4.scale.value = t3.scale;
      }(e3, n2)) : n2.isPointsMaterial ? function(e4, t3, r3, n3) {
        let i3;
        e4.diffuse.value.copy(t3.color), e4.opacity.value = t3.opacity, e4.size.value = t3.size * r3, e4.scale.value = 0.5 * n3, t3.map && (e4.map.value = t3.map), t3.alphaMap && (e4.alphaMap.value = t3.alphaMap), t3.alphaTest > 0 && (e4.alphaTest.value = t3.alphaTest), t3.map ? i3 = t3.map : t3.alphaMap && (i3 = t3.alphaMap), void 0 !== i3 && (true === i3.matrixAutoUpdate && i3.updateMatrix(), e4.uvTransform.value.copy(i3.matrix));
      }(e3, n2, i2, s2) : n2.isSpriteMaterial ? function(e4, t3) {
        let r3;
        e4.diffuse.value.copy(t3.color), e4.opacity.value = t3.opacity, e4.rotation.value = t3.rotation, t3.map && (e4.map.value = t3.map), t3.alphaMap && (e4.alphaMap.value = t3.alphaMap), t3.alphaTest > 0 && (e4.alphaTest.value = t3.alphaTest), t3.map ? r3 = t3.map : t3.alphaMap && (r3 = t3.alphaMap), void 0 !== r3 && (true === r3.matrixAutoUpdate && r3.updateMatrix(), e4.uvTransform.value.copy(r3.matrix));
      }(e3, n2) : n2.isShadowMaterial ? (e3.color.value.copy(n2.color), e3.opacity.value = n2.opacity) : n2.isShaderMaterial && (void 0 !== n2.transmission && (e3.transmission && (e3.transmission.value = n2.transmission), e3.transmissionSamplerMap && o2 && (e3.transmissionSamplerMap.value = o2 ? o2.texture : null), e3.transmissionSamplerSize && o2 && e3.transmissionSamplerSize.value.set(o2.width, o2.height)), n2.uniformsNeedUpdate = false);
    } };
  }
  function ol(e2, t2, r2, n2) {
    let i2 = {}, s2 = {}, o2 = [];
    const a2 = r2.isWebGL2 ? e2.getParameter(35375) : 0;
    function l2(e3, t3, r3) {
      const n3 = e3.value;
      if (void 0 === r3[t3])
        return r3[t3] = "number" == typeof n3 ? n3 : n3.clone(), true;
      if ("number" == typeof n3) {
        if (r3[t3] !== n3)
          return r3[t3] = n3, true;
      } else {
        const e4 = r3[t3];
        if (false === e4.equals(n3))
          return e4.copy(n3), true;
      }
      return false;
    }
    function c2(e3) {
      const t3 = e3.value, r3 = { boundary: 0, storage: 0 };
      return "number" == typeof t3 ? (r3.boundary = 4, r3.storage = 4) : t3.isVector2 ? (r3.boundary = 8, r3.storage = 8) : t3.isVector3 || t3.isColor ? (r3.boundary = 16, r3.storage = 12) : t3.isVector4 ? (r3.boundary = 16, r3.storage = 16) : t3.isMatrix3 ? (r3.boundary = 48, r3.storage = 48) : t3.isMatrix4 ? (r3.boundary = 64, r3.storage = 64) : t3.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t3), r3;
    }
    function u2(t3) {
      const r3 = t3.target;
      r3.removeEventListener("dispose", u2);
      const n3 = o2.indexOf(r3.__bindingPointIndex);
      o2.splice(n3, 1), e2.deleteBuffer(i2[r3.id]), delete i2[r3.id], delete s2[r3.id];
    }
    return { bind: function(e3, t3) {
      const r3 = t3.program;
      n2.uniformBlockBinding(e3, r3);
    }, update: function(r3, h2) {
      let p2 = i2[r3.id];
      void 0 === p2 && (function(e3) {
        const t3 = e3.uniforms;
        let r4 = 0;
        let n3 = 0;
        for (let e4 = 0, i3 = t3.length; e4 < i3; e4++) {
          const i4 = t3[e4], s3 = c2(i4);
          if (i4.__data = new Float32Array(s3.storage / Float32Array.BYTES_PER_ELEMENT), i4.__offset = r4, e4 > 0) {
            n3 = r4 % 16;
            const e5 = 16 - n3;
            0 !== n3 && e5 - s3.boundary < 0 && (r4 += 16 - n3, i4.__offset = r4);
          }
          r4 += s3.storage;
        }
        n3 = r4 % 16, n3 > 0 && (r4 += 16 - n3), e3.__size = r4, e3.__cache = {};
      }(r3), p2 = function(t3) {
        const r4 = function() {
          for (let e3 = 0; e3 < a2; e3++)
            if (-1 === o2.indexOf(e3))
              return o2.push(e3), e3;
          return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
        }();
        t3.__bindingPointIndex = r4;
        const n3 = e2.createBuffer(), i3 = t3.__size, s3 = t3.usage;
        return e2.bindBuffer(35345, n3), e2.bufferData(35345, i3, s3), e2.bindBuffer(35345, null), e2.bindBufferBase(35345, r4, n3), n3;
      }(r3), i2[r3.id] = p2, r3.addEventListener("dispose", u2));
      const d2 = h2.program;
      n2.updateUBOMapping(r3, d2);
      const f2 = t2.render.frame;
      s2[r3.id] !== f2 && (function(t3) {
        const r4 = i2[t3.id], n3 = t3.uniforms, s3 = t3.__cache;
        e2.bindBuffer(35345, r4);
        for (let t4 = 0, r5 = n3.length; t4 < r5; t4++) {
          const r6 = n3[t4];
          if (true === l2(r6, t4, s3)) {
            const t5 = r6.value, n4 = r6.__offset;
            "number" == typeof t5 ? (r6.__data[0] = t5, e2.bufferSubData(35345, n4, r6.__data)) : (r6.value.isMatrix3 ? (r6.__data[0] = r6.value.elements[0], r6.__data[1] = r6.value.elements[1], r6.__data[2] = r6.value.elements[2], r6.__data[3] = r6.value.elements[0], r6.__data[4] = r6.value.elements[3], r6.__data[5] = r6.value.elements[4], r6.__data[6] = r6.value.elements[5], r6.__data[7] = r6.value.elements[0], r6.__data[8] = r6.value.elements[6], r6.__data[9] = r6.value.elements[7], r6.__data[10] = r6.value.elements[8], r6.__data[11] = r6.value.elements[0]) : t5.toArray(r6.__data), e2.bufferSubData(35345, n4, r6.__data));
          }
        }
        e2.bindBuffer(35345, null);
      }(r3), s2[r3.id] = f2);
    }, dispose: function() {
      for (const t3 in i2)
        e2.deleteBuffer(i2[t3]);
      o2 = [], i2 = {}, s2 = {};
    } };
  }
  function al(e2 = {}) {
    this.isWebGLRenderer = true;
    const t2 = void 0 !== e2.canvas ? e2.canvas : function() {
      const e3 = Lr("canvas");
      return e3.style.display = "block", e3;
    }(), r2 = void 0 !== e2.context ? e2.context : null, i2 = void 0 === e2.depth || e2.depth, s2 = void 0 === e2.stencil || e2.stencil, o2 = void 0 !== e2.antialias && e2.antialias, a2 = void 0 === e2.premultipliedAlpha || e2.premultipliedAlpha, l2 = void 0 !== e2.preserveDrawingBuffer && e2.preserveDrawingBuffer, c2 = void 0 !== e2.powerPreference ? e2.powerPreference : "default", u2 = void 0 !== e2.failIfMajorPerformanceCaveat && e2.failIfMajorPerformanceCaveat;
    let h2;
    h2 = null !== r2 ? r2.getContextAttributes().alpha : void 0 !== e2.alpha && e2.alpha;
    let p2 = null, d2 = null;
    const g2 = [], v2 = [];
    this.domElement = t2, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.outputEncoding = kt, this.physicallyCorrectLights = false, this.toneMapping = K, this.toneMappingExposure = 1, this.userData = {}, Object.defineProperties(this, { gammaFactor: { get: function() {
      return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
    }, set: function() {
      console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
    } } });
    const A2 = this;
    let b2 = false, y2 = 0, x2 = 0, w2 = null, E2 = -1, S2 = null;
    const C2 = new $r(), M2 = new $r();
    let T2 = null, I2 = t2.width, k2 = t2.height, D2 = 1, P2 = null, B2 = null;
    const R2 = new $r(0, 0, I2, k2), L2 = new $r(0, 0, I2, k2);
    let O2 = false;
    const F2 = new Ts();
    let U2 = false, N2 = false, j2 = null;
    const z2 = new Nn(), G2 = new kr(), V2 = new ln(), Q2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function H2() {
      return null === w2 ? D2 : 1;
    }
    let W2, q2, X2, Y2, J2, Z2, $2, ee2, te2, re2, ne2, ie2, se2, oe2, ae2, le2, ce2, ue2, he2, pe2, de2, fe2, me2, _e2, ge2 = r2;
    function ve2(e3, r3) {
      for (let n2 = 0; n2 < e3.length; n2++) {
        const i3 = e3[n2], s3 = t2.getContext(i3, r3);
        if (null !== s3)
          return s3;
      }
      return null;
    }
    try {
      const e3 = { alpha: true, depth: i2, stencil: s2, antialias: o2, premultipliedAlpha: a2, preserveDrawingBuffer: l2, powerPreference: c2, failIfMajorPerformanceCaveat: u2 };
      if ("setAttribute" in t2 && t2.setAttribute("data-engine", `three.js r${n}`), t2.addEventListener("webglcontextlost", we2, false), t2.addEventListener("webglcontextrestored", Ee2, false), t2.addEventListener("webglcontextcreationerror", Se2, false), null === ge2) {
        const t3 = ["webgl2", "webgl", "experimental-webgl"];
        if (true === A2.isWebGL1Renderer && t3.shift(), ge2 = ve2(t3, e3), null === ge2)
          throw ve2(t3) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      void 0 === ge2.getShaderPrecisionFormat && (ge2.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (e3) {
      throw console.error("THREE.WebGLRenderer: " + e3.message), e3;
    }
    function be2() {
      W2 = new to(ge2), q2 = new Us(ge2, W2, e2), W2.init(q2), fe2 = new Za(ge2, W2, q2), X2 = new Ka(ge2, W2, q2), Y2 = new io(), J2 = new Oa(), Z2 = new Ja(ge2, W2, X2, J2, q2, fe2, Y2), $2 = new js(A2), ee2 = new eo(A2), te2 = new ks(ge2, q2), me2 = new Os(ge2, W2, te2, q2), re2 = new ro(ge2, te2, Y2, me2), ne2 = new lo(ge2, re2, te2, Y2), he2 = new ao(ge2, q2, Z2), le2 = new Ns(J2), ie2 = new La(A2, $2, ee2, W2, q2, me2, le2), se2 = new sl(A2, J2), oe2 = new ja(), ae2 = new Wa(W2, q2), ue2 = new Ls(A2, $2, X2, ne2, h2, a2), ce2 = new Ya(A2, ne2, q2), _e2 = new ol(ge2, Y2, q2, X2), pe2 = new Fs(ge2, W2, Y2, q2), de2 = new no(ge2, W2, Y2, q2), Y2.programs = ie2.programs, A2.capabilities = q2, A2.extensions = W2, A2.properties = J2, A2.renderLists = oe2, A2.shadowMap = ce2, A2.state = X2, A2.info = Y2, A2.background = ue2, A2.cubeuvmaps = ee2;
    }
    be2();
    const xe2 = new il(A2, ge2);
    function we2(e3) {
      e3.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), b2 = true;
    }
    function Ee2() {
      console.log("THREE.WebGLRenderer: Context Restored."), b2 = false;
      const e3 = Y2.autoReset, t3 = ce2.enabled, r3 = ce2.autoUpdate, n2 = ce2.needsUpdate, i3 = ce2.type;
      be2(), Y2.autoReset = e3, ce2.enabled = t3, ce2.autoUpdate = r3, ce2.needsUpdate = n2, ce2.type = i3;
    }
    function Se2(e3) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e3.statusMessage);
    }
    function Ce2(e3) {
      const t3 = e3.target;
      t3.removeEventListener("dispose", Ce2), function(e4) {
        (function(e5) {
          const t4 = J2.get(e5).programs;
          void 0 !== t4 && (t4.forEach(function(e6) {
            ie2.releaseProgram(e6);
          }), e5.isShaderMaterial && ie2.releaseShaderCache(e5));
        })(e4), J2.remove(e4);
      }(t3);
    }
    this.xr = xe2, this.getContext = function() {
      return ge2;
    }, this.getContextAttributes = function() {
      return ge2.getContextAttributes();
    }, this.forceContextLoss = function() {
      const e3 = W2.get("WEBGL_lose_context");
      e3 && e3.loseContext();
    }, this.forceContextRestore = function() {
      const e3 = W2.get("WEBGL_lose_context");
      e3 && e3.restoreContext();
    }, this.getPixelRatio = function() {
      return D2;
    }, this.setPixelRatio = function(e3) {
      void 0 !== e3 && (D2 = e3, this.setSize(I2, k2, false));
    }, this.getSize = function(e3) {
      return e3.set(I2, k2);
    }, this.setSize = function(e3, r3, n2) {
      xe2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (I2 = e3, k2 = r3, t2.width = Math.floor(e3 * D2), t2.height = Math.floor(r3 * D2), false !== n2 && (t2.style.width = e3 + "px", t2.style.height = r3 + "px"), this.setViewport(0, 0, e3, r3));
    }, this.getDrawingBufferSize = function(e3) {
      return e3.set(I2 * D2, k2 * D2).floor();
    }, this.setDrawingBufferSize = function(e3, r3, n2) {
      I2 = e3, k2 = r3, D2 = n2, t2.width = Math.floor(e3 * n2), t2.height = Math.floor(r3 * n2), this.setViewport(0, 0, e3, r3);
    }, this.getCurrentViewport = function(e3) {
      return e3.copy(C2);
    }, this.getViewport = function(e3) {
      return e3.copy(R2);
    }, this.setViewport = function(e3, t3, r3, n2) {
      e3.isVector4 ? R2.set(e3.x, e3.y, e3.z, e3.w) : R2.set(e3, t3, r3, n2), X2.viewport(C2.copy(R2).multiplyScalar(D2).floor());
    }, this.getScissor = function(e3) {
      return e3.copy(L2);
    }, this.setScissor = function(e3, t3, r3, n2) {
      e3.isVector4 ? L2.set(e3.x, e3.y, e3.z, e3.w) : L2.set(e3, t3, r3, n2), X2.scissor(M2.copy(L2).multiplyScalar(D2).floor());
    }, this.getScissorTest = function() {
      return O2;
    }, this.setScissorTest = function(e3) {
      X2.setScissorTest(O2 = e3);
    }, this.setOpaqueSort = function(e3) {
      P2 = e3;
    }, this.setTransparentSort = function(e3) {
      B2 = e3;
    }, this.getClearColor = function(e3) {
      return e3.copy(ue2.getClearColor());
    }, this.setClearColor = function() {
      ue2.setClearColor.apply(ue2, arguments);
    }, this.getClearAlpha = function() {
      return ue2.getClearAlpha();
    }, this.setClearAlpha = function() {
      ue2.setClearAlpha.apply(ue2, arguments);
    }, this.clear = function(e3 = true, t3 = true, r3 = true) {
      let n2 = 0;
      e3 && (n2 |= 16384), t3 && (n2 |= 256), r3 && (n2 |= 1024), ge2.clear(n2);
    }, this.clearColor = function() {
      this.clear(true, false, false);
    }, this.clearDepth = function() {
      this.clear(false, true, false);
    }, this.clearStencil = function() {
      this.clear(false, false, true);
    }, this.dispose = function() {
      t2.removeEventListener("webglcontextlost", we2, false), t2.removeEventListener("webglcontextrestored", Ee2, false), t2.removeEventListener("webglcontextcreationerror", Se2, false), oe2.dispose(), ae2.dispose(), J2.dispose(), $2.dispose(), ee2.dispose(), ne2.dispose(), me2.dispose(), _e2.dispose(), ie2.dispose(), xe2.dispose(), xe2.removeEventListener("sessionstart", ke2), xe2.removeEventListener("sessionend", De2), j2 && (j2.dispose(), j2 = null), Pe2.stop();
    }, this.renderBufferDirect = function(e3, t3, r3, n2, i3, s3) {
      null === t3 && (t3 = Q2);
      const o3 = i3.isMesh && i3.matrixWorld.determinant() < 0, a3 = function(e4, t4, r4, n3, i4) {
        true !== t4.isScene && (t4 = Q2), Z2.resetTextureUnits();
        const s4 = t4.fog, o4 = n3.isMeshStandardMaterial ? t4.environment : null, a4 = null === w2 ? A2.outputEncoding : true === w2.isXRRenderTarget || w2.texture.encoding && w2.texture.encoding !== Dt ? w2.texture.encoding : kt, l4 = (n3.isMeshStandardMaterial ? ee2 : $2).get(n3.envMap || o4), c4 = true === n3.vertexColors && !!r4.attributes.color && 4 === r4.attributes.color.itemSize, u4 = !!n3.normalMap && !!r4.attributes.tangent, h4 = !!r4.morphAttributes.position, p4 = !!r4.morphAttributes.normal, f3 = !!r4.morphAttributes.color, m3 = n3.toneMapped ? A2.toneMapping : K, _3 = r4.morphAttributes.position || r4.morphAttributes.normal || r4.morphAttributes.color, g4 = void 0 !== _3 ? _3.length : 0, v4 = J2.get(n3), b4 = d2.state.lights;
        if (true === U2 && (true === N2 || e4 !== S2)) {
          const t5 = e4 === S2 && n3.id === E2;
          le2.setState(n3, e4, t5);
        }
        let y4 = false;
        n3.version === v4.__version ? v4.needsLights && v4.lightsStateVersion !== b4.state.version || v4.outputEncoding !== a4 || i4.isInstancedMesh && false === v4.instancing ? y4 = true : i4.isInstancedMesh || true !== v4.instancing ? i4.isSkinnedMesh && false === v4.skinning ? y4 = true : i4.isSkinnedMesh || true !== v4.skinning ? v4.envMap !== l4 || true === n3.fog && v4.fog !== s4 ? y4 = true : void 0 === v4.numClippingPlanes || v4.numClippingPlanes === le2.numPlanes && v4.numIntersection === le2.numIntersection ? (v4.vertexAlphas !== c4 || v4.vertexTangents !== u4 || v4.morphTargets !== h4 || v4.morphNormals !== p4 || v4.morphColors !== f3 || v4.toneMapping !== m3 || true === q2.isWebGL2 && v4.morphTargetsCount !== g4) && (y4 = true) : y4 = true : y4 = true : y4 = true : (y4 = true, v4.__version = n3.version);
        let x4 = v4.currentProgram;
        true === y4 && (x4 = Ue2(n3, t4, i4));
        let C3 = false, M3 = false, T3 = false;
        const I3 = x4.getUniforms(), P3 = v4.uniforms;
        if (X2.useProgram(x4.program) && (C3 = true, M3 = true, T3 = true), n3.id !== E2 && (E2 = n3.id, M3 = true), C3 || S2 !== e4) {
          if (I3.setValue(ge2, "projectionMatrix", e4.projectionMatrix), q2.logarithmicDepthBuffer && I3.setValue(ge2, "logDepthBufFC", 2 / (Math.log(e4.far + 1) / Math.LN2)), S2 !== e4 && (S2 = e4, M3 = true, T3 = true), n3.isShaderMaterial || n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshStandardMaterial || n3.envMap) {
            const t5 = I3.map.cameraPosition;
            void 0 !== t5 && t5.setValue(ge2, V2.setFromMatrixPosition(e4.matrixWorld));
          }
          (n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshLambertMaterial || n3.isMeshBasicMaterial || n3.isMeshStandardMaterial || n3.isShaderMaterial) && I3.setValue(ge2, "isOrthographic", true === e4.isOrthographicCamera), (n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshLambertMaterial || n3.isMeshBasicMaterial || n3.isMeshStandardMaterial || n3.isShaderMaterial || n3.isShadowMaterial || i4.isSkinnedMesh) && I3.setValue(ge2, "viewMatrix", e4.matrixWorldInverse);
        }
        if (i4.isSkinnedMesh) {
          I3.setOptional(ge2, i4, "bindMatrix"), I3.setOptional(ge2, i4, "bindMatrixInverse");
          const e5 = i4.skeleton;
          e5 && (q2.floatVertexTextures ? (null === e5.boneTexture && e5.computeBoneTexture(), I3.setValue(ge2, "boneTexture", e5.boneTexture, Z2), I3.setValue(ge2, "boneTextureSize", e5.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
        }
        const B3 = r4.morphAttributes;
        var R3, L3;
        (void 0 !== B3.position || void 0 !== B3.normal || void 0 !== B3.color && true === q2.isWebGL2) && he2.update(i4, r4, n3, x4), (M3 || v4.receiveShadow !== i4.receiveShadow) && (v4.receiveShadow = i4.receiveShadow, I3.setValue(ge2, "receiveShadow", i4.receiveShadow)), n3.isMeshGouraudMaterial && null !== n3.envMap && (P3.envMap.value = l4, P3.flipEnvMap.value = l4.isCubeTexture && false === l4.isRenderTargetTexture ? -1 : 1), M3 && (I3.setValue(ge2, "toneMappingExposure", A2.toneMappingExposure), v4.needsLights && (L3 = T3, (R3 = P3).ambientLightColor.needsUpdate = L3, R3.lightProbe.needsUpdate = L3, R3.directionalLights.needsUpdate = L3, R3.directionalLightShadows.needsUpdate = L3, R3.pointLights.needsUpdate = L3, R3.pointLightShadows.needsUpdate = L3, R3.spotLights.needsUpdate = L3, R3.spotLightShadows.needsUpdate = L3, R3.rectAreaLights.needsUpdate = L3, R3.hemisphereLights.needsUpdate = L3), s4 && true === n3.fog && se2.refreshFogUniforms(P3, s4), se2.refreshMaterialUniforms(P3, n3, D2, k2, A2.userData.transmissionRenderTarget || j2), da.upload(ge2, v4.uniformsList, P3, Z2)), n3.isShaderMaterial && true === n3.uniformsNeedUpdate && (da.upload(ge2, v4.uniformsList, P3, Z2), n3.uniformsNeedUpdate = false), n3.isSpriteMaterial && I3.setValue(ge2, "center", i4.center), I3.setValue(ge2, "modelViewMatrix", i4.modelViewMatrix), I3.setValue(ge2, "normalMatrix", i4.normalMatrix), I3.setValue(ge2, "modelMatrix", i4.matrixWorld);
        const O3 = n3.extraUniformsToUpload;
        if (O3 && Object.entries(O3).forEach(([e5, t5]) => I3.setValue(ge2, e5, t5.value, Z2)), n3.isShaderMaterial || n3.isRawShaderMaterial) {
          const e5 = n3.uniformsGroups;
          for (let t5 = 0, r5 = e5.length; t5 < r5; t5++)
            if (q2.isWebGL2) {
              const r6 = e5[t5];
              _e2.update(r6, x4), _e2.bind(r6, x4);
            } else
              console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
        }
        return x4;
      }(e3, t3, r3, n2, i3);
      X2.setMaterial(n2, o3);
      let l3 = r3.index;
      const c3 = r3.attributes.position;
      if (null === l3) {
        if (void 0 === c3 || 0 === c3.count)
          return;
      } else if (0 === l3.count)
        return;
      let u3, h3 = 1;
      true === n2.wireframe && (l3 = re2.getWireframeAttribute(r3), h3 = 2), me2.setup(i3, n2, a3, r3, l3);
      let p3 = pe2;
      null !== l3 && (u3 = te2.get(l3), p3 = de2, p3.setIndex(u3));
      const f2 = null !== l3 ? l3.count : c3.count, m2 = r3.drawRange.start * h3, _2 = r3.drawRange.count * h3, g3 = null !== s3 ? s3.start * h3 : 0, v3 = null !== s3 ? s3.count * h3 : 1 / 0, b3 = Math.max(m2, g3), y3 = Math.min(f2, m2 + _2, g3 + v3) - 1, x3 = Math.max(0, y3 - b3 + 1);
      if (0 !== x3) {
        if (i3.isMesh)
          true === n2.wireframe ? (X2.setLineWidth(n2.wireframeLinewidth * H2()), p3.setMode(1)) : p3.setMode(4);
        else if (i3.isLine) {
          let e4 = n2.linewidth;
          void 0 === e4 && (e4 = 1), X2.setLineWidth(e4 * H2()), i3.isLineSegments ? p3.setMode(1) : i3.isLineLoop ? p3.setMode(2) : p3.setMode(3);
        } else
          i3.isPoints ? p3.setMode(0) : i3.isSprite && p3.setMode(4);
        if (i3.isInstancedMesh)
          p3.renderInstances(b3, x3, i3.count);
        else if (r3.isInstancedBufferGeometry) {
          const e4 = Math.min(r3.instanceCount, r3._maxInstanceCount);
          p3.renderInstances(b3, x3, e4);
        } else
          p3.render(b3, x3);
      }
    }, this.compile = function(e3, t3) {
      function r3(e4, t4, r4) {
        true === e4.transparent && e4.side === _ ? (e4.side = m, e4.needsUpdate = true, Ue2(e4, t4, r4), e4.side = f, e4.needsUpdate = true, Ue2(e4, t4, r4), e4.side = _) : Ue2(e4, t4, r4);
      }
      d2 = ae2.get(e3), d2.init(), v2.push(d2), e3.traverseVisible(function(e4) {
        e4.isLight && e4.layers.test(t3.layers) && (d2.pushLight(e4), e4.castShadow && d2.pushShadow(e4));
      }), d2.setupLights(A2.physicallyCorrectLights), e3.traverse(function(t4) {
        const n2 = t4.material;
        if (n2)
          if (Array.isArray(n2))
            for (let i3 = 0; i3 < n2.length; i3++)
              r3(n2[i3], e3, t4);
          else
            r3(n2, e3, t4);
      }), v2.pop(), d2 = null;
    };
    let Ie2 = null;
    function ke2() {
      Pe2.stop();
    }
    function De2() {
      Pe2.start();
    }
    const Pe2 = new Is();
    function Be2(e3, t3, r3, n2) {
      if (false === e3.visible)
        return;
      if (e3.layers.test(t3.layers)) {
        if (e3.isGroup)
          r3 = e3.renderOrder;
        else if (e3.isLOD)
          true === e3.autoUpdate && e3.update(t3);
        else if (e3.isLight)
          d2.pushLight(e3), e3.castShadow && d2.pushShadow(e3);
        else if (e3.isSprite) {
          if (!e3.frustumCulled || F2.intersectsSprite(e3)) {
            n2 && V2.setFromMatrixPosition(e3.matrixWorld).applyMatrix4(z2);
            const t4 = ne2.update(e3), i4 = e3.material;
            i4.visible && p2.push(e3, t4, i4, r3, V2.z, null);
          }
        } else if ((e3.isMesh || e3.isLine || e3.isPoints) && (e3.isSkinnedMesh && e3.skeleton.frame !== Y2.render.frame && (e3.skeleton.update(), e3.skeleton.frame = Y2.render.frame), !e3.frustumCulled || F2.intersectsObject(e3))) {
          n2 && V2.setFromMatrixPosition(e3.matrixWorld).applyMatrix4(z2);
          const t4 = ne2.update(e3), i4 = e3.material;
          if (Array.isArray(i4)) {
            const n3 = t4.groups;
            for (let s3 = 0, o3 = n3.length; s3 < o3; s3++) {
              const o4 = n3[s3], a3 = i4[o4.materialIndex];
              a3 && a3.visible && p2.push(e3, t4, a3, r3, V2.z, o4);
            }
          } else
            i4.visible && p2.push(e3, t4, i4, r3, V2.z, null);
        }
      }
      const i3 = e3.children;
      for (let e4 = 0, s3 = i3.length; e4 < s3; e4++)
        Be2(i3[e4], t3, r3, n2);
    }
    function Le2(e3, t3, r3, n2) {
      const i3 = e3.opaque, s3 = e3.transmissive, a3 = e3.transparent;
      if (d2.setupLightsView(r3), void 0 === A2.userData.transmissionRender && false !== A2.userData.renderTransmissionPass && s3.length > 0 && function(e4, t4, r4) {
        console.error("three.js internal render transmission pass should not be called");
        const n3 = q2.isWebGL2;
        null === j2 && (j2 = new en(1, 1, { generateMipmaps: true, type: W2.has("EXT_color_buffer_half_float") ? Te : ye, minFilter: Ae, samples: n3 && true === o2 ? 4 : 0 })), A2.getDrawingBufferSize(G2), n3 ? j2.setSize(G2.x, G2.y) : j2.setSize(Cr(G2.x), Cr(G2.y));
        const i4 = A2.getRenderTarget();
        A2.setRenderTarget(j2), A2.clear();
        const s4 = A2.toneMapping;
        A2.toneMapping = K, Oe2(e4, t4, r4), A2.toneMapping = s4, Z2.updateMultisampleRenderTarget(j2), Z2.updateRenderTargetMipmap(j2), A2.setRenderTarget(i4);
      }([...i3, ...a3], t3, r3), n2 && X2.viewport(C2.copy(n2)), false !== A2.userData.opaqueRender && i3.length > 0 && Oe2(i3, t3, r3), false !== A2.userData.transparentRender && a3.length > 0 && Oe2(a3, t3, r3), false !== A2.userData.transmissionRender && s3.length > 0) {
        j2 || (j2 = new en(1, 1));
        const e4 = A2.userData.transmissionRenderTarget.texture, n3 = q2.isWebGL2, i4 = e4.generateMipmaps, o3 = e4.minFilter;
        n3 && A2.userData.blurTransmissionTarget && (e4.generateMipmaps = true, e4.minFilter = Ae, e4.needsUpdate = true, Z2.updateRenderTargetMipmap(A2.userData.transmissionRenderTarget)), Oe2(s3, t3, r3), n3 && A2.userData.blurTransmissionTarget && (e4.generateMipmaps = i4, e4.minFilter = o3, e4.needsUpdate = true, Z2.updateRenderTargetMipmap(A2.userData.transmissionRenderTarget));
      }
      X2.buffers.depth.setTest(true), X2.buffers.depth.setMask(true), X2.buffers.color.setMask(true), X2.setPolygonOffset(false);
    }
    function Oe2(e3, t3, r3) {
      const n2 = { ...A2.userData };
      A2.userData.opaqueRender = void 0, A2.userData.transparentRender = void 0, A2.userData.transmissionRender = void 0, A2.userData.backgroundRender = void 0;
      const i3 = true === t3.isScene ? t3.overrideMaterial : null;
      for (let n3 = 0, s3 = e3.length; n3 < s3; n3++) {
        const s4 = e3[n3], o3 = s4.object, a3 = s4.geometry, l3 = null === i3 ? s4.material : i3, c3 = s4.group;
        o3.layers.test(r3.layers) && Fe2(o3, t3, r3, a3, l3, c3);
      }
      Object.assign(A2.userData, n2);
    }
    function Fe2(e3, t3, r3, n2, i3, s3) {
      e3.onBeforeRender(A2, t3, r3, n2, i3, s3), e3.modelViewMatrix.multiplyMatrices(r3.matrixWorldInverse, e3.matrixWorld), e3.normalMatrix.getNormalMatrix(e3.modelViewMatrix), i3.onBeforeRender(A2, t3, r3, n2, e3, s3), true === i3.transparent && i3.side === _ ? (i3.side = m, i3.needsUpdate = true, A2.renderBufferDirect(r3, t3, n2, i3, e3, s3), i3.side = f, i3.needsUpdate = true, A2.renderBufferDirect(r3, t3, n2, i3, e3, s3), i3.side = _) : A2.renderBufferDirect(r3, t3, n2, i3, e3, s3), e3.onAfterRender(A2, t3, r3, n2, i3, s3), i3.onAfterRender(A2, t3, r3, n2, e3, s3);
    }
    function Ue2(e3, t3, r3) {
      true !== t3.isScene && (t3 = Q2);
      const n2 = J2.get(e3), i3 = d2.state.lights, s3 = d2.state.shadowsArray, o3 = i3.state.version, a3 = ie2.getParameters(e3, i3.state, s3, t3, r3), l3 = ie2.getProgramCacheKey(a3);
      let c3 = n2.programs;
      n2.environment = e3.isMeshStandardMaterial ? t3.environment : null, n2.fog = t3.fog, n2.envMap = (e3.isMeshStandardMaterial ? ee2 : $2).get(e3.envMap || n2.environment), void 0 === c3 && (e3.addEventListener("dispose", Ce2), c3 = /* @__PURE__ */ new Map(), n2.programs = c3);
      let u3 = c3.get(l3);
      if (void 0 !== u3) {
        if (n2.currentProgram === u3 && n2.lightsStateVersion === o3)
          return Ne2(e3, a3), u3;
      } else
        a3.uniforms = ie2.getUniforms(e3), e3.onBuild(r3, a3, A2), e3.onBeforeCompile(a3, A2), u3 = ie2.acquireProgram(a3, l3), c3.set(l3, u3), n2.uniforms = a3.uniforms;
      const h3 = n2.uniforms;
      (e3.isShaderMaterial || e3.isRawShaderMaterial) && true !== e3.clipping || (h3.clippingPlanes = le2.uniform), Ne2(e3, a3), n2.needsLights = function(e4) {
        return e4.isMeshLambertMaterial || e4.isMeshToonMaterial || e4.isMeshPhongMaterial || e4.isMeshStandardMaterial || e4.isShadowMaterial || e4.isShaderMaterial && true === e4.lights;
      }(e3), n2.lightsStateVersion = o3, n2.needsLights && (h3.ambientLightColor.value = i3.state.ambient, h3.lightProbe.value = i3.state.probe, h3.directionalLights.value = i3.state.directional, h3.directionalLightShadows.value = i3.state.directionalShadow, h3.spotLights.value = i3.state.spot, h3.spotLightShadows.value = i3.state.spotShadow, h3.rectAreaLights.value = i3.state.rectArea, h3.ltc_1.value = i3.state.rectAreaLTC1, h3.ltc_2.value = i3.state.rectAreaLTC2, h3.pointLights.value = i3.state.point, h3.pointLightShadows.value = i3.state.pointShadow, h3.hemisphereLights.value = i3.state.hemi, h3.directionalShadowMap.value = i3.state.directionalShadowMap, h3.directionalShadowMatrix.value = i3.state.directionalShadowMatrix, h3.spotShadowMap.value = i3.state.spotShadowMap, h3.spotLightMatrix.value = i3.state.spotLightMatrix, h3.spotLightMap.value = i3.state.spotLightMap, h3.pointShadowMap.value = i3.state.pointShadowMap, h3.pointShadowMatrix.value = i3.state.pointShadowMatrix);
      const p3 = u3.getUniforms(), f2 = da.seqWithValue(p3.seq, h3);
      return n2.currentProgram = u3, n2.uniformsList = f2, u3;
    }
    function Ne2(e3, t3) {
      const r3 = J2.get(e3);
      r3.outputEncoding = t3.outputEncoding, r3.instancing = t3.instancing, r3.skinning = t3.skinning, r3.morphTargets = t3.morphTargets, r3.morphNormals = t3.morphNormals, r3.morphColors = t3.morphColors, r3.morphTargetsCount = t3.morphTargetsCount, r3.numClippingPlanes = t3.numClippingPlanes, r3.numIntersection = t3.numClipIntersection, r3.vertexAlphas = t3.vertexAlphas, r3.vertexTangents = t3.vertexTangents, r3.toneMapping = t3.toneMapping;
    }
    Pe2.setAnimationLoop(function(e3) {
      Ie2 && Ie2(e3);
    }), "undefined" != typeof self && Pe2.setContext(self), this.setAnimationLoop = function(e3) {
      Ie2 = e3, xe2.setAnimationLoop(e3), null === e3 ? Pe2.stop() : Pe2.start();
    }, xe2.addEventListener("sessionstart", ke2), xe2.addEventListener("sessionend", De2), this.render = function(e3, t3) {
      if (void 0 === t3 || true === t3.isCamera) {
        if (true !== b2) {
          if (true === e3.matrixWorldAutoUpdate && e3.updateMatrixWorld(), null === t3.parent && true === t3.matrixWorldAutoUpdate && t3.updateMatrixWorld(), true === xe2.enabled && true === xe2.isPresenting && (true === xe2.cameraAutoUpdate && xe2.updateCamera(t3), t3 = xe2.getCamera()), true === e3.isScene && e3.onBeforeRender(A2, e3, t3, w2), d2 = ae2.get(e3, v2.length), d2.init(), v2.push(d2), z2.multiplyMatrices(t3.projectionMatrix, t3.matrixWorldInverse), F2.setFromProjectionMatrix(z2), N2 = this.localClippingEnabled, U2 = le2.init(this.clippingPlanes, N2, t3), p2 = oe2.get(e3, g2.length), p2.init(), g2.push(p2), Be2(e3, t3, 0, A2.sortObjects), p2.finish(), true === A2.sortObjects && p2.sort(P2, B2), A2.userData.shadowMapRender) {
            true === U2 && le2.beginShadows();
            const r3 = d2.state.shadowsArray;
            r3.length > 0 && ce2.render(r3, e3, t3), true === U2 && le2.endShadows();
          }
          if (true === this.info.autoReset && this.info.reset(), false !== A2.userData.backgroundRender && ue2.render(p2, e3), false !== A2.userData.sceneRender)
            if (d2.setupLights(A2.physicallyCorrectLights), t3.isArrayCamera) {
              const r3 = t3.cameras;
              for (let t4 = 0, n2 = r3.length; t4 < n2; t4++) {
                const n3 = r3[t4];
                Le2(p2, e3, n3, n3.viewport);
              }
            } else
              Le2(p2, e3, t3);
          null !== w2 && (Z2.updateMultisampleRenderTarget(w2), Z2.updateRenderTargetMipmap(w2)), true === e3.isScene && e3.onAfterRender(A2, e3, t3), me2.resetDefaultState(), E2 = -1, S2 = null, v2.pop(), d2 = v2.length > 0 ? v2[v2.length - 1] : null, g2.pop(), p2 = g2.length > 0 ? g2[g2.length - 1] : null;
        }
      } else
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
    }, this.getActiveCubeFace = function() {
      return y2;
    }, this.getActiveMipmapLevel = function() {
      return x2;
    }, this.getRenderTarget = function() {
      return w2;
    }, this.setRenderTargetTextures = function(e3, t3, r3) {
      J2.get(e3.texture).__webglTexture = t3, J2.get(e3.depthTexture).__webglTexture = r3;
      const n2 = J2.get(e3);
      n2.__hasExternalTextures = true, n2.__hasExternalTextures && (n2.__autoAllocateDepthBuffer = void 0 === r3, n2.__autoAllocateDepthBuffer || true === W2.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), n2.__useRenderToTexture = false));
    }, this.setRenderTargetFramebuffer = function(e3, t3) {
      const r3 = J2.get(e3);
      r3.__webglFramebuffer = t3, r3.__useDefaultFramebuffer = void 0 === t3;
    }, this.setRenderTarget = function(e3, t3 = 0, r3 = 0) {
      w2 = e3, y2 = t3, x2 = r3;
      let n2 = true;
      if (e3) {
        const t4 = J2.get(e3);
        void 0 !== t4.__useDefaultFramebuffer ? (X2.bindFramebuffer(36160, null), n2 = false) : void 0 === t4.__webglFramebuffer ? Z2.setupRenderTarget(e3) : t4.__hasExternalTextures && Z2.rebindTextures(e3, J2.get(e3.texture).__webglTexture, J2.get(e3.depthTexture).__webglTexture);
      }
      let i3 = null, s3 = false, o3 = false;
      if (e3) {
        const r4 = e3.texture;
        (r4.isData3DTexture || r4.isDataArrayTexture) && (o3 = true);
        const n3 = J2.get(e3).__webglFramebuffer;
        e3.isWebGLCubeRenderTarget ? (i3 = n3[t3], s3 = true) : i3 = q2.isWebGL2 && e3.samples > 0 && false === Z2.useMultisampledRTT(e3) ? J2.get(e3).__webglMultisampledFramebuffer : n3, C2.copy(e3.viewport), M2.copy(e3.scissor), T2 = e3.scissorTest;
      } else
        C2.copy(R2).multiplyScalar(D2).floor(), M2.copy(L2).multiplyScalar(D2).floor(), T2 = O2;
      if (X2.bindFramebuffer(36160, i3) && q2.drawBuffers && n2 && X2.drawBuffers(e3, i3), X2.viewport(C2), X2.scissor(M2), X2.setScissorTest(T2), s3) {
        const n3 = J2.get(e3.texture);
        ge2.framebufferTexture2D(36160, 36064, 34069 + t3, n3.__webglTexture, r3);
      } else if (o3) {
        const n3 = J2.get(e3.texture), i4 = t3 || 0;
        ge2.framebufferTextureLayer(36160, 36064, n3.__webglTexture, r3 || 0, i4);
      }
      E2 = -1;
    }, this.readRenderTargetPixels = function(e3, t3, r3, n2, i3, s3, o3) {
      if (!e3 || !e3.isWebGLRenderTarget)
        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let a3 = J2.get(e3).__webglFramebuffer;
      if (e3.isWebGLCubeRenderTarget && void 0 !== o3 && (a3 = a3[o3]), a3) {
        X2.bindFramebuffer(36160, a3);
        try {
          const o4 = e3.texture, a4 = o4.format, l3 = o4.type;
          if (a4 !== Re && fe2.convert(a4) !== ge2.getParameter(35739))
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          const c3 = l3 === Te && (W2.has("EXT_color_buffer_half_float") || q2.isWebGL2 && W2.has("EXT_color_buffer_float"));
          if (!(l3 === ye || fe2.convert(l3) === ge2.getParameter(35738) || l3 === Me && (q2.isWebGL2 || W2.has("OES_texture_float") || W2.has("WEBGL_color_buffer_float")) || c3))
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          t3 >= 0 && t3 <= e3.width - n2 && r3 >= 0 && r3 <= e3.height - i3 && ge2.readPixels(t3, r3, n2, i3, fe2.convert(a4), fe2.convert(l3), s3);
        } finally {
          const e4 = null !== w2 ? J2.get(w2).__webglFramebuffer : null;
          X2.bindFramebuffer(36160, e4);
        }
      }
    }, this.copyFramebufferToTexture = function(e3, t3, r3 = 0) {
      const n2 = Math.pow(2, -r3), i3 = Math.floor(t3.image.width * n2), s3 = Math.floor(t3.image.height * n2);
      Z2.setTexture2D(t3, 0), ge2.copyTexSubImage2D(3553, r3, 0, 0, e3.x, e3.y, i3, s3), X2.unbindTexture();
    }, this.copyTextureToTexture = function(e3, t3, r3, n2 = 0) {
      const i3 = t3.image.width, s3 = t3.image.height, o3 = fe2.convert(r3.format), a3 = fe2.convert(r3.type);
      Z2.setTexture2D(r3, 0), ge2.pixelStorei(37440, r3.flipY), ge2.pixelStorei(37441, r3.premultiplyAlpha), ge2.pixelStorei(3317, r3.unpackAlignment), t3.isDataTexture ? ge2.texSubImage2D(3553, n2, e3.x, e3.y, i3, s3, o3, a3, t3.image.data) : t3.isCompressedTexture ? ge2.compressedTexSubImage2D(3553, n2, e3.x, e3.y, t3.mipmaps[0].width, t3.mipmaps[0].height, o3, t3.mipmaps[0].data) : ge2.texSubImage2D(3553, n2, e3.x, e3.y, o3, a3, t3.image), 0 === n2 && r3.generateMipmaps && ge2.generateMipmap(3553), X2.unbindTexture();
    }, this.copyTextureToTexture3D = function(e3, t3, r3, n2, i3 = 0) {
      if (A2.isWebGL1Renderer)
        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      const s3 = e3.max.x - e3.min.x + 1, o3 = e3.max.y - e3.min.y + 1, a3 = e3.max.z - e3.min.z + 1, l3 = fe2.convert(n2.format), c3 = fe2.convert(n2.type);
      let u3;
      if (n2.isData3DTexture)
        Z2.setTexture3D(n2, 0), u3 = 32879;
      else {
        if (!n2.isDataArrayTexture)
          return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        Z2.setTexture2DArray(n2, 0), u3 = 35866;
      }
      ge2.pixelStorei(37440, n2.flipY), ge2.pixelStorei(37441, n2.premultiplyAlpha), ge2.pixelStorei(3317, n2.unpackAlignment);
      const h3 = ge2.getParameter(3314), p3 = ge2.getParameter(32878), d3 = ge2.getParameter(3316), f2 = ge2.getParameter(3315), m2 = ge2.getParameter(32877), _2 = r3.isCompressedTexture ? r3.mipmaps[0] : r3.image;
      ge2.pixelStorei(3314, _2.width), ge2.pixelStorei(32878, _2.height), ge2.pixelStorei(3316, e3.min.x), ge2.pixelStorei(3315, e3.min.y), ge2.pixelStorei(32877, e3.min.z), r3.isDataTexture || r3.isData3DTexture ? ge2.texSubImage3D(u3, i3, t3.x, t3.y, t3.z, s3, o3, a3, l3, c3, _2.data) : r3.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ge2.compressedTexSubImage3D(u3, i3, t3.x, t3.y, t3.z, s3, o3, a3, l3, _2.data)) : ge2.texSubImage3D(u3, i3, t3.x, t3.y, t3.z, s3, o3, a3, l3, c3, _2), ge2.pixelStorei(3314, h3), ge2.pixelStorei(32878, p3), ge2.pixelStorei(3316, d3), ge2.pixelStorei(3315, f2), ge2.pixelStorei(32877, m2), 0 === i3 && n2.generateMipmaps && ge2.generateMipmap(u3), X2.unbindTexture();
    }, this.initTexture = function(e3) {
      e3.isCubeTexture ? Z2.setTextureCube(e3, 0) : e3.isData3DTexture ? Z2.setTexture3D(e3, 0) : e3.isDataArrayTexture ? Z2.setTexture2DArray(e3, 0) : Z2.setTexture2D(e3, 0), X2.unbindTexture();
    }, this.resetState = function() {
      y2 = 0, x2 = 0, w2 = null, X2.reset(), me2.reset();
    }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  class ll extends al {
  }
  ll.prototype.isWebGL1Renderer = true;
  class cl {
    constructor(e2, t2 = 25e-5) {
      this.isFogExp2 = true, this.name = "", this.color = new Wr(e2), this.density = t2;
    }
    clone() {
      return new cl(this.color, this.density);
    }
    toJSON() {
      return { type: "FogExp2", color: this.color.getHex(), density: this.density };
    }
  }
  class ul {
    constructor(e2, t2 = 1, r2 = 1e3) {
      this.isFog = true, this.name = "", this.color = new Wr(e2), this.near = t2, this.far = r2;
    }
    clone() {
      return new ul(this.color, this.near, this.far);
    }
    toJSON() {
      return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
    }
  }
  class hl extends ui {
    constructor() {
      super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
    copy(e2, t2) {
      return super.copy(e2, t2), null !== e2.background && (this.background = e2.background.clone()), null !== e2.environment && (this.environment = e2.environment.clone()), null !== e2.fog && (this.fog = e2.fog.clone()), null !== e2.overrideMaterial && (this.overrideMaterial = e2.overrideMaterial.clone()), this.matrixAutoUpdate = e2.matrixAutoUpdate, this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return null !== this.fog && (t2.object.fog = this.fog.toJSON()), t2;
    }
    get autoUpdate() {
      return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate;
    }
    set autoUpdate(e2) {
      console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e2;
    }
  }
  class pl {
    constructor(e2, t2) {
      this.isInterleavedBuffer = true, this.array = e2, this.stride = t2, this.count = void 0 !== e2 ? e2.length / t2 : 0, this.usage = nr, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = br();
    }
    onUploadCallback() {
    }
    set needsUpdate(e2) {
      true === e2 && this.version++;
    }
    setUsage(e2) {
      return this.usage = e2, this;
    }
    copy(e2) {
      return this.array = new e2.array.constructor(e2.array), this.count = e2.count, this.stride = e2.stride, this.usage = e2.usage, this;
    }
    copyAt(e2, t2, r2) {
      e2 *= this.stride, r2 *= t2.stride;
      for (let n2 = 0, i2 = this.stride; n2 < i2; n2++)
        this.array[e2 + n2] = t2.array[r2 + n2];
      return this;
    }
    set(e2, t2 = 0) {
      return this.array.set(e2, t2), this;
    }
    clone(e2) {
      void 0 === e2.arrayBuffers && (e2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = br()), void 0 === e2.arrayBuffers[this.array.buffer._uuid] && (e2.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      const t2 = new this.array.constructor(e2.arrayBuffers[this.array.buffer._uuid]), r2 = new this.constructor(t2, this.stride);
      return r2.setUsage(this.usage), r2;
    }
    onUpload(e2) {
      return this.onUploadCallback = e2, this;
    }
    toJSON(e2) {
      return void 0 === e2.arrayBuffers && (e2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = br()), void 0 === e2.arrayBuffers[this.array.buffer._uuid] && (e2.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
    }
  }
  const dl = new ln();
  class fl {
    constructor(e2, t2, r2, n2 = false) {
      this.isInterleavedBufferAttribute = true, this.name = "", this.data = e2, this.itemSize = t2, this.offset = r2, this.normalized = true === n2;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(e2) {
      this.data.needsUpdate = e2;
    }
    applyMatrix4(e2) {
      for (let t2 = 0, r2 = this.data.count; t2 < r2; t2++)
        dl.fromBufferAttribute(this, t2), dl.applyMatrix4(e2), this.setXYZ(t2, dl.x, dl.y, dl.z);
      return this;
    }
    applyNormalMatrix(e2) {
      for (let t2 = 0, r2 = this.count; t2 < r2; t2++)
        dl.fromBufferAttribute(this, t2), dl.applyNormalMatrix(e2), this.setXYZ(t2, dl.x, dl.y, dl.z);
      return this;
    }
    transformDirection(e2) {
      for (let t2 = 0, r2 = this.count; t2 < r2; t2++)
        dl.fromBufferAttribute(this, t2), dl.transformDirection(e2), this.setXYZ(t2, dl.x, dl.y, dl.z);
      return this;
    }
    setX(e2, t2) {
      return this.normalized && (t2 = Tr(t2, this.array)), this.data.array[e2 * this.data.stride + this.offset] = t2, this;
    }
    setY(e2, t2) {
      return this.normalized && (t2 = Tr(t2, this.array)), this.data.array[e2 * this.data.stride + this.offset + 1] = t2, this;
    }
    setZ(e2, t2) {
      return this.normalized && (t2 = Tr(t2, this.array)), this.data.array[e2 * this.data.stride + this.offset + 2] = t2, this;
    }
    setW(e2, t2) {
      return this.normalized && (t2 = Tr(t2, this.array)), this.data.array[e2 * this.data.stride + this.offset + 3] = t2, this;
    }
    getX(e2) {
      let t2 = this.data.array[e2 * this.data.stride + this.offset];
      return this.normalized && (t2 = Mr(t2, this.array)), t2;
    }
    getY(e2) {
      let t2 = this.data.array[e2 * this.data.stride + this.offset + 1];
      return this.normalized && (t2 = Mr(t2, this.array)), t2;
    }
    getZ(e2) {
      let t2 = this.data.array[e2 * this.data.stride + this.offset + 2];
      return this.normalized && (t2 = Mr(t2, this.array)), t2;
    }
    getW(e2) {
      let t2 = this.data.array[e2 * this.data.stride + this.offset + 3];
      return this.normalized && (t2 = Mr(t2, this.array)), t2;
    }
    setXY(e2, t2, r2) {
      return e2 = e2 * this.data.stride + this.offset, this.normalized && (t2 = Tr(t2, this.array), r2 = Tr(r2, this.array)), this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = r2, this;
    }
    setXYZ(e2, t2, r2, n2) {
      return e2 = e2 * this.data.stride + this.offset, this.normalized && (t2 = Tr(t2, this.array), r2 = Tr(r2, this.array), n2 = Tr(n2, this.array)), this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = r2, this.data.array[e2 + 2] = n2, this;
    }
    setXYZW(e2, t2, r2, n2, i2) {
      return e2 = e2 * this.data.stride + this.offset, this.normalized && (t2 = Tr(t2, this.array), r2 = Tr(r2, this.array), n2 = Tr(n2, this.array), i2 = Tr(i2, this.array)), this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = r2, this.data.array[e2 + 2] = n2, this.data.array[e2 + 3] = i2, this;
    }
    clone(e2) {
      if (void 0 === e2) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
        const e3 = [];
        for (let t2 = 0; t2 < this.count; t2++) {
          const r2 = t2 * this.data.stride + this.offset;
          for (let t3 = 0; t3 < this.itemSize; t3++)
            e3.push(this.data.array[r2 + t3]);
        }
        return new Mi(new this.array.constructor(e3), this.itemSize, this.normalized);
      }
      return void 0 === e2.interleavedBuffers && (e2.interleavedBuffers = {}), void 0 === e2.interleavedBuffers[this.data.uuid] && (e2.interleavedBuffers[this.data.uuid] = this.data.clone(e2)), new fl(e2.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
    toJSON(e2) {
      if (void 0 === e2) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
        const e3 = [];
        for (let t2 = 0; t2 < this.count; t2++) {
          const r2 = t2 * this.data.stride + this.offset;
          for (let t3 = 0; t3 < this.itemSize; t3++)
            e3.push(this.data.array[r2 + t3]);
        }
        return { itemSize: this.itemSize, type: this.array.constructor.name, array: e3, normalized: this.normalized };
      }
      return void 0 === e2.interleavedBuffers && (e2.interleavedBuffers = {}), void 0 === e2.interleavedBuffers[this.data.uuid] && (e2.interleavedBuffers[this.data.uuid] = this.data.toJSON(e2)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
    }
  }
  class ml extends wi {
    constructor(e2) {
      super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new Wr(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.alphaMap = e2.alphaMap, this.rotation = e2.rotation, this.sizeAttenuation = e2.sizeAttenuation, this.fog = e2.fog, this;
    }
  }
  let _l;
  const gl = new ln(), vl = new ln(), Al = new ln(), bl = new kr(), yl = new kr(), xl = new Nn(), wl = new ln(), El = new ln(), Sl = new ln(), Cl = new kr(), Ml = new kr(), Tl = new kr();
  class Il extends ui {
    constructor(e2) {
      if (super(), this.isSprite = true, this.type = "Sprite", void 0 === _l) {
        _l = new Hi();
        const e3 = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), t2 = new pl(e3, 5);
        _l.setIndex([0, 1, 2, 0, 2, 3]), _l.setAttribute("position", new fl(t2, 3, 0, false)), _l.setAttribute("uv", new fl(t2, 2, 3, false));
      }
      this.geometry = _l, this.material = void 0 !== e2 ? e2 : new ml(), this.center = new kr(0.5, 0.5);
    }
    raycast(e2, t2) {
      null === e2.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), vl.setFromMatrixScale(this.matrixWorld), xl.copy(e2.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e2.camera.matrixWorldInverse, this.matrixWorld), Al.setFromMatrixPosition(this.modelViewMatrix), e2.camera.isPerspectiveCamera && false === this.material.sizeAttenuation && vl.multiplyScalar(-Al.z);
      const r2 = this.material.rotation;
      let n2, i2;
      0 !== r2 && (i2 = Math.cos(r2), n2 = Math.sin(r2));
      const s2 = this.center;
      kl(wl.set(-0.5, -0.5, 0), Al, s2, vl, n2, i2), kl(El.set(0.5, -0.5, 0), Al, s2, vl, n2, i2), kl(Sl.set(0.5, 0.5, 0), Al, s2, vl, n2, i2), Cl.set(0, 0), Ml.set(1, 0), Tl.set(1, 1);
      let o2 = e2.ray.intersectTriangle(wl, El, Sl, false, gl);
      if (null === o2 && (kl(El.set(-0.5, 0.5, 0), Al, s2, vl, n2, i2), Ml.set(0, 1), o2 = e2.ray.intersectTriangle(wl, Sl, El, false, gl), null === o2))
        return;
      const a2 = e2.ray.origin.distanceTo(gl);
      a2 < e2.near || a2 > e2.far || t2.push({ distance: a2, point: gl.clone(), uv: yi.getUV(gl, wl, El, Sl, Cl, Ml, Tl, new kr()), face: null, object: this });
    }
    copy(e2, t2) {
      return super.copy(e2, t2), void 0 !== e2.center && this.center.copy(e2.center), this.material = e2.material, this;
    }
  }
  function kl(e2, t2, r2, n2, i2, s2) {
    bl.subVectors(e2, r2).addScalar(0.5).multiply(n2), void 0 !== i2 ? (yl.x = s2 * bl.x - i2 * bl.y, yl.y = i2 * bl.x + s2 * bl.y) : yl.copy(bl), e2.copy(t2), e2.x += yl.x, e2.y += yl.y, e2.applyMatrix4(xl);
  }
  const Dl = new ln(), Pl = new ln();
  class Bl extends ui {
    constructor() {
      super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: true, value: [] }, isLOD: { value: true } }), this.autoUpdate = true;
    }
    copy(e2) {
      super.copy(e2, false);
      const t2 = e2.levels;
      for (let e3 = 0, r2 = t2.length; e3 < r2; e3++) {
        const r3 = t2[e3];
        this.addLevel(r3.object.clone(), r3.distance);
      }
      return this.autoUpdate = e2.autoUpdate, this;
    }
    addLevel(e2, t2 = 0) {
      t2 = Math.abs(t2);
      const r2 = this.levels;
      let n2;
      for (n2 = 0; n2 < r2.length && !(t2 < r2[n2].distance); n2++)
        ;
      return r2.splice(n2, 0, { distance: t2, object: e2 }), this.add(e2), this;
    }
    getCurrentLevel() {
      return this._currentLevel;
    }
    getObjectForDistance(e2) {
      const t2 = this.levels;
      if (t2.length > 0) {
        let r2, n2;
        for (r2 = 1, n2 = t2.length; r2 < n2 && !(e2 < t2[r2].distance); r2++)
          ;
        return t2[r2 - 1].object;
      }
      return null;
    }
    raycast(e2, t2) {
      if (this.levels.length > 0) {
        Dl.setFromMatrixPosition(this.matrixWorld);
        const r2 = e2.ray.origin.distanceTo(Dl);
        this.getObjectForDistance(r2).raycast(e2, t2);
      }
    }
    update(e2) {
      const t2 = this.levels;
      if (t2.length > 1) {
        Dl.setFromMatrixPosition(e2.matrixWorld), Pl.setFromMatrixPosition(this.matrixWorld);
        const r2 = Dl.distanceTo(Pl) / e2.zoom;
        let n2, i2;
        for (t2[0].object.visible = true, n2 = 1, i2 = t2.length; n2 < i2 && r2 >= t2[n2].distance; n2++)
          t2[n2 - 1].object.visible = false, t2[n2].object.visible = true;
        for (this._currentLevel = n2 - 1; n2 < i2; n2++)
          t2[n2].object.visible = false;
      }
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      false === this.autoUpdate && (t2.object.autoUpdate = false), t2.object.levels = [];
      const r2 = this.levels;
      for (let e3 = 0, n2 = r2.length; e3 < n2; e3++) {
        const n3 = r2[e3];
        t2.object.levels.push({ object: n3.object.uuid, distance: n3.distance });
      }
      return t2;
    }
  }
  const Rl = new ln(), Ll = new $r(), Ol = new $r(), Fl = new ln(), Ul = new Nn();
  class Nl extends cs {
    constructor(e2, t2) {
      super(e2, t2), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Nn(), this.bindMatrixInverse = new Nn();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.bindMode = e2.bindMode, this.bindMatrix.copy(e2.bindMatrix), this.bindMatrixInverse.copy(e2.bindMatrixInverse), this.skeleton = e2.skeleton, this;
    }
    bind(e2, t2) {
      this.skeleton = e2, void 0 === t2 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t2 = this.matrixWorld), this.bindMatrix.copy(t2), this.bindMatrixInverse.copy(t2).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const e2 = new $r(), t2 = this.geometry.attributes.skinWeight;
      for (let r2 = 0, n2 = t2.count; r2 < n2; r2++) {
        e2.fromBufferAttribute(t2, r2);
        const n3 = 1 / e2.manhattanLength();
        n3 !== 1 / 0 ? e2.multiplyScalar(n3) : e2.set(1, 0, 0, 0), t2.setXYZW(r2, e2.x, e2.y, e2.z, e2.w);
      }
    }
    updateMatrixWorld(e2) {
      super.updateMatrixWorld(e2), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    boneTransform(e2, t2) {
      const r2 = this.skeleton, n2 = this.geometry;
      Ll.fromBufferAttribute(n2.attributes.skinIndex, e2), Ol.fromBufferAttribute(n2.attributes.skinWeight, e2), Rl.copy(t2).applyMatrix4(this.bindMatrix), t2.set(0, 0, 0);
      for (let e3 = 0; e3 < 4; e3++) {
        const n3 = Ol.getComponent(e3);
        if (0 !== n3) {
          const i2 = Ll.getComponent(e3);
          Ul.multiplyMatrices(r2.bones[i2].matrixWorld, r2.boneInverses[i2]), t2.addScaledVector(Fl.copy(Rl).applyMatrix4(Ul), n3);
        }
      }
      return t2.applyMatrix4(this.bindMatrixInverse);
    }
  }
  class jl extends ui {
    constructor() {
      super(), this.isBone = true, this.type = "Bone";
    }
  }
  class zl extends Zr {
    constructor(e2 = null, t2 = 1, r2 = 1, n2, i2, s2, o2, a2, l2 = he, c2 = he, u2, h2) {
      super(null, s2, o2, a2, l2, c2, n2, i2, u2, h2), this.isDataTexture = true, this.image = { data: e2, width: t2, height: r2 }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  const Gl = new Nn(), Vl = new Nn();
  class Ql {
    constructor(e2 = [], t2 = []) {
      this.uuid = br(), this.bones = e2.slice(0), this.boneInverses = t2, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
    }
    init() {
      const e2 = this.bones, t2 = this.boneInverses;
      if (this.boneMatrices = new Float32Array(16 * e2.length), 0 === t2.length)
        this.calculateInverses();
      else if (e2.length !== t2.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
        for (let e3 = 0, t3 = this.bones.length; e3 < t3; e3++)
          this.boneInverses.push(new Nn());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let e2 = 0, t2 = this.bones.length; e2 < t2; e2++) {
        const t3 = new Nn();
        this.bones[e2] && t3.copy(this.bones[e2].matrixWorld).invert(), this.boneInverses.push(t3);
      }
    }
    pose() {
      for (let e2 = 0, t2 = this.bones.length; e2 < t2; e2++) {
        const t3 = this.bones[e2];
        t3 && t3.matrixWorld.copy(this.boneInverses[e2]).invert();
      }
      for (let e2 = 0, t2 = this.bones.length; e2 < t2; e2++) {
        const t3 = this.bones[e2];
        t3 && (t3.parent && t3.parent.isBone ? (t3.matrix.copy(t3.parent.matrixWorld).invert(), t3.matrix.multiply(t3.matrixWorld)) : t3.matrix.copy(t3.matrixWorld), t3.matrix.decompose(t3.position, t3.quaternion, t3.scale));
      }
    }
    update() {
      const e2 = this.bones, t2 = this.boneInverses, r2 = this.boneMatrices, n2 = this.boneTexture;
      for (let n3 = 0, i2 = e2.length; n3 < i2; n3++) {
        const i3 = e2[n3] ? e2[n3].matrixWorld : Vl;
        Gl.multiplyMatrices(i3, t2[n3]), Gl.toArray(r2, 16 * n3);
      }
      null !== n2 && (n2.needsUpdate = true);
    }
    clone() {
      return new Ql(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let e2 = Math.sqrt(4 * this.bones.length);
      e2 = Sr(e2), e2 = Math.max(e2, 4);
      const t2 = new Float32Array(e2 * e2 * 4);
      t2.set(this.boneMatrices);
      const r2 = new zl(t2, e2, e2, Re, Me);
      return r2.needsUpdate = true, this.boneMatrices = t2, this.boneTexture = r2, this.boneTextureSize = e2, this;
    }
    getBoneByName(e2) {
      for (let t2 = 0, r2 = this.bones.length; t2 < r2; t2++) {
        const r3 = this.bones[t2];
        if (r3.name === e2)
          return r3;
      }
    }
    dispose() {
      null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
    }
    fromJSON(e2, t2) {
      this.uuid = e2.uuid;
      for (let r2 = 0, n2 = e2.bones.length; r2 < n2; r2++) {
        const n3 = e2.bones[r2];
        let i2 = t2[n3];
        void 0 === i2 && (console.warn("THREE.Skeleton: No bone found with UUID:", n3), i2 = new jl()), this.bones.push(i2), this.boneInverses.push(new Nn().fromArray(e2.boneInverses[r2]));
      }
      return this.init(), this;
    }
    toJSON() {
      const e2 = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
      e2.uuid = this.uuid;
      const t2 = this.bones, r2 = this.boneInverses;
      for (let n2 = 0, i2 = t2.length; n2 < i2; n2++) {
        const i3 = t2[n2];
        e2.bones.push(i3.uuid);
        const s2 = r2[n2];
        e2.boneInverses.push(s2.toArray());
      }
      return e2;
    }
  }
  class Hl extends Mi {
    constructor(e2, t2, r2, n2 = 1) {
      super(e2, t2, r2), this.isInstancedBufferAttribute = true, this.meshPerAttribute = n2;
    }
    copy(e2) {
      return super.copy(e2), this.meshPerAttribute = e2.meshPerAttribute, this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.meshPerAttribute = this.meshPerAttribute, e2.isInstancedBufferAttribute = true, e2;
    }
  }
  const Wl = new Nn(), ql = new Nn(), Xl = [], Yl = new cs();
  class Kl extends cs {
    constructor(e2, t2, r2) {
      super(e2, t2), this.isInstancedMesh = true, this.instanceMatrix = new Hl(new Float32Array(16 * r2), 16), this.instanceColor = null, this.count = r2, this.frustumCulled = false;
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.instanceMatrix.copy(e2.instanceMatrix), null !== e2.instanceColor && (this.instanceColor = e2.instanceColor.clone()), this.count = e2.count, this;
    }
    getColorAt(e2, t2) {
      t2.fromArray(this.instanceColor.array, 3 * e2);
    }
    getMatrixAt(e2, t2) {
      t2.fromArray(this.instanceMatrix.array, 16 * e2);
    }
    raycast(e2, t2) {
      const r2 = this.matrixWorld, n2 = this.count;
      if (Yl.geometry = this.geometry, Yl.material = this.material, void 0 !== Yl.material)
        for (let i2 = 0; i2 < n2; i2++) {
          this.getMatrixAt(i2, Wl), ql.multiplyMatrices(r2, Wl), Yl.matrixWorld = ql, Yl.raycast(e2, Xl);
          for (let e3 = 0, r3 = Xl.length; e3 < r3; e3++) {
            const r4 = Xl[e3];
            r4.instanceId = i2, r4.object = this, t2.push(r4);
          }
          Xl.length = 0;
        }
    }
    setColorAt(e2, t2) {
      null === this.instanceColor && (this.instanceColor = new Hl(new Float32Array(3 * this.instanceMatrix.count), 3)), t2.toArray(this.instanceColor.array, 3 * e2);
    }
    setMatrixAt(e2, t2) {
      t2.toArray(this.instanceMatrix.array, 16 * e2);
    }
    updateMorphTargets() {
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  class Jl extends wi {
    constructor(e2) {
      super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new Wr(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.linewidth = e2.linewidth, this.linecap = e2.linecap, this.linejoin = e2.linejoin, this.fog = e2.fog, this;
    }
  }
  const Zl = new ln(), $l = new ln(), ec = new Nn(), tc = new Un(), rc = new kn();
  class nc extends ui {
    constructor(e2 = new Hi(), t2 = new Jl()) {
      super(), this.isLine = true, this.type = "Line", this.geometry = e2, this.material = t2, this.updateMorphTargets();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.material = e2.material, this.geometry = e2.geometry, this;
    }
    computeLineDistances() {
      const e2 = this.geometry;
      if (null === e2.index) {
        const t2 = e2.attributes.position, r2 = [0];
        for (let e3 = 1, n2 = t2.count; e3 < n2; e3++)
          Zl.fromBufferAttribute(t2, e3 - 1), $l.fromBufferAttribute(t2, e3), r2[e3] = r2[e3 - 1], r2[e3] += Zl.distanceTo($l);
        e2.setAttribute("lineDistance", new Oi(r2, 1));
      } else
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
    raycast(e2, t2) {
      const r2 = this.geometry, n2 = this.matrixWorld, i2 = e2.params.Line.threshold, s2 = r2.drawRange;
      if (null === r2.boundingSphere && r2.computeBoundingSphere(), rc.copy(r2.boundingSphere), rc.applyMatrix4(n2), rc.radius += i2, false === e2.ray.intersectsSphere(rc))
        return;
      ec.copy(n2).invert(), tc.copy(e2.ray).applyMatrix4(ec);
      const o2 = i2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = o2 * o2, l2 = new ln(), c2 = new ln(), u2 = new ln(), h2 = new ln(), p2 = this.isLineSegments ? 2 : 1, d2 = r2.index, f2 = r2.attributes.position;
      if (null !== d2)
        for (let r3 = Math.max(0, s2.start), n3 = Math.min(d2.count, s2.start + s2.count) - 1; r3 < n3; r3 += p2) {
          const n4 = d2.getX(r3), i3 = d2.getX(r3 + 1);
          if (l2.fromBufferAttribute(f2, n4), c2.fromBufferAttribute(f2, i3), tc.distanceSqToSegment(l2, c2, h2, u2) > a2)
            continue;
          h2.applyMatrix4(this.matrixWorld);
          const s3 = e2.ray.origin.distanceTo(h2);
          s3 < e2.near || s3 > e2.far || t2.push({ distance: s3, point: u2.clone().applyMatrix4(this.matrixWorld), index: r3, face: null, faceIndex: null, object: this });
        }
      else
        for (let r3 = Math.max(0, s2.start), n3 = Math.min(f2.count, s2.start + s2.count) - 1; r3 < n3; r3 += p2) {
          if (l2.fromBufferAttribute(f2, r3), c2.fromBufferAttribute(f2, r3 + 1), tc.distanceSqToSegment(l2, c2, h2, u2) > a2)
            continue;
          h2.applyMatrix4(this.matrixWorld);
          const n4 = e2.ray.origin.distanceTo(h2);
          n4 < e2.near || n4 > e2.far || t2.push({ distance: n4, point: u2.clone().applyMatrix4(this.matrixWorld), index: r3, face: null, faceIndex: null, object: this });
        }
    }
    updateMorphTargets() {
      const e2 = this.geometry.morphAttributes, t2 = Object.keys(e2);
      if (t2.length > 0) {
        const r2 = e2[t2[0]];
        if (void 0 !== r2) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let e3 = 0, t3 = r2.length; e3 < t3; e3++) {
            const t4 = r2[e3].name || String(e3);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t4] = e3;
          }
        }
      }
    }
  }
  const ic = new ln(), sc = new ln();
  class oc extends nc {
    constructor(e2, t2) {
      super(e2, t2), this.isLineSegments = true, this.type = "LineSegments";
    }
    computeLineDistances() {
      const e2 = this.geometry;
      if (null === e2.index) {
        const t2 = e2.attributes.position, r2 = [];
        for (let e3 = 0, n2 = t2.count; e3 < n2; e3 += 2)
          ic.fromBufferAttribute(t2, e3), sc.fromBufferAttribute(t2, e3 + 1), r2[e3] = 0 === e3 ? 0 : r2[e3 - 1], r2[e3 + 1] = r2[e3] + ic.distanceTo(sc);
        e2.setAttribute("lineDistance", new Oi(r2, 1));
      } else
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
  }
  class ac extends nc {
    constructor(e2, t2) {
      super(e2, t2), this.isLineLoop = true, this.type = "LineLoop";
    }
  }
  class lc extends wi {
    constructor(e2) {
      super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new Wr(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.alphaMap = e2.alphaMap, this.size = e2.size, this.sizeAttenuation = e2.sizeAttenuation, this.fog = e2.fog, this;
    }
  }
  const cc = new Nn(), uc = new Un(), hc = new kn(), pc = new ln();
  class dc extends ui {
    constructor(e2 = new Hi(), t2 = new lc()) {
      super(), this.isPoints = true, this.type = "Points", this.geometry = e2, this.material = t2, this.updateMorphTargets();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.material = e2.material, this.geometry = e2.geometry, this;
    }
    raycast(e2, t2) {
      const r2 = this.geometry, n2 = this.matrixWorld, i2 = e2.params.Points.threshold, s2 = r2.drawRange;
      if (null === r2.boundingSphere && r2.computeBoundingSphere(), hc.copy(r2.boundingSphere), hc.applyMatrix4(n2), hc.radius += i2, false === e2.ray.intersectsSphere(hc))
        return;
      cc.copy(n2).invert(), uc.copy(e2.ray).applyMatrix4(cc);
      const o2 = i2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = o2 * o2, l2 = r2.index, c2 = r2.attributes.position;
      if (null !== l2)
        for (let r3 = Math.max(0, s2.start), i3 = Math.min(l2.count, s2.start + s2.count); r3 < i3; r3++) {
          const i4 = l2.getX(r3);
          pc.fromBufferAttribute(c2, i4), fc(pc, i4, a2, n2, e2, t2, this);
        }
      else
        for (let r3 = Math.max(0, s2.start), i3 = Math.min(c2.count, s2.start + s2.count); r3 < i3; r3++)
          pc.fromBufferAttribute(c2, r3), fc(pc, r3, a2, n2, e2, t2, this);
    }
    updateMorphTargets() {
      const e2 = this.geometry.morphAttributes, t2 = Object.keys(e2);
      if (t2.length > 0) {
        const r2 = e2[t2[0]];
        if (void 0 !== r2) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let e3 = 0, t3 = r2.length; e3 < t3; e3++) {
            const t4 = r2[e3].name || String(e3);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t4] = e3;
          }
        }
      }
    }
  }
  function fc(e2, t2, r2, n2, i2, s2, o2) {
    const a2 = uc.distanceSqToPoint(e2);
    if (a2 < r2) {
      const r3 = new ln();
      uc.closestPointToPoint(e2, r3), r3.applyMatrix4(n2);
      const l2 = i2.ray.origin.distanceTo(r3);
      if (l2 < i2.near || l2 > i2.far)
        return;
      s2.push({ distance: l2, distanceToRay: Math.sqrt(a2), point: r3, index: t2, face: null, object: o2 });
    }
  }
  class mc extends Zr {
    constructor(e2, t2, r2, n2, i2, s2, o2, a2, l2) {
      super(e2, t2, r2, n2, i2, s2, o2, a2, l2), this.isVideoTexture = true, this.minFilter = void 0 !== s2 ? s2 : _e, this.magFilter = void 0 !== i2 ? i2 : _e, this.generateMipmaps = false;
      const c2 = this;
      "requestVideoFrameCallback" in e2 && e2.requestVideoFrameCallback(function t3() {
        c2.needsUpdate = true, e2.requestVideoFrameCallback(t3);
      });
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      const e2 = this.image;
      false == "requestVideoFrameCallback" in e2 && e2.readyState >= e2.HAVE_CURRENT_DATA && (this.needsUpdate = true);
    }
  }
  class _c extends Zr {
    constructor(e2, t2, r2) {
      super({ width: e2, height: t2 }), this.isFramebufferTexture = true, this.format = r2, this.magFilter = he, this.minFilter = he, this.generateMipmaps = false, this.needsUpdate = true;
    }
  }
  class gc extends Zr {
    constructor(e2, t2, r2, n2, i2, s2, o2, a2, l2, c2, u2, h2) {
      super(null, s2, o2, a2, l2, c2, n2, i2, u2, h2), this.isCompressedTexture = true, this.image = { width: t2, height: r2 }, this.mipmaps = e2, this.flipY = false, this.generateMipmaps = false;
    }
  }
  class vc extends Zr {
    constructor(e2, t2, r2, n2, i2, s2, o2, a2, l2) {
      super(e2, t2, r2, n2, i2, s2, o2, a2, l2), this.isCanvasTexture = true, this.needsUpdate = true;
    }
  }
  class Ac {
    constructor() {
      this.type = "Curve", this.arcLengthDivisions = 200;
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(e2, t2) {
      const r2 = this.getUtoTmapping(e2);
      return this.getPoint(r2, t2);
    }
    getPoints(e2 = 5) {
      const t2 = [];
      for (let r2 = 0; r2 <= e2; r2++)
        t2.push(this.getPoint(r2 / e2));
      return t2;
    }
    getSpacedPoints(e2 = 5) {
      const t2 = [];
      for (let r2 = 0; r2 <= e2; r2++)
        t2.push(this.getPointAt(r2 / e2));
      return t2;
    }
    getLength() {
      const e2 = this.getLengths();
      return e2[e2.length - 1];
    }
    getLengths(e2 = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === e2 + 1 && !this.needsUpdate)
        return this.cacheArcLengths;
      this.needsUpdate = false;
      const t2 = [];
      let r2, n2 = this.getPoint(0), i2 = 0;
      t2.push(0);
      for (let s2 = 1; s2 <= e2; s2++)
        r2 = this.getPoint(s2 / e2), i2 += r2.distanceTo(n2), t2.push(i2), n2 = r2;
      return this.cacheArcLengths = t2, t2;
    }
    updateArcLengths() {
      this.needsUpdate = true, this.getLengths();
    }
    getUtoTmapping(e2, t2) {
      const r2 = this.getLengths();
      let n2 = 0;
      const i2 = r2.length;
      let s2;
      s2 = t2 || e2 * r2[i2 - 1];
      let o2, a2 = 0, l2 = i2 - 1;
      for (; a2 <= l2; )
        if (n2 = Math.floor(a2 + (l2 - a2) / 2), o2 = r2[n2] - s2, o2 < 0)
          a2 = n2 + 1;
        else {
          if (!(o2 > 0)) {
            l2 = n2;
            break;
          }
          l2 = n2 - 1;
        }
      if (n2 = l2, r2[n2] === s2)
        return n2 / (i2 - 1);
      const c2 = r2[n2];
      return (n2 + (s2 - c2) / (r2[n2 + 1] - c2)) / (i2 - 1);
    }
    getTangent(e2, t2) {
      const r2 = 1e-4;
      let n2 = e2 - r2, i2 = e2 + r2;
      n2 < 0 && (n2 = 0), i2 > 1 && (i2 = 1);
      const s2 = this.getPoint(n2), o2 = this.getPoint(i2), a2 = t2 || (s2.isVector2 ? new kr() : new ln());
      return a2.copy(o2).sub(s2).normalize(), a2;
    }
    getTangentAt(e2, t2) {
      const r2 = this.getUtoTmapping(e2);
      return this.getTangent(r2, t2);
    }
    computeFrenetFrames(e2, t2) {
      const r2 = new ln(), n2 = [], i2 = [], s2 = [], o2 = new ln(), a2 = new Nn();
      for (let t3 = 0; t3 <= e2; t3++) {
        const r3 = t3 / e2;
        n2[t3] = this.getTangentAt(r3, new ln());
      }
      i2[0] = new ln(), s2[0] = new ln();
      let l2 = Number.MAX_VALUE;
      const c2 = Math.abs(n2[0].x), u2 = Math.abs(n2[0].y), h2 = Math.abs(n2[0].z);
      c2 <= l2 && (l2 = c2, r2.set(1, 0, 0)), u2 <= l2 && (l2 = u2, r2.set(0, 1, 0)), h2 <= l2 && r2.set(0, 0, 1), o2.crossVectors(n2[0], r2).normalize(), i2[0].crossVectors(n2[0], o2), s2[0].crossVectors(n2[0], i2[0]);
      for (let t3 = 1; t3 <= e2; t3++) {
        if (i2[t3] = i2[t3 - 1].clone(), s2[t3] = s2[t3 - 1].clone(), o2.crossVectors(n2[t3 - 1], n2[t3]), o2.length() > Number.EPSILON) {
          o2.normalize();
          const e3 = Math.acos(yr(n2[t3 - 1].dot(n2[t3]), -1, 1));
          i2[t3].applyMatrix4(a2.makeRotationAxis(o2, e3));
        }
        s2[t3].crossVectors(n2[t3], i2[t3]);
      }
      if (true === t2) {
        let t3 = Math.acos(yr(i2[0].dot(i2[e2]), -1, 1));
        t3 /= e2, n2[0].dot(o2.crossVectors(i2[0], i2[e2])) > 0 && (t3 = -t3);
        for (let r3 = 1; r3 <= e2; r3++)
          i2[r3].applyMatrix4(a2.makeRotationAxis(n2[r3], t3 * r3)), s2[r3].crossVectors(n2[r3], i2[r3]);
      }
      return { tangents: n2, normals: i2, binormals: s2 };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.arcLengthDivisions = e2.arcLengthDivisions, this;
    }
    toJSON() {
      const e2 = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
      return e2.arcLengthDivisions = this.arcLengthDivisions, e2.type = this.type, e2;
    }
    fromJSON(e2) {
      return this.arcLengthDivisions = e2.arcLengthDivisions, this;
    }
  }
  class bc extends Ac {
    constructor(e2 = 0, t2 = 0, r2 = 1, n2 = 1, i2 = 0, s2 = 2 * Math.PI, o2 = false, a2 = 0) {
      super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = e2, this.aY = t2, this.xRadius = r2, this.yRadius = n2, this.aStartAngle = i2, this.aEndAngle = s2, this.aClockwise = o2, this.aRotation = a2;
    }
    getPoint(e2, t2) {
      const r2 = t2 || new kr(), n2 = 2 * Math.PI;
      let i2 = this.aEndAngle - this.aStartAngle;
      const s2 = Math.abs(i2) < Number.EPSILON;
      for (; i2 < 0; )
        i2 += n2;
      for (; i2 > n2; )
        i2 -= n2;
      i2 < Number.EPSILON && (i2 = s2 ? 0 : n2), true !== this.aClockwise || s2 || (i2 === n2 ? i2 = -n2 : i2 -= n2);
      const o2 = this.aStartAngle + e2 * i2;
      let a2 = this.aX + this.xRadius * Math.cos(o2), l2 = this.aY + this.yRadius * Math.sin(o2);
      if (0 !== this.aRotation) {
        const e3 = Math.cos(this.aRotation), t3 = Math.sin(this.aRotation), r3 = a2 - this.aX, n3 = l2 - this.aY;
        a2 = r3 * e3 - n3 * t3 + this.aX, l2 = r3 * t3 + n3 * e3 + this.aY;
      }
      return r2.set(a2, l2);
    }
    copy(e2) {
      return super.copy(e2), this.aX = e2.aX, this.aY = e2.aY, this.xRadius = e2.xRadius, this.yRadius = e2.yRadius, this.aStartAngle = e2.aStartAngle, this.aEndAngle = e2.aEndAngle, this.aClockwise = e2.aClockwise, this.aRotation = e2.aRotation, this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.aX = this.aX, e2.aY = this.aY, e2.xRadius = this.xRadius, e2.yRadius = this.yRadius, e2.aStartAngle = this.aStartAngle, e2.aEndAngle = this.aEndAngle, e2.aClockwise = this.aClockwise, e2.aRotation = this.aRotation, e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.aX = e2.aX, this.aY = e2.aY, this.xRadius = e2.xRadius, this.yRadius = e2.yRadius, this.aStartAngle = e2.aStartAngle, this.aEndAngle = e2.aEndAngle, this.aClockwise = e2.aClockwise, this.aRotation = e2.aRotation, this;
    }
  }
  class yc extends bc {
    constructor(e2, t2, r2, n2, i2, s2) {
      super(e2, t2, r2, r2, n2, i2, s2), this.isArcCurve = true, this.type = "ArcCurve";
    }
  }
  function xc() {
    let e2 = 0, t2 = 0, r2 = 0, n2 = 0;
    function i2(i3, s2, o2, a2) {
      e2 = i3, t2 = o2, r2 = -3 * i3 + 3 * s2 - 2 * o2 - a2, n2 = 2 * i3 - 2 * s2 + o2 + a2;
    }
    return { initCatmullRom: function(e3, t3, r3, n3, s2) {
      i2(t3, r3, s2 * (r3 - e3), s2 * (n3 - t3));
    }, initNonuniformCatmullRom: function(e3, t3, r3, n3, s2, o2, a2) {
      let l2 = (t3 - e3) / s2 - (r3 - e3) / (s2 + o2) + (r3 - t3) / o2, c2 = (r3 - t3) / o2 - (n3 - t3) / (o2 + a2) + (n3 - r3) / a2;
      l2 *= o2, c2 *= o2, i2(t3, r3, l2, c2);
    }, calc: function(i3) {
      const s2 = i3 * i3;
      return e2 + t2 * i3 + r2 * s2 + n2 * (s2 * i3);
    } };
  }
  const wc = new ln(), Ec = new xc(), Sc = new xc(), Cc = new xc();
  class Mc extends Ac {
    constructor(e2 = [], t2 = false, r2 = "centripetal", n2 = 0.5) {
      super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = e2, this.closed = t2, this.curveType = r2, this.tension = n2;
    }
    getPoint(e2, t2 = new ln()) {
      const r2 = t2, n2 = this.points, i2 = n2.length, s2 = (i2 - (this.closed ? 0 : 1)) * e2;
      let o2, a2, l2 = Math.floor(s2), c2 = s2 - l2;
      this.closed ? l2 += l2 > 0 ? 0 : (Math.floor(Math.abs(l2) / i2) + 1) * i2 : 0 === c2 && l2 === i2 - 1 && (l2 = i2 - 2, c2 = 1), this.closed || l2 > 0 ? o2 = n2[(l2 - 1) % i2] : (wc.subVectors(n2[0], n2[1]).add(n2[0]), o2 = wc);
      const u2 = n2[l2 % i2], h2 = n2[(l2 + 1) % i2];
      if (this.closed || l2 + 2 < i2 ? a2 = n2[(l2 + 2) % i2] : (wc.subVectors(n2[i2 - 1], n2[i2 - 2]).add(n2[i2 - 1]), a2 = wc), "centripetal" === this.curveType || "chordal" === this.curveType) {
        const e3 = "chordal" === this.curveType ? 0.5 : 0.25;
        let t3 = Math.pow(o2.distanceToSquared(u2), e3), r3 = Math.pow(u2.distanceToSquared(h2), e3), n3 = Math.pow(h2.distanceToSquared(a2), e3);
        r3 < 1e-4 && (r3 = 1), t3 < 1e-4 && (t3 = r3), n3 < 1e-4 && (n3 = r3), Ec.initNonuniformCatmullRom(o2.x, u2.x, h2.x, a2.x, t3, r3, n3), Sc.initNonuniformCatmullRom(o2.y, u2.y, h2.y, a2.y, t3, r3, n3), Cc.initNonuniformCatmullRom(o2.z, u2.z, h2.z, a2.z, t3, r3, n3);
      } else
        "catmullrom" === this.curveType && (Ec.initCatmullRom(o2.x, u2.x, h2.x, a2.x, this.tension), Sc.initCatmullRom(o2.y, u2.y, h2.y, a2.y, this.tension), Cc.initCatmullRom(o2.z, u2.z, h2.z, a2.z, this.tension));
      return r2.set(Ec.calc(c2), Sc.calc(c2), Cc.calc(c2)), r2;
    }
    copy(e2) {
      super.copy(e2), this.points = [];
      for (let t2 = 0, r2 = e2.points.length; t2 < r2; t2++) {
        const r3 = e2.points[t2];
        this.points.push(r3.clone());
      }
      return this.closed = e2.closed, this.curveType = e2.curveType, this.tension = e2.tension, this;
    }
    toJSON() {
      const e2 = super.toJSON();
      e2.points = [];
      for (let t2 = 0, r2 = this.points.length; t2 < r2; t2++) {
        const r3 = this.points[t2];
        e2.points.push(r3.toArray());
      }
      return e2.closed = this.closed, e2.curveType = this.curveType, e2.tension = this.tension, e2;
    }
    fromJSON(e2) {
      super.fromJSON(e2), this.points = [];
      for (let t2 = 0, r2 = e2.points.length; t2 < r2; t2++) {
        const r3 = e2.points[t2];
        this.points.push(new ln().fromArray(r3));
      }
      return this.closed = e2.closed, this.curveType = e2.curveType, this.tension = e2.tension, this;
    }
  }
  function Tc(e2, t2, r2, n2, i2) {
    const s2 = 0.5 * (n2 - t2), o2 = 0.5 * (i2 - r2), a2 = e2 * e2;
    return (2 * r2 - 2 * n2 + s2 + o2) * (e2 * a2) + (-3 * r2 + 3 * n2 - 2 * s2 - o2) * a2 + s2 * e2 + r2;
  }
  function Ic(e2, t2, r2, n2) {
    return function(e3, t3) {
      const r3 = 1 - e3;
      return r3 * r3 * t3;
    }(e2, t2) + function(e3, t3) {
      return 2 * (1 - e3) * e3 * t3;
    }(e2, r2) + function(e3, t3) {
      return e3 * e3 * t3;
    }(e2, n2);
  }
  function kc(e2, t2, r2, n2, i2) {
    return function(e3, t3) {
      const r3 = 1 - e3;
      return r3 * r3 * r3 * t3;
    }(e2, t2) + function(e3, t3) {
      const r3 = 1 - e3;
      return 3 * r3 * r3 * e3 * t3;
    }(e2, r2) + function(e3, t3) {
      return 3 * (1 - e3) * e3 * e3 * t3;
    }(e2, n2) + function(e3, t3) {
      return e3 * e3 * e3 * t3;
    }(e2, i2);
  }
  class Dc extends Ac {
    constructor(e2 = new kr(), t2 = new kr(), r2 = new kr(), n2 = new kr()) {
      super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = e2, this.v1 = t2, this.v2 = r2, this.v3 = n2;
    }
    getPoint(e2, t2 = new kr()) {
      const r2 = t2, n2 = this.v0, i2 = this.v1, s2 = this.v2, o2 = this.v3;
      return r2.set(kc(e2, n2.x, i2.x, s2.x, o2.x), kc(e2, n2.y, i2.y, s2.y, o2.y)), r2;
    }
    copy(e2) {
      return super.copy(e2), this.v0.copy(e2.v0), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this.v3.copy(e2.v3), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v0 = this.v0.toArray(), e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2.v3 = this.v3.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v0.fromArray(e2.v0), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this.v3.fromArray(e2.v3), this;
    }
  }
  class Pc extends Ac {
    constructor(e2 = new ln(), t2 = new ln(), r2 = new ln(), n2 = new ln()) {
      super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = e2, this.v1 = t2, this.v2 = r2, this.v3 = n2;
    }
    getPoint(e2, t2 = new ln()) {
      const r2 = t2, n2 = this.v0, i2 = this.v1, s2 = this.v2, o2 = this.v3;
      return r2.set(kc(e2, n2.x, i2.x, s2.x, o2.x), kc(e2, n2.y, i2.y, s2.y, o2.y), kc(e2, n2.z, i2.z, s2.z, o2.z)), r2;
    }
    copy(e2) {
      return super.copy(e2), this.v0.copy(e2.v0), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this.v3.copy(e2.v3), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v0 = this.v0.toArray(), e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2.v3 = this.v3.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v0.fromArray(e2.v0), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this.v3.fromArray(e2.v3), this;
    }
  }
  class Bc extends Ac {
    constructor(e2 = new kr(), t2 = new kr()) {
      super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = e2, this.v2 = t2;
    }
    getPoint(e2, t2 = new kr()) {
      const r2 = t2;
      return 1 === e2 ? r2.copy(this.v2) : (r2.copy(this.v2).sub(this.v1), r2.multiplyScalar(e2).add(this.v1)), r2;
    }
    getPointAt(e2, t2) {
      return this.getPoint(e2, t2);
    }
    getTangent(e2, t2) {
      const r2 = t2 || new kr();
      return r2.copy(this.v2).sub(this.v1).normalize(), r2;
    }
    copy(e2) {
      return super.copy(e2), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this;
    }
  }
  class Rc extends Ac {
    constructor(e2 = new ln(), t2 = new ln()) {
      super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = e2, this.v2 = t2;
    }
    getPoint(e2, t2 = new ln()) {
      const r2 = t2;
      return 1 === e2 ? r2.copy(this.v2) : (r2.copy(this.v2).sub(this.v1), r2.multiplyScalar(e2).add(this.v1)), r2;
    }
    getPointAt(e2, t2) {
      return this.getPoint(e2, t2);
    }
    copy(e2) {
      return super.copy(e2), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this;
    }
  }
  class Lc extends Ac {
    constructor(e2 = new kr(), t2 = new kr(), r2 = new kr()) {
      super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = e2, this.v1 = t2, this.v2 = r2;
    }
    getPoint(e2, t2 = new kr()) {
      const r2 = t2, n2 = this.v0, i2 = this.v1, s2 = this.v2;
      return r2.set(Ic(e2, n2.x, i2.x, s2.x), Ic(e2, n2.y, i2.y, s2.y)), r2;
    }
    copy(e2) {
      return super.copy(e2), this.v0.copy(e2.v0), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v0 = this.v0.toArray(), e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v0.fromArray(e2.v0), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this;
    }
  }
  class Oc extends Ac {
    constructor(e2 = new ln(), t2 = new ln(), r2 = new ln()) {
      super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = e2, this.v1 = t2, this.v2 = r2;
    }
    getPoint(e2, t2 = new ln()) {
      const r2 = t2, n2 = this.v0, i2 = this.v1, s2 = this.v2;
      return r2.set(Ic(e2, n2.x, i2.x, s2.x), Ic(e2, n2.y, i2.y, s2.y), Ic(e2, n2.z, i2.z, s2.z)), r2;
    }
    copy(e2) {
      return super.copy(e2), this.v0.copy(e2.v0), this.v1.copy(e2.v1), this.v2.copy(e2.v2), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.v0 = this.v0.toArray(), e2.v1 = this.v1.toArray(), e2.v2 = this.v2.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.v0.fromArray(e2.v0), this.v1.fromArray(e2.v1), this.v2.fromArray(e2.v2), this;
    }
  }
  class Fc extends Ac {
    constructor(e2 = []) {
      super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = e2;
    }
    getPoint(e2, t2 = new kr()) {
      const r2 = t2, n2 = this.points, i2 = (n2.length - 1) * e2, s2 = Math.floor(i2), o2 = i2 - s2, a2 = n2[0 === s2 ? s2 : s2 - 1], l2 = n2[s2], c2 = n2[s2 > n2.length - 2 ? n2.length - 1 : s2 + 1], u2 = n2[s2 > n2.length - 3 ? n2.length - 1 : s2 + 2];
      return r2.set(Tc(o2, a2.x, l2.x, c2.x, u2.x), Tc(o2, a2.y, l2.y, c2.y, u2.y)), r2;
    }
    copy(e2) {
      super.copy(e2), this.points = [];
      for (let t2 = 0, r2 = e2.points.length; t2 < r2; t2++) {
        const r3 = e2.points[t2];
        this.points.push(r3.clone());
      }
      return this;
    }
    toJSON() {
      const e2 = super.toJSON();
      e2.points = [];
      for (let t2 = 0, r2 = this.points.length; t2 < r2; t2++) {
        const r3 = this.points[t2];
        e2.points.push(r3.toArray());
      }
      return e2;
    }
    fromJSON(e2) {
      super.fromJSON(e2), this.points = [];
      for (let t2 = 0, r2 = e2.points.length; t2 < r2; t2++) {
        const r3 = e2.points[t2];
        this.points.push(new kr().fromArray(r3));
      }
      return this;
    }
  }
  var Uc = Object.freeze({ __proto__: null, ArcCurve: yc, CatmullRomCurve3: Mc, CubicBezierCurve: Dc, CubicBezierCurve3: Pc, EllipseCurve: bc, LineCurve: Bc, LineCurve3: Rc, QuadraticBezierCurve: Lc, QuadraticBezierCurve3: Oc, SplineCurve: Fc });
  class Nc extends Ac {
    constructor() {
      super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
    }
    add(e2) {
      this.curves.push(e2);
    }
    closePath() {
      const e2 = this.curves[0].getPoint(0), t2 = this.curves[this.curves.length - 1].getPoint(1);
      e2.equals(t2) || this.curves.push(new Bc(t2, e2));
    }
    getPoint(e2, t2) {
      const r2 = e2 * this.getLength(), n2 = this.getCurveLengths();
      let i2 = 0;
      for (; i2 < n2.length; ) {
        if (n2[i2] >= r2) {
          const e3 = n2[i2] - r2, s2 = this.curves[i2], o2 = s2.getLength(), a2 = 0 === o2 ? 0 : 1 - e3 / o2;
          return s2.getPointAt(a2, t2);
        }
        i2++;
      }
      return null;
    }
    getLength() {
      const e2 = this.getCurveLengths();
      return e2[e2.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      const e2 = [];
      let t2 = 0;
      for (let r2 = 0, n2 = this.curves.length; r2 < n2; r2++)
        t2 += this.curves[r2].getLength(), e2.push(t2);
      return this.cacheLengths = e2, e2;
    }
    getSpacedPoints(e2 = 40) {
      const t2 = [];
      for (let r2 = 0; r2 <= e2; r2++)
        t2.push(this.getPoint(r2 / e2));
      return this.autoClose && t2.push(t2[0]), t2;
    }
    getPoints(e2 = 12) {
      const t2 = [];
      let r2;
      for (let n2 = 0, i2 = this.curves; n2 < i2.length; n2++) {
        const s2 = i2[n2], o2 = s2.isEllipseCurve ? 2 * e2 : s2.isLineCurve || s2.isLineCurve3 ? 1 : s2.isSplineCurve ? e2 * s2.points.length : e2, a2 = s2.getPoints(o2);
        for (let e3 = 0; e3 < a2.length; e3++) {
          const n3 = a2[e3];
          r2 && r2.equals(n3) || (t2.push(n3), r2 = n3);
        }
      }
      return this.autoClose && t2.length > 1 && !t2[t2.length - 1].equals(t2[0]) && t2.push(t2[0]), t2;
    }
    copy(e2) {
      super.copy(e2), this.curves = [];
      for (let t2 = 0, r2 = e2.curves.length; t2 < r2; t2++) {
        const r3 = e2.curves[t2];
        this.curves.push(r3.clone());
      }
      return this.autoClose = e2.autoClose, this;
    }
    toJSON() {
      const e2 = super.toJSON();
      e2.autoClose = this.autoClose, e2.curves = [];
      for (let t2 = 0, r2 = this.curves.length; t2 < r2; t2++) {
        const r3 = this.curves[t2];
        e2.curves.push(r3.toJSON());
      }
      return e2;
    }
    fromJSON(e2) {
      super.fromJSON(e2), this.autoClose = e2.autoClose, this.curves = [];
      for (let t2 = 0, r2 = e2.curves.length; t2 < r2; t2++) {
        const r3 = e2.curves[t2];
        this.curves.push(new Uc[r3.type]().fromJSON(r3));
      }
      return this;
    }
  }
  class jc extends Nc {
    constructor(e2) {
      super(), this.type = "Path", this.currentPoint = new kr(), e2 && this.setFromPoints(e2);
    }
    setFromPoints(e2) {
      this.moveTo(e2[0].x, e2[0].y);
      for (let t2 = 1, r2 = e2.length; t2 < r2; t2++)
        this.lineTo(e2[t2].x, e2[t2].y);
      return this;
    }
    moveTo(e2, t2) {
      return this.currentPoint.set(e2, t2), this;
    }
    lineTo(e2, t2) {
      const r2 = new Bc(this.currentPoint.clone(), new kr(e2, t2));
      return this.curves.push(r2), this.currentPoint.set(e2, t2), this;
    }
    quadraticCurveTo(e2, t2, r2, n2) {
      const i2 = new Lc(this.currentPoint.clone(), new kr(e2, t2), new kr(r2, n2));
      return this.curves.push(i2), this.currentPoint.set(r2, n2), this;
    }
    bezierCurveTo(e2, t2, r2, n2, i2, s2) {
      const o2 = new Dc(this.currentPoint.clone(), new kr(e2, t2), new kr(r2, n2), new kr(i2, s2));
      return this.curves.push(o2), this.currentPoint.set(i2, s2), this;
    }
    splineThru(e2) {
      const t2 = [this.currentPoint.clone()].concat(e2), r2 = new Fc(t2);
      return this.curves.push(r2), this.currentPoint.copy(e2[e2.length - 1]), this;
    }
    arc(e2, t2, r2, n2, i2, s2) {
      const o2 = this.currentPoint.x, a2 = this.currentPoint.y;
      return this.absarc(e2 + o2, t2 + a2, r2, n2, i2, s2), this;
    }
    absarc(e2, t2, r2, n2, i2, s2) {
      return this.absellipse(e2, t2, r2, r2, n2, i2, s2), this;
    }
    ellipse(e2, t2, r2, n2, i2, s2, o2, a2) {
      const l2 = this.currentPoint.x, c2 = this.currentPoint.y;
      return this.absellipse(e2 + l2, t2 + c2, r2, n2, i2, s2, o2, a2), this;
    }
    absellipse(e2, t2, r2, n2, i2, s2, o2, a2) {
      const l2 = new bc(e2, t2, r2, n2, i2, s2, o2, a2);
      if (this.curves.length > 0) {
        const e3 = l2.getPoint(0);
        e3.equals(this.currentPoint) || this.lineTo(e3.x, e3.y);
      }
      this.curves.push(l2);
      const c2 = l2.getPoint(1);
      return this.currentPoint.copy(c2), this;
    }
    copy(e2) {
      return super.copy(e2), this.currentPoint.copy(e2.currentPoint), this;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.currentPoint = this.currentPoint.toArray(), e2;
    }
    fromJSON(e2) {
      return super.fromJSON(e2), this.currentPoint.fromArray(e2.currentPoint), this;
    }
  }
  class zc extends Hi {
    constructor(e2 = [new kr(0, -0.5), new kr(0.5, 0), new kr(0, 0.5)], t2 = 12, r2 = 0, n2 = 2 * Math.PI) {
      super(), this.type = "LatheGeometry", this.parameters = { points: e2, segments: t2, phiStart: r2, phiLength: n2 }, t2 = Math.floor(t2), n2 = yr(n2, 0, 2 * Math.PI);
      const i2 = [], s2 = [], o2 = [], a2 = [], l2 = [], c2 = 1 / t2, u2 = new ln(), h2 = new kr(), p2 = new ln(), d2 = new ln(), f2 = new ln();
      let m2 = 0, _2 = 0;
      for (let t3 = 0; t3 <= e2.length - 1; t3++)
        switch (t3) {
          case 0:
            m2 = e2[t3 + 1].x - e2[t3].x, _2 = e2[t3 + 1].y - e2[t3].y, p2.x = 1 * _2, p2.y = -m2, p2.z = 0 * _2, f2.copy(p2), p2.normalize(), a2.push(p2.x, p2.y, p2.z);
            break;
          case e2.length - 1:
            a2.push(f2.x, f2.y, f2.z);
            break;
          default:
            m2 = e2[t3 + 1].x - e2[t3].x, _2 = e2[t3 + 1].y - e2[t3].y, p2.x = 1 * _2, p2.y = -m2, p2.z = 0 * _2, d2.copy(p2), p2.x += f2.x, p2.y += f2.y, p2.z += f2.z, p2.normalize(), a2.push(p2.x, p2.y, p2.z), f2.copy(d2);
        }
      for (let i3 = 0; i3 <= t2; i3++) {
        const p3 = r2 + i3 * c2 * n2, d3 = Math.sin(p3), f3 = Math.cos(p3);
        for (let r3 = 0; r3 <= e2.length - 1; r3++) {
          u2.x = e2[r3].x * d3, u2.y = e2[r3].y, u2.z = e2[r3].x * f3, s2.push(u2.x, u2.y, u2.z), h2.x = i3 / t2, h2.y = r3 / (e2.length - 1), o2.push(h2.x, h2.y);
          const n3 = a2[3 * r3 + 0] * d3, c3 = a2[3 * r3 + 1], p4 = a2[3 * r3 + 0] * f3;
          l2.push(n3, c3, p4);
        }
      }
      for (let r3 = 0; r3 < t2; r3++)
        for (let t3 = 0; t3 < e2.length - 1; t3++) {
          const n3 = t3 + r3 * e2.length, s3 = n3, o3 = n3 + e2.length, a3 = n3 + e2.length + 1, l3 = n3 + 1;
          i2.push(s3, o3, l3), i2.push(a3, l3, o3);
        }
      this.setIndex(i2), this.setAttribute("position", new Oi(s2, 3)), this.setAttribute("uv", new Oi(o2, 2)), this.setAttribute("normal", new Oi(l2, 3));
    }
    static fromJSON(e2) {
      return new zc(e2.points, e2.segments, e2.phiStart, e2.phiLength);
    }
  }
  class Gc extends zc {
    constructor(e2 = 1, t2 = 1, r2 = 4, n2 = 8) {
      const i2 = new jc();
      i2.absarc(0, -t2 / 2, e2, 1.5 * Math.PI, 0), i2.absarc(0, t2 / 2, e2, 0, 0.5 * Math.PI), super(i2.getPoints(r2), n2), this.type = "CapsuleGeometry", this.parameters = { radius: e2, height: t2, capSegments: r2, radialSegments: n2 };
    }
    static fromJSON(e2) {
      return new Gc(e2.radius, e2.length, e2.capSegments, e2.radialSegments);
    }
  }
  class Vc extends Hi {
    constructor(e2 = 1, t2 = 8, r2 = 0, n2 = 2 * Math.PI) {
      super(), this.type = "CircleGeometry", this.parameters = { radius: e2, segments: t2, thetaStart: r2, thetaLength: n2 }, t2 = Math.max(3, t2);
      const i2 = [], s2 = [], o2 = [], a2 = [], l2 = new ln(), c2 = new kr();
      s2.push(0, 0, 0), o2.push(0, 0, 1), a2.push(0.5, 0.5);
      for (let i3 = 0, u2 = 3; i3 <= t2; i3++, u2 += 3) {
        const h2 = r2 + i3 / t2 * n2;
        l2.x = e2 * Math.cos(h2), l2.y = e2 * Math.sin(h2), s2.push(l2.x, l2.y, l2.z), o2.push(0, 0, 1), c2.x = (s2[u2] / e2 + 1) / 2, c2.y = (s2[u2 + 1] / e2 + 1) / 2, a2.push(c2.x, c2.y);
      }
      for (let e3 = 1; e3 <= t2; e3++)
        i2.push(e3, e3 + 1, 0);
      this.setIndex(i2), this.setAttribute("position", new Oi(s2, 3)), this.setAttribute("normal", new Oi(o2, 3)), this.setAttribute("uv", new Oi(a2, 2));
    }
    static fromJSON(e2) {
      return new Vc(e2.radius, e2.segments, e2.thetaStart, e2.thetaLength);
    }
  }
  class Qc extends Hi {
    constructor(e2 = 1, t2 = 1, r2 = 1, n2 = 8, i2 = 1, s2 = false, o2 = 0, a2 = 2 * Math.PI) {
      super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e2, radiusBottom: t2, height: r2, radialSegments: n2, heightSegments: i2, openEnded: s2, thetaStart: o2, thetaLength: a2 };
      const l2 = this;
      n2 = Math.floor(n2), i2 = Math.floor(i2);
      const c2 = [], u2 = [], h2 = [], p2 = [];
      let d2 = 0;
      const f2 = [], m2 = r2 / 2;
      let _2 = 0;
      function g2(r3) {
        const i3 = d2, s3 = new kr(), f3 = new ln();
        let g3 = 0;
        const v2 = true === r3 ? e2 : t2, A2 = true === r3 ? 1 : -1;
        for (let e3 = 1; e3 <= n2; e3++)
          u2.push(0, m2 * A2, 0), h2.push(0, A2, 0), p2.push(0.5, 0.5), d2++;
        const b2 = d2;
        for (let e3 = 0; e3 <= n2; e3++) {
          const t3 = e3 / n2 * a2 + o2, r4 = Math.cos(t3), i4 = Math.sin(t3);
          f3.x = v2 * i4, f3.y = m2 * A2, f3.z = v2 * r4, u2.push(f3.x, f3.y, f3.z), h2.push(0, A2, 0), s3.x = 0.5 * r4 + 0.5, s3.y = 0.5 * i4 * A2 + 0.5, p2.push(s3.x, s3.y), d2++;
        }
        for (let e3 = 0; e3 < n2; e3++) {
          const t3 = i3 + e3, n3 = b2 + e3;
          true === r3 ? c2.push(n3, n3 + 1, t3) : c2.push(n3 + 1, n3, t3), g3 += 3;
        }
        l2.addGroup(_2, g3, true === r3 ? 1 : 2), _2 += g3;
      }
      !function() {
        const s3 = new ln(), g3 = new ln();
        let v2 = 0;
        const A2 = (t2 - e2) / r2;
        for (let l3 = 0; l3 <= i2; l3++) {
          const c3 = [], _3 = l3 / i2, v3 = _3 * (t2 - e2) + e2;
          for (let e3 = 0; e3 <= n2; e3++) {
            const t3 = e3 / n2, i3 = t3 * a2 + o2, l4 = Math.sin(i3), f3 = Math.cos(i3);
            g3.x = v3 * l4, g3.y = -_3 * r2 + m2, g3.z = v3 * f3, u2.push(g3.x, g3.y, g3.z), s3.set(l4, A2, f3).normalize(), h2.push(s3.x, s3.y, s3.z), p2.push(t3, 1 - _3), c3.push(d2++);
          }
          f2.push(c3);
        }
        for (let e3 = 0; e3 < n2; e3++)
          for (let t3 = 0; t3 < i2; t3++) {
            const r3 = f2[t3][e3], n3 = f2[t3 + 1][e3], i3 = f2[t3 + 1][e3 + 1], s4 = f2[t3][e3 + 1];
            c2.push(r3, n3, s4), c2.push(n3, i3, s4), v2 += 6;
          }
        l2.addGroup(_2, v2, 0), _2 += v2;
      }(), false === s2 && (e2 > 0 && g2(true), t2 > 0 && g2(false)), this.setIndex(c2), this.setAttribute("position", new Oi(u2, 3)), this.setAttribute("normal", new Oi(h2, 3)), this.setAttribute("uv", new Oi(p2, 2));
    }
    static fromJSON(e2) {
      return new Qc(e2.radiusTop, e2.radiusBottom, e2.height, e2.radialSegments, e2.heightSegments, e2.openEnded, e2.thetaStart, e2.thetaLength);
    }
  }
  class Hc extends Qc {
    constructor(e2 = 1, t2 = 1, r2 = 8, n2 = 1, i2 = false, s2 = 0, o2 = 2 * Math.PI) {
      super(0, e2, t2, r2, n2, i2, s2, o2), this.type = "ConeGeometry", this.parameters = { radius: e2, height: t2, radialSegments: r2, heightSegments: n2, openEnded: i2, thetaStart: s2, thetaLength: o2 };
    }
    static fromJSON(e2) {
      return new Hc(e2.radius, e2.height, e2.radialSegments, e2.heightSegments, e2.openEnded, e2.thetaStart, e2.thetaLength);
    }
  }
  class Wc extends Hi {
    constructor(e2 = [], t2 = [], r2 = 1, n2 = 0) {
      super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e2, indices: t2, radius: r2, detail: n2 };
      const i2 = [], s2 = [];
      function o2(e3, t3, r3, n3) {
        const i3 = n3 + 1, s3 = [];
        for (let n4 = 0; n4 <= i3; n4++) {
          s3[n4] = [];
          const o3 = e3.clone().lerp(r3, n4 / i3), a3 = t3.clone().lerp(r3, n4 / i3), l3 = i3 - n4;
          for (let e4 = 0; e4 <= l3; e4++)
            s3[n4][e4] = 0 === e4 && n4 === i3 ? o3 : o3.clone().lerp(a3, e4 / l3);
        }
        for (let e4 = 0; e4 < i3; e4++)
          for (let t4 = 0; t4 < 2 * (i3 - e4) - 1; t4++) {
            const r4 = Math.floor(t4 / 2);
            t4 % 2 == 0 ? (a2(s3[e4][r4 + 1]), a2(s3[e4 + 1][r4]), a2(s3[e4][r4])) : (a2(s3[e4][r4 + 1]), a2(s3[e4 + 1][r4 + 1]), a2(s3[e4 + 1][r4]));
          }
      }
      function a2(e3) {
        i2.push(e3.x, e3.y, e3.z);
      }
      function l2(t3, r3) {
        const n3 = 3 * t3;
        r3.x = e2[n3 + 0], r3.y = e2[n3 + 1], r3.z = e2[n3 + 2];
      }
      function c2(e3, t3, r3, n3) {
        n3 < 0 && 1 === e3.x && (s2[t3] = e3.x - 1), 0 === r3.x && 0 === r3.z && (s2[t3] = n3 / 2 / Math.PI + 0.5);
      }
      function u2(e3) {
        return Math.atan2(e3.z, -e3.x);
      }
      !function(e3) {
        const r3 = new ln(), n3 = new ln(), i3 = new ln();
        for (let s3 = 0; s3 < t2.length; s3 += 3)
          l2(t2[s3 + 0], r3), l2(t2[s3 + 1], n3), l2(t2[s3 + 2], i3), o2(r3, n3, i3, e3);
      }(n2), function(e3) {
        const t3 = new ln();
        for (let r3 = 0; r3 < i2.length; r3 += 3)
          t3.x = i2[r3 + 0], t3.y = i2[r3 + 1], t3.z = i2[r3 + 2], t3.normalize().multiplyScalar(e3), i2[r3 + 0] = t3.x, i2[r3 + 1] = t3.y, i2[r3 + 2] = t3.z;
      }(r2), function() {
        const e3 = new ln();
        for (let r3 = 0; r3 < i2.length; r3 += 3) {
          e3.x = i2[r3 + 0], e3.y = i2[r3 + 1], e3.z = i2[r3 + 2];
          const n3 = u2(e3) / 2 / Math.PI + 0.5, o3 = (t3 = e3, Math.atan2(-t3.y, Math.sqrt(t3.x * t3.x + t3.z * t3.z)) / Math.PI + 0.5);
          s2.push(n3, 1 - o3);
        }
        var t3;
        (function() {
          const e4 = new ln(), t4 = new ln(), r3 = new ln(), n3 = new ln(), o3 = new kr(), a3 = new kr(), l3 = new kr();
          for (let h2 = 0, p2 = 0; h2 < i2.length; h2 += 9, p2 += 6) {
            e4.set(i2[h2 + 0], i2[h2 + 1], i2[h2 + 2]), t4.set(i2[h2 + 3], i2[h2 + 4], i2[h2 + 5]), r3.set(i2[h2 + 6], i2[h2 + 7], i2[h2 + 8]), o3.set(s2[p2 + 0], s2[p2 + 1]), a3.set(s2[p2 + 2], s2[p2 + 3]), l3.set(s2[p2 + 4], s2[p2 + 5]), n3.copy(e4).add(t4).add(r3).divideScalar(3);
            const d2 = u2(n3);
            c2(o3, p2 + 0, e4, d2), c2(a3, p2 + 2, t4, d2), c2(l3, p2 + 4, r3, d2);
          }
        })(), function() {
          for (let e4 = 0; e4 < s2.length; e4 += 6) {
            const t4 = s2[e4 + 0], r3 = s2[e4 + 2], n3 = s2[e4 + 4], i3 = Math.max(t4, r3, n3), o3 = Math.min(t4, r3, n3);
            i3 > 0.9 && o3 < 0.1 && (t4 < 0.2 && (s2[e4 + 0] += 1), r3 < 0.2 && (s2[e4 + 2] += 1), n3 < 0.2 && (s2[e4 + 4] += 1));
          }
        }();
      }(), this.setAttribute("position", new Oi(i2, 3)), this.setAttribute("normal", new Oi(i2.slice(), 3)), this.setAttribute("uv", new Oi(s2, 2)), 0 === n2 ? this.computeVertexNormals() : this.normalizeNormals();
    }
    static fromJSON(e2) {
      return new Wc(e2.vertices, e2.indices, e2.radius, e2.details);
    }
  }
  class qc extends Wc {
    constructor(e2 = 1, t2 = 0) {
      const r2 = (1 + Math.sqrt(5)) / 2, n2 = 1 / r2;
      super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n2, -r2, 0, -n2, r2, 0, n2, -r2, 0, n2, r2, -n2, -r2, 0, -n2, r2, 0, n2, -r2, 0, n2, r2, 0, -r2, 0, -n2, r2, 0, -n2, -r2, 0, n2, r2, 0, n2], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e2, t2), this.type = "DodecahedronGeometry", this.parameters = { radius: e2, detail: t2 };
    }
    static fromJSON(e2) {
      return new qc(e2.radius, e2.detail);
    }
  }
  const Xc = new ln(), Yc = new ln(), Kc = new ln(), Jc = new yi();
  class Zc extends Hi {
    constructor(e2 = null, t2 = 1) {
      if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e2, thresholdAngle: t2 }, null !== e2) {
        const r2 = 4, n2 = Math.pow(10, r2), i2 = Math.cos(vr * t2), s2 = e2.getIndex(), o2 = e2.getAttribute("position"), a2 = s2 ? s2.count : o2.count, l2 = [0, 0, 0], c2 = ["a", "b", "c"], u2 = new Array(3), h2 = {}, p2 = [];
        for (let e3 = 0; e3 < a2; e3 += 3) {
          s2 ? (l2[0] = s2.getX(e3), l2[1] = s2.getX(e3 + 1), l2[2] = s2.getX(e3 + 2)) : (l2[0] = e3, l2[1] = e3 + 1, l2[2] = e3 + 2);
          const { a: t3, b: r3, c: a3 } = Jc;
          if (t3.fromBufferAttribute(o2, l2[0]), r3.fromBufferAttribute(o2, l2[1]), a3.fromBufferAttribute(o2, l2[2]), Jc.getNormal(Kc), u2[0] = `${Math.round(t3.x * n2)},${Math.round(t3.y * n2)},${Math.round(t3.z * n2)}`, u2[1] = `${Math.round(r3.x * n2)},${Math.round(r3.y * n2)},${Math.round(r3.z * n2)}`, u2[2] = `${Math.round(a3.x * n2)},${Math.round(a3.y * n2)},${Math.round(a3.z * n2)}`, u2[0] !== u2[1] && u2[1] !== u2[2] && u2[2] !== u2[0])
            for (let e4 = 0; e4 < 3; e4++) {
              const t4 = (e4 + 1) % 3, r4 = u2[e4], n3 = u2[t4], s3 = Jc[c2[e4]], o3 = Jc[c2[t4]], a4 = `${r4}_${n3}`, d2 = `${n3}_${r4}`;
              d2 in h2 && h2[d2] ? (Kc.dot(h2[d2].normal) <= i2 && (p2.push(s3.x, s3.y, s3.z), p2.push(o3.x, o3.y, o3.z)), h2[d2] = null) : a4 in h2 || (h2[a4] = { index0: l2[e4], index1: l2[t4], normal: Kc.clone() });
            }
        }
        for (const e3 in h2)
          if (h2[e3]) {
            const { index0: t3, index1: r3 } = h2[e3];
            Xc.fromBufferAttribute(o2, t3), Yc.fromBufferAttribute(o2, r3), p2.push(Xc.x, Xc.y, Xc.z), p2.push(Yc.x, Yc.y, Yc.z);
          }
        this.setAttribute("position", new Oi(p2, 3));
      }
    }
  }
  class $c extends jc {
    constructor(e2) {
      super(e2), this.uuid = br(), this.type = "Shape", this.holes = [];
    }
    getPointsHoles(e2) {
      const t2 = [];
      for (let r2 = 0, n2 = this.holes.length; r2 < n2; r2++)
        t2[r2] = this.holes[r2].getPoints(e2);
      return t2;
    }
    extractPoints(e2) {
      return { shape: this.getPoints(e2), holes: this.getPointsHoles(e2) };
    }
    copy(e2) {
      super.copy(e2), this.holes = [];
      for (let t2 = 0, r2 = e2.holes.length; t2 < r2; t2++) {
        const r3 = e2.holes[t2];
        this.holes.push(r3.clone());
      }
      return this;
    }
    toJSON() {
      const e2 = super.toJSON();
      e2.uuid = this.uuid, e2.holes = [];
      for (let t2 = 0, r2 = this.holes.length; t2 < r2; t2++) {
        const r3 = this.holes[t2];
        e2.holes.push(r3.toJSON());
      }
      return e2;
    }
    fromJSON(e2) {
      super.fromJSON(e2), this.uuid = e2.uuid, this.holes = [];
      for (let t2 = 0, r2 = e2.holes.length; t2 < r2; t2++) {
        const r3 = e2.holes[t2];
        this.holes.push(new jc().fromJSON(r3));
      }
      return this;
    }
  }
  function eu(e2, t2, r2, n2, i2) {
    let s2, o2;
    if (i2 === function(e3, t3, r3, n3) {
      let i3 = 0;
      for (let s3 = t3, o3 = r3 - n3; s3 < r3; s3 += n3)
        i3 += (e3[o3] - e3[s3]) * (e3[s3 + 1] + e3[o3 + 1]), o3 = s3;
      return i3;
    }(e2, t2, r2, n2) > 0)
      for (s2 = t2; s2 < r2; s2 += n2)
        o2 = yu(s2, e2[s2], e2[s2 + 1], o2);
    else
      for (s2 = r2 - n2; s2 >= t2; s2 -= n2)
        o2 = yu(s2, e2[s2], e2[s2 + 1], o2);
    return o2 && mu(o2, o2.next) && (xu(o2), o2 = o2.next), o2;
  }
  function tu(e2, t2) {
    if (!e2)
      return e2;
    t2 || (t2 = e2);
    let r2, n2 = e2;
    do {
      if (r2 = false, n2.steiner || !mu(n2, n2.next) && 0 !== fu(n2.prev, n2, n2.next))
        n2 = n2.next;
      else {
        if (xu(n2), n2 = t2 = n2.prev, n2 === n2.next)
          break;
        r2 = true;
      }
    } while (r2 || n2 !== t2);
    return t2;
  }
  function ru(e2, t2, r2, n2, i2, s2, o2) {
    if (!e2)
      return;
    !o2 && s2 && function(e3, t3, r3, n3) {
      let i3 = e3;
      do {
        null === i3.z && (i3.z = uu(i3.x, i3.y, t3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
      } while (i3 !== e3);
      i3.prevZ.nextZ = null, i3.prevZ = null, function(e4) {
        let t4, r4, n4, i4, s3, o3, a3, l3, c3 = 1;
        do {
          for (r4 = e4, e4 = null, s3 = null, o3 = 0; r4; ) {
            for (o3++, n4 = r4, a3 = 0, t4 = 0; t4 < c3 && (a3++, n4 = n4.nextZ, n4); t4++)
              ;
            for (l3 = c3; a3 > 0 || l3 > 0 && n4; )
              0 !== a3 && (0 === l3 || !n4 || r4.z <= n4.z) ? (i4 = r4, r4 = r4.nextZ, a3--) : (i4 = n4, n4 = n4.nextZ, l3--), s3 ? s3.nextZ = i4 : e4 = i4, i4.prevZ = s3, s3 = i4;
            r4 = n4;
          }
          s3.nextZ = null, c3 *= 2;
        } while (o3 > 1);
      }(i3);
    }(e2, n2, i2, s2);
    let a2, l2, c2 = e2;
    for (; e2.prev !== e2.next; )
      if (a2 = e2.prev, l2 = e2.next, s2 ? iu(e2, n2, i2, s2) : nu(e2))
        t2.push(a2.i / r2), t2.push(e2.i / r2), t2.push(l2.i / r2), xu(e2), e2 = l2.next, c2 = l2.next;
      else if ((e2 = l2) === c2) {
        o2 ? 1 === o2 ? ru(e2 = su(tu(e2), t2, r2), t2, r2, n2, i2, s2, 2) : 2 === o2 && ou(e2, t2, r2, n2, i2, s2) : ru(tu(e2), t2, r2, n2, i2, s2, 1);
        break;
      }
  }
  function nu(e2) {
    const t2 = e2.prev, r2 = e2, n2 = e2.next;
    if (fu(t2, r2, n2) >= 0)
      return false;
    let i2 = e2.next.next;
    for (; i2 !== e2.prev; ) {
      if (pu(t2.x, t2.y, r2.x, r2.y, n2.x, n2.y, i2.x, i2.y) && fu(i2.prev, i2, i2.next) >= 0)
        return false;
      i2 = i2.next;
    }
    return true;
  }
  function iu(e2, t2, r2, n2) {
    const i2 = e2.prev, s2 = e2, o2 = e2.next;
    if (fu(i2, s2, o2) >= 0)
      return false;
    const a2 = i2.x < s2.x ? i2.x < o2.x ? i2.x : o2.x : s2.x < o2.x ? s2.x : o2.x, l2 = i2.y < s2.y ? i2.y < o2.y ? i2.y : o2.y : s2.y < o2.y ? s2.y : o2.y, c2 = i2.x > s2.x ? i2.x > o2.x ? i2.x : o2.x : s2.x > o2.x ? s2.x : o2.x, u2 = i2.y > s2.y ? i2.y > o2.y ? i2.y : o2.y : s2.y > o2.y ? s2.y : o2.y, h2 = uu(a2, l2, t2, r2, n2), p2 = uu(c2, u2, t2, r2, n2);
    let d2 = e2.prevZ, f2 = e2.nextZ;
    for (; d2 && d2.z >= h2 && f2 && f2.z <= p2; ) {
      if (d2 !== e2.prev && d2 !== e2.next && pu(i2.x, i2.y, s2.x, s2.y, o2.x, o2.y, d2.x, d2.y) && fu(d2.prev, d2, d2.next) >= 0)
        return false;
      if (d2 = d2.prevZ, f2 !== e2.prev && f2 !== e2.next && pu(i2.x, i2.y, s2.x, s2.y, o2.x, o2.y, f2.x, f2.y) && fu(f2.prev, f2, f2.next) >= 0)
        return false;
      f2 = f2.nextZ;
    }
    for (; d2 && d2.z >= h2; ) {
      if (d2 !== e2.prev && d2 !== e2.next && pu(i2.x, i2.y, s2.x, s2.y, o2.x, o2.y, d2.x, d2.y) && fu(d2.prev, d2, d2.next) >= 0)
        return false;
      d2 = d2.prevZ;
    }
    for (; f2 && f2.z <= p2; ) {
      if (f2 !== e2.prev && f2 !== e2.next && pu(i2.x, i2.y, s2.x, s2.y, o2.x, o2.y, f2.x, f2.y) && fu(f2.prev, f2, f2.next) >= 0)
        return false;
      f2 = f2.nextZ;
    }
    return true;
  }
  function su(e2, t2, r2) {
    let n2 = e2;
    do {
      const i2 = n2.prev, s2 = n2.next.next;
      !mu(i2, s2) && _u(i2, n2, n2.next, s2) && Au(i2, s2) && Au(s2, i2) && (t2.push(i2.i / r2), t2.push(n2.i / r2), t2.push(s2.i / r2), xu(n2), xu(n2.next), n2 = e2 = s2), n2 = n2.next;
    } while (n2 !== e2);
    return tu(n2);
  }
  function ou(e2, t2, r2, n2, i2, s2) {
    let o2 = e2;
    do {
      let e3 = o2.next.next;
      for (; e3 !== o2.prev; ) {
        if (o2.i !== e3.i && du(o2, e3)) {
          let a2 = bu(o2, e3);
          return o2 = tu(o2, o2.next), a2 = tu(a2, a2.next), ru(o2, t2, r2, n2, i2, s2), void ru(a2, t2, r2, n2, i2, s2);
        }
        e3 = e3.next;
      }
      o2 = o2.next;
    } while (o2 !== e2);
  }
  function au(e2, t2) {
    return e2.x - t2.x;
  }
  function lu(e2, t2) {
    if (t2 = function(e3, t3) {
      let r2 = t3;
      const n2 = e3.x, i2 = e3.y;
      let s2, o2 = -1 / 0;
      do {
        if (i2 <= r2.y && i2 >= r2.next.y && r2.next.y !== r2.y) {
          const e4 = r2.x + (i2 - r2.y) * (r2.next.x - r2.x) / (r2.next.y - r2.y);
          if (e4 <= n2 && e4 > o2) {
            if (o2 = e4, e4 === n2) {
              if (i2 === r2.y)
                return r2;
              if (i2 === r2.next.y)
                return r2.next;
            }
            s2 = r2.x < r2.next.x ? r2 : r2.next;
          }
        }
        r2 = r2.next;
      } while (r2 !== t3);
      if (!s2)
        return null;
      if (n2 === o2)
        return s2;
      const a2 = s2, l2 = s2.x, c2 = s2.y;
      let u2, h2 = 1 / 0;
      r2 = s2;
      do {
        n2 >= r2.x && r2.x >= l2 && n2 !== r2.x && pu(i2 < c2 ? n2 : o2, i2, l2, c2, i2 < c2 ? o2 : n2, i2, r2.x, r2.y) && (u2 = Math.abs(i2 - r2.y) / (n2 - r2.x), Au(r2, e3) && (u2 < h2 || u2 === h2 && (r2.x > s2.x || r2.x === s2.x && cu(s2, r2))) && (s2 = r2, h2 = u2)), r2 = r2.next;
      } while (r2 !== a2);
      return s2;
    }(e2, t2), t2) {
      const r2 = bu(t2, e2);
      tu(t2, t2.next), tu(r2, r2.next);
    }
  }
  function cu(e2, t2) {
    return fu(e2.prev, e2, t2.prev) < 0 && fu(t2.next, e2, e2.next) < 0;
  }
  function uu(e2, t2, r2, n2, i2) {
    return (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - r2) * i2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) | (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - n2) * i2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) << 1;
  }
  function hu(e2) {
    let t2 = e2, r2 = e2;
    do {
      (t2.x < r2.x || t2.x === r2.x && t2.y < r2.y) && (r2 = t2), t2 = t2.next;
    } while (t2 !== e2);
    return r2;
  }
  function pu(e2, t2, r2, n2, i2, s2, o2, a2) {
    return (i2 - o2) * (t2 - a2) - (e2 - o2) * (s2 - a2) >= 0 && (e2 - o2) * (n2 - a2) - (r2 - o2) * (t2 - a2) >= 0 && (r2 - o2) * (s2 - a2) - (i2 - o2) * (n2 - a2) >= 0;
  }
  function du(e2, t2) {
    return e2.next.i !== t2.i && e2.prev.i !== t2.i && !function(e3, t3) {
      let r2 = e3;
      do {
        if (r2.i !== e3.i && r2.next.i !== e3.i && r2.i !== t3.i && r2.next.i !== t3.i && _u(r2, r2.next, e3, t3))
          return true;
        r2 = r2.next;
      } while (r2 !== e3);
      return false;
    }(e2, t2) && (Au(e2, t2) && Au(t2, e2) && function(e3, t3) {
      let r2 = e3, n2 = false;
      const i2 = (e3.x + t3.x) / 2, s2 = (e3.y + t3.y) / 2;
      do {
        r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
      } while (r2 !== e3);
      return n2;
    }(e2, t2) && (fu(e2.prev, e2, t2.prev) || fu(e2, t2.prev, t2)) || mu(e2, t2) && fu(e2.prev, e2, e2.next) > 0 && fu(t2.prev, t2, t2.next) > 0);
  }
  function fu(e2, t2, r2) {
    return (t2.y - e2.y) * (r2.x - t2.x) - (t2.x - e2.x) * (r2.y - t2.y);
  }
  function mu(e2, t2) {
    return e2.x === t2.x && e2.y === t2.y;
  }
  function _u(e2, t2, r2, n2) {
    const i2 = vu(fu(e2, t2, r2)), s2 = vu(fu(e2, t2, n2)), o2 = vu(fu(r2, n2, e2)), a2 = vu(fu(r2, n2, t2));
    return i2 !== s2 && o2 !== a2 || !(0 !== i2 || !gu(e2, r2, t2)) || !(0 !== s2 || !gu(e2, n2, t2)) || !(0 !== o2 || !gu(r2, e2, n2)) || !(0 !== a2 || !gu(r2, t2, n2));
  }
  function gu(e2, t2, r2) {
    return t2.x <= Math.max(e2.x, r2.x) && t2.x >= Math.min(e2.x, r2.x) && t2.y <= Math.max(e2.y, r2.y) && t2.y >= Math.min(e2.y, r2.y);
  }
  function vu(e2) {
    return e2 > 0 ? 1 : e2 < 0 ? -1 : 0;
  }
  function Au(e2, t2) {
    return fu(e2.prev, e2, e2.next) < 0 ? fu(e2, t2, e2.next) >= 0 && fu(e2, e2.prev, t2) >= 0 : fu(e2, t2, e2.prev) < 0 || fu(e2, e2.next, t2) < 0;
  }
  function bu(e2, t2) {
    const r2 = new wu(e2.i, e2.x, e2.y), n2 = new wu(t2.i, t2.x, t2.y), i2 = e2.next, s2 = t2.prev;
    return e2.next = t2, t2.prev = e2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
  }
  function yu(e2, t2, r2, n2) {
    const i2 = new wu(e2, t2, r2);
    return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
  }
  function xu(e2) {
    e2.next.prev = e2.prev, e2.prev.next = e2.next, e2.prevZ && (e2.prevZ.nextZ = e2.nextZ), e2.nextZ && (e2.nextZ.prevZ = e2.prevZ);
  }
  function wu(e2, t2, r2) {
    this.i = e2, this.x = t2, this.y = r2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  class Eu {
    static area(e2) {
      const t2 = e2.length;
      let r2 = 0;
      for (let n2 = t2 - 1, i2 = 0; i2 < t2; n2 = i2++)
        r2 += e2[n2].x * e2[i2].y - e2[i2].x * e2[n2].y;
      return 0.5 * r2;
    }
    static isClockWise(e2) {
      return Eu.area(e2) < 0;
    }
    static triangulateShape(e2, t2) {
      const r2 = [], n2 = [], i2 = [];
      Su(e2), Cu(r2, e2);
      let s2 = e2.length;
      t2.forEach(Su);
      for (let e3 = 0; e3 < t2.length; e3++)
        n2.push(s2), s2 += t2[e3].length, Cu(r2, t2[e3]);
      const o2 = function(e3, t3, r3 = 2) {
        const n3 = t3 && t3.length, i3 = n3 ? t3[0] * r3 : e3.length;
        let s3 = eu(e3, 0, i3, r3, true);
        const o3 = [];
        if (!s3 || s3.next === s3.prev)
          return o3;
        let a2, l2, c2, u2, h2, p2, d2;
        if (n3 && (s3 = function(e4, t4, r4, n4) {
          const i4 = [];
          let s4, o4, a3, l3, c3;
          for (s4 = 0, o4 = t4.length; s4 < o4; s4++)
            a3 = t4[s4] * n4, l3 = s4 < o4 - 1 ? t4[s4 + 1] * n4 : e4.length, c3 = eu(e4, a3, l3, n4, false), c3 === c3.next && (c3.steiner = true), i4.push(hu(c3));
          for (i4.sort(au), s4 = 0; s4 < i4.length; s4++)
            lu(i4[s4], r4), r4 = tu(r4, r4.next);
          return r4;
        }(e3, t3, s3, r3)), e3.length > 80 * r3) {
          a2 = c2 = e3[0], l2 = u2 = e3[1];
          for (let t4 = r3; t4 < i3; t4 += r3)
            h2 = e3[t4], p2 = e3[t4 + 1], h2 < a2 && (a2 = h2), p2 < l2 && (l2 = p2), h2 > c2 && (c2 = h2), p2 > u2 && (u2 = p2);
          d2 = Math.max(c2 - a2, u2 - l2), d2 = 0 !== d2 ? 1 / d2 : 0;
        }
        return ru(s3, o3, r3, a2, l2, d2), o3;
      }(r2, n2);
      for (let e3 = 0; e3 < o2.length; e3 += 3)
        i2.push(o2.slice(e3, e3 + 3));
      return i2;
    }
  }
  function Su(e2) {
    const t2 = e2.length;
    t2 > 2 && e2[t2 - 1].equals(e2[0]) && e2.pop();
  }
  function Cu(e2, t2) {
    for (let r2 = 0; r2 < t2.length; r2++)
      e2.push(t2[r2].x), e2.push(t2[r2].y);
  }
  class Mu extends Hi {
    constructor(e2 = new $c([new kr(0.5, 0.5), new kr(-0.5, 0.5), new kr(-0.5, -0.5), new kr(0.5, -0.5)]), t2 = {}) {
      super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e2, options: t2 }, e2 = Array.isArray(e2) ? e2 : [e2];
      const r2 = this, n2 = [], i2 = [];
      for (let t3 = 0, r3 = e2.length; t3 < r3; t3++)
        s2(e2[t3]);
      function s2(e3) {
        const s3 = [], o2 = void 0 !== t2.curveSegments ? t2.curveSegments : 12, a2 = void 0 !== t2.steps ? t2.steps : 1, l2 = void 0 !== t2.depth ? t2.depth : 1;
        let c2 = void 0 === t2.bevelEnabled || t2.bevelEnabled, u2 = void 0 !== t2.bevelThickness ? t2.bevelThickness : 0.2, h2 = void 0 !== t2.bevelSize ? t2.bevelSize : u2 - 0.1, p2 = void 0 !== t2.bevelOffset ? t2.bevelOffset : 0, d2 = void 0 !== t2.bevelSegments ? t2.bevelSegments : 3;
        const f2 = t2.extrudePath, m2 = void 0 !== t2.UVGenerator ? t2.UVGenerator : Tu;
        let _2, g2, v2, A2, b2, y2 = false;
        f2 && (_2 = f2.getSpacedPoints(a2), y2 = true, c2 = false, g2 = f2.computeFrenetFrames(a2, false), v2 = new ln(), A2 = new ln(), b2 = new ln()), c2 || (d2 = 0, u2 = 0, h2 = 0, p2 = 0);
        const x2 = e3.extractPoints(o2);
        let w2 = x2.shape;
        const E2 = x2.holes;
        if (!Eu.isClockWise(w2)) {
          w2 = w2.reverse();
          for (let e4 = 0, t3 = E2.length; e4 < t3; e4++) {
            const t4 = E2[e4];
            Eu.isClockWise(t4) && (E2[e4] = t4.reverse());
          }
        }
        const S2 = Eu.triangulateShape(w2, E2), C2 = w2;
        for (let e4 = 0, t3 = E2.length; e4 < t3; e4++) {
          const t4 = E2[e4];
          w2 = w2.concat(t4);
        }
        function M2(e4, t3, r3) {
          return t3 || console.error("THREE.ExtrudeGeometry: vec does not exist"), t3.clone().multiplyScalar(r3).add(e4);
        }
        const T2 = w2.length, I2 = S2.length;
        function k2(e4, t3, r3) {
          let n3, i3, s4;
          const o3 = e4.x - t3.x, a3 = e4.y - t3.y, l3 = r3.x - e4.x, c3 = r3.y - e4.y, u3 = o3 * o3 + a3 * a3, h3 = o3 * c3 - a3 * l3;
          if (Math.abs(h3) > Number.EPSILON) {
            const h4 = Math.sqrt(u3), p3 = Math.sqrt(l3 * l3 + c3 * c3), d3 = t3.x - a3 / h4, f3 = t3.y + o3 / h4, m3 = ((r3.x - c3 / p3 - d3) * c3 - (r3.y + l3 / p3 - f3) * l3) / (o3 * c3 - a3 * l3);
            n3 = d3 + o3 * m3 - e4.x, i3 = f3 + a3 * m3 - e4.y;
            const _3 = n3 * n3 + i3 * i3;
            if (_3 <= 2)
              return new kr(n3, i3);
            s4 = Math.sqrt(_3 / 2);
          } else {
            let e5 = false;
            o3 > Number.EPSILON ? l3 > Number.EPSILON && (e5 = true) : o3 < -Number.EPSILON ? l3 < -Number.EPSILON && (e5 = true) : Math.sign(a3) === Math.sign(c3) && (e5 = true), e5 ? (n3 = -a3, i3 = o3, s4 = Math.sqrt(u3)) : (n3 = o3, i3 = a3, s4 = Math.sqrt(u3 / 2));
          }
          return new kr(n3 / s4, i3 / s4);
        }
        const D2 = [];
        for (let e4 = 0, t3 = C2.length, r3 = t3 - 1, n3 = e4 + 1; e4 < t3; e4++, r3++, n3++)
          r3 === t3 && (r3 = 0), n3 === t3 && (n3 = 0), D2[e4] = k2(C2[e4], C2[r3], C2[n3]);
        const P2 = [];
        let B2, R2 = D2.concat();
        for (let e4 = 0, t3 = E2.length; e4 < t3; e4++) {
          const t4 = E2[e4];
          B2 = [];
          for (let e5 = 0, r3 = t4.length, n3 = r3 - 1, i3 = e5 + 1; e5 < r3; e5++, n3++, i3++)
            n3 === r3 && (n3 = 0), i3 === r3 && (i3 = 0), B2[e5] = k2(t4[e5], t4[n3], t4[i3]);
          P2.push(B2), R2 = R2.concat(B2);
        }
        for (let e4 = 0; e4 < d2; e4++) {
          const t3 = e4 / d2, r3 = u2 * Math.cos(t3 * Math.PI / 2), n3 = h2 * Math.sin(t3 * Math.PI / 2) + p2;
          for (let e5 = 0, t4 = C2.length; e5 < t4; e5++) {
            const t5 = M2(C2[e5], D2[e5], n3);
            F2(t5.x, t5.y, -r3);
          }
          for (let e5 = 0, t4 = E2.length; e5 < t4; e5++) {
            const t5 = E2[e5];
            B2 = P2[e5];
            for (let e6 = 0, i3 = t5.length; e6 < i3; e6++) {
              const i4 = M2(t5[e6], B2[e6], n3);
              F2(i4.x, i4.y, -r3);
            }
          }
        }
        const L2 = h2 + p2;
        for (let e4 = 0; e4 < T2; e4++) {
          const t3 = c2 ? M2(w2[e4], R2[e4], L2) : w2[e4];
          y2 ? (A2.copy(g2.normals[0]).multiplyScalar(t3.x), v2.copy(g2.binormals[0]).multiplyScalar(t3.y), b2.copy(_2[0]).add(A2).add(v2), F2(b2.x, b2.y, b2.z)) : F2(t3.x, t3.y, 0);
        }
        for (let e4 = 1; e4 <= a2; e4++)
          for (let t3 = 0; t3 < T2; t3++) {
            const r3 = c2 ? M2(w2[t3], R2[t3], L2) : w2[t3];
            y2 ? (A2.copy(g2.normals[e4]).multiplyScalar(r3.x), v2.copy(g2.binormals[e4]).multiplyScalar(r3.y), b2.copy(_2[e4]).add(A2).add(v2), F2(b2.x, b2.y, b2.z)) : F2(r3.x, r3.y, l2 / a2 * e4);
          }
        for (let e4 = d2 - 1; e4 >= 0; e4--) {
          const t3 = e4 / d2, r3 = u2 * Math.cos(t3 * Math.PI / 2), n3 = h2 * Math.sin(t3 * Math.PI / 2) + p2;
          for (let e5 = 0, t4 = C2.length; e5 < t4; e5++) {
            const t5 = M2(C2[e5], D2[e5], n3);
            F2(t5.x, t5.y, l2 + r3);
          }
          for (let e5 = 0, t4 = E2.length; e5 < t4; e5++) {
            const t5 = E2[e5];
            B2 = P2[e5];
            for (let e6 = 0, i3 = t5.length; e6 < i3; e6++) {
              const i4 = M2(t5[e6], B2[e6], n3);
              y2 ? F2(i4.x, i4.y + _2[a2 - 1].y, _2[a2 - 1].x + r3) : F2(i4.x, i4.y, l2 + r3);
            }
          }
        }
        function O2(e4, t3) {
          let r3 = e4.length;
          for (; --r3 >= 0; ) {
            const n3 = r3;
            let i3 = r3 - 1;
            i3 < 0 && (i3 = e4.length - 1);
            for (let e5 = 0, r4 = a2 + 2 * d2; e5 < r4; e5++) {
              const r5 = T2 * e5, s4 = T2 * (e5 + 1);
              N2(t3 + n3 + r5, t3 + i3 + r5, t3 + i3 + s4, t3 + n3 + s4);
            }
          }
        }
        function F2(e4, t3, r3) {
          s3.push(e4), s3.push(t3), s3.push(r3);
        }
        function U2(e4, t3, i3) {
          j2(e4), j2(t3), j2(i3);
          const s4 = n2.length / 3, o3 = m2.generateTopUV(r2, n2, s4 - 3, s4 - 2, s4 - 1);
          z2(o3[0]), z2(o3[1]), z2(o3[2]);
        }
        function N2(e4, t3, i3, s4) {
          j2(e4), j2(t3), j2(s4), j2(t3), j2(i3), j2(s4);
          const o3 = n2.length / 3, a3 = m2.generateSideWallUV(r2, n2, o3 - 6, o3 - 3, o3 - 2, o3 - 1);
          z2(a3[0]), z2(a3[1]), z2(a3[3]), z2(a3[1]), z2(a3[2]), z2(a3[3]);
        }
        function j2(e4) {
          n2.push(s3[3 * e4 + 0]), n2.push(s3[3 * e4 + 1]), n2.push(s3[3 * e4 + 2]);
        }
        function z2(e4) {
          i2.push(e4.x), i2.push(e4.y);
        }
        !function() {
          const e4 = n2.length / 3;
          if (c2) {
            let e5 = 0, t3 = T2 * e5;
            for (let e6 = 0; e6 < I2; e6++) {
              const r3 = S2[e6];
              U2(r3[2] + t3, r3[1] + t3, r3[0] + t3);
            }
            e5 = a2 + 2 * d2, t3 = T2 * e5;
            for (let e6 = 0; e6 < I2; e6++) {
              const r3 = S2[e6];
              U2(r3[0] + t3, r3[1] + t3, r3[2] + t3);
            }
          } else {
            for (let e5 = 0; e5 < I2; e5++) {
              const t3 = S2[e5];
              U2(t3[2], t3[1], t3[0]);
            }
            for (let e5 = 0; e5 < I2; e5++) {
              const t3 = S2[e5];
              U2(t3[0] + T2 * a2, t3[1] + T2 * a2, t3[2] + T2 * a2);
            }
          }
          r2.addGroup(e4, n2.length / 3 - e4, 0);
        }(), function() {
          const e4 = n2.length / 3;
          let t3 = 0;
          O2(C2, t3), t3 += C2.length;
          for (let e5 = 0, r3 = E2.length; e5 < r3; e5++) {
            const r4 = E2[e5];
            O2(r4, t3), t3 += r4.length;
          }
          r2.addGroup(e4, n2.length / 3 - e4, 1);
        }();
      }
      this.setAttribute("position", new Oi(n2, 3)), this.setAttribute("uv", new Oi(i2, 2)), this.computeVertexNormals();
    }
    toJSON() {
      const e2 = super.toJSON();
      return function(e3, t2, r2) {
        if (r2.shapes = [], Array.isArray(e3))
          for (let t3 = 0, n2 = e3.length; t3 < n2; t3++) {
            const n3 = e3[t3];
            r2.shapes.push(n3.uuid);
          }
        else
          r2.shapes.push(e3.uuid);
        return r2.options = Object.assign({}, t2), void 0 !== t2.extrudePath && (r2.options.extrudePath = t2.extrudePath.toJSON()), r2;
      }(this.parameters.shapes, this.parameters.options, e2);
    }
    static fromJSON(e2, t2) {
      const r2 = [];
      for (let n3 = 0, i2 = e2.shapes.length; n3 < i2; n3++) {
        const i3 = t2[e2.shapes[n3]];
        r2.push(i3);
      }
      const n2 = e2.options.extrudePath;
      return void 0 !== n2 && (e2.options.extrudePath = new Uc[n2.type]().fromJSON(n2)), new Mu(r2, e2.options);
    }
  }
  const Tu = { generateTopUV: function(e2, t2, r2, n2, i2) {
    const s2 = t2[3 * r2], o2 = t2[3 * r2 + 1], a2 = t2[3 * n2], l2 = t2[3 * n2 + 1], c2 = t2[3 * i2], u2 = t2[3 * i2 + 1];
    return [new kr(s2, o2), new kr(a2, l2), new kr(c2, u2)];
  }, generateSideWallUV: function(e2, t2, r2, n2, i2, s2) {
    const o2 = t2[3 * r2], a2 = t2[3 * r2 + 1], l2 = t2[3 * r2 + 2], c2 = t2[3 * n2], u2 = t2[3 * n2 + 1], h2 = t2[3 * n2 + 2], p2 = t2[3 * i2], d2 = t2[3 * i2 + 1], f2 = t2[3 * i2 + 2], m2 = t2[3 * s2], _2 = t2[3 * s2 + 1], g2 = t2[3 * s2 + 2];
    return Math.abs(a2 - u2) < Math.abs(o2 - c2) ? [new kr(o2, 1 - l2), new kr(c2, 1 - h2), new kr(p2, 1 - f2), new kr(m2, 1 - g2)] : [new kr(a2, 1 - l2), new kr(u2, 1 - h2), new kr(d2, 1 - f2), new kr(_2, 1 - g2)];
  } };
  class Iu extends Wc {
    constructor(e2 = 1, t2 = 0) {
      const r2 = (1 + Math.sqrt(5)) / 2;
      super([-1, r2, 0, 1, r2, 0, -1, -r2, 0, 1, -r2, 0, 0, -1, r2, 0, 1, r2, 0, -1, -r2, 0, 1, -r2, r2, 0, -1, r2, 0, 1, -r2, 0, -1, -r2, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e2, t2), this.type = "IcosahedronGeometry", this.parameters = { radius: e2, detail: t2 };
    }
    static fromJSON(e2) {
      return new Iu(e2.radius, e2.detail);
    }
  }
  class ku extends Wc {
    constructor(e2 = 1, t2 = 0) {
      super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e2, t2), this.type = "OctahedronGeometry", this.parameters = { radius: e2, detail: t2 };
    }
    static fromJSON(e2) {
      return new ku(e2.radius, e2.detail);
    }
  }
  class Du extends Hi {
    constructor(e2 = 0.5, t2 = 1, r2 = 8, n2 = 1, i2 = 0, s2 = 2 * Math.PI) {
      super(), this.type = "RingGeometry", this.parameters = { innerRadius: e2, outerRadius: t2, thetaSegments: r2, phiSegments: n2, thetaStart: i2, thetaLength: s2 }, r2 = Math.max(3, r2);
      const o2 = [], a2 = [], l2 = [], c2 = [];
      let u2 = e2;
      const h2 = (t2 - e2) / (n2 = Math.max(1, n2)), p2 = new ln(), d2 = new kr();
      for (let e3 = 0; e3 <= n2; e3++) {
        for (let e4 = 0; e4 <= r2; e4++) {
          const n3 = i2 + e4 / r2 * s2;
          p2.x = u2 * Math.cos(n3), p2.y = u2 * Math.sin(n3), a2.push(p2.x, p2.y, p2.z), l2.push(0, 0, 1), d2.x = (p2.x / t2 + 1) / 2, d2.y = (p2.y / t2 + 1) / 2, c2.push(d2.x, d2.y);
        }
        u2 += h2;
      }
      for (let e3 = 0; e3 < n2; e3++) {
        const t3 = e3 * (r2 + 1);
        for (let e4 = 0; e4 < r2; e4++) {
          const n3 = e4 + t3, i3 = n3, s3 = n3 + r2 + 1, a3 = n3 + r2 + 2, l3 = n3 + 1;
          o2.push(i3, s3, l3), o2.push(s3, a3, l3);
        }
      }
      this.setIndex(o2), this.setAttribute("position", new Oi(a2, 3)), this.setAttribute("normal", new Oi(l2, 3)), this.setAttribute("uv", new Oi(c2, 2));
    }
    static fromJSON(e2) {
      return new Du(e2.innerRadius, e2.outerRadius, e2.thetaSegments, e2.phiSegments, e2.thetaStart, e2.thetaLength);
    }
  }
  class Pu extends Hi {
    constructor(e2 = new $c([new kr(0, 0.5), new kr(-0.5, -0.5), new kr(0.5, -0.5)]), t2 = 12) {
      super(), this.type = "ShapeGeometry", this.parameters = { shapes: e2, curveSegments: t2 };
      const r2 = [], n2 = [], i2 = [], s2 = [];
      let o2 = 0, a2 = 0;
      if (false === Array.isArray(e2))
        l2(e2);
      else
        for (let t3 = 0; t3 < e2.length; t3++)
          l2(e2[t3]), this.addGroup(o2, a2, t3), o2 += a2, a2 = 0;
      function l2(e3) {
        const o3 = n2.length / 3, l3 = e3.extractPoints(t2);
        let c2 = l3.shape;
        const u2 = l3.holes;
        false === Eu.isClockWise(c2) && (c2 = c2.reverse());
        for (let e4 = 0, t3 = u2.length; e4 < t3; e4++) {
          const t4 = u2[e4];
          true === Eu.isClockWise(t4) && (u2[e4] = t4.reverse());
        }
        const h2 = Eu.triangulateShape(c2, u2);
        for (let e4 = 0, t3 = u2.length; e4 < t3; e4++) {
          const t4 = u2[e4];
          c2 = c2.concat(t4);
        }
        for (let e4 = 0, t3 = c2.length; e4 < t3; e4++) {
          const t4 = c2[e4];
          n2.push(t4.x, t4.y, 0), i2.push(0, 0, 1), s2.push(t4.x, t4.y);
        }
        for (let e4 = 0, t3 = h2.length; e4 < t3; e4++) {
          const t4 = h2[e4], n3 = t4[0] + o3, i3 = t4[1] + o3, s3 = t4[2] + o3;
          r2.push(n3, i3, s3), a2 += 3;
        }
      }
      this.setIndex(r2), this.setAttribute("position", new Oi(n2, 3)), this.setAttribute("normal", new Oi(i2, 3)), this.setAttribute("uv", new Oi(s2, 2));
    }
    toJSON() {
      const e2 = super.toJSON();
      return function(e3, t2) {
        if (t2.shapes = [], Array.isArray(e3))
          for (let r2 = 0, n2 = e3.length; r2 < n2; r2++) {
            const n3 = e3[r2];
            t2.shapes.push(n3.uuid);
          }
        else
          t2.shapes.push(e3.uuid);
        return t2;
      }(this.parameters.shapes, e2);
    }
    static fromJSON(e2, t2) {
      const r2 = [];
      for (let n2 = 0, i2 = e2.shapes.length; n2 < i2; n2++) {
        const i3 = t2[e2.shapes[n2]];
        r2.push(i3);
      }
      return new Pu(r2, e2.curveSegments);
    }
  }
  class Bu extends Hi {
    constructor(e2 = 1, t2 = 32, r2 = 16, n2 = 0, i2 = 2 * Math.PI, s2 = 0, o2 = Math.PI) {
      super(), this.type = "SphereGeometry", this.parameters = { radius: e2, widthSegments: t2, heightSegments: r2, phiStart: n2, phiLength: i2, thetaStart: s2, thetaLength: o2 }, t2 = Math.max(3, Math.floor(t2)), r2 = Math.max(2, Math.floor(r2));
      const a2 = Math.min(s2 + o2, Math.PI);
      let l2 = 0;
      const c2 = [], u2 = new ln(), h2 = new ln(), p2 = [], d2 = [], f2 = [], m2 = [];
      for (let p3 = 0; p3 <= r2; p3++) {
        const _2 = [], g2 = p3 / r2;
        let v2 = 0;
        0 == p3 && 0 == s2 ? v2 = 0.5 / t2 : p3 == r2 && a2 == Math.PI && (v2 = -0.5 / t2);
        for (let r3 = 0; r3 <= t2; r3++) {
          const a3 = r3 / t2;
          u2.x = -e2 * Math.cos(n2 + a3 * i2) * Math.sin(s2 + g2 * o2), u2.y = e2 * Math.cos(s2 + g2 * o2), u2.z = e2 * Math.sin(n2 + a3 * i2) * Math.sin(s2 + g2 * o2), d2.push(u2.x, u2.y, u2.z), h2.copy(u2).normalize(), f2.push(h2.x, h2.y, h2.z), m2.push(a3 + v2, 1 - g2), _2.push(l2++);
        }
        c2.push(_2);
      }
      for (let e3 = 0; e3 < r2; e3++)
        for (let n3 = 0; n3 < t2; n3++) {
          const t3 = c2[e3][n3 + 1], i3 = c2[e3][n3], o3 = c2[e3 + 1][n3], l3 = c2[e3 + 1][n3 + 1];
          (0 !== e3 || s2 > 0) && p2.push(t3, i3, l3), (e3 !== r2 - 1 || a2 < Math.PI) && p2.push(i3, o3, l3);
        }
      this.setIndex(p2), this.setAttribute("position", new Oi(d2, 3)), this.setAttribute("normal", new Oi(f2, 3)), this.setAttribute("uv", new Oi(m2, 2));
    }
    static fromJSON(e2) {
      return new Bu(e2.radius, e2.widthSegments, e2.heightSegments, e2.phiStart, e2.phiLength, e2.thetaStart, e2.thetaLength);
    }
  }
  class Ru extends Wc {
    constructor(e2 = 1, t2 = 0) {
      super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e2, t2), this.type = "TetrahedronGeometry", this.parameters = { radius: e2, detail: t2 };
    }
    static fromJSON(e2) {
      return new Ru(e2.radius, e2.detail);
    }
  }
  class Lu extends Hi {
    constructor(e2 = 1, t2 = 0.4, r2 = 8, n2 = 6, i2 = 2 * Math.PI) {
      super(), this.type = "TorusGeometry", this.parameters = { radius: e2, tube: t2, radialSegments: r2, tubularSegments: n2, arc: i2 }, r2 = Math.floor(r2), n2 = Math.floor(n2);
      const s2 = [], o2 = [], a2 = [], l2 = [], c2 = new ln(), u2 = new ln(), h2 = new ln();
      for (let s3 = 0; s3 <= r2; s3++)
        for (let p2 = 0; p2 <= n2; p2++) {
          const d2 = p2 / n2 * i2, f2 = s3 / r2 * Math.PI * 2;
          u2.x = (e2 + t2 * Math.cos(f2)) * Math.cos(d2), u2.y = (e2 + t2 * Math.cos(f2)) * Math.sin(d2), u2.z = t2 * Math.sin(f2), o2.push(u2.x, u2.y, u2.z), c2.x = e2 * Math.cos(d2), c2.y = e2 * Math.sin(d2), h2.subVectors(u2, c2).normalize(), a2.push(h2.x, h2.y, h2.z), l2.push(p2 / n2), l2.push(s3 / r2);
        }
      for (let e3 = 1; e3 <= r2; e3++)
        for (let t3 = 1; t3 <= n2; t3++) {
          const r3 = (n2 + 1) * e3 + t3 - 1, i3 = (n2 + 1) * (e3 - 1) + t3 - 1, o3 = (n2 + 1) * (e3 - 1) + t3, a3 = (n2 + 1) * e3 + t3;
          s2.push(r3, i3, a3), s2.push(i3, o3, a3);
        }
      this.setIndex(s2), this.setAttribute("position", new Oi(o2, 3)), this.setAttribute("normal", new Oi(a2, 3)), this.setAttribute("uv", new Oi(l2, 2));
    }
    static fromJSON(e2) {
      return new Lu(e2.radius, e2.tube, e2.radialSegments, e2.tubularSegments, e2.arc);
    }
  }
  class Ou extends Hi {
    constructor(e2 = 1, t2 = 0.4, r2 = 64, n2 = 8, i2 = 2, s2 = 3) {
      super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e2, tube: t2, tubularSegments: r2, radialSegments: n2, p: i2, q: s2 }, r2 = Math.floor(r2), n2 = Math.floor(n2);
      const o2 = [], a2 = [], l2 = [], c2 = [], u2 = new ln(), h2 = new ln(), p2 = new ln(), d2 = new ln(), f2 = new ln(), m2 = new ln(), _2 = new ln();
      for (let o3 = 0; o3 <= r2; ++o3) {
        const v2 = o3 / r2 * i2 * Math.PI * 2;
        g2(v2, i2, s2, e2, p2), g2(v2 + 0.01, i2, s2, e2, d2), m2.subVectors(d2, p2), _2.addVectors(d2, p2), f2.crossVectors(m2, _2), _2.crossVectors(f2, m2), f2.normalize(), _2.normalize();
        for (let e3 = 0; e3 <= n2; ++e3) {
          const i3 = e3 / n2 * Math.PI * 2, s3 = -t2 * Math.cos(i3), d3 = t2 * Math.sin(i3);
          u2.x = p2.x + (s3 * _2.x + d3 * f2.x), u2.y = p2.y + (s3 * _2.y + d3 * f2.y), u2.z = p2.z + (s3 * _2.z + d3 * f2.z), a2.push(u2.x, u2.y, u2.z), h2.subVectors(u2, p2).normalize(), l2.push(h2.x, h2.y, h2.z), c2.push(o3 / r2), c2.push(e3 / n2);
        }
      }
      for (let e3 = 1; e3 <= r2; e3++)
        for (let t3 = 1; t3 <= n2; t3++) {
          const r3 = (n2 + 1) * (e3 - 1) + (t3 - 1), i3 = (n2 + 1) * e3 + (t3 - 1), s3 = (n2 + 1) * e3 + t3, a3 = (n2 + 1) * (e3 - 1) + t3;
          o2.push(r3, i3, a3), o2.push(i3, s3, a3);
        }
      function g2(e3, t3, r3, n3, i3) {
        const s3 = Math.cos(e3), o3 = Math.sin(e3), a3 = r3 / t3 * e3, l3 = Math.cos(a3);
        i3.x = n3 * (2 + l3) * 0.5 * s3, i3.y = n3 * (2 + l3) * o3 * 0.5, i3.z = n3 * Math.sin(a3) * 0.5;
      }
      this.setIndex(o2), this.setAttribute("position", new Oi(a2, 3)), this.setAttribute("normal", new Oi(l2, 3)), this.setAttribute("uv", new Oi(c2, 2));
    }
    static fromJSON(e2) {
      return new Ou(e2.radius, e2.tube, e2.tubularSegments, e2.radialSegments, e2.p, e2.q);
    }
  }
  class Fu extends Hi {
    constructor(e2 = new Oc(new ln(-1, -1, 0), new ln(-1, 1, 0), new ln(1, 1, 0)), t2 = 64, r2 = 1, n2 = 8, i2 = false) {
      super(), this.type = "TubeGeometry", this.parameters = { path: e2, tubularSegments: t2, radius: r2, radialSegments: n2, closed: i2 };
      const s2 = e2.computeFrenetFrames(t2, i2);
      this.tangents = s2.tangents, this.normals = s2.normals, this.binormals = s2.binormals;
      const o2 = new ln(), a2 = new ln(), l2 = new kr();
      let c2 = new ln();
      const u2 = [], h2 = [], p2 = [], d2 = [];
      function f2(i3) {
        c2 = e2.getPointAt(i3 / t2, c2);
        const l3 = s2.normals[i3], p3 = s2.binormals[i3];
        for (let e3 = 0; e3 <= n2; e3++) {
          const t3 = e3 / n2 * Math.PI * 2, i4 = Math.sin(t3), s3 = -Math.cos(t3);
          a2.x = s3 * l3.x + i4 * p3.x, a2.y = s3 * l3.y + i4 * p3.y, a2.z = s3 * l3.z + i4 * p3.z, a2.normalize(), h2.push(a2.x, a2.y, a2.z), o2.x = c2.x + r2 * a2.x, o2.y = c2.y + r2 * a2.y, o2.z = c2.z + r2 * a2.z, u2.push(o2.x, o2.y, o2.z);
        }
      }
      !function() {
        for (let e3 = 0; e3 < t2; e3++)
          f2(e3);
        f2(false === i2 ? t2 : 0), function() {
          for (let e3 = 0; e3 <= t2; e3++)
            for (let r3 = 0; r3 <= n2; r3++)
              l2.x = e3 / t2, l2.y = r3 / n2, p2.push(l2.x, l2.y);
        }(), function() {
          for (let e3 = 1; e3 <= t2; e3++)
            for (let t3 = 1; t3 <= n2; t3++) {
              const r3 = (n2 + 1) * (e3 - 1) + (t3 - 1), i3 = (n2 + 1) * e3 + (t3 - 1), s3 = (n2 + 1) * e3 + t3, o3 = (n2 + 1) * (e3 - 1) + t3;
              d2.push(r3, i3, o3), d2.push(i3, s3, o3);
            }
        }();
      }(), this.setIndex(d2), this.setAttribute("position", new Oi(u2, 3)), this.setAttribute("normal", new Oi(h2, 3)), this.setAttribute("uv", new Oi(p2, 2));
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.path = this.parameters.path.toJSON(), e2;
    }
    static fromJSON(e2) {
      return new Fu(new Uc[e2.path.type]().fromJSON(e2.path), e2.tubularSegments, e2.radius, e2.radialSegments, e2.closed);
    }
  }
  class Uu extends Hi {
    constructor(e2 = null) {
      if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e2 }, null !== e2) {
        const t2 = [], r2 = /* @__PURE__ */ new Set(), n2 = new ln(), i2 = new ln();
        if (null !== e2.index) {
          const s2 = e2.attributes.position, o2 = e2.index;
          let a2 = e2.groups;
          0 === a2.length && (a2 = [{ start: 0, count: o2.count, materialIndex: 0 }]);
          for (let e3 = 0, l2 = a2.length; e3 < l2; ++e3) {
            const l3 = a2[e3], c2 = l3.start;
            for (let e4 = c2, a3 = c2 + l3.count; e4 < a3; e4 += 3)
              for (let a4 = 0; a4 < 3; a4++) {
                const l4 = o2.getX(e4 + a4), c3 = o2.getX(e4 + (a4 + 1) % 3);
                n2.fromBufferAttribute(s2, l4), i2.fromBufferAttribute(s2, c3), true === Nu(n2, i2, r2) && (t2.push(n2.x, n2.y, n2.z), t2.push(i2.x, i2.y, i2.z));
              }
          }
        } else {
          const s2 = e2.attributes.position;
          for (let e3 = 0, o2 = s2.count / 3; e3 < o2; e3++)
            for (let o3 = 0; o3 < 3; o3++) {
              const a2 = 3 * e3 + o3, l2 = 3 * e3 + (o3 + 1) % 3;
              n2.fromBufferAttribute(s2, a2), i2.fromBufferAttribute(s2, l2), true === Nu(n2, i2, r2) && (t2.push(n2.x, n2.y, n2.z), t2.push(i2.x, i2.y, i2.z));
            }
        }
        this.setAttribute("position", new Oi(t2, 3));
      }
    }
  }
  function Nu(e2, t2, r2) {
    const n2 = `${e2.x},${e2.y},${e2.z}-${t2.x},${t2.y},${t2.z}`, i2 = `${t2.x},${t2.y},${t2.z}-${e2.x},${e2.y},${e2.z}`;
    return true !== r2.has(n2) && true !== r2.has(i2) && (r2.add(n2), r2.add(i2), true);
  }
  var ju = Object.freeze({ __proto__: null, BoxGeometry: hs, CapsuleGeometry: Gc, CircleGeometry: Vc, ConeGeometry: Hc, CylinderGeometry: Qc, DodecahedronGeometry: qc, EdgesGeometry: Zc, ExtrudeGeometry: Mu, IcosahedronGeometry: Iu, LatheGeometry: zc, OctahedronGeometry: ku, PlaneGeometry: Ds, PolyhedronGeometry: Wc, RingGeometry: Du, ShapeGeometry: Pu, SphereGeometry: Bu, TetrahedronGeometry: Ru, TorusGeometry: Lu, TorusKnotGeometry: Ou, TubeGeometry: Fu, WireframeGeometry: Uu });
  class zu extends wi {
    constructor(e2) {
      super(), this.isShadowMaterial = true, this.type = "ShadowMaterial", this.color = new Wr(0), this.transparent = true, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.fog = e2.fog, this;
    }
  }
  class Gu extends ms {
    constructor(e2) {
      super(e2), this.isRawShaderMaterial = true, this.type = "RawShaderMaterial";
    }
  }
  class Vu extends wi {
    constructor(e2) {
      super(), this.isMeshStandardMaterial = true, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Wr(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Wr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ot, this.normalScale = new kr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.defines = { STANDARD: "" }, this.color.copy(e2.color), this.roughness = e2.roughness, this.metalness = e2.metalness, this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.roughnessMap = e2.roughnessMap, this.metalnessMap = e2.metalnessMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.envMapIntensity = e2.envMapIntensity, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.flatShading = e2.flatShading, this.fog = e2.fog, this;
    }
  }
  class Qu extends Vu {
    constructor(e2) {
      super(), this.isMeshPhysicalMaterial = true, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new kr(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
        return yr(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      }, set: function(e3) {
        this.ior = (1 + 0.4 * e3) / (1 - 0.4 * e3);
      } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Wr(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Wr(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Wr(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e2);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(e2) {
      this._sheen > 0 != e2 > 0 && this.version++, this._sheen = e2;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(e2) {
      this._clearcoat > 0 != e2 > 0 && this.version++, this._clearcoat = e2;
    }
    get iridescence() {
      return this._iridescence;
    }
    set iridescence(e2) {
      this._iridescence > 0 != e2 > 0 && this.version++, this._iridescence = e2;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(e2) {
      this._transmission > 0 != e2 > 0 && this.version++, this._transmission = e2;
    }
    copy(e2) {
      return super.copy(e2), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e2.clearcoat, this.clearcoatMap = e2.clearcoatMap, this.clearcoatRoughness = e2.clearcoatRoughness, this.clearcoatRoughnessMap = e2.clearcoatRoughnessMap, this.clearcoatNormalMap = e2.clearcoatNormalMap, this.clearcoatNormalScale.copy(e2.clearcoatNormalScale), this.ior = e2.ior, this.iridescence = e2.iridescence, this.iridescenceMap = e2.iridescenceMap, this.iridescenceIOR = e2.iridescenceIOR, this.iridescenceThicknessRange = [...e2.iridescenceThicknessRange], this.iridescenceThicknessMap = e2.iridescenceThicknessMap, this.sheen = e2.sheen, this.sheenColor.copy(e2.sheenColor), this.sheenColorMap = e2.sheenColorMap, this.sheenRoughness = e2.sheenRoughness, this.sheenRoughnessMap = e2.sheenRoughnessMap, this.transmission = e2.transmission, this.transmissionMap = e2.transmissionMap, this.thickness = e2.thickness, this.thicknessMap = e2.thicknessMap, this.attenuationDistance = e2.attenuationDistance, this.attenuationColor.copy(e2.attenuationColor), this.specularIntensity = e2.specularIntensity, this.specularIntensityMap = e2.specularIntensityMap, this.specularColor.copy(e2.specularColor), this.specularColorMap = e2.specularColorMap, this;
    }
  }
  class Hu extends wi {
    constructor(e2) {
      super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new Wr(16777215), this.specular = new Wr(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Wr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ot, this.normalScale = new kr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = q, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.specular.copy(e2.specular), this.shininess = e2.shininess, this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.specularMap = e2.specularMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.combine = e2.combine, this.reflectivity = e2.reflectivity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.flatShading = e2.flatShading, this.fog = e2.fog, this;
    }
  }
  class Wu extends wi {
    constructor(e2) {
      super(), this.isMeshToonMaterial = true, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Wr(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Wr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ot, this.normalScale = new kr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.gradientMap = e2.gradientMap, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.alphaMap = e2.alphaMap, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.fog = e2.fog, this;
    }
  }
  class qu extends wi {
    constructor(e2) {
      super(), this.isMeshNormalMaterial = true, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ot, this.normalScale = new kr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.flatShading = false, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.flatShading = e2.flatShading, this;
    }
  }
  class Xu extends wi {
    constructor(e2) {
      super(), this.isMeshLambertMaterial = true, this.type = "MeshLambertMaterial", this.color = new Wr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Wr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ot, this.normalScale = new kr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = q, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.specularMap = e2.specularMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.combine = e2.combine, this.reflectivity = e2.reflectivity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.flatShading = e2.flatShading, this.fog = e2.fog, this;
    }
  }
  class Yu extends wi {
    constructor(e2) {
      super(), this.isMeshMatcapMaterial = true, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Wr(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ot, this.normalScale = new kr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.fog = true, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.defines = { MATCAP: "" }, this.color.copy(e2.color), this.matcap = e2.matcap, this.map = e2.map, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.alphaMap = e2.alphaMap, this.flatShading = e2.flatShading, this.fog = e2.fog, this;
    }
  }
  class Ku extends Jl {
    constructor(e2) {
      super(), this.isLineDashedMaterial = true, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.scale = e2.scale, this.dashSize = e2.dashSize, this.gapSize = e2.gapSize, this;
    }
  }
  function Ju(e2, t2, r2) {
    return $u(e2) ? new e2.constructor(e2.subarray(t2, void 0 !== r2 ? r2 : e2.length)) : e2.slice(t2, r2);
  }
  function Zu(e2, t2, r2) {
    return !e2 || !r2 && e2.constructor === t2 ? e2 : "number" == typeof t2.BYTES_PER_ELEMENT ? new t2(e2) : Array.prototype.slice.call(e2);
  }
  function $u(e2) {
    return ArrayBuffer.isView(e2) && !(e2 instanceof DataView);
  }
  function eh(e2) {
    const t2 = e2.length, r2 = new Array(t2);
    for (let e3 = 0; e3 !== t2; ++e3)
      r2[e3] = e3;
    return r2.sort(function(t3, r3) {
      return e2[t3] - e2[r3];
    }), r2;
  }
  function th(e2, t2, r2) {
    const n2 = e2.length, i2 = new e2.constructor(n2);
    for (let s2 = 0, o2 = 0; o2 !== n2; ++s2) {
      const n3 = r2[s2] * t2;
      for (let r3 = 0; r3 !== t2; ++r3)
        i2[o2++] = e2[n3 + r3];
    }
    return i2;
  }
  function rh(e2, t2, r2, n2) {
    let i2 = 1, s2 = e2[0];
    for (; void 0 !== s2 && void 0 === s2[n2]; )
      s2 = e2[i2++];
    if (void 0 === s2)
      return;
    let o2 = s2[n2];
    if (void 0 !== o2)
      if (Array.isArray(o2))
        do {
          o2 = s2[n2], void 0 !== o2 && (t2.push(s2.time), r2.push.apply(r2, o2)), s2 = e2[i2++];
        } while (void 0 !== s2);
      else if (void 0 !== o2.toArray)
        do {
          o2 = s2[n2], void 0 !== o2 && (t2.push(s2.time), o2.toArray(r2, r2.length)), s2 = e2[i2++];
        } while (void 0 !== s2);
      else
        do {
          o2 = s2[n2], void 0 !== o2 && (t2.push(s2.time), r2.push(o2)), s2 = e2[i2++];
        } while (void 0 !== s2);
  }
  var nh = Object.freeze({ __proto__: null, arraySlice: Ju, convertArray: Zu, isTypedArray: $u, getKeyframeOrder: eh, sortedArray: th, flattenJSON: rh, subclip: function(e2, t2, r2, n2, i2 = 30) {
    const s2 = e2.clone();
    s2.name = t2;
    const o2 = [];
    for (let e3 = 0; e3 < s2.tracks.length; ++e3) {
      const t3 = s2.tracks[e3], a3 = t3.getValueSize(), l2 = [], c2 = [];
      for (let e4 = 0; e4 < t3.times.length; ++e4) {
        const s3 = t3.times[e4] * i2;
        if (!(s3 < r2 || s3 >= n2)) {
          l2.push(t3.times[e4]);
          for (let r3 = 0; r3 < a3; ++r3)
            c2.push(t3.values[e4 * a3 + r3]);
        }
      }
      0 !== l2.length && (t3.times = Zu(l2, t3.times.constructor), t3.values = Zu(c2, t3.values.constructor), o2.push(t3));
    }
    s2.tracks = o2;
    let a2 = 1 / 0;
    for (let e3 = 0; e3 < s2.tracks.length; ++e3)
      a2 > s2.tracks[e3].times[0] && (a2 = s2.tracks[e3].times[0]);
    for (let e3 = 0; e3 < s2.tracks.length; ++e3)
      s2.tracks[e3].shift(-1 * a2);
    return s2.resetDuration(), s2;
  }, makeClipAdditive: function(e2, t2 = 0, r2 = e2, n2 = 30) {
    n2 <= 0 && (n2 = 30);
    const i2 = r2.tracks.length, s2 = t2 / n2;
    for (let t3 = 0; t3 < i2; ++t3) {
      const n3 = r2.tracks[t3], i3 = n3.ValueTypeName;
      if ("bool" === i3 || "string" === i3)
        continue;
      const o2 = e2.tracks.find(function(e3) {
        return e3.name === n3.name && e3.ValueTypeName === i3;
      });
      if (void 0 === o2)
        continue;
      let a2 = 0;
      const l2 = n3.getValueSize();
      n3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a2 = l2 / 3);
      let c2 = 0;
      const u2 = o2.getValueSize();
      o2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c2 = u2 / 3);
      const h2 = n3.times.length - 1;
      let p2;
      if (s2 <= n3.times[0]) {
        const e3 = a2, t4 = l2 - a2;
        p2 = Ju(n3.values, e3, t4);
      } else if (s2 >= n3.times[h2]) {
        const e3 = h2 * l2 + a2, t4 = e3 + l2 - a2;
        p2 = Ju(n3.values, e3, t4);
      } else {
        const e3 = n3.createInterpolant(), t4 = a2, r3 = l2 - a2;
        e3.evaluate(s2), p2 = Ju(e3.resultBuffer, t4, r3);
      }
      "quaternion" === i3 && new an().fromArray(p2).normalize().conjugate().toArray(p2);
      const d2 = o2.times.length;
      for (let e3 = 0; e3 < d2; ++e3) {
        const t4 = e3 * u2 + c2;
        if ("quaternion" === i3)
          an.multiplyQuaternionsFlat(o2.values, t4, p2, 0, o2.values, t4);
        else {
          const e4 = u2 - 2 * c2;
          for (let r3 = 0; r3 < e4; ++r3)
            o2.values[t4 + r3] -= p2[r3];
        }
      }
    }
    return e2.blendMode = Ct, e2;
  } });
  class ih {
    constructor(e2, t2, r2, n2) {
      this.parameterPositions = e2, this._cachedIndex = 0, this.resultBuffer = void 0 !== n2 ? n2 : new t2.constructor(r2), this.sampleValues = t2, this.valueSize = r2, this.settings = null, this.DefaultSettings_ = {};
    }
    evaluate(e2) {
      const t2 = this.parameterPositions;
      let r2 = this._cachedIndex, n2 = t2[r2], i2 = t2[r2 - 1];
      e: {
        t: {
          let s2;
          r: {
            n:
              if (!(e2 < n2)) {
                for (let s3 = r2 + 2; ; ) {
                  if (void 0 === n2) {
                    if (e2 < i2)
                      break n;
                    return r2 = t2.length, this._cachedIndex = r2, this.copySampleValue_(r2 - 1);
                  }
                  if (r2 === s3)
                    break;
                  if (i2 = n2, n2 = t2[++r2], e2 < n2)
                    break t;
                }
                s2 = t2.length;
                break r;
              }
            if (e2 >= i2)
              break e;
            {
              const o2 = t2[1];
              e2 < o2 && (r2 = 2, i2 = o2);
              for (let s3 = r2 - 2; ; ) {
                if (void 0 === i2)
                  return this._cachedIndex = 0, this.copySampleValue_(0);
                if (r2 === s3)
                  break;
                if (n2 = i2, i2 = t2[--r2 - 1], e2 >= i2)
                  break t;
              }
              s2 = r2, r2 = 0;
            }
          }
          for (; r2 < s2; ) {
            const n3 = r2 + s2 >>> 1;
            e2 < t2[n3] ? s2 = n3 : r2 = n3 + 1;
          }
          if (n2 = t2[r2], i2 = t2[r2 - 1], void 0 === i2)
            return this._cachedIndex = 0, this.copySampleValue_(0);
          if (void 0 === n2)
            return r2 = t2.length, this._cachedIndex = r2, this.copySampleValue_(r2 - 1);
        }
        this._cachedIndex = r2, this.intervalChanged_(r2, i2, n2);
      }
      return this.interpolate_(r2, i2, e2, n2);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(e2) {
      const t2 = this.resultBuffer, r2 = this.sampleValues, n2 = this.valueSize, i2 = e2 * n2;
      for (let e3 = 0; e3 !== n2; ++e3)
        t2[e3] = r2[i2 + e3];
      return t2;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  }
  class sh extends ih {
    constructor(e2, t2, r2, n2) {
      super(e2, t2, r2, n2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: xt, endingEnd: xt };
    }
    intervalChanged_(e2, t2, r2) {
      const n2 = this.parameterPositions;
      let i2 = e2 - 2, s2 = e2 + 1, o2 = n2[i2], a2 = n2[s2];
      if (void 0 === o2)
        switch (this.getSettings_().endingStart) {
          case wt:
            i2 = e2, o2 = 2 * t2 - r2;
            break;
          case Et:
            i2 = n2.length - 2, o2 = t2 + n2[i2] - n2[i2 + 1];
            break;
          default:
            i2 = e2, o2 = r2;
        }
      if (void 0 === a2)
        switch (this.getSettings_().endingEnd) {
          case wt:
            s2 = e2, a2 = 2 * r2 - t2;
            break;
          case Et:
            s2 = 1, a2 = r2 + n2[1] - n2[0];
            break;
          default:
            s2 = e2 - 1, a2 = t2;
        }
      const l2 = 0.5 * (r2 - t2), c2 = this.valueSize;
      this._weightPrev = l2 / (t2 - o2), this._weightNext = l2 / (a2 - r2), this._offsetPrev = i2 * c2, this._offsetNext = s2 * c2;
    }
    interpolate_(e2, t2, r2, n2) {
      const i2 = this.resultBuffer, s2 = this.sampleValues, o2 = this.valueSize, a2 = e2 * o2, l2 = a2 - o2, c2 = this._offsetPrev, u2 = this._offsetNext, h2 = this._weightPrev, p2 = this._weightNext, d2 = (r2 - t2) / (n2 - t2), f2 = d2 * d2, m2 = f2 * d2, _2 = -h2 * m2 + 2 * h2 * f2 - h2 * d2, g2 = (1 + h2) * m2 + (-1.5 - 2 * h2) * f2 + (-0.5 + h2) * d2 + 1, v2 = (-1 - p2) * m2 + (1.5 + p2) * f2 + 0.5 * d2, A2 = p2 * m2 - p2 * f2;
      for (let e3 = 0; e3 !== o2; ++e3)
        i2[e3] = _2 * s2[c2 + e3] + g2 * s2[l2 + e3] + v2 * s2[a2 + e3] + A2 * s2[u2 + e3];
      return i2;
    }
  }
  class oh extends ih {
    constructor(e2, t2, r2, n2) {
      super(e2, t2, r2, n2);
    }
    interpolate_(e2, t2, r2, n2) {
      const i2 = this.resultBuffer, s2 = this.sampleValues, o2 = this.valueSize, a2 = e2 * o2, l2 = a2 - o2, c2 = (r2 - t2) / (n2 - t2), u2 = 1 - c2;
      for (let e3 = 0; e3 !== o2; ++e3)
        i2[e3] = s2[l2 + e3] * u2 + s2[a2 + e3] * c2;
      return i2;
    }
  }
  class ah extends ih {
    constructor(e2, t2, r2, n2) {
      super(e2, t2, r2, n2);
    }
    interpolate_(e2) {
      return this.copySampleValue_(e2 - 1);
    }
  }
  class lh {
    constructor(e2, t2, r2, n2) {
      if (void 0 === e2)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (void 0 === t2 || 0 === t2.length)
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e2);
      this.name = e2, this.times = Zu(t2, this.TimeBufferType), this.values = Zu(r2, this.ValueBufferType), this.setInterpolation(n2 || this.DefaultInterpolation);
    }
    static toJSON(e2) {
      const t2 = e2.constructor;
      let r2;
      if (t2.toJSON !== this.toJSON)
        r2 = t2.toJSON(e2);
      else {
        r2 = { name: e2.name, times: Zu(e2.times, Array), values: Zu(e2.values, Array) };
        const t3 = e2.getInterpolation();
        t3 !== e2.DefaultInterpolation && (r2.interpolation = t3);
      }
      return r2.type = e2.ValueTypeName, r2;
    }
    InterpolantFactoryMethodDiscrete(e2) {
      return new ah(this.times, this.values, this.getValueSize(), e2);
    }
    InterpolantFactoryMethodLinear(e2) {
      return new oh(this.times, this.values, this.getValueSize(), e2);
    }
    InterpolantFactoryMethodSmooth(e2) {
      return new sh(this.times, this.values, this.getValueSize(), e2);
    }
    setInterpolation(e2) {
      let t2;
      switch (e2) {
        case At:
          t2 = this.InterpolantFactoryMethodDiscrete;
          break;
        case bt:
          t2 = this.InterpolantFactoryMethodLinear;
          break;
        case yt:
          t2 = this.InterpolantFactoryMethodSmooth;
      }
      if (void 0 === t2) {
        const t3 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (void 0 === this.createInterpolant) {
          if (e2 === this.DefaultInterpolation)
            throw new Error(t3);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", t3), this;
      }
      return this.createInterpolant = t2, this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return At;
        case this.InterpolantFactoryMethodLinear:
          return bt;
        case this.InterpolantFactoryMethodSmooth:
          return yt;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(e2) {
      if (0 !== e2) {
        const t2 = this.times;
        for (let r2 = 0, n2 = t2.length; r2 !== n2; ++r2)
          t2[r2] += e2;
      }
      return this;
    }
    scale(e2) {
      if (1 !== e2) {
        const t2 = this.times;
        for (let r2 = 0, n2 = t2.length; r2 !== n2; ++r2)
          t2[r2] *= e2;
      }
      return this;
    }
    trim(e2, t2) {
      const r2 = this.times, n2 = r2.length;
      let i2 = 0, s2 = n2 - 1;
      for (; i2 !== n2 && r2[i2] < e2; )
        ++i2;
      for (; -1 !== s2 && r2[s2] > t2; )
        --s2;
      if (++s2, 0 !== i2 || s2 !== n2) {
        i2 >= s2 && (s2 = Math.max(s2, 1), i2 = s2 - 1);
        const e3 = this.getValueSize();
        this.times = Ju(r2, i2, s2), this.values = Ju(this.values, i2 * e3, s2 * e3);
      }
      return this;
    }
    validate() {
      let e2 = true;
      const t2 = this.getValueSize();
      t2 - Math.floor(t2) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e2 = false);
      const r2 = this.times, n2 = this.values, i2 = r2.length;
      0 === i2 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e2 = false);
      let s2 = null;
      for (let t3 = 0; t3 !== i2; t3++) {
        const n3 = r2[t3];
        if ("number" == typeof n3 && isNaN(n3)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t3, n3), e2 = false;
          break;
        }
        if (null !== s2 && s2 > n3) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, t3, n3, s2), e2 = false;
          break;
        }
        s2 = n3;
      }
      if (void 0 !== n2 && $u(n2))
        for (let t3 = 0, r3 = n2.length; t3 !== r3; ++t3) {
          const r4 = n2[t3];
          if (isNaN(r4)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t3, r4), e2 = false;
            break;
          }
        }
      return e2;
    }
    optimize() {
      const e2 = Ju(this.times), t2 = Ju(this.values), r2 = this.getValueSize(), n2 = this.getInterpolation() === yt, i2 = e2.length - 1;
      let s2 = 1;
      for (let o2 = 1; o2 < i2; ++o2) {
        let i3 = false;
        const a2 = e2[o2];
        if (a2 !== e2[o2 + 1] && (1 !== o2 || a2 !== e2[0]))
          if (n2)
            i3 = true;
          else {
            const e3 = o2 * r2, n3 = e3 - r2, s3 = e3 + r2;
            for (let o3 = 0; o3 !== r2; ++o3) {
              const r3 = t2[e3 + o3];
              if (r3 !== t2[n3 + o3] || r3 !== t2[s3 + o3]) {
                i3 = true;
                break;
              }
            }
          }
        if (i3) {
          if (o2 !== s2) {
            e2[s2] = e2[o2];
            const n3 = o2 * r2, i4 = s2 * r2;
            for (let e3 = 0; e3 !== r2; ++e3)
              t2[i4 + e3] = t2[n3 + e3];
          }
          ++s2;
        }
      }
      if (i2 > 0) {
        e2[s2] = e2[i2];
        for (let e3 = i2 * r2, n3 = s2 * r2, o2 = 0; o2 !== r2; ++o2)
          t2[n3 + o2] = t2[e3 + o2];
        ++s2;
      }
      return s2 !== e2.length ? (this.times = Ju(e2, 0, s2), this.values = Ju(t2, 0, s2 * r2)) : (this.times = e2, this.values = t2), this;
    }
    clone() {
      const e2 = Ju(this.times, 0), t2 = Ju(this.values, 0), r2 = new (0, this.constructor)(this.name, e2, t2);
      return r2.createInterpolant = this.createInterpolant, r2;
    }
  }
  lh.prototype.TimeBufferType = Float32Array, lh.prototype.ValueBufferType = Float32Array, lh.prototype.DefaultInterpolation = bt;
  class ch extends lh {
  }
  ch.prototype.ValueTypeName = "bool", ch.prototype.ValueBufferType = Array, ch.prototype.DefaultInterpolation = At, ch.prototype.InterpolantFactoryMethodLinear = void 0, ch.prototype.InterpolantFactoryMethodSmooth = void 0;
  class uh extends lh {
  }
  uh.prototype.ValueTypeName = "color";
  class hh extends lh {
  }
  hh.prototype.ValueTypeName = "number";
  class ph extends ih {
    constructor(e2, t2, r2, n2) {
      super(e2, t2, r2, n2);
    }
    interpolate_(e2, t2, r2, n2) {
      const i2 = this.resultBuffer, s2 = this.sampleValues, o2 = this.valueSize, a2 = (r2 - t2) / (n2 - t2);
      let l2 = e2 * o2;
      for (let e3 = l2 + o2; l2 !== e3; l2 += 4)
        an.slerpFlat(i2, 0, s2, l2 - o2, s2, l2, a2);
      return i2;
    }
  }
  class dh extends lh {
    InterpolantFactoryMethodLinear(e2) {
      return new ph(this.times, this.values, this.getValueSize(), e2);
    }
  }
  dh.prototype.ValueTypeName = "quaternion", dh.prototype.DefaultInterpolation = bt, dh.prototype.InterpolantFactoryMethodSmooth = void 0;
  class fh extends lh {
  }
  fh.prototype.ValueTypeName = "string", fh.prototype.ValueBufferType = Array, fh.prototype.DefaultInterpolation = At, fh.prototype.InterpolantFactoryMethodLinear = void 0, fh.prototype.InterpolantFactoryMethodSmooth = void 0;
  class mh extends lh {
  }
  mh.prototype.ValueTypeName = "vector";
  class _h {
    constructor(e2, t2 = -1, r2, n2 = St) {
      this.name = e2, this.tracks = r2, this.duration = t2, this.blendMode = n2, this.uuid = br(), this.duration < 0 && this.resetDuration();
    }
    static parse(e2) {
      const t2 = [], r2 = e2.tracks, n2 = 1 / (e2.fps || 1);
      for (let e3 = 0, i3 = r2.length; e3 !== i3; ++e3)
        t2.push(gh(r2[e3]).scale(n2));
      const i2 = new this(e2.name, e2.duration, t2, e2.blendMode);
      return i2.uuid = e2.uuid, i2;
    }
    static toJSON(e2) {
      const t2 = [], r2 = e2.tracks, n2 = { name: e2.name, duration: e2.duration, tracks: t2, uuid: e2.uuid, blendMode: e2.blendMode };
      for (let e3 = 0, n3 = r2.length; e3 !== n3; ++e3)
        t2.push(lh.toJSON(r2[e3]));
      return n2;
    }
    static CreateFromMorphTargetSequence(e2, t2, r2, n2) {
      const i2 = t2.length, s2 = [];
      for (let e3 = 0; e3 < i2; e3++) {
        let o2 = [], a2 = [];
        o2.push((e3 + i2 - 1) % i2, e3, (e3 + 1) % i2), a2.push(0, 1, 0);
        const l2 = eh(o2);
        o2 = th(o2, 1, l2), a2 = th(a2, 1, l2), n2 || 0 !== o2[0] || (o2.push(i2), a2.push(a2[0])), s2.push(new hh(".morphTargetInfluences[" + t2[e3].name + "]", o2, a2).scale(1 / r2));
      }
      return new this(e2, -1, s2);
    }
    static findByName(e2, t2) {
      let r2 = e2;
      if (!Array.isArray(e2)) {
        const t3 = e2;
        r2 = t3.geometry && t3.geometry.animations || t3.animations;
      }
      for (let e3 = 0; e3 < r2.length; e3++)
        if (r2[e3].name === t2)
          return r2[e3];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(e2, t2, r2) {
      const n2 = {}, i2 = /^([\w-]*?)([\d]+)$/;
      for (let t3 = 0, r3 = e2.length; t3 < r3; t3++) {
        const r4 = e2[t3], s3 = r4.name.match(i2);
        if (s3 && s3.length > 1) {
          const e3 = s3[1];
          let t4 = n2[e3];
          t4 || (n2[e3] = t4 = []), t4.push(r4);
        }
      }
      const s2 = [];
      for (const e3 in n2)
        s2.push(this.CreateFromMorphTargetSequence(e3, n2[e3], t2, r2));
      return s2;
    }
    static parseAnimation(e2, t2) {
      if (!e2)
        return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      const r2 = function(e3, t3, r3, n3, i3) {
        if (0 !== r3.length) {
          const s3 = [], o3 = [];
          rh(r3, s3, o3, n3), 0 !== s3.length && i3.push(new e3(t3, s3, o3));
        }
      }, n2 = [], i2 = e2.name || "default", s2 = e2.fps || 30, o2 = e2.blendMode;
      let a2 = e2.length || -1;
      const l2 = e2.hierarchy || [];
      for (let e3 = 0; e3 < l2.length; e3++) {
        const i3 = l2[e3].keys;
        if (i3 && 0 !== i3.length)
          if (i3[0].morphTargets) {
            const e4 = {};
            let t3;
            for (t3 = 0; t3 < i3.length; t3++)
              if (i3[t3].morphTargets)
                for (let r3 = 0; r3 < i3[t3].morphTargets.length; r3++)
                  e4[i3[t3].morphTargets[r3]] = -1;
            for (const r3 in e4) {
              const e5 = [], s3 = [];
              for (let n3 = 0; n3 !== i3[t3].morphTargets.length; ++n3) {
                const n4 = i3[t3];
                e5.push(n4.time), s3.push(n4.morphTarget === r3 ? 1 : 0);
              }
              n2.push(new hh(".morphTargetInfluence[" + r3 + "]", e5, s3));
            }
            a2 = e4.length * s2;
          } else {
            const s3 = ".bones[" + t2[e3].name + "]";
            r2(mh, s3 + ".position", i3, "pos", n2), r2(dh, s3 + ".quaternion", i3, "rot", n2), r2(mh, s3 + ".scale", i3, "scl", n2);
          }
      }
      return 0 === n2.length ? null : new this(i2, a2, n2, o2);
    }
    resetDuration() {
      let e2 = 0;
      for (let t2 = 0, r2 = this.tracks.length; t2 !== r2; ++t2) {
        const r3 = this.tracks[t2];
        e2 = Math.max(e2, r3.times[r3.times.length - 1]);
      }
      return this.duration = e2, this;
    }
    trim() {
      for (let e2 = 0; e2 < this.tracks.length; e2++)
        this.tracks[e2].trim(0, this.duration);
      return this;
    }
    validate() {
      let e2 = true;
      for (let t2 = 0; t2 < this.tracks.length; t2++)
        e2 = e2 && this.tracks[t2].validate();
      return e2;
    }
    optimize() {
      for (let e2 = 0; e2 < this.tracks.length; e2++)
        this.tracks[e2].optimize();
      return this;
    }
    clone() {
      const e2 = [];
      for (let t2 = 0; t2 < this.tracks.length; t2++)
        e2.push(this.tracks[t2].clone());
      return new this.constructor(this.name, this.duration, e2, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function gh(e2) {
    if (void 0 === e2.type)
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const t2 = function(e3) {
      switch (e3.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return hh;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return mh;
        case "color":
          return uh;
        case "quaternion":
          return dh;
        case "bool":
        case "boolean":
          return ch;
        case "string":
          return fh;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e3);
    }(e2.type);
    if (void 0 === e2.times) {
      const t3 = [], r2 = [];
      rh(e2.keys, t3, r2, "value"), e2.times = t3, e2.values = r2;
    }
    return void 0 !== t2.parse ? t2.parse(e2) : new t2(e2.name, e2.times, e2.values, e2.interpolation);
  }
  const vh = { enabled: false, files: {}, add: function(e2, t2) {
    false !== this.enabled && (this.files[e2] = t2);
  }, get: function(e2, t2) {
    return false === this.enabled ? t2 ? Promise.resolve() : void 0 : t2 ? Promise.resolve(this.files[e2]) : this.files[e2];
  }, remove: function(e2) {
    delete this.files[e2];
  }, clear: function() {
    this.files = {};
  } };
  class Ah {
    constructor(e2, t2, r2) {
      const n2 = this;
      let i2, s2 = false, o2 = 0, a2 = 0;
      const l2 = [];
      this.onStart = void 0, this.onLoad = e2, this.onProgress = t2, this.onError = r2, this.itemStart = function(e3) {
        a2++, false === s2 && void 0 !== n2.onStart && n2.onStart(e3, o2, a2), s2 = true;
      }, this.itemEnd = function(e3) {
        o2++, void 0 !== n2.onProgress && n2.onProgress(e3, o2, a2), o2 === a2 && (s2 = false, void 0 !== n2.onLoad && n2.onLoad());
      }, this.itemError = function(e3) {
        void 0 !== n2.onError && n2.onError(e3);
      }, this.resolveURL = function(e3) {
        return i2 ? i2(e3) : e3;
      }, this.setURLModifier = function(e3) {
        return i2 = e3, this;
      }, this.addHandler = function(e3, t3) {
        return l2.push(e3, t3), this;
      }, this.removeHandler = function(e3) {
        const t3 = l2.indexOf(e3);
        return -1 !== t3 && l2.splice(t3, 2), this;
      }, this.getHandler = function(e3) {
        for (let t3 = 0, r3 = l2.length; t3 < r3; t3 += 2) {
          const r4 = l2[t3], n3 = l2[t3 + 1];
          if (r4.global && (r4.lastIndex = 0), r4.test(e3))
            return n3;
        }
        return null;
      };
    }
  }
  const bh = new Ah();
  class yh {
    constructor(e2) {
      this.manager = void 0 !== e2 ? e2 : bh, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
    }
    load() {
    }
    loadAsync(e2, t2) {
      const r2 = this;
      return new Promise(function(n2, i2) {
        r2.load(e2, n2, t2, i2);
      });
    }
    parse() {
    }
    setCrossOrigin(e2) {
      return this.crossOrigin = e2, this;
    }
    setWithCredentials(e2) {
      return this.withCredentials = e2, this;
    }
    setPath(e2) {
      return this.path = e2, this;
    }
    setResourcePath(e2) {
      return this.resourcePath = e2, this;
    }
    setRequestHeader(e2) {
      return this.requestHeader = e2, this;
    }
  }
  const xh = {};
  class wh extends Error {
    constructor(e2, t2) {
      super(e2), this.response = t2;
    }
  }
  class Eh extends yh {
    constructor(e2) {
      super(e2), this.responseType = "text";
    }
    load(e2, t2, r2, n2) {
      void 0 === e2 && (e2 = ""), void 0 !== this.path && (e2 = this.path + e2), e2 = this.manager.resolveURL(e2), vh.get(e2, this.responseType, this.mimeType).then((i2) => {
        if (void 0 !== i2)
          return this.manager.itemStart(e2), setTimeout(() => {
            t2 && t2(i2), this.manager.itemEnd(e2);
          }, 0), i2;
        if (void 0 !== xh[e2])
          return void xh[e2].push({ onLoad: t2, onProgress: r2, onError: n2 });
        xh[e2] = [], xh[e2].push({ onLoad: t2, onProgress: r2, onError: n2 });
        const s2 = new Request(e2, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), o2 = this.mimeType, a2 = this.responseType;
        fetch(s2).then((t3) => {
          if (200 === t3.status || 0 === t3.status) {
            if (0 === t3.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t3.body || void 0 === t3.body.getReader)
              return t3;
            const r3 = xh[e2], n3 = t3.body.getReader(), i3 = t3.headers.get("Content-Length"), s3 = i3 ? parseInt(i3) : 0, o3 = 0 !== s3;
            let a3 = 0;
            const l2 = new ReadableStream({ start(e3) {
              !function t4() {
                n3.read().then(({ done: n4, value: i4 }) => {
                  if (n4)
                    e3.close();
                  else {
                    a3 += i4.byteLength;
                    const n5 = new ProgressEvent("progress", { lengthComputable: o3, loaded: a3, total: s3 });
                    for (let e4 = 0, t5 = r3.length; e4 < t5; e4++) {
                      const t6 = r3[e4];
                      t6.onProgress && t6.onProgress(n5);
                    }
                    e3.enqueue(i4), t4();
                  }
                });
              }();
            } });
            return new Response(l2);
          }
          throw new wh(`fetch for "${t3.url}" responded with ${t3.status}: ${t3.statusText}`, t3);
        }).then((e3) => {
          switch (a2) {
            case "arraybuffer":
              return e3.arrayBuffer();
            case "blob":
              return e3.blob();
            case "document":
              return e3.text().then((e4) => new DOMParser().parseFromString(e4, o2));
            case "json":
              return e3.json();
            default:
              if (void 0 === o2)
                return e3.text();
              {
                const t3 = /charset="?([^;"\s]*)"?/i.exec(o2), r3 = t3 && t3[1] ? t3[1].toLowerCase() : void 0, n3 = new TextDecoder(r3);
                return e3.arrayBuffer().then((e4) => n3.decode(e4));
              }
          }
        }).then((t3) => {
          vh.add(e2, t3, this.responseType);
          const r3 = xh[e2];
          delete xh[e2];
          for (let e3 = 0, n3 = r3.length; e3 < n3; e3++) {
            const n4 = r3[e3];
            n4.onLoad && n4.onLoad(t3);
          }
        }).catch((t3) => {
          const r3 = xh[e2];
          if (void 0 === r3)
            throw this.manager.itemError(e2), t3;
          delete xh[e2];
          for (let e3 = 0, n3 = r3.length; e3 < n3; e3++) {
            const n4 = r3[e3];
            n4.onError && n4.onError(t3);
          }
          this.manager.itemError(e2);
        }).finally(() => {
          this.manager.itemEnd(e2);
        }), this.manager.itemStart(e2);
      });
    }
    setResponseType(e2) {
      return this.responseType = e2, this;
    }
    setMimeType(e2) {
      return this.mimeType = e2, this;
    }
  }
  class Sh extends yh {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, n2) {
      const i2 = this, s2 = new Eh(this.manager);
      s2.setPath(this.path), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(this.withCredentials), s2.load(e2, function(r3) {
        try {
          t2(i2.parse(JSON.parse(r3)));
        } catch (t3) {
          n2 ? n2(t3) : console.error(t3), i2.manager.itemError(e2);
        }
      }, r2, n2);
    }
    parse(e2) {
      const t2 = [];
      for (let r2 = 0; r2 < e2.length; r2++) {
        const n2 = _h.parse(e2[r2]);
        t2.push(n2);
      }
      return t2;
    }
  }
  class Ch extends yh {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, n2) {
      const i2 = this, s2 = [], o2 = new gc(), a2 = new Eh(this.manager);
      a2.setPath(this.path), a2.setResponseType("arraybuffer"), a2.setRequestHeader(this.requestHeader), a2.setWithCredentials(i2.withCredentials);
      let l2 = 0;
      function c2(c3) {
        a2.load(e2[c3], function(e3) {
          const r3 = i2.parse(e3, true);
          s2[c3] = { width: r3.width, height: r3.height, format: r3.format, mipmaps: r3.mipmaps }, l2 += 1, 6 === l2 && (1 === r3.mipmapCount && (o2.minFilter = _e), o2.image = s2, o2.format = r3.format, o2.needsUpdate = true, t2 && t2(o2));
        }, r2, n2);
      }
      if (Array.isArray(e2))
        for (let t3 = 0, r3 = e2.length; t3 < r3; ++t3)
          c2(t3);
      else
        a2.load(e2, function(e3) {
          const r3 = i2.parse(e3, true);
          if (r3.isCubemap) {
            const e4 = r3.mipmaps.length / r3.mipmapCount;
            for (let t3 = 0; t3 < e4; t3++) {
              s2[t3] = { mipmaps: [] };
              for (let e5 = 0; e5 < r3.mipmapCount; e5++)
                s2[t3].mipmaps.push(r3.mipmaps[t3 * r3.mipmapCount + e5]), s2[t3].format = r3.format, s2[t3].width = r3.width, s2[t3].height = r3.height;
            }
            o2.image = s2;
          } else
            o2.image.width = r3.width, o2.image.height = r3.height, o2.mipmaps = r3.mipmaps;
          1 === r3.mipmapCount && (o2.minFilter = _e), o2.format = r3.format, o2.needsUpdate = true, t2 && t2(o2);
        }, r2, n2);
      return o2;
    }
  }
  class Mh extends yh {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, n2) {
      void 0 !== this.path && (e2 = this.path + e2), e2 = this.manager.resolveURL(e2);
      const i2 = this, s2 = vh.get(e2);
      if (void 0 !== s2)
        return i2.manager.itemStart(e2), setTimeout(function() {
          t2 && t2(s2), i2.manager.itemEnd(e2);
        }, 0), s2;
      const o2 = Lr("img");
      function a2() {
        c2(), vh.add(e2, this), t2 && t2(this), i2.manager.itemEnd(e2);
      }
      function l2(t3) {
        c2(), n2 && n2(t3), i2.manager.itemError(e2), i2.manager.itemEnd(e2);
      }
      function c2() {
        o2.removeEventListener("load", a2, false), o2.removeEventListener("error", l2, false);
      }
      return o2.addEventListener("load", a2, false), o2.addEventListener("error", l2, false), "data:" !== e2.slice(0, 5) && void 0 !== this.crossOrigin && (o2.crossOrigin = this.crossOrigin), i2.manager.itemStart(e2), o2.src = e2, o2;
    }
  }
  class Th extends yh {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, n2) {
      const i2 = new bs(), s2 = new Mh(this.manager);
      s2.setCrossOrigin(this.crossOrigin), s2.setPath(this.path);
      let o2 = 0;
      function a2(r3) {
        s2.load(e2[r3], function(e3) {
          i2.images[r3] = e3, o2++, 6 === o2 && (i2.needsUpdate = true, t2 && t2(i2));
        }, void 0, n2);
      }
      for (let t3 = 0; t3 < e2.length; ++t3)
        a2(t3);
      return i2;
    }
  }
  class Ih extends yh {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, n2) {
      const i2 = this, s2 = new zl(), o2 = new Eh(this.manager);
      return o2.setResponseType("arraybuffer"), o2.setRequestHeader(this.requestHeader), o2.setPath(this.path), o2.setWithCredentials(i2.withCredentials), o2.load(e2, function(e3) {
        const r3 = i2.parse(e3);
        r3 && (void 0 !== r3.image ? s2.image = r3.image : void 0 !== r3.data && (s2.image.width = r3.width, s2.image.height = r3.height, s2.image.data = r3.data, s2.image.complete = true), s2.wrapS = void 0 !== r3.wrapS ? r3.wrapS : ce, s2.wrapT = void 0 !== r3.wrapT ? r3.wrapT : ce, s2.magFilter = void 0 !== r3.magFilter ? r3.magFilter : _e, s2.minFilter = void 0 !== r3.minFilter ? r3.minFilter : _e, s2.anisotropy = void 0 !== r3.anisotropy ? r3.anisotropy : 1, void 0 !== r3.encoding && (s2.encoding = r3.encoding), void 0 !== r3.flipY && (s2.flipY = r3.flipY), void 0 !== r3.format && (s2.format = r3.format), void 0 !== r3.type && (s2.type = r3.type), void 0 !== r3.mipmaps && (s2.mipmaps = r3.mipmaps, s2.minFilter = Ae), 1 === r3.mipmapCount && (s2.minFilter = _e), void 0 !== r3.generateMipmaps && (s2.generateMipmaps = r3.generateMipmaps), s2.needsUpdate = true, t2 && t2(s2, r3));
      }, r2, n2), s2;
    }
  }
  class kh extends yh {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, n2) {
      const i2 = new Zr(), s2 = new Mh(this.manager);
      return s2.setCrossOrigin(this.crossOrigin), s2.setPath(this.path), s2.load(e2, function(e3) {
        i2.image = e3, i2.needsUpdate = true, void 0 !== t2 && t2(i2);
      }, r2, n2), i2;
    }
  }
  class Dh extends ui {
    constructor(e2, t2 = 1) {
      super(), this.isLight = true, this.type = "Light", this.color = new Wr(e2), this.intensity = t2;
    }
    dispose() {
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.color.copy(e2.color), this.intensity = e2.intensity, this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.color = this.color.getHex(), t2.object.intensity = this.intensity, void 0 !== this.groundColor && (t2.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t2.object.distance = this.distance), void 0 !== this.angle && (t2.object.angle = this.angle), void 0 !== this.decay && (t2.object.decay = this.decay), void 0 !== this.penumbra && (t2.object.penumbra = this.penumbra), void 0 !== this.shadow && (t2.object.shadow = this.shadow.toJSON()), t2;
    }
  }
  class Ph extends Dh {
    constructor(e2, t2, r2) {
      super(e2, r2), this.isHemisphereLight = true, this.type = "HemisphereLight", this.position.copy(ui.DefaultUp), this.updateMatrix(), this.groundColor = new Wr(t2);
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.groundColor.copy(e2.groundColor), this;
    }
  }
  const Bh = new Nn(), Rh = new ln(), Lh = new ln();
  class Oh {
    constructor(e2) {
      this.camera = e2, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new kr(512, 512), this.map = null, this.mapPass = null, this.matrix = new Nn(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Ts(), this._frameExtents = new kr(1, 1), this._viewportCount = 1, this._viewports = [new $r(0, 0, 1, 1)];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(e2) {
      const t2 = this.camera, r2 = this.matrix;
      Rh.setFromMatrixPosition(e2.matrixWorld), t2.position.copy(Rh), Lh.setFromMatrixPosition(e2.target.matrixWorld), t2.lookAt(Lh), t2.updateMatrixWorld(), Bh.multiplyMatrices(t2.projectionMatrix, t2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Bh), r2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), r2.multiply(t2.projectionMatrix), r2.multiply(t2.matrixWorldInverse);
    }
    getViewport(e2) {
      return this._viewports[e2];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(e2) {
      return this.camera = e2.camera.clone(), this.bias = e2.bias, this.normalBias = e2.normalBias, this.radius = e2.radius, this.mapSize.copy(e2.mapSize), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const e2 = {};
      return 0 !== this.bias && (e2.bias = this.bias), 0 !== this.normalBias && (e2.normalBias = this.normalBias), 1 !== this.radius && (e2.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e2.mapSize = this.mapSize.toArray()), e2.camera = this.camera.toJSON(false).object, delete e2.camera.matrix, e2;
    }
  }
  class Fh extends Oh {
    constructor() {
      super(new gs(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
    }
    updateMatrices(e2) {
      const t2 = this.camera, r2 = 2 * Ar * e2.angle * this.focus, n2 = this.mapSize.width / this.mapSize.height, i2 = e2.distance || t2.far;
      r2 === t2.fov && n2 === t2.aspect && i2 === t2.far || (t2.fov = r2, t2.aspect = n2, t2.far = i2, t2.updateProjectionMatrix()), super.updateMatrices(e2);
    }
    copy(e2) {
      return super.copy(e2), this.focus = e2.focus, this;
    }
  }
  class Uh extends Dh {
    constructor(e2, t2, r2 = 0, n2 = Math.PI / 3, i2 = 0, s2 = 1) {
      super(e2, t2), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(ui.DefaultUp), this.updateMatrix(), this.target = new ui(), this.distance = r2, this.angle = n2, this.penumbra = i2, this.decay = s2, this.map = null, this.shadow = new Fh();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(e2) {
      this.intensity = e2 / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.distance = e2.distance, this.angle = e2.angle, this.penumbra = e2.penumbra, this.decay = e2.decay, this.target = e2.target.clone(), this.shadow = e2.shadow.clone(), this;
    }
  }
  const Nh = new Nn(), jh = new ln(), zh = new ln();
  class Gh extends Oh {
    constructor() {
      super(new gs(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new kr(4, 2), this._viewportCount = 6, this._viewports = [new $r(2, 1, 1, 1), new $r(0, 1, 1, 1), new $r(3, 1, 1, 1), new $r(1, 1, 1, 1), new $r(3, 0, 1, 1), new $r(1, 0, 1, 1)], this._cubeDirections = [new ln(1, 0, 0), new ln(-1, 0, 0), new ln(0, 0, 1), new ln(0, 0, -1), new ln(0, 1, 0), new ln(0, -1, 0)], this._cubeUps = [new ln(0, 1, 0), new ln(0, 1, 0), new ln(0, 1, 0), new ln(0, 1, 0), new ln(0, 0, 1), new ln(0, 0, -1)];
    }
    updateMatrices(e2, t2 = 0) {
      const r2 = this.camera, n2 = this.matrix, i2 = e2.distance || r2.far;
      i2 !== r2.far && (r2.far = i2, r2.updateProjectionMatrix()), jh.setFromMatrixPosition(e2.matrixWorld), r2.position.copy(jh), zh.copy(r2.position), zh.add(this._cubeDirections[t2]), r2.up.copy(this._cubeUps[t2]), r2.lookAt(zh), r2.updateMatrixWorld(), n2.makeTranslation(-jh.x, -jh.y, -jh.z), Nh.multiplyMatrices(r2.projectionMatrix, r2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Nh);
    }
  }
  class Vh extends Dh {
    constructor(e2, t2, r2 = 0, n2 = 1) {
      super(e2, t2), this.isPointLight = true, this.type = "PointLight", this.distance = r2, this.decay = n2, this.shadow = new Gh();
    }
    get power() {
      return 4 * this.intensity * Math.PI;
    }
    set power(e2) {
      this.intensity = e2 / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.distance = e2.distance, this.decay = e2.decay, this.shadow = e2.shadow.clone(), this;
    }
  }
  class Qh extends Oh {
    constructor() {
      super(new zs(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
    }
  }
  class Hh extends Dh {
    constructor(e2, t2) {
      super(e2, t2), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(ui.DefaultUp), this.updateMatrix(), this.target = new ui(), this.shadow = new Qh();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e2) {
      return super.copy(e2), this.target = e2.target.clone(), this.shadow = e2.shadow.clone(), this;
    }
  }
  class Wh extends Dh {
    constructor(e2, t2) {
      super(e2, t2), this.isAmbientLight = true, this.type = "AmbientLight";
    }
  }
  class qh extends Dh {
    constructor(e2, t2, r2 = 10, n2 = 10) {
      super(e2, t2), this.isRectAreaLight = true, this.type = "RectAreaLight", this.width = r2, this.height = n2;
    }
    get power() {
      return this.intensity * this.width * this.height * Math.PI;
    }
    set power(e2) {
      this.intensity = e2 / (this.width * this.height * Math.PI);
    }
    copy(e2) {
      return super.copy(e2), this.width = e2.width, this.height = e2.height, this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.width = this.width, t2.object.height = this.height, t2;
    }
  }
  class Xh {
    constructor() {
      this.isSphericalHarmonics3 = true, this.coefficients = [];
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients.push(new ln());
    }
    set(e2) {
      for (let t2 = 0; t2 < 9; t2++)
        this.coefficients[t2].copy(e2[t2]);
      return this;
    }
    zero() {
      for (let e2 = 0; e2 < 9; e2++)
        this.coefficients[e2].set(0, 0, 0);
      return this;
    }
    getAt(e2, t2) {
      const r2 = e2.x, n2 = e2.y, i2 = e2.z, s2 = this.coefficients;
      return t2.copy(s2[0]).multiplyScalar(0.282095), t2.addScaledVector(s2[1], 0.488603 * n2), t2.addScaledVector(s2[2], 0.488603 * i2), t2.addScaledVector(s2[3], 0.488603 * r2), t2.addScaledVector(s2[4], r2 * n2 * 1.092548), t2.addScaledVector(s2[5], n2 * i2 * 1.092548), t2.addScaledVector(s2[6], 0.315392 * (3 * i2 * i2 - 1)), t2.addScaledVector(s2[7], r2 * i2 * 1.092548), t2.addScaledVector(s2[8], 0.546274 * (r2 * r2 - n2 * n2)), t2;
    }
    getIrradianceAt(e2, t2) {
      const r2 = e2.x, n2 = e2.y, i2 = e2.z, s2 = this.coefficients;
      return t2.copy(s2[0]).multiplyScalar(0.886227), t2.addScaledVector(s2[1], 1.023328 * n2), t2.addScaledVector(s2[2], 1.023328 * i2), t2.addScaledVector(s2[3], 1.023328 * r2), t2.addScaledVector(s2[4], 0.858086 * r2 * n2), t2.addScaledVector(s2[5], 0.858086 * n2 * i2), t2.addScaledVector(s2[6], 0.743125 * i2 * i2 - 0.247708), t2.addScaledVector(s2[7], 0.858086 * r2 * i2), t2.addScaledVector(s2[8], 0.429043 * (r2 * r2 - n2 * n2)), t2;
    }
    add(e2) {
      for (let t2 = 0; t2 < 9; t2++)
        this.coefficients[t2].add(e2.coefficients[t2]);
      return this;
    }
    addScaledSH(e2, t2) {
      for (let r2 = 0; r2 < 9; r2++)
        this.coefficients[r2].addScaledVector(e2.coefficients[r2], t2);
      return this;
    }
    scale(e2) {
      for (let t2 = 0; t2 < 9; t2++)
        this.coefficients[t2].multiplyScalar(e2);
      return this;
    }
    lerp(e2, t2) {
      for (let r2 = 0; r2 < 9; r2++)
        this.coefficients[r2].lerp(e2.coefficients[r2], t2);
      return this;
    }
    equals(e2) {
      for (let t2 = 0; t2 < 9; t2++)
        if (!this.coefficients[t2].equals(e2.coefficients[t2]))
          return false;
      return true;
    }
    copy(e2) {
      return this.set(e2.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(e2, t2 = 0) {
      const r2 = this.coefficients;
      for (let n2 = 0; n2 < 9; n2++)
        r2[n2].fromArray(e2, t2 + 3 * n2);
      return this;
    }
    toArray(e2 = [], t2 = 0) {
      const r2 = this.coefficients;
      for (let n2 = 0; n2 < 9; n2++)
        r2[n2].toArray(e2, t2 + 3 * n2);
      return e2;
    }
    static getBasisAt(e2, t2) {
      const r2 = e2.x, n2 = e2.y, i2 = e2.z;
      t2[0] = 0.282095, t2[1] = 0.488603 * n2, t2[2] = 0.488603 * i2, t2[3] = 0.488603 * r2, t2[4] = 1.092548 * r2 * n2, t2[5] = 1.092548 * n2 * i2, t2[6] = 0.315392 * (3 * i2 * i2 - 1), t2[7] = 1.092548 * r2 * i2, t2[8] = 0.546274 * (r2 * r2 - n2 * n2);
    }
  }
  class Yh extends Dh {
    constructor(e2 = new Xh(), t2 = 1) {
      super(void 0, t2), this.isLightProbe = true, this.sh = e2;
    }
    copy(e2) {
      return super.copy(e2), this.sh.copy(e2.sh), this;
    }
    fromJSON(e2) {
      return this.intensity = e2.intensity, this.sh.fromArray(e2.sh), this;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.object.sh = this.sh.toArray(), t2;
    }
  }
  class Kh extends yh {
    constructor(e2) {
      super(e2), this.textures = {};
    }
    load(e2, t2, r2, n2) {
      const i2 = this, s2 = new Eh(i2.manager);
      s2.setPath(i2.path), s2.setRequestHeader(i2.requestHeader), s2.setWithCredentials(i2.withCredentials), s2.load(e2, function(r3) {
        try {
          t2(i2.parse(JSON.parse(r3)));
        } catch (t3) {
          n2 ? n2(t3) : console.error(t3), i2.manager.itemError(e2);
        }
      }, r2, n2);
    }
    parse(e2) {
      const t2 = this.textures;
      function r2(e3) {
        return void 0 === t2[e3] && console.warn("THREE.MaterialLoader: Undefined texture", e3), t2[e3];
      }
      const n2 = Kh.createMaterialFromType(e2.type);
      if (void 0 !== e2.uuid && (n2.uuid = e2.uuid), void 0 !== e2.name && (n2.name = e2.name), void 0 !== e2.color && void 0 !== n2.color && n2.color.setHex(e2.color), void 0 !== e2.roughness && (n2.roughness = e2.roughness), void 0 !== e2.metalness && (n2.metalness = e2.metalness), void 0 !== e2.sheen && (n2.sheen = e2.sheen), void 0 !== e2.sheenColor && (n2.sheenColor = new Wr().setHex(e2.sheenColor)), void 0 !== e2.sheenRoughness && (n2.sheenRoughness = e2.sheenRoughness), void 0 !== e2.emissive && void 0 !== n2.emissive && n2.emissive.setHex(e2.emissive), void 0 !== e2.specular && void 0 !== n2.specular && n2.specular.setHex(e2.specular), void 0 !== e2.specularIntensity && (n2.specularIntensity = e2.specularIntensity), void 0 !== e2.specularColor && void 0 !== n2.specularColor && n2.specularColor.setHex(e2.specularColor), void 0 !== e2.shininess && (n2.shininess = e2.shininess), void 0 !== e2.clearcoat && (n2.clearcoat = e2.clearcoat), void 0 !== e2.clearcoatRoughness && (n2.clearcoatRoughness = e2.clearcoatRoughness), void 0 !== e2.iridescence && (n2.iridescence = e2.iridescence), void 0 !== e2.iridescenceIOR && (n2.iridescenceIOR = e2.iridescenceIOR), void 0 !== e2.iridescenceThicknessRange && (n2.iridescenceThicknessRange = e2.iridescenceThicknessRange), void 0 !== e2.transmission && (n2.transmission = e2.transmission), void 0 !== e2.thickness && (n2.thickness = e2.thickness), void 0 !== e2.attenuationDistance && (n2.attenuationDistance = e2.attenuationDistance), void 0 !== e2.attenuationColor && void 0 !== n2.attenuationColor && n2.attenuationColor.setHex(e2.attenuationColor), void 0 !== e2.fog && (n2.fog = e2.fog), void 0 !== e2.flatShading && (n2.flatShading = e2.flatShading), void 0 !== e2.blending && (n2.blending = e2.blending), void 0 !== e2.combine && (n2.combine = e2.combine), void 0 !== e2.side && (n2.side = e2.side), void 0 !== e2.shadowSide && (n2.shadowSide = e2.shadowSide), void 0 !== e2.opacity && (n2.opacity = e2.opacity), void 0 !== e2.transparent && (n2.transparent = e2.transparent), void 0 !== e2.alphaTest && (n2.alphaTest = e2.alphaTest), void 0 !== e2.depthTest && (n2.depthTest = e2.depthTest), void 0 !== e2.depthWrite && (n2.depthWrite = e2.depthWrite), void 0 !== e2.colorWrite && (n2.colorWrite = e2.colorWrite), void 0 !== e2.stencilWrite && (n2.stencilWrite = e2.stencilWrite), void 0 !== e2.stencilWriteMask && (n2.stencilWriteMask = e2.stencilWriteMask), void 0 !== e2.stencilFunc && (n2.stencilFunc = e2.stencilFunc), void 0 !== e2.stencilRef && (n2.stencilRef = e2.stencilRef), void 0 !== e2.stencilFuncMask && (n2.stencilFuncMask = e2.stencilFuncMask), void 0 !== e2.stencilFail && (n2.stencilFail = e2.stencilFail), void 0 !== e2.stencilZFail && (n2.stencilZFail = e2.stencilZFail), void 0 !== e2.stencilZPass && (n2.stencilZPass = e2.stencilZPass), void 0 !== e2.wireframe && (n2.wireframe = e2.wireframe), void 0 !== e2.wireframeLinewidth && (n2.wireframeLinewidth = e2.wireframeLinewidth), void 0 !== e2.wireframeLinecap && (n2.wireframeLinecap = e2.wireframeLinecap), void 0 !== e2.wireframeLinejoin && (n2.wireframeLinejoin = e2.wireframeLinejoin), void 0 !== e2.rotation && (n2.rotation = e2.rotation), 1 !== e2.linewidth && (n2.linewidth = e2.linewidth), void 0 !== e2.dashSize && (n2.dashSize = e2.dashSize), void 0 !== e2.gapSize && (n2.gapSize = e2.gapSize), void 0 !== e2.scale && (n2.scale = e2.scale), void 0 !== e2.polygonOffset && (n2.polygonOffset = e2.polygonOffset), void 0 !== e2.polygonOffsetFactor && (n2.polygonOffsetFactor = e2.polygonOffsetFactor), void 0 !== e2.polygonOffsetUnits && (n2.polygonOffsetUnits = e2.polygonOffsetUnits), void 0 !== e2.dithering && (n2.dithering = e2.dithering), void 0 !== e2.alphaToCoverage && (n2.alphaToCoverage = e2.alphaToCoverage), void 0 !== e2.premultipliedAlpha && (n2.premultipliedAlpha = e2.premultipliedAlpha), void 0 !== e2.visible && (n2.visible = e2.visible), void 0 !== e2.toneMapped && (n2.toneMapped = e2.toneMapped), void 0 !== e2.userData && (n2.userData = e2.userData), void 0 !== e2.vertexColors && ("number" == typeof e2.vertexColors ? n2.vertexColors = e2.vertexColors > 0 : n2.vertexColors = e2.vertexColors), void 0 !== e2.uniforms)
        for (const t3 in e2.uniforms) {
          const i2 = e2.uniforms[t3];
          switch (n2.uniforms[t3] = {}, i2.type) {
            case "t":
              n2.uniforms[t3].value = r2(i2.value);
              break;
            case "c":
              n2.uniforms[t3].value = new Wr().setHex(i2.value);
              break;
            case "v2":
              n2.uniforms[t3].value = new kr().fromArray(i2.value);
              break;
            case "v3":
              n2.uniforms[t3].value = new ln().fromArray(i2.value);
              break;
            case "v4":
              n2.uniforms[t3].value = new $r().fromArray(i2.value);
              break;
            case "m3":
              n2.uniforms[t3].value = new Dr().fromArray(i2.value);
              break;
            case "m4":
              n2.uniforms[t3].value = new Nn().fromArray(i2.value);
              break;
            default:
              n2.uniforms[t3].value = i2.value;
          }
        }
      if (void 0 !== e2.defines && (n2.defines = e2.defines), void 0 !== e2.vertexShader && (n2.vertexShader = e2.vertexShader), void 0 !== e2.fragmentShader && (n2.fragmentShader = e2.fragmentShader), void 0 !== e2.glslVersion && (n2.glslVersion = e2.glslVersion), void 0 !== e2.extensions)
        for (const t3 in e2.extensions)
          n2.extensions[t3] = e2.extensions[t3];
      if (void 0 !== e2.size && (n2.size = e2.size), void 0 !== e2.sizeAttenuation && (n2.sizeAttenuation = e2.sizeAttenuation), void 0 !== e2.map && (n2.map = r2(e2.map)), void 0 !== e2.matcap && (n2.matcap = r2(e2.matcap)), void 0 !== e2.alphaMap && (n2.alphaMap = r2(e2.alphaMap)), void 0 !== e2.bumpMap && (n2.bumpMap = r2(e2.bumpMap)), void 0 !== e2.bumpScale && (n2.bumpScale = e2.bumpScale), void 0 !== e2.normalMap && (n2.normalMap = r2(e2.normalMap)), void 0 !== e2.normalMapType && (n2.normalMapType = e2.normalMapType), void 0 !== e2.normalScale) {
        let t3 = e2.normalScale;
        false === Array.isArray(t3) && (t3 = [t3, t3]), n2.normalScale = new kr().fromArray(t3);
      }
      return void 0 !== e2.displacementMap && (n2.displacementMap = r2(e2.displacementMap)), void 0 !== e2.displacementScale && (n2.displacementScale = e2.displacementScale), void 0 !== e2.displacementBias && (n2.displacementBias = e2.displacementBias), void 0 !== e2.roughnessMap && (n2.roughnessMap = r2(e2.roughnessMap)), void 0 !== e2.metalnessMap && (n2.metalnessMap = r2(e2.metalnessMap)), void 0 !== e2.emissiveMap && (n2.emissiveMap = r2(e2.emissiveMap)), void 0 !== e2.emissiveIntensity && (n2.emissiveIntensity = e2.emissiveIntensity), void 0 !== e2.specularMap && (n2.specularMap = r2(e2.specularMap)), void 0 !== e2.specularIntensityMap && (n2.specularIntensityMap = r2(e2.specularIntensityMap)), void 0 !== e2.specularColorMap && (n2.specularColorMap = r2(e2.specularColorMap)), void 0 !== e2.envMap && (n2.envMap = r2(e2.envMap)), void 0 !== e2.envMapIntensity && (n2.envMapIntensity = e2.envMapIntensity), void 0 !== e2.reflectivity && (n2.reflectivity = e2.reflectivity), void 0 !== e2.refractionRatio && (n2.refractionRatio = e2.refractionRatio), void 0 !== e2.lightMap && (n2.lightMap = r2(e2.lightMap)), void 0 !== e2.lightMapIntensity && (n2.lightMapIntensity = e2.lightMapIntensity), void 0 !== e2.aoMap && (n2.aoMap = r2(e2.aoMap)), void 0 !== e2.aoMapIntensity && (n2.aoMapIntensity = e2.aoMapIntensity), void 0 !== e2.gradientMap && (n2.gradientMap = r2(e2.gradientMap)), void 0 !== e2.clearcoatMap && (n2.clearcoatMap = r2(e2.clearcoatMap)), void 0 !== e2.clearcoatRoughnessMap && (n2.clearcoatRoughnessMap = r2(e2.clearcoatRoughnessMap)), void 0 !== e2.clearcoatNormalMap && (n2.clearcoatNormalMap = r2(e2.clearcoatNormalMap)), void 0 !== e2.clearcoatNormalScale && (n2.clearcoatNormalScale = new kr().fromArray(e2.clearcoatNormalScale)), void 0 !== e2.iridescenceMap && (n2.iridescenceMap = r2(e2.iridescenceMap)), void 0 !== e2.iridescenceThicknessMap && (n2.iridescenceThicknessMap = r2(e2.iridescenceThicknessMap)), void 0 !== e2.transmissionMap && (n2.transmissionMap = r2(e2.transmissionMap)), void 0 !== e2.thicknessMap && (n2.thicknessMap = r2(e2.thicknessMap)), void 0 !== e2.sheenColorMap && (n2.sheenColorMap = r2(e2.sheenColorMap)), void 0 !== e2.sheenRoughnessMap && (n2.sheenRoughnessMap = r2(e2.sheenRoughnessMap)), n2;
    }
    setTextures(e2) {
      return this.textures = e2, this;
    }
    static createMaterialFromType(e2) {
      return new { ShadowMaterial: zu, SpriteMaterial: ml, RawShaderMaterial: Gu, ShaderMaterial: ms, PointsMaterial: lc, MeshPhysicalMaterial: Qu, MeshStandardMaterial: Vu, MeshPhongMaterial: Hu, MeshToonMaterial: Wu, MeshNormalMaterial: qu, MeshLambertMaterial: Xu, MeshDepthMaterial: qa, MeshDistanceMaterial: Xa, MeshBasicMaterial: Ei, MeshMatcapMaterial: Yu, LineDashedMaterial: Ku, LineBasicMaterial: Jl, Material: wi }[e2]();
    }
  }
  class Jh {
    static decodeText(e2) {
      if ("undefined" != typeof TextDecoder)
        return new TextDecoder().decode(e2);
      let t2 = "";
      for (let r2 = 0, n2 = e2.length; r2 < n2; r2++)
        t2 += String.fromCharCode(e2[r2]);
      try {
        return decodeURIComponent(escape(t2));
      } catch (e3) {
        return t2;
      }
    }
    static extractUrlBase(e2) {
      const t2 = e2.lastIndexOf("/");
      return -1 === t2 ? "./" : e2.slice(0, t2 + 1);
    }
    static resolveURL(e2, t2) {
      return "string" != typeof e2 || "" === e2 ? "" : (/^https?:\/\//i.test(t2) && /^\//.test(e2) && (t2 = t2.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e2) || /^data:.*,.*$/i.test(e2) || /^blob:.*$/i.test(e2) ? e2 : t2 + e2);
    }
  }
  class Zh extends Hi {
    constructor() {
      super(), this.isInstancedBufferGeometry = true, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
    }
    copy(e2) {
      return super.copy(e2), this.instanceCount = e2.instanceCount, this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const e2 = super.toJSON(this);
      return e2.instanceCount = this.instanceCount, e2.isInstancedBufferGeometry = true, e2;
    }
  }
  class $h extends yh {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, n2) {
      const i2 = this, s2 = new Eh(i2.manager);
      s2.setPath(i2.path), s2.setRequestHeader(i2.requestHeader), s2.setWithCredentials(i2.withCredentials), s2.load(e2, function(r3) {
        try {
          t2(i2.parse(JSON.parse(r3)));
        } catch (t3) {
          n2 ? n2(t3) : console.error(t3), i2.manager.itemError(e2);
        }
      }, r2, n2);
    }
    parse(e2) {
      const t2 = {}, r2 = {};
      function n2(e3, n3) {
        if (void 0 !== t2[n3])
          return t2[n3];
        const i3 = e3.interleavedBuffers[n3], s3 = function(e4, t3) {
          if (void 0 !== r2[t3])
            return r2[t3];
          const n4 = e4.arrayBuffers[t3], i4 = new Uint32Array(n4).buffer;
          return r2[t3] = i4, i4;
        }(e3, i3.buffer), o3 = Rr(i3.type, s3), a3 = new pl(o3, i3.stride);
        return a3.uuid = i3.uuid, t2[n3] = a3, a3;
      }
      const i2 = e2.isInstancedBufferGeometry ? new Zh() : new Hi(), s2 = e2.data.index;
      if (void 0 !== s2) {
        const e3 = Rr(s2.type, s2.array);
        i2.setIndex(new Mi(e3, 1));
      }
      const o2 = e2.data.attributes;
      for (const t3 in o2) {
        const r3 = o2[t3];
        let s3;
        if (r3.isInterleavedBufferAttribute) {
          const t4 = n2(e2.data, r3.data);
          s3 = new fl(t4, r3.itemSize, r3.offset, r3.normalized);
        } else {
          const e3 = Rr(r3.type, r3.array);
          s3 = new (r3.isInstancedBufferAttribute ? Hl : Mi)(e3, r3.itemSize, r3.normalized);
        }
        void 0 !== r3.name && (s3.name = r3.name), void 0 !== r3.usage && s3.setUsage(r3.usage), void 0 !== r3.updateRange && (s3.updateRange.offset = r3.updateRange.offset, s3.updateRange.count = r3.updateRange.count), i2.setAttribute(t3, s3);
      }
      const a2 = e2.data.morphAttributes;
      if (a2)
        for (const t3 in a2) {
          const r3 = a2[t3], s3 = [];
          for (let t4 = 0, i3 = r3.length; t4 < i3; t4++) {
            const i4 = r3[t4];
            let o3;
            if (i4.isInterleavedBufferAttribute) {
              const t5 = n2(e2.data, i4.data);
              o3 = new fl(t5, i4.itemSize, i4.offset, i4.normalized);
            } else {
              const e3 = Rr(i4.type, i4.array);
              o3 = new Mi(e3, i4.itemSize, i4.normalized);
            }
            void 0 !== i4.name && (o3.name = i4.name), s3.push(o3);
          }
          i2.morphAttributes[t3] = s3;
        }
      e2.data.morphTargetsRelative && (i2.morphTargetsRelative = true);
      const l2 = e2.data.groups || e2.data.drawcalls || e2.data.offsets;
      if (void 0 !== l2)
        for (let e3 = 0, t3 = l2.length; e3 !== t3; ++e3) {
          const t4 = l2[e3];
          i2.addGroup(t4.start, t4.count, t4.materialIndex);
        }
      const c2 = e2.data.boundingSphere;
      if (void 0 !== c2) {
        const e3 = new ln();
        void 0 !== c2.center && e3.fromArray(c2.center), i2.boundingSphere = new kn(e3, c2.radius);
      }
      return e2.name && (i2.name = e2.name), e2.userData && (i2.userData = e2.userData), i2;
    }
  }
  class ep extends yh {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, n2) {
      const i2 = this, s2 = "" === this.path ? Jh.extractUrlBase(e2) : this.path;
      this.resourcePath = this.resourcePath || s2;
      const o2 = new Eh(this.manager);
      o2.setPath(this.path), o2.setRequestHeader(this.requestHeader), o2.setWithCredentials(this.withCredentials), o2.load(e2, function(r3) {
        let s3 = null;
        try {
          s3 = JSON.parse(r3);
        } catch (t3) {
          return void 0 !== n2 && n2(t3), void console.error("THREE:ObjectLoader: Can't parse " + e2 + ".", t3.message);
        }
        const o3 = s3.metadata;
        void 0 !== o3 && void 0 !== o3.type && "geometry" !== o3.type.toLowerCase() ? i2.parse(s3, t2) : console.error("THREE.ObjectLoader: Can't load " + e2);
      }, r2, n2);
    }
    async loadAsync(e2, t2) {
      const r2 = "" === this.path ? Jh.extractUrlBase(e2) : this.path;
      this.resourcePath = this.resourcePath || r2;
      const n2 = new Eh(this.manager);
      n2.setPath(this.path), n2.setRequestHeader(this.requestHeader), n2.setWithCredentials(this.withCredentials);
      const i2 = await n2.loadAsync(e2, t2), s2 = JSON.parse(i2), o2 = s2.metadata;
      if (void 0 === o2 || void 0 === o2.type || "geometry" === o2.type.toLowerCase())
        throw new Error("THREE.ObjectLoader: Can't load " + e2);
      return await this.parseAsync(s2);
    }
    parse(e2, t2) {
      const r2 = this.parseAnimations(e2.animations), n2 = this.parseShapes(e2.shapes), i2 = this.parseGeometries(e2.geometries, n2), s2 = this.parseImages(e2.images, function() {
        void 0 !== t2 && t2(l2);
      }), o2 = this.parseTextures(e2.textures, s2), a2 = this.parseMaterials(e2.materials, o2), l2 = this.parseObject(e2.object, i2, a2, o2, r2), c2 = this.parseSkeletons(e2.skeletons, l2);
      if (this.bindSkeletons(l2, c2), void 0 !== t2) {
        let e3 = false;
        for (const t3 in s2)
          if (s2[t3].data instanceof HTMLImageElement) {
            e3 = true;
            break;
          }
        false === e3 && t2(l2);
      }
      return l2;
    }
    async parseAsync(e2) {
      const t2 = this.parseAnimations(e2.animations), r2 = this.parseShapes(e2.shapes), n2 = this.parseGeometries(e2.geometries, r2), i2 = await this.parseImagesAsync(e2.images), s2 = this.parseTextures(e2.textures, i2), o2 = this.parseMaterials(e2.materials, s2), a2 = this.parseObject(e2.object, n2, o2, s2, t2), l2 = this.parseSkeletons(e2.skeletons, a2);
      return this.bindSkeletons(a2, l2), a2;
    }
    parseShapes(e2) {
      const t2 = {};
      if (void 0 !== e2)
        for (let r2 = 0, n2 = e2.length; r2 < n2; r2++) {
          const n3 = new $c().fromJSON(e2[r2]);
          t2[n3.uuid] = n3;
        }
      return t2;
    }
    parseSkeletons(e2, t2) {
      const r2 = {}, n2 = {};
      if (t2.traverse(function(e3) {
        e3.isBone && (n2[e3.uuid] = e3);
      }), void 0 !== e2)
        for (let t3 = 0, i2 = e2.length; t3 < i2; t3++) {
          const i3 = new Ql().fromJSON(e2[t3], n2);
          r2[i3.uuid] = i3;
        }
      return r2;
    }
    parseGeometries(e2, t2) {
      const r2 = {};
      if (void 0 !== e2) {
        const n2 = new $h();
        for (let i2 = 0, s2 = e2.length; i2 < s2; i2++) {
          let s3;
          const o2 = e2[i2];
          switch (o2.type) {
            case "BufferGeometry":
            case "InstancedBufferGeometry":
              s3 = n2.parse(o2);
              break;
            default:
              o2.type in ju ? s3 = ju[o2.type].fromJSON(o2, t2) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o2.type}"`);
          }
          s3.uuid = o2.uuid, void 0 !== o2.name && (s3.name = o2.name), true === s3.isBufferGeometry && void 0 !== o2.userData && (s3.userData = o2.userData), r2[o2.uuid] = s3;
        }
      }
      return r2;
    }
    parseMaterials(e2, t2) {
      const r2 = {}, n2 = {};
      if (void 0 !== e2) {
        const i2 = new Kh();
        i2.setTextures(t2);
        for (let t3 = 0, s2 = e2.length; t3 < s2; t3++) {
          const s3 = e2[t3];
          void 0 === r2[s3.uuid] && (r2[s3.uuid] = i2.parse(s3)), n2[s3.uuid] = r2[s3.uuid];
        }
      }
      return n2;
    }
    parseAnimations(e2) {
      const t2 = {};
      if (void 0 !== e2)
        for (let r2 = 0; r2 < e2.length; r2++) {
          const n2 = e2[r2], i2 = _h.parse(n2);
          t2[i2.uuid] = i2;
        }
      return t2;
    }
    parseImages(e2, t2) {
      const r2 = this, n2 = {};
      let i2;
      function s2(e3) {
        if ("string" == typeof e3) {
          const t3 = e3;
          return function(e4) {
            return r2.manager.itemStart(e4), i2.load(e4, function() {
              r2.manager.itemEnd(e4);
            }, void 0, function() {
              r2.manager.itemError(e4), r2.manager.itemEnd(e4);
            });
          }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t3) ? t3 : r2.resourcePath + t3);
        }
        return e3.data ? { data: Rr(e3.type, e3.data), width: e3.width, height: e3.height, complete: true } : null;
      }
      if (void 0 !== e2 && e2.length > 0) {
        const r3 = new Ah(t2);
        i2 = new Mh(r3), i2.setCrossOrigin(this.crossOrigin);
        for (let t3 = 0, r4 = e2.length; t3 < r4; t3++) {
          const r5 = e2[t3], i3 = r5.url;
          if (Array.isArray(i3)) {
            const e3 = [];
            for (let t4 = 0, r6 = i3.length; t4 < r6; t4++) {
              const r7 = s2(i3[t4]);
              null !== r7 && (r7 instanceof HTMLImageElement ? e3.push(r7) : e3.push(new zl(r7.data, r7.width, r7.height)));
            }
            n2[r5.uuid] = new Yr(e3);
          } else {
            const e3 = s2(r5.url);
            n2[r5.uuid] = new Yr(e3);
          }
        }
      }
      return n2;
    }
    async parseImagesAsync(e2) {
      const t2 = this, r2 = {};
      let n2;
      async function i2(e3) {
        if ("string" == typeof e3) {
          const r3 = e3, i3 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(r3) ? r3 : t2.resourcePath + r3;
          return await n2.loadAsync(i3);
        }
        return e3.data ? { data: Rr(e3.type, e3.data), width: e3.width, height: e3.height, complete: true } : null;
      }
      if (void 0 !== e2 && e2.length > 0) {
        n2 = new Mh(this.manager), n2.setCrossOrigin(this.crossOrigin);
        for (let t3 = 0, n3 = e2.length; t3 < n3; t3++) {
          const n4 = e2[t3], s2 = n4.url;
          if (Array.isArray(s2)) {
            const e3 = [];
            for (let t4 = 0, r3 = s2.length; t4 < r3; t4++) {
              const r4 = s2[t4], n5 = await i2(r4);
              null !== n5 && (n5 instanceof HTMLImageElement ? e3.push(n5) : e3.push(new zl(n5.data, n5.width, n5.height)));
            }
            r2[n4.uuid] = new Yr(e3);
          } else {
            const e3 = await i2(n4.url);
            r2[n4.uuid] = new Yr(e3);
          }
        }
      }
      return r2;
    }
    parseTextures(e2, t2) {
      function r2(e3, t3) {
        return "number" == typeof e3 ? e3 : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e3), t3[e3]);
      }
      const n2 = {};
      if (void 0 !== e2)
        for (let i2 = 0, s2 = e2.length; i2 < s2; i2++) {
          const s3 = e2[i2];
          void 0 === s3.image && console.warn('THREE.ObjectLoader: No "image" specified for', s3.uuid), void 0 === t2[s3.image] && console.warn("THREE.ObjectLoader: Undefined image", s3.image);
          const o2 = t2[s3.image], a2 = o2 ? o2.data : void 0;
          let l2;
          Array.isArray(a2) ? (l2 = new bs(), 6 === a2.length && (l2.needsUpdate = true)) : (l2 = a2 && a2.data ? new zl() : new Zr(), a2 && a2.complete && (l2.needsUpdate = true)), l2.source = o2, l2.uuid = s3.uuid, void 0 !== s3.name && (l2.name = s3.name), void 0 !== s3.mapping && (l2.mapping = r2(s3.mapping, tp)), void 0 !== s3.offset && l2.offset.fromArray(s3.offset), void 0 !== s3.repeat && l2.repeat.fromArray(s3.repeat), void 0 !== s3.center && l2.center.fromArray(s3.center), void 0 !== s3.rotation && (l2.rotation = s3.rotation), void 0 !== s3.wrap && (l2.wrapS = r2(s3.wrap[0], rp), l2.wrapT = r2(s3.wrap[1], rp)), void 0 !== s3.format && (l2.format = s3.format), void 0 !== s3.type && (l2.type = s3.type), void 0 !== s3.encoding && (l2.encoding = s3.encoding), void 0 !== s3.minFilter && (l2.minFilter = r2(s3.minFilter, np)), void 0 !== s3.magFilter && (l2.magFilter = r2(s3.magFilter, np)), void 0 !== s3.anisotropy && (l2.anisotropy = s3.anisotropy), void 0 !== s3.flipY && (l2.flipY = s3.flipY), void 0 !== s3.premultiplyAlpha && (l2.premultiplyAlpha = s3.premultiplyAlpha), void 0 !== s3.unpackAlignment && (l2.unpackAlignment = s3.unpackAlignment), void 0 !== s3.userData && (l2.userData = s3.userData), n2[s3.uuid] = l2;
        }
      return n2;
    }
    parseObject(e2, t2, r2, n2, i2) {
      let s2, o2, a2;
      function l2(e3) {
        return void 0 === t2[e3] && console.warn("THREE.ObjectLoader: Undefined geometry", e3), t2[e3];
      }
      function c2(e3) {
        if (void 0 !== e3) {
          if (Array.isArray(e3)) {
            const t3 = [];
            for (let n3 = 0, i3 = e3.length; n3 < i3; n3++) {
              const i4 = e3[n3];
              void 0 === r2[i4] && console.warn("THREE.ObjectLoader: Undefined material", i4), t3.push(r2[i4]);
            }
            return t3;
          }
          return void 0 === r2[e3] && console.warn("THREE.ObjectLoader: Undefined material", e3), r2[e3];
        }
      }
      function u2(e3) {
        return void 0 === n2[e3] && console.warn("THREE.ObjectLoader: Undefined texture", e3), n2[e3];
      }
      switch (e2.type) {
        case "Scene":
          s2 = new hl(), void 0 !== e2.background && (Number.isInteger(e2.background) ? s2.background = new Wr(e2.background) : s2.background = u2(e2.background)), void 0 !== e2.environment && (s2.environment = u2(e2.environment)), void 0 !== e2.fog && ("Fog" === e2.fog.type ? s2.fog = new ul(e2.fog.color, e2.fog.near, e2.fog.far) : "FogExp2" === e2.fog.type && (s2.fog = new cl(e2.fog.color, e2.fog.density)));
          break;
        case "PerspectiveCamera":
          s2 = new gs(e2.fov, e2.aspect, e2.near, e2.far), void 0 !== e2.focus && (s2.focus = e2.focus), void 0 !== e2.zoom && (s2.zoom = e2.zoom), void 0 !== e2.filmGauge && (s2.filmGauge = e2.filmGauge), void 0 !== e2.filmOffset && (s2.filmOffset = e2.filmOffset), void 0 !== e2.view && (s2.view = Object.assign({}, e2.view));
          break;
        case "OrthographicCamera":
          s2 = new zs(e2.left, e2.right, e2.top, e2.bottom, e2.near, e2.far), void 0 !== e2.zoom && (s2.zoom = e2.zoom), void 0 !== e2.view && (s2.view = Object.assign({}, e2.view));
          break;
        case "AmbientLight":
          s2 = new Wh(e2.color, e2.intensity);
          break;
        case "DirectionalLight":
          s2 = new Hh(e2.color, e2.intensity);
          break;
        case "PointLight":
          s2 = new Vh(e2.color, e2.intensity, e2.distance, e2.decay);
          break;
        case "RectAreaLight":
          s2 = new qh(e2.color, e2.intensity, e2.width, e2.height);
          break;
        case "SpotLight":
          s2 = new Uh(e2.color, e2.intensity, e2.distance, e2.angle, e2.penumbra, e2.decay);
          break;
        case "HemisphereLight":
          s2 = new Ph(e2.color, e2.groundColor, e2.intensity);
          break;
        case "LightProbe":
          s2 = new Yh().fromJSON(e2);
          break;
        case "SkinnedMesh":
          o2 = l2(e2.geometry), a2 = c2(e2.material), s2 = new Nl(o2, a2), void 0 !== e2.bindMode && (s2.bindMode = e2.bindMode), void 0 !== e2.bindMatrix && s2.bindMatrix.fromArray(e2.bindMatrix), void 0 !== e2.skeleton && (s2.skeleton = e2.skeleton);
          break;
        case "Mesh":
          o2 = l2(e2.geometry), a2 = c2(e2.material), s2 = new cs(o2, a2);
          break;
        case "InstancedMesh":
          o2 = l2(e2.geometry), a2 = c2(e2.material);
          const t3 = e2.count, r3 = e2.instanceMatrix, n3 = e2.instanceColor;
          s2 = new Kl(o2, a2, t3), s2.instanceMatrix = new Hl(new Float32Array(r3.array), 16), void 0 !== n3 && (s2.instanceColor = new Hl(new Float32Array(n3.array), n3.itemSize));
          break;
        case "LOD":
          s2 = new Bl();
          break;
        case "Line":
          s2 = new nc(l2(e2.geometry), c2(e2.material));
          break;
        case "LineLoop":
          s2 = new ac(l2(e2.geometry), c2(e2.material));
          break;
        case "LineSegments":
          s2 = new oc(l2(e2.geometry), c2(e2.material));
          break;
        case "PointCloud":
        case "Points":
          s2 = new dc(l2(e2.geometry), c2(e2.material));
          break;
        case "Sprite":
          s2 = new Il(c2(e2.material));
          break;
        case "Group":
          s2 = new el();
          break;
        case "Bone":
          s2 = new jl();
          break;
        default:
          s2 = new ui();
      }
      if (s2.uuid = e2.uuid, void 0 !== e2.name && (s2.name = e2.name), void 0 !== e2.matrix ? (s2.matrix.fromArray(e2.matrix), void 0 !== e2.matrixAutoUpdate && (s2.matrixAutoUpdate = e2.matrixAutoUpdate), s2.matrixAutoUpdate && s2.matrix.decompose(s2.position, s2.quaternion, s2.scale)) : (void 0 !== e2.position && s2.position.fromArray(e2.position), void 0 !== e2.rotation && s2.rotation.fromArray(e2.rotation), void 0 !== e2.quaternion && s2.quaternion.fromArray(e2.quaternion), void 0 !== e2.scale && s2.scale.fromArray(e2.scale)), void 0 !== e2.castShadow && (s2.castShadow = e2.castShadow), void 0 !== e2.receiveShadow && (s2.receiveShadow = e2.receiveShadow), e2.shadow && (void 0 !== e2.shadow.bias && (s2.shadow.bias = e2.shadow.bias), void 0 !== e2.shadow.normalBias && (s2.shadow.normalBias = e2.shadow.normalBias), void 0 !== e2.shadow.radius && (s2.shadow.radius = e2.shadow.radius), void 0 !== e2.shadow.mapSize && s2.shadow.mapSize.fromArray(e2.shadow.mapSize), void 0 !== e2.shadow.camera && (s2.shadow.camera = this.parseObject(e2.shadow.camera))), void 0 !== e2.visible && (s2.visible = e2.visible), void 0 !== e2.frustumCulled && (s2.frustumCulled = e2.frustumCulled), void 0 !== e2.renderOrder && (s2.renderOrder = e2.renderOrder), void 0 !== e2.userData && (s2.userData = e2.userData), void 0 !== e2.layers && (s2.layers.mask = e2.layers), void 0 !== e2.children) {
        const o3 = e2.children;
        for (let e3 = 0; e3 < o3.length; e3++)
          s2.add(this.parseObject(o3[e3], t2, r2, n2, i2));
      }
      if (void 0 !== e2.animations) {
        const t3 = e2.animations;
        for (let e3 = 0; e3 < t3.length; e3++) {
          const r3 = t3[e3];
          s2.animations.push(i2[r3]);
        }
      }
      if ("LOD" === e2.type) {
        void 0 !== e2.autoUpdate && (s2.autoUpdate = e2.autoUpdate);
        const t3 = e2.levels;
        for (let e3 = 0; e3 < t3.length; e3++) {
          const r3 = t3[e3], n3 = s2.getObjectByProperty("uuid", r3.object);
          void 0 !== n3 && s2.addLevel(n3, r3.distance);
        }
      }
      return s2;
    }
    bindSkeletons(e2, t2) {
      0 !== Object.keys(t2).length && e2.traverse(function(e3) {
        if (true === e3.isSkinnedMesh && void 0 !== e3.skeleton) {
          const r2 = t2[e3.skeleton];
          void 0 === r2 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e3.skeleton) : e3.bind(r2, e3.bindMatrix);
        }
      });
    }
  }
  const tp = { UVMapping: re, CubeReflectionMapping: ne, CubeRefractionMapping: ie, EquirectangularReflectionMapping: se, EquirectangularRefractionMapping: oe, CubeUVReflectionMapping: ae }, rp = { RepeatWrapping: le, ClampToEdgeWrapping: ce, MirroredRepeatWrapping: ue }, np = { NearestFilter: he, NearestMipmapNearestFilter: pe, NearestMipmapLinearFilter: fe, LinearFilter: _e, LinearMipmapNearestFilter: ge, LinearMipmapLinearFilter: Ae };
  class ip extends yh {
    constructor(e2) {
      super(e2), this.isImageBitmapLoader = true, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
    }
    setOptions(e2) {
      return this.options = e2, this;
    }
    load(e2, t2, r2, n2) {
      void 0 === e2 && (e2 = ""), void 0 !== this.path && (e2 = this.path + e2), e2 = this.manager.resolveURL(e2);
      const i2 = this, s2 = vh.get(e2);
      if (void 0 !== s2)
        return i2.manager.itemStart(e2), setTimeout(function() {
          t2 && t2(s2), i2.manager.itemEnd(e2);
        }, 0), s2;
      const o2 = {};
      o2.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o2.headers = this.requestHeader, fetch(e2, o2).then(function(e3) {
        return e3.blob();
      }).then(function(e3) {
        return createImageBitmap(e3, Object.assign(i2.options, { colorSpaceConversion: "none" }));
      }).then(function(r3) {
        vh.add(e2, r3), t2 && t2(r3), i2.manager.itemEnd(e2);
      }).catch(function(t3) {
        n2 && n2(t3), i2.manager.itemError(e2), i2.manager.itemEnd(e2);
      }), i2.manager.itemStart(e2);
    }
  }
  let sp;
  const op = { getContext: function() {
    return void 0 === sp && (sp = new (window.AudioContext || window.webkitAudioContext)()), sp;
  }, setContext: function(e2) {
    sp = e2;
  } };
  class ap extends yh {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, n2) {
      const i2 = this, s2 = new Eh(this.manager);
      s2.setResponseType("arraybuffer"), s2.setPath(this.path), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(this.withCredentials), s2.load(e2, function(r3) {
        try {
          const e3 = r3.slice(0);
          op.getContext().decodeAudioData(e3, function(e4) {
            t2(e4);
          });
        } catch (t3) {
          n2 ? n2(t3) : console.error(t3), i2.manager.itemError(e2);
        }
      }, r2, n2);
    }
  }
  class lp extends Yh {
    constructor(e2, t2, r2 = 1) {
      super(void 0, r2), this.isHemisphereLightProbe = true;
      const n2 = new Wr().set(e2), i2 = new Wr().set(t2), s2 = new ln(n2.r, n2.g, n2.b), o2 = new ln(i2.r, i2.g, i2.b), a2 = Math.sqrt(Math.PI), l2 = a2 * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(s2).add(o2).multiplyScalar(a2), this.sh.coefficients[1].copy(s2).sub(o2).multiplyScalar(l2);
    }
  }
  class cp extends Yh {
    constructor(e2, t2 = 1) {
      super(void 0, t2), this.isAmbientLightProbe = true;
      const r2 = new Wr().set(e2);
      this.sh.coefficients[0].set(r2.r, r2.g, r2.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
  }
  const up = new Nn(), hp = new Nn(), pp = new Nn();
  class dp {
    constructor() {
      this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new gs(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new gs(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
    }
    update(e2) {
      const t2 = this._cache;
      if (t2.focus !== e2.focus || t2.fov !== e2.fov || t2.aspect !== e2.aspect * this.aspect || t2.near !== e2.near || t2.far !== e2.far || t2.zoom !== e2.zoom || t2.eyeSep !== this.eyeSep) {
        t2.focus = e2.focus, t2.fov = e2.fov, t2.aspect = e2.aspect * this.aspect, t2.near = e2.near, t2.far = e2.far, t2.zoom = e2.zoom, t2.eyeSep = this.eyeSep, pp.copy(e2.projectionMatrix);
        const r2 = t2.eyeSep / 2, n2 = r2 * t2.near / t2.focus, i2 = t2.near * Math.tan(vr * t2.fov * 0.5) / t2.zoom;
        let s2, o2;
        hp.elements[12] = -r2, up.elements[12] = r2, s2 = -i2 * t2.aspect + n2, o2 = i2 * t2.aspect + n2, pp.elements[0] = 2 * t2.near / (o2 - s2), pp.elements[8] = (o2 + s2) / (o2 - s2), this.cameraL.projectionMatrix.copy(pp), s2 = -i2 * t2.aspect - n2, o2 = i2 * t2.aspect - n2, pp.elements[0] = 2 * t2.near / (o2 - s2), pp.elements[8] = (o2 + s2) / (o2 - s2), this.cameraR.projectionMatrix.copy(pp);
      }
      this.cameraL.matrixWorld.copy(e2.matrixWorld).multiply(hp), this.cameraR.matrixWorld.copy(e2.matrixWorld).multiply(up);
    }
  }
  class fp {
    constructor(e2 = true) {
      this.autoStart = e2, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
    }
    start() {
      this.startTime = mp(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
    }
    stop() {
      this.getElapsedTime(), this.running = false, this.autoStart = false;
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let e2 = 0;
      if (this.autoStart && !this.running)
        return this.start(), 0;
      if (this.running) {
        const t2 = mp();
        e2 = (t2 - this.oldTime) / 1e3, this.oldTime = t2, this.elapsedTime += e2;
      }
      return e2;
    }
  }
  function mp() {
    return ("undefined" == typeof performance ? Date : performance).now();
  }
  const _p = new ln(), gp = new an(), vp = new ln(), Ap = new ln();
  class bp extends ui {
    constructor() {
      super(), this.type = "AudioListener", this.context = op.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new fp();
    }
    getInput() {
      return this.gain;
    }
    removeFilter() {
      return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
    }
    getFilter() {
      return this.filter;
    }
    setFilter(e2) {
      return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e2, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
    }
    getMasterVolume() {
      return this.gain.gain.value;
    }
    setMasterVolume(e2) {
      return this.gain.gain.setTargetAtTime(e2, this.context.currentTime, 0.01), this;
    }
    updateMatrixWorld(e2) {
      super.updateMatrixWorld(e2);
      const t2 = this.context.listener, r2 = this.up;
      if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(_p, gp, vp), Ap.set(0, 0, -1).applyQuaternion(gp), t2.positionX) {
        const e3 = this.context.currentTime + this.timeDelta;
        t2.positionX.linearRampToValueAtTime(_p.x, e3), t2.positionY.linearRampToValueAtTime(_p.y, e3), t2.positionZ.linearRampToValueAtTime(_p.z, e3), t2.forwardX.linearRampToValueAtTime(Ap.x, e3), t2.forwardY.linearRampToValueAtTime(Ap.y, e3), t2.forwardZ.linearRampToValueAtTime(Ap.z, e3), t2.upX.linearRampToValueAtTime(r2.x, e3), t2.upY.linearRampToValueAtTime(r2.y, e3), t2.upZ.linearRampToValueAtTime(r2.z, e3);
      } else
        t2.setPosition(_p.x, _p.y, _p.z), t2.setOrientation(Ap.x, Ap.y, Ap.z, r2.x, r2.y, r2.z);
    }
  }
  class yp extends ui {
    constructor(e2) {
      super(), this.type = "Audio", this.listener = e2, this.context = e2.context, this.gain = this.context.createGain(), this.gain.connect(e2.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(e2) {
      return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = e2, this.connect(), this;
    }
    setMediaElementSource(e2) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e2), this.connect(), this;
    }
    setMediaStreamSource(e2) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e2), this.connect(), this;
    }
    setBuffer(e2) {
      return this.buffer = e2, this.sourceType = "buffer", this.autoplay && this.play(), this;
    }
    play(e2 = 0) {
      if (true === this.isPlaying)
        return void console.warn("THREE.Audio: Audio is already playing.");
      if (false === this.hasPlaybackControl)
        return void console.warn("THREE.Audio: this Audio has no playback control.");
      this._startedAt = this.context.currentTime + e2;
      const t2 = this.context.createBufferSource();
      return t2.buffer = this.buffer, t2.loop = this.loop, t2.loopStart = this.loopStart, t2.loopEnd = this.loopEnd, t2.onended = this.onEnded.bind(this), t2.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = t2, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
    }
    pause() {
      if (false !== this.hasPlaybackControl)
        return true === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, true === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    stop() {
      if (false !== this.hasPlaybackControl)
        return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let e2 = 1, t2 = this.filters.length; e2 < t2; e2++)
          this.filters[e2 - 1].connect(this.filters[e2]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else
        this.source.connect(this.getOutput());
      return this._connected = true, this;
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e2 = 1, t2 = this.filters.length; e2 < t2; e2++)
          this.filters[e2 - 1].disconnect(this.filters[e2]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = false, this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(e2) {
      return e2 || (e2 = []), true === this._connected ? (this.disconnect(), this.filters = e2.slice(), this.connect()) : this.filters = e2.slice(), this;
    }
    setDetune(e2) {
      if (this.detune = e2, void 0 !== this.source.detune)
        return true === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(e2) {
      return this.setFilters(e2 ? [e2] : []);
    }
    setPlaybackRate(e2) {
      if (false !== this.hasPlaybackControl)
        return this.playbackRate = e2, true === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = false;
    }
    getLoop() {
      return false === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
    }
    setLoop(e2) {
      if (false !== this.hasPlaybackControl)
        return this.loop = e2, true === this.isPlaying && (this.source.loop = this.loop), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    setLoopStart(e2) {
      return this.loopStart = e2, this;
    }
    setLoopEnd(e2) {
      return this.loopEnd = e2, this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(e2) {
      return this.gain.gain.setTargetAtTime(e2, this.context.currentTime, 0.01), this;
    }
  }
  const xp = new ln(), wp = new an(), Ep = new ln(), Sp = new ln();
  class Cp extends yp {
    constructor(e2) {
      super(e2), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
    }
    disconnect() {
      super.disconnect(), this.panner.disconnect(this.gain);
    }
    getOutput() {
      return this.panner;
    }
    getRefDistance() {
      return this.panner.refDistance;
    }
    setRefDistance(e2) {
      return this.panner.refDistance = e2, this;
    }
    getRolloffFactor() {
      return this.panner.rolloffFactor;
    }
    setRolloffFactor(e2) {
      return this.panner.rolloffFactor = e2, this;
    }
    getDistanceModel() {
      return this.panner.distanceModel;
    }
    setDistanceModel(e2) {
      return this.panner.distanceModel = e2, this;
    }
    getMaxDistance() {
      return this.panner.maxDistance;
    }
    setMaxDistance(e2) {
      return this.panner.maxDistance = e2, this;
    }
    setDirectionalCone(e2, t2, r2) {
      return this.panner.coneInnerAngle = e2, this.panner.coneOuterAngle = t2, this.panner.coneOuterGain = r2, this;
    }
    updateMatrixWorld(e2) {
      if (super.updateMatrixWorld(e2), true === this.hasPlaybackControl && false === this.isPlaying)
        return;
      this.matrixWorld.decompose(xp, wp, Ep), Sp.set(0, 0, 1).applyQuaternion(wp);
      const t2 = this.panner;
      if (t2.positionX) {
        const e3 = this.context.currentTime + this.listener.timeDelta;
        t2.positionX.linearRampToValueAtTime(xp.x, e3), t2.positionY.linearRampToValueAtTime(xp.y, e3), t2.positionZ.linearRampToValueAtTime(xp.z, e3), t2.orientationX.linearRampToValueAtTime(Sp.x, e3), t2.orientationY.linearRampToValueAtTime(Sp.y, e3), t2.orientationZ.linearRampToValueAtTime(Sp.z, e3);
      } else
        t2.setPosition(xp.x, xp.y, xp.z), t2.setOrientation(Sp.x, Sp.y, Sp.z);
    }
  }
  class Mp {
    constructor(e2, t2 = 2048) {
      this.analyser = e2.context.createAnalyser(), this.analyser.fftSize = t2, this.data = new Uint8Array(this.analyser.frequencyBinCount), e2.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
      return this.analyser.getByteFrequencyData(this.data), this.data;
    }
    getAverageFrequency() {
      let e2 = 0;
      const t2 = this.getFrequencyData();
      for (let r2 = 0; r2 < t2.length; r2++)
        e2 += t2[r2];
      return e2 / t2.length;
    }
  }
  class Tp {
    constructor(e2, t2, r2) {
      let n2, i2, s2;
      switch (this.binding = e2, this.valueSize = r2, t2) {
        case "quaternion":
          n2 = this._slerp, i2 = this._slerpAdditive, s2 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * r2), this._workIndex = 5;
          break;
        case "string":
        case "bool":
          n2 = this._select, i2 = this._select, s2 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * r2);
          break;
        default:
          n2 = this._lerp, i2 = this._lerpAdditive, s2 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * r2);
      }
      this._mixBufferRegion = n2, this._mixBufferRegionAdditive = i2, this._setIdentity = s2, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
    }
    accumulate(e2, t2) {
      const r2 = this.buffer, n2 = this.valueSize, i2 = e2 * n2 + n2;
      let s2 = this.cumulativeWeight;
      if (0 === s2) {
        for (let e3 = 0; e3 !== n2; ++e3)
          r2[i2 + e3] = r2[e3];
        s2 = t2;
      } else {
        s2 += t2;
        const e3 = t2 / s2;
        this._mixBufferRegion(r2, i2, 0, e3, n2);
      }
      this.cumulativeWeight = s2;
    }
    accumulateAdditive(e2) {
      const t2 = this.buffer, r2 = this.valueSize, n2 = r2 * this._addIndex;
      0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t2, n2, 0, e2, r2), this.cumulativeWeightAdditive += e2;
    }
    apply(e2) {
      const t2 = this.valueSize, r2 = this.buffer, n2 = e2 * t2 + t2, i2 = this.cumulativeWeight, s2 = this.cumulativeWeightAdditive, o2 = this.binding;
      if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i2 < 1) {
        const e3 = t2 * this._origIndex;
        this._mixBufferRegion(r2, n2, e3, 1 - i2, t2);
      }
      s2 > 0 && this._mixBufferRegionAdditive(r2, n2, this._addIndex * t2, 1, t2);
      for (let e3 = t2, i3 = t2 + t2; e3 !== i3; ++e3)
        if (r2[e3] !== r2[e3 + t2]) {
          o2.setValue(r2, n2);
          break;
        }
    }
    saveOriginalState() {
      const e2 = this.binding, t2 = this.buffer, r2 = this.valueSize, n2 = r2 * this._origIndex;
      e2.getValue(t2, n2);
      for (let e3 = r2, i2 = n2; e3 !== i2; ++e3)
        t2[e3] = t2[n2 + e3 % r2];
      this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
      const e2 = 3 * this.valueSize;
      this.binding.setValue(this.buffer, e2);
    }
    _setAdditiveIdentityNumeric() {
      const e2 = this._addIndex * this.valueSize, t2 = e2 + this.valueSize;
      for (let r2 = e2; r2 < t2; r2++)
        this.buffer[r2] = 0;
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      const e2 = this._origIndex * this.valueSize, t2 = this._addIndex * this.valueSize;
      for (let r2 = 0; r2 < this.valueSize; r2++)
        this.buffer[t2 + r2] = this.buffer[e2 + r2];
    }
    _select(e2, t2, r2, n2, i2) {
      if (n2 >= 0.5)
        for (let n3 = 0; n3 !== i2; ++n3)
          e2[t2 + n3] = e2[r2 + n3];
    }
    _slerp(e2, t2, r2, n2) {
      an.slerpFlat(e2, t2, e2, t2, e2, r2, n2);
    }
    _slerpAdditive(e2, t2, r2, n2, i2) {
      const s2 = this._workIndex * i2;
      an.multiplyQuaternionsFlat(e2, s2, e2, t2, e2, r2), an.slerpFlat(e2, t2, e2, t2, e2, s2, n2);
    }
    _lerp(e2, t2, r2, n2, i2) {
      const s2 = 1 - n2;
      for (let o2 = 0; o2 !== i2; ++o2) {
        const i3 = t2 + o2;
        e2[i3] = e2[i3] * s2 + e2[r2 + o2] * n2;
      }
    }
    _lerpAdditive(e2, t2, r2, n2, i2) {
      for (let s2 = 0; s2 !== i2; ++s2) {
        const i3 = t2 + s2;
        e2[i3] = e2[i3] + e2[r2 + s2] * n2;
      }
    }
  }
  const Ip = new RegExp("[\\[\\]\\.:\\/]", "g"), kp = "[^\\[\\]\\.:\\/]", Dp = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Pp = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", kp) + /(WCOD+)?/.source.replace("WCOD", Dp) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", kp) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", kp) + "$"), Bp = ["material", "materials", "bones", "map"];
  class Rp {
    constructor(e2, t2, r2) {
      this.path = t2, this.parsedPath = r2 || Rp.parseTrackName(t2), this.node = Rp.findNode(e2, this.parsedPath.nodeName) || e2, this.rootNode = e2, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
    static create(e2, t2, r2) {
      return e2 && e2.isAnimationObjectGroup ? new Rp.Composite(e2, t2, r2) : new Rp(e2, t2, r2);
    }
    static sanitizeNodeName(e2) {
      return e2.replace(/\s/g, "_").replace(Ip, "");
    }
    static parseTrackName(e2) {
      const t2 = Pp.exec(e2);
      if (null === t2)
        throw new Error("PropertyBinding: Cannot parse trackName: " + e2);
      const r2 = { nodeName: t2[2], objectName: t2[3], objectIndex: t2[4], propertyName: t2[5], propertyIndex: t2[6] }, n2 = r2.nodeName && r2.nodeName.lastIndexOf(".");
      if (void 0 !== n2 && -1 !== n2) {
        const e3 = r2.nodeName.substring(n2 + 1);
        -1 !== Bp.indexOf(e3) && (r2.nodeName = r2.nodeName.substring(0, n2), r2.objectName = e3);
      }
      if (null === r2.propertyName || 0 === r2.propertyName.length)
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e2);
      return r2;
    }
    static findNode(e2, t2) {
      if (void 0 === t2 || "" === t2 || "." === t2 || -1 === t2 || t2 === e2.name || t2 === e2.uuid)
        return e2;
      if (e2.skeleton) {
        const r2 = e2.skeleton.getBoneByName(t2);
        if (void 0 !== r2)
          return r2;
      }
      if (e2.children) {
        const r2 = function(e3) {
          for (let n3 = 0; n3 < e3.length; n3++) {
            const i2 = e3[n3];
            if (i2.name === t2 || i2.uuid === t2)
              return i2;
            const s2 = r2(i2.children);
            if (s2)
              return s2;
          }
          return null;
        }, n2 = r2(e2.children);
        if (n2)
          return n2;
      }
      return null;
    }
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    _getValue_direct(e2, t2) {
      e2[t2] = this.targetObject[this.propertyName];
    }
    _getValue_array(e2, t2) {
      const r2 = this.resolvedProperty;
      for (let n2 = 0, i2 = r2.length; n2 !== i2; ++n2)
        e2[t2++] = r2[n2];
    }
    _getValue_arrayElement(e2, t2) {
      e2[t2] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(e2, t2) {
      this.resolvedProperty.toArray(e2, t2);
    }
    _setValue_direct(e2, t2) {
      this.targetObject[this.propertyName] = e2[t2];
    }
    _setValue_direct_setNeedsUpdate(e2, t2) {
      this.targetObject[this.propertyName] = e2[t2], this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e2, t2) {
      this.targetObject[this.propertyName] = e2[t2], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_array(e2, t2) {
      const r2 = this.resolvedProperty;
      for (let n2 = 0, i2 = r2.length; n2 !== i2; ++n2)
        r2[n2] = e2[t2++];
    }
    _setValue_array_setNeedsUpdate(e2, t2) {
      const r2 = this.resolvedProperty;
      for (let n2 = 0, i2 = r2.length; n2 !== i2; ++n2)
        r2[n2] = e2[t2++];
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e2, t2) {
      const r2 = this.resolvedProperty;
      for (let n2 = 0, i2 = r2.length; n2 !== i2; ++n2)
        r2[n2] = e2[t2++];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_arrayElement(e2, t2) {
      this.resolvedProperty[this.propertyIndex] = e2[t2];
    }
    _setValue_arrayElement_setNeedsUpdate(e2, t2) {
      this.resolvedProperty[this.propertyIndex] = e2[t2], this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e2, t2) {
      this.resolvedProperty[this.propertyIndex] = e2[t2], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_fromArray(e2, t2) {
      this.resolvedProperty.fromArray(e2, t2);
    }
    _setValue_fromArray_setNeedsUpdate(e2, t2) {
      this.resolvedProperty.fromArray(e2, t2), this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e2, t2) {
      this.resolvedProperty.fromArray(e2, t2), this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(e2, t2) {
      this.bind(), this.getValue(e2, t2);
    }
    _setValue_unbound(e2, t2) {
      this.bind(), this.setValue(e2, t2);
    }
    bind() {
      let e2 = this.node;
      const t2 = this.parsedPath, r2 = t2.objectName, n2 = t2.propertyName;
      let i2 = t2.propertyIndex;
      if (e2 || (e2 = Rp.findNode(this.rootNode, t2.nodeName) || this.rootNode, this.node = e2), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e2)
        return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      if (r2) {
        let n3 = t2.objectIndex;
        switch (r2) {
          case "materials":
            if (!e2.material)
              return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            if (!e2.material.materials)
              return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            e2 = e2.material.materials;
            break;
          case "bones":
            if (!e2.skeleton)
              return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            e2 = e2.skeleton.bones;
            for (let t3 = 0; t3 < e2.length; t3++)
              if (e2[t3].name === n3) {
                n3 = t3;
                break;
              }
            break;
          case "map":
            if (!e2.material)
              return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            if (!e2.material.map)
              return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            e2 = e2.material.map;
            break;
          default:
            if (void 0 === e2[r2])
              return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            e2 = e2[r2];
        }
        if (void 0 !== n3) {
          if (void 0 === e2[n3])
            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e2);
          e2 = e2[n3];
        }
      }
      const s2 = e2[n2];
      if (void 0 === s2) {
        const r3 = t2.nodeName;
        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + r3 + "." + n2 + " but it wasn't found.", e2);
      }
      let o2 = this.Versioning.None;
      this.targetObject = e2, void 0 !== e2.needsUpdate ? o2 = this.Versioning.NeedsUpdate : void 0 !== e2.matrixWorldNeedsUpdate && (o2 = this.Versioning.MatrixWorldNeedsUpdate);
      let a2 = this.BindingType.Direct;
      if (void 0 !== i2) {
        if ("morphTargetInfluences" === n2) {
          if (!e2.geometry)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          if (!e2.geometry.morphAttributes)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          void 0 !== e2.morphTargetDictionary[i2] && (i2 = e2.morphTargetDictionary[i2]);
        }
        a2 = this.BindingType.ArrayElement, this.resolvedProperty = s2, this.propertyIndex = i2;
      } else
        void 0 !== s2.fromArray && void 0 !== s2.toArray ? (a2 = this.BindingType.HasFromToArray, this.resolvedProperty = s2) : Array.isArray(s2) ? (a2 = this.BindingType.EntireArray, this.resolvedProperty = s2) : this.propertyName = n2;
      this.getValue = this.GetterByBindingType[a2], this.setValue = this.SetterByBindingTypeAndVersioning[a2][o2];
    }
    unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }
  Rp.Composite = class {
    constructor(e2, t2, r2) {
      const n2 = r2 || Rp.parseTrackName(t2);
      this._targetGroup = e2, this._bindings = e2.subscribe_(t2, n2);
    }
    getValue(e2, t2) {
      this.bind();
      const r2 = this._targetGroup.nCachedObjects_, n2 = this._bindings[r2];
      void 0 !== n2 && n2.getValue(e2, t2);
    }
    setValue(e2, t2) {
      const r2 = this._bindings;
      for (let n2 = this._targetGroup.nCachedObjects_, i2 = r2.length; n2 !== i2; ++n2)
        r2[n2].setValue(e2, t2);
    }
    bind() {
      const e2 = this._bindings;
      for (let t2 = this._targetGroup.nCachedObjects_, r2 = e2.length; t2 !== r2; ++t2)
        e2[t2].bind();
    }
    unbind() {
      const e2 = this._bindings;
      for (let t2 = this._targetGroup.nCachedObjects_, r2 = e2.length; t2 !== r2; ++t2)
        e2[t2].unbind();
    }
  }, Rp.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Rp.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Rp.prototype.GetterByBindingType = [Rp.prototype._getValue_direct, Rp.prototype._getValue_array, Rp.prototype._getValue_arrayElement, Rp.prototype._getValue_toArray], Rp.prototype.SetterByBindingTypeAndVersioning = [[Rp.prototype._setValue_direct, Rp.prototype._setValue_direct_setNeedsUpdate, Rp.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Rp.prototype._setValue_array, Rp.prototype._setValue_array_setNeedsUpdate, Rp.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Rp.prototype._setValue_arrayElement, Rp.prototype._setValue_arrayElement_setNeedsUpdate, Rp.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Rp.prototype._setValue_fromArray, Rp.prototype._setValue_fromArray_setNeedsUpdate, Rp.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
  class Lp {
    constructor() {
      this.isAnimationObjectGroup = true, this.uuid = br(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
      const e2 = {};
      this._indicesByUUID = e2;
      for (let t3 = 0, r2 = arguments.length; t3 !== r2; ++t3)
        e2[arguments[t3].uuid] = t3;
      this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
      const t2 = this;
      this.stats = { objects: { get total() {
        return t2._objects.length;
      }, get inUse() {
        return this.total - t2.nCachedObjects_;
      } }, get bindingsPerObject() {
        return t2._bindings.length;
      } };
    }
    add() {
      const e2 = this._objects, t2 = this._indicesByUUID, r2 = this._paths, n2 = this._parsedPaths, i2 = this._bindings, s2 = i2.length;
      let o2, a2 = e2.length, l2 = this.nCachedObjects_;
      for (let c2 = 0, u2 = arguments.length; c2 !== u2; ++c2) {
        const u3 = arguments[c2], h2 = u3.uuid;
        let p2 = t2[h2];
        if (void 0 === p2) {
          p2 = a2++, t2[h2] = p2, e2.push(u3);
          for (let e3 = 0, t3 = s2; e3 !== t3; ++e3)
            i2[e3].push(new Rp(u3, r2[e3], n2[e3]));
        } else if (p2 < l2) {
          o2 = e2[p2];
          const a3 = --l2, c3 = e2[a3];
          t2[c3.uuid] = p2, e2[p2] = c3, t2[h2] = a3, e2[a3] = u3;
          for (let e3 = 0, t3 = s2; e3 !== t3; ++e3) {
            const t4 = i2[e3], s3 = t4[a3];
            let o3 = t4[p2];
            t4[p2] = s3, void 0 === o3 && (o3 = new Rp(u3, r2[e3], n2[e3])), t4[a3] = o3;
          }
        } else
          e2[p2] !== o2 && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
      this.nCachedObjects_ = l2;
    }
    remove() {
      const e2 = this._objects, t2 = this._indicesByUUID, r2 = this._bindings, n2 = r2.length;
      let i2 = this.nCachedObjects_;
      for (let s2 = 0, o2 = arguments.length; s2 !== o2; ++s2) {
        const o3 = arguments[s2], a2 = o3.uuid, l2 = t2[a2];
        if (void 0 !== l2 && l2 >= i2) {
          const s3 = i2++, c2 = e2[s3];
          t2[c2.uuid] = l2, e2[l2] = c2, t2[a2] = s3, e2[s3] = o3;
          for (let e3 = 0, t3 = n2; e3 !== t3; ++e3) {
            const t4 = r2[e3], n3 = t4[s3], i3 = t4[l2];
            t4[l2] = n3, t4[s3] = i3;
          }
        }
      }
      this.nCachedObjects_ = i2;
    }
    uncache() {
      const e2 = this._objects, t2 = this._indicesByUUID, r2 = this._bindings, n2 = r2.length;
      let i2 = this.nCachedObjects_, s2 = e2.length;
      for (let o2 = 0, a2 = arguments.length; o2 !== a2; ++o2) {
        const a3 = arguments[o2].uuid, l2 = t2[a3];
        if (void 0 !== l2)
          if (delete t2[a3], l2 < i2) {
            const o3 = --i2, a4 = e2[o3], c2 = --s2, u2 = e2[c2];
            t2[a4.uuid] = l2, e2[l2] = a4, t2[u2.uuid] = o3, e2[o3] = u2, e2.pop();
            for (let e3 = 0, t3 = n2; e3 !== t3; ++e3) {
              const t4 = r2[e3], n3 = t4[o3], i3 = t4[c2];
              t4[l2] = n3, t4[o3] = i3, t4.pop();
            }
          } else {
            const i3 = --s2, o3 = e2[i3];
            i3 > 0 && (t2[o3.uuid] = l2), e2[l2] = o3, e2.pop();
            for (let e3 = 0, t3 = n2; e3 !== t3; ++e3) {
              const t4 = r2[e3];
              t4[l2] = t4[i3], t4.pop();
            }
          }
      }
      this.nCachedObjects_ = i2;
    }
    subscribe_(e2, t2) {
      const r2 = this._bindingsIndicesByPath;
      let n2 = r2[e2];
      const i2 = this._bindings;
      if (void 0 !== n2)
        return i2[n2];
      const s2 = this._paths, o2 = this._parsedPaths, a2 = this._objects, l2 = a2.length, c2 = this.nCachedObjects_, u2 = new Array(l2);
      n2 = i2.length, r2[e2] = n2, s2.push(e2), o2.push(t2), i2.push(u2);
      for (let r3 = c2, n3 = a2.length; r3 !== n3; ++r3) {
        const n4 = a2[r3];
        u2[r3] = new Rp(n4, e2, t2);
      }
      return u2;
    }
    unsubscribe_(e2) {
      const t2 = this._bindingsIndicesByPath, r2 = t2[e2];
      if (void 0 !== r2) {
        const n2 = this._paths, i2 = this._parsedPaths, s2 = this._bindings, o2 = s2.length - 1, a2 = s2[o2];
        t2[e2[o2]] = r2, s2[r2] = a2, s2.pop(), i2[r2] = i2[o2], i2.pop(), n2[r2] = n2[o2], n2.pop();
      }
    }
  }
  class Op {
    constructor(e2, t2, r2 = null, n2 = t2.blendMode) {
      this._mixer = e2, this._clip = t2, this._localRoot = r2, this.blendMode = n2;
      const i2 = t2.tracks, s2 = i2.length, o2 = new Array(s2), a2 = { endingStart: xt, endingEnd: xt };
      for (let e3 = 0; e3 !== s2; ++e3) {
        const t3 = i2[e3].createInterpolant(null);
        o2[e3] = t3, t3.settings = a2;
      }
      this._interpolantSettings = a2, this._interpolants = o2, this._propertyBindings = new Array(s2), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = gt, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
    }
    play() {
      return this._mixer._activateAction(this), this;
    }
    stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
      return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(e2) {
      return this._startTime = e2, this;
    }
    setLoop(e2, t2) {
      return this.loop = e2, this.repetitions = t2, this;
    }
    setEffectiveWeight(e2) {
      return this.weight = e2, this._effectiveWeight = this.enabled ? e2 : 0, this.stopFading();
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(e2) {
      return this._scheduleFading(e2, 0, 1);
    }
    fadeOut(e2) {
      return this._scheduleFading(e2, 1, 0);
    }
    crossFadeFrom(e2, t2, r2) {
      if (e2.fadeOut(t2), this.fadeIn(t2), r2) {
        const r3 = this._clip.duration, n2 = e2._clip.duration, i2 = n2 / r3, s2 = r3 / n2;
        e2.warp(1, i2, t2), this.warp(s2, 1, t2);
      }
      return this;
    }
    crossFadeTo(e2, t2, r2) {
      return e2.crossFadeFrom(this, t2, r2);
    }
    stopFading() {
      const e2 = this._weightInterpolant;
      return null !== e2 && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e2)), this;
    }
    setEffectiveTimeScale(e2) {
      return this.timeScale = e2, this._effectiveTimeScale = this.paused ? 0 : e2, this.stopWarping();
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(e2) {
      return this.timeScale = this._clip.duration / e2, this.stopWarping();
    }
    syncWith(e2) {
      return this.time = e2.time, this.timeScale = e2.timeScale, this.stopWarping();
    }
    halt(e2) {
      return this.warp(this._effectiveTimeScale, 0, e2);
    }
    warp(e2, t2, r2) {
      const n2 = this._mixer, i2 = n2.time, s2 = this.timeScale;
      let o2 = this._timeScaleInterpolant;
      null === o2 && (o2 = n2._lendControlInterpolant(), this._timeScaleInterpolant = o2);
      const a2 = o2.parameterPositions, l2 = o2.sampleValues;
      return a2[0] = i2, a2[1] = i2 + r2, l2[0] = e2 / s2, l2[1] = t2 / s2, this;
    }
    stopWarping() {
      const e2 = this._timeScaleInterpolant;
      return null !== e2 && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e2)), this;
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(e2, t2, r2, n2) {
      if (!this.enabled)
        return void this._updateWeight(e2);
      const i2 = this._startTime;
      if (null !== i2) {
        const n3 = (e2 - i2) * r2;
        n3 < 0 || 0 === r2 ? t2 = 0 : (this._startTime = null, t2 = r2 * n3);
      }
      t2 *= this._updateTimeScale(e2);
      const s2 = this._updateTime(t2), o2 = this._updateWeight(e2);
      if (o2 > 0) {
        const e3 = this._interpolants, t3 = this._propertyBindings;
        if (this.blendMode === Ct)
          for (let r3 = 0, n3 = e3.length; r3 !== n3; ++r3)
            e3[r3].evaluate(s2), t3[r3].accumulateAdditive(o2);
        else
          for (let r3 = 0, i3 = e3.length; r3 !== i3; ++r3)
            e3[r3].evaluate(s2), t3[r3].accumulate(n2, o2);
      }
    }
    _updateWeight(e2) {
      let t2 = 0;
      if (this.enabled) {
        t2 = this.weight;
        const r2 = this._weightInterpolant;
        if (null !== r2) {
          const n2 = r2.evaluate(e2)[0];
          t2 *= n2, e2 > r2.parameterPositions[1] && (this.stopFading(), 0 === n2 && (this.enabled = false));
        }
      }
      return this._effectiveWeight = t2, t2;
    }
    _updateTimeScale(e2) {
      let t2 = 0;
      if (!this.paused) {
        t2 = this.timeScale;
        const r2 = this._timeScaleInterpolant;
        null !== r2 && (t2 *= r2.evaluate(e2)[0], e2 > r2.parameterPositions[1] && (this.stopWarping(), 0 === t2 ? this.paused = true : this.timeScale = t2));
      }
      return this._effectiveTimeScale = t2, t2;
    }
    _updateTime(e2) {
      const t2 = this._clip.duration, r2 = this.loop;
      let n2 = this.time + e2, i2 = this._loopCount;
      const s2 = r2 === vt;
      if (0 === e2)
        return -1 === i2 ? n2 : s2 && 1 == (1 & i2) ? t2 - n2 : n2;
      if (r2 === _t) {
        -1 === i2 && (this._loopCount = 0, this._setEndings(true, true, false));
        e: {
          if (n2 >= t2)
            n2 = t2;
          else {
            if (!(n2 < 0)) {
              this.time = n2;
              break e;
            }
            n2 = 0;
          }
          this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e2 < 0 ? -1 : 1 });
        }
      } else {
        if (-1 === i2 && (e2 >= 0 ? (i2 = 0, this._setEndings(true, 0 === this.repetitions, s2)) : this._setEndings(0 === this.repetitions, true, s2)), n2 >= t2 || n2 < 0) {
          const r3 = Math.floor(n2 / t2);
          n2 -= t2 * r3, i2 += Math.abs(r3);
          const o2 = this.repetitions - i2;
          if (o2 <= 0)
            this.clampWhenFinished ? this.paused = true : this.enabled = false, n2 = e2 > 0 ? t2 : 0, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e2 > 0 ? 1 : -1 });
          else {
            if (1 === o2) {
              const t3 = e2 < 0;
              this._setEndings(t3, !t3, s2);
            } else
              this._setEndings(false, false, s2);
            this._loopCount = i2, this.time = n2, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: r3 });
          }
        } else
          this.time = n2;
        if (s2 && 1 == (1 & i2))
          return t2 - n2;
      }
      return n2;
    }
    _setEndings(e2, t2, r2) {
      const n2 = this._interpolantSettings;
      r2 ? (n2.endingStart = wt, n2.endingEnd = wt) : (n2.endingStart = e2 ? this.zeroSlopeAtStart ? wt : xt : Et, n2.endingEnd = t2 ? this.zeroSlopeAtEnd ? wt : xt : Et);
    }
    _scheduleFading(e2, t2, r2) {
      const n2 = this._mixer, i2 = n2.time;
      let s2 = this._weightInterpolant;
      null === s2 && (s2 = n2._lendControlInterpolant(), this._weightInterpolant = s2);
      const o2 = s2.parameterPositions, a2 = s2.sampleValues;
      return o2[0] = i2, a2[0] = t2, o2[1] = i2 + e2, a2[1] = r2, this;
    }
  }
  const Fp = new Float32Array(1);
  class Up extends mr {
    constructor(e2) {
      super(), this._root = e2, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
    }
    _bindAction(e2, t2) {
      const r2 = e2._localRoot || this._root, n2 = e2._clip.tracks, i2 = n2.length, s2 = e2._propertyBindings, o2 = e2._interpolants, a2 = r2.uuid, l2 = this._bindingsByRootAndName;
      let c2 = l2[a2];
      void 0 === c2 && (c2 = {}, l2[a2] = c2);
      for (let e3 = 0; e3 !== i2; ++e3) {
        const i3 = n2[e3], l3 = i3.name;
        let u2 = c2[l3];
        if (void 0 !== u2)
          ++u2.referenceCount, s2[e3] = u2;
        else {
          if (u2 = s2[e3], void 0 !== u2) {
            null === u2._cacheIndex && (++u2.referenceCount, this._addInactiveBinding(u2, a2, l3));
            continue;
          }
          const n3 = t2 && t2._propertyBindings[e3].binding.parsedPath;
          u2 = new Tp(Rp.create(r2, l3, n3), i3.ValueTypeName, i3.getValueSize()), ++u2.referenceCount, this._addInactiveBinding(u2, a2, l3), s2[e3] = u2;
        }
        o2[e3].resultBuffer = u2.buffer;
      }
    }
    _activateAction(e2) {
      if (!this._isActiveAction(e2)) {
        if (null === e2._cacheIndex) {
          const t3 = (e2._localRoot || this._root).uuid, r2 = e2._clip.uuid, n2 = this._actionsByClip[r2];
          this._bindAction(e2, n2 && n2.knownActions[0]), this._addInactiveAction(e2, r2, t3);
        }
        const t2 = e2._propertyBindings;
        for (let e3 = 0, r2 = t2.length; e3 !== r2; ++e3) {
          const r3 = t2[e3];
          0 == r3.useCount++ && (this._lendBinding(r3), r3.saveOriginalState());
        }
        this._lendAction(e2);
      }
    }
    _deactivateAction(e2) {
      if (this._isActiveAction(e2)) {
        const t2 = e2._propertyBindings;
        for (let e3 = 0, r2 = t2.length; e3 !== r2; ++e3) {
          const r3 = t2[e3];
          0 == --r3.useCount && (r3.restoreOriginalState(), this._takeBackBinding(r3));
        }
        this._takeBackAction(e2);
      }
    }
    _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      const e2 = this;
      this.stats = { actions: { get total() {
        return e2._actions.length;
      }, get inUse() {
        return e2._nActiveActions;
      } }, bindings: { get total() {
        return e2._bindings.length;
      }, get inUse() {
        return e2._nActiveBindings;
      } }, controlInterpolants: { get total() {
        return e2._controlInterpolants.length;
      }, get inUse() {
        return e2._nActiveControlInterpolants;
      } } };
    }
    _isActiveAction(e2) {
      const t2 = e2._cacheIndex;
      return null !== t2 && t2 < this._nActiveActions;
    }
    _addInactiveAction(e2, t2, r2) {
      const n2 = this._actions, i2 = this._actionsByClip;
      let s2 = i2[t2];
      if (void 0 === s2)
        s2 = { knownActions: [e2], actionByRoot: {} }, e2._byClipCacheIndex = 0, i2[t2] = s2;
      else {
        const t3 = s2.knownActions;
        e2._byClipCacheIndex = t3.length, t3.push(e2);
      }
      e2._cacheIndex = n2.length, n2.push(e2), s2.actionByRoot[r2] = e2;
    }
    _removeInactiveAction(e2) {
      const t2 = this._actions, r2 = t2[t2.length - 1], n2 = e2._cacheIndex;
      r2._cacheIndex = n2, t2[n2] = r2, t2.pop(), e2._cacheIndex = null;
      const i2 = e2._clip.uuid, s2 = this._actionsByClip, o2 = s2[i2], a2 = o2.knownActions, l2 = a2[a2.length - 1], c2 = e2._byClipCacheIndex;
      l2._byClipCacheIndex = c2, a2[c2] = l2, a2.pop(), e2._byClipCacheIndex = null, delete o2.actionByRoot[(e2._localRoot || this._root).uuid], 0 === a2.length && delete s2[i2], this._removeInactiveBindingsForAction(e2);
    }
    _removeInactiveBindingsForAction(e2) {
      const t2 = e2._propertyBindings;
      for (let e3 = 0, r2 = t2.length; e3 !== r2; ++e3) {
        const r3 = t2[e3];
        0 == --r3.referenceCount && this._removeInactiveBinding(r3);
      }
    }
    _lendAction(e2) {
      const t2 = this._actions, r2 = e2._cacheIndex, n2 = this._nActiveActions++, i2 = t2[n2];
      e2._cacheIndex = n2, t2[n2] = e2, i2._cacheIndex = r2, t2[r2] = i2;
    }
    _takeBackAction(e2) {
      const t2 = this._actions, r2 = e2._cacheIndex, n2 = --this._nActiveActions, i2 = t2[n2];
      e2._cacheIndex = n2, t2[n2] = e2, i2._cacheIndex = r2, t2[r2] = i2;
    }
    _addInactiveBinding(e2, t2, r2) {
      const n2 = this._bindingsByRootAndName, i2 = this._bindings;
      let s2 = n2[t2];
      void 0 === s2 && (s2 = {}, n2[t2] = s2), s2[r2] = e2, e2._cacheIndex = i2.length, i2.push(e2);
    }
    _removeInactiveBinding(e2) {
      const t2 = this._bindings, r2 = e2.binding, n2 = r2.rootNode.uuid, i2 = r2.path, s2 = this._bindingsByRootAndName, o2 = s2[n2], a2 = t2[t2.length - 1], l2 = e2._cacheIndex;
      a2._cacheIndex = l2, t2[l2] = a2, t2.pop(), delete o2[i2], 0 === Object.keys(o2).length && delete s2[n2];
    }
    _lendBinding(e2) {
      const t2 = this._bindings, r2 = e2._cacheIndex, n2 = this._nActiveBindings++, i2 = t2[n2];
      e2._cacheIndex = n2, t2[n2] = e2, i2._cacheIndex = r2, t2[r2] = i2;
    }
    _takeBackBinding(e2) {
      const t2 = this._bindings, r2 = e2._cacheIndex, n2 = --this._nActiveBindings, i2 = t2[n2];
      e2._cacheIndex = n2, t2[n2] = e2, i2._cacheIndex = r2, t2[r2] = i2;
    }
    _lendControlInterpolant() {
      const e2 = this._controlInterpolants, t2 = this._nActiveControlInterpolants++;
      let r2 = e2[t2];
      return void 0 === r2 && (r2 = new oh(new Float32Array(2), new Float32Array(2), 1, Fp), r2.__cacheIndex = t2, e2[t2] = r2), r2;
    }
    _takeBackControlInterpolant(e2) {
      const t2 = this._controlInterpolants, r2 = e2.__cacheIndex, n2 = --this._nActiveControlInterpolants, i2 = t2[n2];
      e2.__cacheIndex = n2, t2[n2] = e2, i2.__cacheIndex = r2, t2[r2] = i2;
    }
    clipAction(e2, t2, r2) {
      const n2 = t2 || this._root, i2 = n2.uuid;
      let s2 = "string" == typeof e2 ? _h.findByName(n2, e2) : e2;
      const o2 = null !== s2 ? s2.uuid : e2, a2 = this._actionsByClip[o2];
      let l2 = null;
      if (void 0 === r2 && (r2 = null !== s2 ? s2.blendMode : St), void 0 !== a2) {
        const e3 = a2.actionByRoot[i2];
        if (void 0 !== e3 && e3.blendMode === r2)
          return e3;
        l2 = a2.knownActions[0], null === s2 && (s2 = l2._clip);
      }
      if (null === s2)
        return null;
      const c2 = new Op(this, s2, t2, r2);
      return this._bindAction(c2, l2), this._addInactiveAction(c2, o2, i2), c2;
    }
    existingAction(e2, t2) {
      const r2 = t2 || this._root, n2 = r2.uuid, i2 = "string" == typeof e2 ? _h.findByName(r2, e2) : e2, s2 = i2 ? i2.uuid : e2, o2 = this._actionsByClip[s2];
      return void 0 !== o2 && o2.actionByRoot[n2] || null;
    }
    stopAllAction() {
      const e2 = this._actions;
      for (let t2 = this._nActiveActions - 1; t2 >= 0; --t2)
        e2[t2].stop();
      return this;
    }
    update(e2) {
      e2 *= this.timeScale;
      const t2 = this._actions, r2 = this._nActiveActions, n2 = this.time += e2, i2 = Math.sign(e2), s2 = this._accuIndex ^= 1;
      for (let o3 = 0; o3 !== r2; ++o3)
        t2[o3]._update(n2, e2, i2, s2);
      const o2 = this._bindings, a2 = this._nActiveBindings;
      for (let e3 = 0; e3 !== a2; ++e3)
        o2[e3].apply(s2);
      return this;
    }
    setTime(e2) {
      this.time = 0;
      for (let e3 = 0; e3 < this._actions.length; e3++)
        this._actions[e3].time = 0;
      return this.update(e2);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(e2) {
      const t2 = this._actions, r2 = e2.uuid, n2 = this._actionsByClip, i2 = n2[r2];
      if (void 0 !== i2) {
        const e3 = i2.knownActions;
        for (let r3 = 0, n3 = e3.length; r3 !== n3; ++r3) {
          const n4 = e3[r3];
          this._deactivateAction(n4);
          const i3 = n4._cacheIndex, s2 = t2[t2.length - 1];
          n4._cacheIndex = null, n4._byClipCacheIndex = null, s2._cacheIndex = i3, t2[i3] = s2, t2.pop(), this._removeInactiveBindingsForAction(n4);
        }
        delete n2[r2];
      }
    }
    uncacheRoot(e2) {
      const t2 = e2.uuid, r2 = this._actionsByClip;
      for (const e3 in r2) {
        const n3 = r2[e3].actionByRoot[t2];
        void 0 !== n3 && (this._deactivateAction(n3), this._removeInactiveAction(n3));
      }
      const n2 = this._bindingsByRootAndName[t2];
      if (void 0 !== n2)
        for (const e3 in n2) {
          const t3 = n2[e3];
          t3.restoreOriginalState(), this._removeInactiveBinding(t3);
        }
    }
    uncacheAction(e2, t2) {
      const r2 = this.existingAction(e2, t2);
      null !== r2 && (this._deactivateAction(r2), this._removeInactiveAction(r2));
    }
  }
  class Np {
    constructor(e2) {
      this.value = e2;
    }
    clone() {
      return new Np(void 0 === this.value.clone ? this.value : this.value.clone());
    }
  }
  let jp = 0;
  class zp extends mr {
    constructor() {
      super(), this.isUniformsGroup = true, Object.defineProperty(this, "id", { value: jp++ }), this.name = "", this.usage = nr, this.uniforms = [];
    }
    add(e2) {
      return this.uniforms.push(e2), this;
    }
    remove(e2) {
      const t2 = this.uniforms.indexOf(e2);
      return -1 !== t2 && this.uniforms.splice(t2, 1), this;
    }
    setName(e2) {
      return this.name = e2, this;
    }
    setUsage(e2) {
      return this.usage = e2, this;
    }
    dispose() {
      return this.dispatchEvent({ type: "dispose" }), this;
    }
    copy(e2) {
      this.name = e2.name, this.usage = e2.usage;
      const t2 = e2.uniforms;
      this.uniforms.length = 0;
      for (let e3 = 0, r2 = t2.length; e3 < r2; e3++)
        this.uniforms.push(t2[e3].clone());
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Gp extends pl {
    constructor(e2, t2, r2 = 1) {
      super(e2, t2), this.isInstancedInterleavedBuffer = true, this.meshPerAttribute = r2;
    }
    copy(e2) {
      return super.copy(e2), this.meshPerAttribute = e2.meshPerAttribute, this;
    }
    clone(e2) {
      const t2 = super.clone(e2);
      return t2.meshPerAttribute = this.meshPerAttribute, t2;
    }
    toJSON(e2) {
      const t2 = super.toJSON(e2);
      return t2.isInstancedInterleavedBuffer = true, t2.meshPerAttribute = this.meshPerAttribute, t2;
    }
  }
  class Vp {
    constructor(e2, t2, r2, n2, i2) {
      this.isGLBufferAttribute = true, this.buffer = e2, this.type = t2, this.itemSize = r2, this.elementSize = n2, this.count = i2, this.version = 0;
    }
    set needsUpdate(e2) {
      true === e2 && this.version++;
    }
    setBuffer(e2) {
      return this.buffer = e2, this;
    }
    setType(e2, t2) {
      return this.type = e2, this.elementSize = t2, this;
    }
    setItemSize(e2) {
      return this.itemSize = e2, this;
    }
    setCount(e2) {
      return this.count = e2, this;
    }
  }
  class Qp {
    constructor(e2, t2, r2 = 0, n2 = 1 / 0) {
      this.ray = new Un(e2, t2), this.near = r2, this.far = n2, this.camera = null, this.layers = new Kn(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
    }
    set(e2, t2) {
      this.ray.set(e2, t2);
    }
    setFromCamera(e2, t2) {
      t2.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t2.matrixWorld), this.ray.direction.set(e2.x, e2.y, 0.5).unproject(t2).sub(this.ray.origin).normalize(), this.camera = t2) : t2.isOrthographicCamera ? (this.ray.origin.set(e2.x, e2.y, (t2.near + t2.far) / (t2.near - t2.far)).unproject(t2), this.ray.direction.set(0, 0, -1).transformDirection(t2.matrixWorld), this.camera = t2) : console.error("THREE.Raycaster: Unsupported camera type: " + t2.type);
    }
    intersectObject(e2, t2 = true, r2 = []) {
      return Wp(e2, this, r2, t2), r2.sort(Hp), r2;
    }
    intersectObjects(e2, t2 = true, r2 = []) {
      for (let n2 = 0, i2 = e2.length; n2 < i2; n2++)
        Wp(e2[n2], this, r2, t2);
      return r2.sort(Hp), r2;
    }
  }
  function Hp(e2, t2) {
    return e2.distance - t2.distance;
  }
  function Wp(e2, t2, r2, n2) {
    if (e2.layers.test(t2.layers) && e2.raycast(t2, r2), true === n2) {
      const n3 = e2.children;
      for (let e3 = 0, i2 = n3.length; e3 < i2; e3++)
        Wp(n3[e3], t2, r2, true);
    }
  }
  class qp {
    constructor(e2 = 1, t2 = 0, r2 = 0) {
      return this.radius = e2, this.phi = t2, this.theta = r2, this;
    }
    set(e2, t2, r2) {
      return this.radius = e2, this.phi = t2, this.theta = r2, this;
    }
    copy(e2) {
      return this.radius = e2.radius, this.phi = e2.phi, this.theta = e2.theta, this;
    }
    makeSafe() {
      const e2 = 1e-6;
      return this.phi = Math.max(e2, Math.min(Math.PI - e2, this.phi)), this;
    }
    setFromVector3(e2) {
      return this.setFromCartesianCoords(e2.x, e2.y, e2.z);
    }
    setFromCartesianCoords(e2, t2, r2) {
      return this.radius = Math.sqrt(e2 * e2 + t2 * t2 + r2 * r2), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e2, r2), this.phi = Math.acos(yr(t2 / this.radius, -1, 1))), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Xp {
    constructor(e2 = 1, t2 = 0, r2 = 0) {
      return this.radius = e2, this.theta = t2, this.y = r2, this;
    }
    set(e2, t2, r2) {
      return this.radius = e2, this.theta = t2, this.y = r2, this;
    }
    copy(e2) {
      return this.radius = e2.radius, this.theta = e2.theta, this.y = e2.y, this;
    }
    setFromVector3(e2) {
      return this.setFromCartesianCoords(e2.x, e2.y, e2.z);
    }
    setFromCartesianCoords(e2, t2, r2) {
      return this.radius = Math.sqrt(e2 * e2 + r2 * r2), this.theta = Math.atan2(e2, r2), this.y = t2, this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Yp = new kr();
  class Kp {
    constructor(e2 = new kr(1 / 0, 1 / 0), t2 = new kr(-1 / 0, -1 / 0)) {
      this.isBox2 = true, this.min = e2, this.max = t2;
    }
    set(e2, t2) {
      return this.min.copy(e2), this.max.copy(t2), this;
    }
    setFromPoints(e2) {
      this.makeEmpty();
      for (let t2 = 0, r2 = e2.length; t2 < r2; t2++)
        this.expandByPoint(e2[t2]);
      return this;
    }
    setFromCenterAndSize(e2, t2) {
      const r2 = Yp.copy(t2).multiplyScalar(0.5);
      return this.min.copy(e2).sub(r2), this.max.copy(e2).add(r2), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.min.copy(e2.min), this.max.copy(e2.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(e2) {
      return this.isEmpty() ? e2.set(0, 0) : e2.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e2) {
      return this.isEmpty() ? e2.set(0, 0) : e2.subVectors(this.max, this.min);
    }
    expandByPoint(e2) {
      return this.min.min(e2), this.max.max(e2), this;
    }
    expandByVector(e2) {
      return this.min.sub(e2), this.max.add(e2), this;
    }
    expandByScalar(e2) {
      return this.min.addScalar(-e2), this.max.addScalar(e2), this;
    }
    containsPoint(e2) {
      return !(e2.x < this.min.x || e2.x > this.max.x || e2.y < this.min.y || e2.y > this.max.y);
    }
    containsBox(e2) {
      return this.min.x <= e2.min.x && e2.max.x <= this.max.x && this.min.y <= e2.min.y && e2.max.y <= this.max.y;
    }
    getParameter(e2, t2) {
      return t2.set((e2.x - this.min.x) / (this.max.x - this.min.x), (e2.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(e2) {
      return !(e2.max.x < this.min.x || e2.min.x > this.max.x || e2.max.y < this.min.y || e2.min.y > this.max.y);
    }
    clampPoint(e2, t2) {
      return t2.copy(e2).clamp(this.min, this.max);
    }
    distanceToPoint(e2) {
      return Yp.copy(e2).clamp(this.min, this.max).sub(e2).length();
    }
    intersect(e2) {
      return this.min.max(e2.min), this.max.min(e2.max), this;
    }
    union(e2) {
      return this.min.min(e2.min), this.max.max(e2.max), this;
    }
    translate(e2) {
      return this.min.add(e2), this.max.add(e2), this;
    }
    equals(e2) {
      return e2.min.equals(this.min) && e2.max.equals(this.max);
    }
  }
  const Jp = new ln(), Zp = new ln();
  class $p {
    constructor(e2 = new ln(), t2 = new ln()) {
      this.start = e2, this.end = t2;
    }
    set(e2, t2) {
      return this.start.copy(e2), this.end.copy(t2), this;
    }
    copy(e2) {
      return this.start.copy(e2.start), this.end.copy(e2.end), this;
    }
    getCenter(e2) {
      return e2.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(e2) {
      return e2.subVectors(this.end, this.start);
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
    distance() {
      return this.start.distanceTo(this.end);
    }
    at(e2, t2) {
      return this.delta(t2).multiplyScalar(e2).add(this.start);
    }
    closestPointToPointParameter(e2, t2) {
      Jp.subVectors(e2, this.start), Zp.subVectors(this.end, this.start);
      const r2 = Zp.dot(Zp);
      let n2 = Zp.dot(Jp) / r2;
      return t2 && (n2 = yr(n2, 0, 1)), n2;
    }
    closestPointToPoint(e2, t2, r2) {
      const n2 = this.closestPointToPointParameter(e2, t2);
      return this.delta(r2).multiplyScalar(n2).add(this.start);
    }
    applyMatrix4(e2) {
      return this.start.applyMatrix4(e2), this.end.applyMatrix4(e2), this;
    }
    equals(e2) {
      return e2.start.equals(this.start) && e2.end.equals(this.end);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const ed = new ln();
  class td extends ui {
    constructor(e2, t2) {
      super(), this.light = e2, this.light.updateMatrixWorld(), this.matrix = e2.matrixWorld, this.matrixAutoUpdate = false, this.color = t2;
      const r2 = new Hi(), n2 = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
      for (let e3 = 0, t3 = 1, r3 = 32; e3 < r3; e3++, t3++) {
        const i3 = e3 / r3 * Math.PI * 2, s2 = t3 / r3 * Math.PI * 2;
        n2.push(Math.cos(i3), Math.sin(i3), 1, Math.cos(s2), Math.sin(s2), 1);
      }
      r2.setAttribute("position", new Oi(n2, 3));
      const i2 = new Jl({ fog: false, toneMapped: false });
      this.cone = new oc(r2, i2), this.add(this.cone), this.update();
    }
    dispose() {
      this.cone.geometry.dispose(), this.cone.material.dispose();
    }
    update() {
      this.light.updateMatrixWorld();
      const e2 = this.light.distance ? this.light.distance : 1e3, t2 = e2 * Math.tan(this.light.angle);
      this.cone.scale.set(t2, t2, e2), ed.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(ed), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    }
  }
  const rd = new ln(), nd = new Nn(), id = new Nn();
  class sd extends oc {
    constructor(e2) {
      const t2 = od(e2), r2 = new Hi(), n2 = [], i2 = [], s2 = new Wr(0, 0, 1), o2 = new Wr(0, 1, 0);
      for (let e3 = 0; e3 < t2.length; e3++) {
        const r3 = t2[e3];
        r3.parent && r3.parent.isBone && (n2.push(0, 0, 0), n2.push(0, 0, 0), i2.push(s2.r, s2.g, s2.b), i2.push(o2.r, o2.g, o2.b));
      }
      r2.setAttribute("position", new Oi(n2, 3)), r2.setAttribute("color", new Oi(i2, 3)), super(r2, new Jl({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true })), this.isSkeletonHelper = true, this.type = "SkeletonHelper", this.root = e2, this.bones = t2, this.matrix = e2.matrixWorld, this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(e2) {
      const t2 = this.bones, r2 = this.geometry, n2 = r2.getAttribute("position");
      id.copy(this.root.matrixWorld).invert();
      for (let e3 = 0, r3 = 0; e3 < t2.length; e3++) {
        const i2 = t2[e3];
        i2.parent && i2.parent.isBone && (nd.multiplyMatrices(id, i2.matrixWorld), rd.setFromMatrixPosition(nd), n2.setXYZ(r3, rd.x, rd.y, rd.z), nd.multiplyMatrices(id, i2.parent.matrixWorld), rd.setFromMatrixPosition(nd), n2.setXYZ(r3 + 1, rd.x, rd.y, rd.z), r3 += 2);
      }
      r2.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(e2);
    }
  }
  function od(e2) {
    const t2 = [];
    true === e2.isBone && t2.push(e2);
    for (let r2 = 0; r2 < e2.children.length; r2++)
      t2.push.apply(t2, od(e2.children[r2]));
    return t2;
  }
  class ad extends cs {
    constructor(e2, t2, r2) {
      super(new Bu(t2, 4, 2), new Ei({ wireframe: true, fog: false, toneMapped: false })), this.light = e2, this.light.updateMatrixWorld(), this.color = r2, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update();
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
    update() {
      void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
    }
  }
  const ld = new ln(), cd = new Wr(), ud = new Wr();
  class hd extends ui {
    constructor(e2, t2, r2) {
      super(), this.light = e2, this.light.updateMatrixWorld(), this.matrix = e2.matrixWorld, this.matrixAutoUpdate = false, this.color = r2;
      const n2 = new ku(t2);
      n2.rotateY(0.5 * Math.PI), this.material = new Ei({ wireframe: true, fog: false, toneMapped: false }), void 0 === this.color && (this.material.vertexColors = true);
      const i2 = n2.getAttribute("position"), s2 = new Float32Array(3 * i2.count);
      n2.setAttribute("color", new Mi(s2, 3)), this.add(new cs(n2, this.material)), this.update();
    }
    dispose() {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }
    update() {
      const e2 = this.children[0];
      if (void 0 !== this.color)
        this.material.color.set(this.color);
      else {
        const t2 = e2.geometry.getAttribute("color");
        cd.copy(this.light.color), ud.copy(this.light.groundColor);
        for (let e3 = 0, r2 = t2.count; e3 < r2; e3++) {
          const n2 = e3 < r2 / 2 ? cd : ud;
          t2.setXYZ(e3, n2.r, n2.g, n2.b);
        }
        t2.needsUpdate = true;
      }
      e2.lookAt(ld.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
  }
  class pd extends oc {
    constructor(e2 = 10, t2 = 10, r2 = 4473924, n2 = 8947848) {
      r2 = new Wr(r2), n2 = new Wr(n2);
      const i2 = t2 / 2, s2 = e2 / t2, o2 = e2 / 2, a2 = [], l2 = [];
      for (let e3 = 0, c3 = 0, u2 = -o2; e3 <= t2; e3++, u2 += s2) {
        a2.push(-o2, 0, u2, o2, 0, u2), a2.push(u2, 0, -o2, u2, 0, o2);
        const t3 = e3 === i2 ? r2 : n2;
        t3.toArray(l2, c3), c3 += 3, t3.toArray(l2, c3), c3 += 3, t3.toArray(l2, c3), c3 += 3, t3.toArray(l2, c3), c3 += 3;
      }
      const c2 = new Hi();
      c2.setAttribute("position", new Oi(a2, 3)), c2.setAttribute("color", new Oi(l2, 3)), super(c2, new Jl({ vertexColors: true, toneMapped: false })), this.type = "GridHelper";
    }
  }
  class dd extends oc {
    constructor(e2 = 10, t2 = 16, r2 = 8, n2 = 64, i2 = 4473924, s2 = 8947848) {
      i2 = new Wr(i2), s2 = new Wr(s2);
      const o2 = [], a2 = [];
      if (t2 > 1)
        for (let r3 = 0; r3 < t2; r3++) {
          const n3 = r3 / t2 * (2 * Math.PI), l3 = Math.sin(n3) * e2, c2 = Math.cos(n3) * e2;
          o2.push(0, 0, 0), o2.push(l3, 0, c2);
          const u2 = 1 & r3 ? i2 : s2;
          a2.push(u2.r, u2.g, u2.b), a2.push(u2.r, u2.g, u2.b);
        }
      for (let t3 = 0; t3 < r2; t3++) {
        const l3 = 1 & t3 ? i2 : s2, c2 = e2 - e2 / r2 * t3;
        for (let e3 = 0; e3 < n2; e3++) {
          let t4 = e3 / n2 * (2 * Math.PI), r3 = Math.sin(t4) * c2, i3 = Math.cos(t4) * c2;
          o2.push(r3, 0, i3), a2.push(l3.r, l3.g, l3.b), t4 = (e3 + 1) / n2 * (2 * Math.PI), r3 = Math.sin(t4) * c2, i3 = Math.cos(t4) * c2, o2.push(r3, 0, i3), a2.push(l3.r, l3.g, l3.b);
        }
      }
      const l2 = new Hi();
      l2.setAttribute("position", new Oi(o2, 3)), l2.setAttribute("color", new Oi(a2, 3)), super(l2, new Jl({ vertexColors: true, toneMapped: false })), this.type = "PolarGridHelper";
    }
  }
  const fd = new ln(), md = new ln(), _d = new ln();
  class gd extends ui {
    constructor(e2, t2, r2) {
      super(), this.light = e2, this.light.updateMatrixWorld(), this.matrix = e2.matrixWorld, this.matrixAutoUpdate = false, this.color = r2, void 0 === t2 && (t2 = 1);
      let n2 = new Hi();
      n2.setAttribute("position", new Oi([-t2, t2, 0, t2, t2, 0, t2, -t2, 0, -t2, -t2, 0, -t2, t2, 0], 3));
      const i2 = new Jl({ fog: false, toneMapped: false });
      this.lightPlane = new nc(n2, i2), this.add(this.lightPlane), n2 = new Hi(), n2.setAttribute("position", new Oi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new nc(n2, i2), this.add(this.targetLine), this.update();
    }
    dispose() {
      this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
    }
    update() {
      fd.setFromMatrixPosition(this.light.matrixWorld), md.setFromMatrixPosition(this.light.target.matrixWorld), _d.subVectors(md, fd), this.lightPlane.lookAt(md), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(md), this.targetLine.scale.z = _d.length();
    }
  }
  const vd = new ln(), Ad = new _s();
  class bd extends oc {
    constructor(e2) {
      const t2 = new Hi(), r2 = new Jl({ color: 16777215, vertexColors: true, toneMapped: false }), n2 = [], i2 = [], s2 = {};
      function o2(e3, t3) {
        a2(e3), a2(t3);
      }
      function a2(e3) {
        n2.push(0, 0, 0), i2.push(0, 0, 0), void 0 === s2[e3] && (s2[e3] = []), s2[e3].push(n2.length / 3 - 1);
      }
      o2("n1", "n2"), o2("n2", "n4"), o2("n4", "n3"), o2("n3", "n1"), o2("f1", "f2"), o2("f2", "f4"), o2("f4", "f3"), o2("f3", "f1"), o2("n1", "f1"), o2("n2", "f2"), o2("n3", "f3"), o2("n4", "f4"), o2("p", "n1"), o2("p", "n2"), o2("p", "n3"), o2("p", "n4"), o2("u1", "u2"), o2("u2", "u3"), o2("u3", "u1"), o2("c", "t"), o2("p", "c"), o2("cn1", "cn2"), o2("cn3", "cn4"), o2("cf1", "cf2"), o2("cf3", "cf4"), t2.setAttribute("position", new Oi(n2, 3)), t2.setAttribute("color", new Oi(i2, 3)), super(t2, r2), this.type = "CameraHelper", this.camera = e2, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e2.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = s2, this.update();
      const l2 = new Wr(16755200), c2 = new Wr(16711680), u2 = new Wr(43775), h2 = new Wr(16777215), p2 = new Wr(3355443);
      this.setColors(l2, c2, u2, h2, p2);
    }
    setColors(e2, t2, r2, n2, i2) {
      const s2 = this.geometry.getAttribute("color");
      s2.setXYZ(0, e2.r, e2.g, e2.b), s2.setXYZ(1, e2.r, e2.g, e2.b), s2.setXYZ(2, e2.r, e2.g, e2.b), s2.setXYZ(3, e2.r, e2.g, e2.b), s2.setXYZ(4, e2.r, e2.g, e2.b), s2.setXYZ(5, e2.r, e2.g, e2.b), s2.setXYZ(6, e2.r, e2.g, e2.b), s2.setXYZ(7, e2.r, e2.g, e2.b), s2.setXYZ(8, e2.r, e2.g, e2.b), s2.setXYZ(9, e2.r, e2.g, e2.b), s2.setXYZ(10, e2.r, e2.g, e2.b), s2.setXYZ(11, e2.r, e2.g, e2.b), s2.setXYZ(12, e2.r, e2.g, e2.b), s2.setXYZ(13, e2.r, e2.g, e2.b), s2.setXYZ(14, e2.r, e2.g, e2.b), s2.setXYZ(15, e2.r, e2.g, e2.b), s2.setXYZ(16, e2.r, e2.g, e2.b), s2.setXYZ(17, e2.r, e2.g, e2.b), s2.setXYZ(18, e2.r, e2.g, e2.b), s2.setXYZ(19, e2.r, e2.g, e2.b), s2.setXYZ(20, e2.r, e2.g, e2.b), s2.setXYZ(21, e2.r, e2.g, e2.b), s2.setXYZ(22, e2.r, e2.g, e2.b), s2.setXYZ(23, e2.r, e2.g, e2.b), s2.setXYZ(24, t2.r, t2.g, t2.b), s2.setXYZ(25, t2.r, t2.g, t2.b), s2.setXYZ(26, t2.r, t2.g, t2.b), s2.setXYZ(27, t2.r, t2.g, t2.b), s2.setXYZ(28, t2.r, t2.g, t2.b), s2.setXYZ(29, t2.r, t2.g, t2.b), s2.setXYZ(30, t2.r, t2.g, t2.b), s2.setXYZ(31, t2.r, t2.g, t2.b), s2.setXYZ(32, r2.r, r2.g, r2.b), s2.setXYZ(33, r2.r, r2.g, r2.b), s2.setXYZ(34, r2.r, r2.g, r2.b), s2.setXYZ(35, r2.r, r2.g, r2.b), s2.setXYZ(36, r2.r, r2.g, r2.b), s2.setXYZ(37, r2.r, r2.g, r2.b), s2.setXYZ(38, n2.r, n2.g, n2.b), s2.setXYZ(39, n2.r, n2.g, n2.b), s2.setXYZ(40, i2.r, i2.g, i2.b), s2.setXYZ(41, i2.r, i2.g, i2.b), s2.setXYZ(42, i2.r, i2.g, i2.b), s2.setXYZ(43, i2.r, i2.g, i2.b), s2.setXYZ(44, i2.r, i2.g, i2.b), s2.setXYZ(45, i2.r, i2.g, i2.b), s2.setXYZ(46, i2.r, i2.g, i2.b), s2.setXYZ(47, i2.r, i2.g, i2.b), s2.setXYZ(48, i2.r, i2.g, i2.b), s2.setXYZ(49, i2.r, i2.g, i2.b), s2.needsUpdate = true;
    }
    update() {
      const e2 = this.geometry, t2 = this.pointMap;
      Ad.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), yd("c", t2, e2, Ad, 0, 0, -1), yd("t", t2, e2, Ad, 0, 0, 1), yd("n1", t2, e2, Ad, -1, -1, -1), yd("n2", t2, e2, Ad, 1, -1, -1), yd("n3", t2, e2, Ad, -1, 1, -1), yd("n4", t2, e2, Ad, 1, 1, -1), yd("f1", t2, e2, Ad, -1, -1, 1), yd("f2", t2, e2, Ad, 1, -1, 1), yd("f3", t2, e2, Ad, -1, 1, 1), yd("f4", t2, e2, Ad, 1, 1, 1), yd("u1", t2, e2, Ad, 0.7, 1.1, -1), yd("u2", t2, e2, Ad, -0.7, 1.1, -1), yd("u3", t2, e2, Ad, 0, 2, -1), yd("cf1", t2, e2, Ad, -1, 0, 1), yd("cf2", t2, e2, Ad, 1, 0, 1), yd("cf3", t2, e2, Ad, 0, -1, 1), yd("cf4", t2, e2, Ad, 0, 1, 1), yd("cn1", t2, e2, Ad, -1, 0, -1), yd("cn2", t2, e2, Ad, 1, 0, -1), yd("cn3", t2, e2, Ad, 0, -1, -1), yd("cn4", t2, e2, Ad, 0, 1, -1), e2.getAttribute("position").needsUpdate = true;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  function yd(e2, t2, r2, n2, i2, s2, o2) {
    vd.set(i2, s2, o2).unproject(n2);
    const a2 = t2[e2];
    if (void 0 !== a2) {
      const e3 = r2.getAttribute("position");
      for (let t3 = 0, r3 = a2.length; t3 < r3; t3++)
        e3.setXYZ(a2[t3], vd.x, vd.y, vd.z);
    }
  }
  const xd = new hn();
  class wd extends oc {
    constructor(e2, t2 = 16776960) {
      const r2 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n2 = new Float32Array(24), i2 = new Hi();
      i2.setIndex(new Mi(r2, 1)), i2.setAttribute("position", new Mi(n2, 3)), super(i2, new Jl({ color: t2, toneMapped: false })), this.object = e2, this.type = "BoxHelper", this.matrixAutoUpdate = false, this.update();
    }
    update(e2) {
      if (void 0 !== e2 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && xd.setFromObject(this.object), xd.isEmpty())
        return;
      const t2 = xd.min, r2 = xd.max, n2 = this.geometry.attributes.position, i2 = n2.array;
      i2[0] = r2.x, i2[1] = r2.y, i2[2] = r2.z, i2[3] = t2.x, i2[4] = r2.y, i2[5] = r2.z, i2[6] = t2.x, i2[7] = t2.y, i2[8] = r2.z, i2[9] = r2.x, i2[10] = t2.y, i2[11] = r2.z, i2[12] = r2.x, i2[13] = r2.y, i2[14] = t2.z, i2[15] = t2.x, i2[16] = r2.y, i2[17] = t2.z, i2[18] = t2.x, i2[19] = t2.y, i2[20] = t2.z, i2[21] = r2.x, i2[22] = t2.y, i2[23] = t2.z, n2.needsUpdate = true, this.geometry.computeBoundingSphere();
    }
    setFromObject(e2) {
      return this.object = e2, this.update(), this;
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.object = e2.object, this;
    }
  }
  class Ed extends oc {
    constructor(e2, t2 = 16776960) {
      const r2 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n2 = new Hi();
      n2.setIndex(new Mi(r2, 1)), n2.setAttribute("position", new Oi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(n2, new Jl({ color: t2, toneMapped: false })), this.box = e2, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(e2) {
      const t2 = this.box;
      t2.isEmpty() || (t2.getCenter(this.position), t2.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e2));
    }
  }
  class Sd extends nc {
    constructor(e2, t2 = 1, r2 = 16776960) {
      const n2 = r2, i2 = new Hi();
      i2.setAttribute("position", new Oi([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), i2.computeBoundingSphere(), super(i2, new Jl({ color: n2, toneMapped: false })), this.type = "PlaneHelper", this.plane = e2, this.size = t2;
      const s2 = new Hi();
      s2.setAttribute("position", new Oi([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), s2.computeBoundingSphere(), this.add(new cs(s2, new Ei({ color: n2, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
    }
    updateMatrixWorld(e2) {
      this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e2);
    }
  }
  const Cd = new ln();
  let Md, Td;
  class Id extends ui {
    constructor(e2 = new ln(0, 0, 1), t2 = new ln(0, 0, 0), r2 = 1, n2 = 16776960, i2 = 0.2 * r2, s2 = 0.2 * i2) {
      super(), this.type = "ArrowHelper", void 0 === Md && (Md = new Hi(), Md.setAttribute("position", new Oi([0, 0, 0, 0, 1, 0], 3)), Td = new Qc(0, 0.5, 1, 5, 1), Td.translate(0, -0.5, 0)), this.position.copy(t2), this.line = new nc(Md, new Jl({ color: n2, toneMapped: false })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new cs(Td, new Ei({ color: n2, toneMapped: false })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(e2), this.setLength(r2, i2, s2);
    }
    setDirection(e2) {
      if (e2.y > 0.99999)
        this.quaternion.set(0, 0, 0, 1);
      else if (e2.y < -0.99999)
        this.quaternion.set(1, 0, 0, 0);
      else {
        Cd.set(e2.z, 0, -e2.x).normalize();
        const t2 = Math.acos(e2.y);
        this.quaternion.setFromAxisAngle(Cd, t2);
      }
    }
    setLength(e2, t2 = 0.2 * e2, r2 = 0.2 * t2) {
      this.line.scale.set(1, Math.max(1e-4, e2 - t2), 1), this.line.updateMatrix(), this.cone.scale.set(r2, t2, r2), this.cone.position.y = e2, this.cone.updateMatrix();
    }
    setColor(e2) {
      this.line.material.color.set(e2), this.cone.material.color.set(e2);
    }
    copy(e2) {
      return super.copy(e2, false), this.line.copy(e2.line), this.cone.copy(e2.cone), this;
    }
  }
  class kd extends oc {
    constructor(e2 = 1) {
      const t2 = [0, 0, 0, e2, 0, 0, 0, 0, 0, 0, e2, 0, 0, 0, 0, 0, 0, e2], r2 = new Hi();
      r2.setAttribute("position", new Oi(t2, 3)), r2.setAttribute("color", new Oi([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)), super(r2, new Jl({ vertexColors: true, toneMapped: false })), this.type = "AxesHelper";
    }
    setColors(e2, t2, r2) {
      const n2 = new Wr(), i2 = this.geometry.attributes.color.array;
      return n2.set(e2), n2.toArray(i2, 0), n2.toArray(i2, 3), n2.set(t2), n2.toArray(i2, 6), n2.toArray(i2, 9), n2.set(r2), n2.toArray(i2, 12), n2.toArray(i2, 15), this.geometry.attributes.color.needsUpdate = true, this;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  class Dd {
    constructor() {
      this.type = "ShapePath", this.color = new Wr(), this.subPaths = [], this.currentPath = null;
    }
    moveTo(e2, t2) {
      return this.currentPath = new jc(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e2, t2), this;
    }
    lineTo(e2, t2) {
      return this.currentPath.lineTo(e2, t2), this;
    }
    quadraticCurveTo(e2, t2, r2, n2) {
      return this.currentPath.quadraticCurveTo(e2, t2, r2, n2), this;
    }
    bezierCurveTo(e2, t2, r2, n2, i2, s2) {
      return this.currentPath.bezierCurveTo(e2, t2, r2, n2, i2, s2), this;
    }
    splineThru(e2) {
      return this.currentPath.splineThru(e2), this;
    }
    toShapes(e2, t2) {
      function r2(e3) {
        const t3 = [];
        for (let r3 = 0, n3 = e3.length; r3 < n3; r3++) {
          const n4 = e3[r3], i3 = new $c();
          i3.curves = n4.curves, t3.push(i3);
        }
        return t3;
      }
      function n2(e3, t3) {
        const r3 = t3.length;
        let n3 = false;
        for (let i3 = r3 - 1, s3 = 0; s3 < r3; i3 = s3++) {
          let r4 = t3[i3], o3 = t3[s3], a3 = o3.x - r4.x, l3 = o3.y - r4.y;
          if (Math.abs(l3) > Number.EPSILON) {
            if (l3 < 0 && (r4 = t3[s3], a3 = -a3, o3 = t3[i3], l3 = -l3), e3.y < r4.y || e3.y > o3.y)
              continue;
            if (e3.y === r4.y) {
              if (e3.x === r4.x)
                return true;
            } else {
              const t4 = l3 * (e3.x - r4.x) - a3 * (e3.y - r4.y);
              if (0 === t4)
                return true;
              if (t4 < 0)
                continue;
              n3 = !n3;
            }
          } else {
            if (e3.y !== r4.y)
              continue;
            if (o3.x <= e3.x && e3.x <= r4.x || r4.x <= e3.x && e3.x <= o3.x)
              return true;
          }
        }
        return n3;
      }
      const i2 = Eu.isClockWise, s2 = this.subPaths;
      if (0 === s2.length)
        return [];
      if (true === t2)
        return r2(s2);
      let o2, a2, l2;
      const c2 = [];
      if (1 === s2.length)
        return a2 = s2[0], l2 = new $c(), l2.curves = a2.curves, c2.push(l2), c2;
      let u2 = !i2(s2[0].getPoints());
      u2 = e2 ? !u2 : u2;
      const h2 = [], p2 = [];
      let d2, f2, m2 = [], _2 = 0;
      p2[_2] = void 0, m2[_2] = [];
      for (let t3 = 0, r3 = s2.length; t3 < r3; t3++)
        a2 = s2[t3], d2 = a2.getPoints(), o2 = i2(d2), o2 = e2 ? !o2 : o2, o2 ? (!u2 && p2[_2] && _2++, p2[_2] = { s: new $c(), p: d2 }, p2[_2].s.curves = a2.curves, u2 && _2++, m2[_2] = []) : m2[_2].push({ h: a2, p: d2[0] });
      if (!p2[0])
        return r2(s2);
      if (p2.length > 1) {
        let e3 = false, t3 = 0;
        for (let e4 = 0, t4 = p2.length; e4 < t4; e4++)
          h2[e4] = [];
        for (let r3 = 0, i3 = p2.length; r3 < i3; r3++) {
          const i4 = m2[r3];
          for (let s3 = 0; s3 < i4.length; s3++) {
            const o3 = i4[s3];
            let a3 = true;
            for (let i5 = 0; i5 < p2.length; i5++)
              n2(o3.p, p2[i5].p) && (r3 !== i5 && t3++, a3 ? (a3 = false, h2[i5].push(o3)) : e3 = true);
            a3 && h2[r3].push(o3);
          }
        }
        t3 > 0 && false === e3 && (m2 = h2);
      }
      for (let e3 = 0, t3 = p2.length; e3 < t3; e3++) {
        l2 = p2[e3].s, c2.push(l2), f2 = m2[e3];
        for (let e4 = 0, t4 = f2.length; e4 < t4; e4++)
          l2.holes.push(f2[e4].h);
      }
      return c2;
    }
  }
  const Pd = Bd();
  function Bd() {
    const e2 = new ArrayBuffer(4), t2 = new Float32Array(e2), r2 = new Uint32Array(e2), n2 = new Uint32Array(512), i2 = new Uint32Array(512);
    for (let e3 = 0; e3 < 256; ++e3) {
      const t3 = e3 - 127;
      t3 < -27 ? (n2[e3] = 0, n2[256 | e3] = 32768, i2[e3] = 24, i2[256 | e3] = 24) : t3 < -14 ? (n2[e3] = 1024 >> -t3 - 14, n2[256 | e3] = 1024 >> -t3 - 14 | 32768, i2[e3] = -t3 - 1, i2[256 | e3] = -t3 - 1) : t3 <= 15 ? (n2[e3] = t3 + 15 << 10, n2[256 | e3] = t3 + 15 << 10 | 32768, i2[e3] = 13, i2[256 | e3] = 13) : t3 < 128 ? (n2[e3] = 31744, n2[256 | e3] = 64512, i2[e3] = 24, i2[256 | e3] = 24) : (n2[e3] = 31744, n2[256 | e3] = 64512, i2[e3] = 13, i2[256 | e3] = 13);
    }
    const s2 = new Uint32Array(2048), o2 = new Uint32Array(64), a2 = new Uint32Array(64);
    for (let e3 = 1; e3 < 1024; ++e3) {
      let t3 = e3 << 13, r3 = 0;
      for (; 0 == (8388608 & t3); )
        t3 <<= 1, r3 -= 8388608;
      t3 &= -8388609, r3 += 947912704, s2[e3] = t3 | r3;
    }
    for (let e3 = 1024; e3 < 2048; ++e3)
      s2[e3] = 939524096 + (e3 - 1024 << 13);
    for (let e3 = 1; e3 < 31; ++e3)
      o2[e3] = e3 << 23;
    o2[31] = 1199570944, o2[32] = 2147483648;
    for (let e3 = 33; e3 < 63; ++e3)
      o2[e3] = 2147483648 + (e3 - 32 << 23);
    o2[63] = 3347054592;
    for (let e3 = 1; e3 < 64; ++e3)
      32 !== e3 && (a2[e3] = 1024);
    return { floatView: t2, uint32View: r2, baseTable: n2, shiftTable: i2, mantissaTable: s2, exponentTable: o2, offsetTable: a2 };
  }
  var Rd = Object.freeze({ __proto__: null, toHalfFloat: function(e2) {
    Math.abs(e2) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e2 = yr(e2, -65504, 65504), Pd.floatView[0] = e2;
    const t2 = Pd.uint32View[0], r2 = t2 >> 23 & 511;
    return Pd.baseTable[r2] + ((8388607 & t2) >> Pd.shiftTable[r2]);
  }, fromHalfFloat: function(e2) {
    const t2 = e2 >> 10;
    return Pd.uint32View[0] = Pd.mantissaTable[Pd.offsetTable[t2] + (1023 & e2)] + Pd.exponentTable[t2], Pd.floatView[0];
  } });
  function Ld() {
    console.error("THREE.ImmediateRenderObject has been removed.");
  }
  class Od extends en {
    constructor(e2, t2, r2) {
      console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'), super(e2, t2, r2), this.samples = 4;
    }
  }
  class Fd extends tn {
    constructor(e2, t2, r2, n2) {
      console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."), super(e2, t2, r2, n2);
    }
  }
  class Ud extends nn {
    constructor(e2, t2, r2, n2) {
      console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."), super(e2, t2, r2, n2);
    }
  }
  class Nd extends hs {
    constructor(e2, t2, r2, n2, i2, s2) {
      console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(e2, t2, r2, n2, i2, s2);
    }
  }
  class jd extends Gc {
    constructor(e2, t2, r2, n2) {
      console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(e2, t2, r2, n2);
    }
  }
  class zd extends Vc {
    constructor(e2, t2, r2, n2) {
      console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(e2, t2, r2, n2);
    }
  }
  class Gd extends Hc {
    constructor(e2, t2, r2, n2, i2, s2, o2) {
      console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(e2, t2, r2, n2, i2, s2, o2);
    }
  }
  class Vd extends Qc {
    constructor(e2, t2, r2, n2, i2, s2, o2, a2) {
      console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(e2, t2, r2, n2, i2, s2, o2, a2);
    }
  }
  class Qd extends qc {
    constructor(e2, t2) {
      console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(e2, t2);
    }
  }
  class Hd extends Mu {
    constructor(e2, t2) {
      console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(e2, t2);
    }
  }
  class Wd extends Iu {
    constructor(e2, t2) {
      console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(e2, t2);
    }
  }
  class qd extends zc {
    constructor(e2, t2, r2, n2) {
      console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(e2, t2, r2, n2);
    }
  }
  class Xd extends ku {
    constructor(e2, t2) {
      console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(e2, t2);
    }
  }
  class Yd extends Ds {
    constructor(e2, t2, r2, n2) {
      console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(e2, t2, r2, n2);
    }
  }
  class Kd extends Wc {
    constructor(e2, t2, r2, n2) {
      console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(e2, t2, r2, n2);
    }
  }
  class Jd extends Du {
    constructor(e2, t2, r2, n2, i2, s2) {
      console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(e2, t2, r2, n2, i2, s2);
    }
  }
  class Zd extends Pu {
    constructor(e2, t2) {
      console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(e2, t2);
    }
  }
  class $d extends Bu {
    constructor(e2, t2, r2, n2, i2, s2, o2) {
      console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(e2, t2, r2, n2, i2, s2, o2);
    }
  }
  class ef extends Ru {
    constructor(e2, t2) {
      console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(e2, t2);
    }
  }
  class tf extends Lu {
    constructor(e2, t2, r2, n2, i2) {
      console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(e2, t2, r2, n2, i2);
    }
  }
  class rf extends Ou {
    constructor(e2, t2, r2, n2, i2, s2) {
      console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(e2, t2, r2, n2, i2, s2);
    }
  }
  class nf extends Fu {
    constructor(e2, t2, r2, n2, i2) {
      console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(e2, t2, r2, n2, i2);
    }
  }
  "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: n } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = n);
}, 553: function(e, t, r) {
  r.d(t, { _: function() {
    return s;
  } });
  var n = r(988);
  const i = /* @__PURE__ */ new WeakMap();
  class s extends n.aNw {
    constructor(e2) {
      super(e2), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" };
    }
    setDecoderPath(e2) {
      return this.decoderPath = e2, this;
    }
    setDecoderConfig(e2) {
      return this.decoderConfig = e2, this;
    }
    setWorkerLimit(e2) {
      return this.workerLimit = e2, this;
    }
    load(e2, t2, r2, i2) {
      const s2 = new n.hH6(this.manager);
      s2.setPath(this.path), s2.setResponseType("arraybuffer"), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(this.withCredentials), s2.load(e2, (e3) => {
        this.decodeDracoFile(e3, t2).catch(i2);
      }, r2, i2);
    }
    decodeDracoFile(e2, t2, r2, n2) {
      const i2 = { attributeIDs: r2 || this.defaultAttributeIDs, attributeTypes: n2 || this.defaultAttributeTypes, useUniqueIDs: !!r2 };
      return this.decodeGeometry(e2, i2).then(t2);
    }
    decodeGeometry(e2, t2) {
      const r2 = JSON.stringify(t2);
      if (i.has(e2)) {
        const t3 = i.get(e2);
        if (t3.key === r2)
          return t3.promise;
        if (0 === e2.byteLength)
          throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
      }
      let n2;
      const s2 = this.workerNextTaskID++, o2 = e2.byteLength, a = this._getWorker(s2, o2).then((r3) => (n2 = r3, new Promise((r4, i2) => {
        n2._callbacks[s2] = { resolve: r4, reject: i2 }, n2.postMessage({ type: "decode", id: s2, taskConfig: t2, buffer: e2 }, [e2]);
      }))).then((e3) => this._createGeometry(e3.geometry));
      return a.catch(() => true).then(() => {
        n2 && s2 && this._releaseTask(n2, s2);
      }), i.set(e2, { key: r2, promise: a }), a;
    }
    _createGeometry(e2) {
      const t2 = new n.u9r();
      e2.index && t2.setIndex(new n.TlE(e2.index.array, 1));
      for (let r2 = 0; r2 < e2.attributes.length; r2++) {
        const i2 = e2.attributes[r2], s2 = i2.name, o2 = i2.array, a = i2.itemSize;
        t2.setAttribute(s2, new n.TlE(o2, a));
      }
      return t2;
    }
    _loadLibrary(e2, t2) {
      const r2 = new n.hH6(this.manager);
      return r2.setPath(this.decoderPath), r2.setResponseType(t2), r2.setWithCredentials(this.withCredentials), new Promise((t3, n2) => {
        r2.load(e2, t3, void 0, n2);
      });
    }
    preload() {
      return this._initDecoder(), this;
    }
    _initDecoder() {
      if (this.decoderPending)
        return this.decoderPending;
      const e2 = "object" != typeof WebAssembly || "js" === this.decoderConfig.type, t2 = [];
      return e2 ? t2.push(this._loadLibrary("draco_decoder.js", "text")) : (t2.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t2.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t2).then((t3) => {
        const r2 = t3[0];
        e2 || (this.decoderConfig.wasmBinary = t3[1]);
        const n2 = o.toString(), i2 = ["/* draco decoder */", r2, "", "/* worker */", n2.substring(n2.indexOf("{") + 1, n2.lastIndexOf("}"))].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([i2]));
      }), this.decoderPending;
    }
    _getWorker(e2, t2) {
      return this._initDecoder().then(() => {
        if (this.workerPool.length < this.workerLimit) {
          const e3 = new Worker(this.workerSourceURL);
          e3._callbacks = {}, e3._taskCosts = {}, e3._taskLoad = 0, e3.postMessage({ type: "init", decoderConfig: this.decoderConfig }), e3.onmessage = function(t3) {
            const r3 = t3.data;
            switch (r3.type) {
              case "decode":
                e3._callbacks[r3.id].resolve(r3);
                break;
              case "error":
                e3._callbacks[r3.id].reject(r3);
                break;
              default:
                console.error('THREE.DRACOLoader: Unexpected message, "' + r3.type + '"');
            }
          }, this.workerPool.push(e3);
        } else
          this.workerPool.sort(function(e3, t3) {
            return e3._taskLoad > t3._taskLoad ? -1 : 1;
          });
        const r2 = this.workerPool[this.workerPool.length - 1];
        return r2._taskCosts[e2] = t2, r2._taskLoad += t2, r2;
      });
    }
    _releaseTask(e2, t2) {
      e2._taskLoad -= e2._taskCosts[t2], delete e2._callbacks[t2], delete e2._taskCosts[t2];
    }
    debug() {
      console.log("Task load: ", this.workerPool.map((e2) => e2._taskLoad));
    }
    dispose() {
      for (let e2 = 0; e2 < this.workerPool.length; ++e2)
        this.workerPool[e2].terminate();
      return this.workerPool.length = 0, this;
    }
  }
  function o() {
    let e2, t2;
    function r2(e3, t3, r3, n2, i2, s2) {
      const o2 = s2.num_components(), a = r3.num_points() * o2, l = a * i2.BYTES_PER_ELEMENT, c = function(e4, t4) {
        switch (t4) {
          case Float32Array:
            return e4.DT_FLOAT32;
          case Int8Array:
            return e4.DT_INT8;
          case Int16Array:
            return e4.DT_INT16;
          case Int32Array:
            return e4.DT_INT32;
          case Uint8Array:
            return e4.DT_UINT8;
          case Uint16Array:
            return e4.DT_UINT16;
          case Uint32Array:
            return e4.DT_UINT32;
        }
      }(e3, i2), u = e3._malloc(l);
      t3.GetAttributeDataArrayForAllPoints(r3, s2, c, l, u);
      const h = new i2(e3.HEAPF32.buffer, u, a).slice();
      return e3._free(u), { name: n2, array: h, itemSize: o2 };
    }
    onmessage = function(n2) {
      const i2 = n2.data;
      switch (i2.type) {
        case "init":
          e2 = i2.decoderConfig, t2 = new Promise(function(t3) {
            e2.onModuleLoaded = function(e3) {
              t3({ draco: e3 });
            }, DracoDecoderModule(e2);
          });
          break;
        case "decode":
          const n3 = i2.buffer, s2 = i2.taskConfig;
          t2.then((e3) => {
            const t3 = e3.draco, o2 = new t3.Decoder(), a = new t3.DecoderBuffer();
            a.Init(new Int8Array(n3), n3.byteLength);
            try {
              const e4 = function(e5, t4, n5, i3) {
                const s3 = i3.attributeIDs, o3 = i3.attributeTypes;
                let a2, l;
                const c = t4.GetEncodedGeometryType(n5);
                if (c === e5.TRIANGULAR_MESH)
                  a2 = new e5.Mesh(), l = t4.DecodeBufferToMesh(n5, a2);
                else {
                  if (c !== e5.POINT_CLOUD)
                    throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                  a2 = new e5.PointCloud(), l = t4.DecodeBufferToPointCloud(n5, a2);
                }
                if (!l.ok() || 0 === a2.ptr)
                  throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                const u = { index: null, attributes: [] };
                for (const n6 in s3) {
                  const l2 = self[o3[n6]];
                  let c2, h;
                  if (i3.useUniqueIDs)
                    h = s3[n6], c2 = t4.GetAttributeByUniqueId(a2, h);
                  else {
                    if (h = t4.GetAttributeId(a2, e5[s3[n6]]), -1 === h)
                      continue;
                    c2 = t4.GetAttribute(a2, h);
                  }
                  u.attributes.push(r2(e5, t4, a2, n6, l2, c2));
                }
                return c === e5.TRIANGULAR_MESH && (u.index = function(e6, t5, r3) {
                  const n6 = 3 * r3.num_faces(), i4 = 4 * n6, s4 = e6._malloc(i4);
                  t5.GetTrianglesUInt32Array(r3, i4, s4);
                  const o4 = new Uint32Array(e6.HEAPF32.buffer, s4, n6).slice();
                  return e6._free(s4), { array: o4, itemSize: 1 };
                }(e5, t4, a2)), e5.destroy(a2), u;
              }(t3, o2, a, s2), n4 = e4.attributes.map((e5) => e5.array.buffer);
              e4.index && n4.push(e4.index.array.buffer), self.postMessage({ type: "decode", id: i2.id, geometry: e4 }, n4);
            } catch (e4) {
              console.error(e4), self.postMessage({ type: "error", id: i2.id, error: e4.message });
            } finally {
              t3.destroy(a), t3.destroy(o2);
            }
          });
      }
    };
  }
} };
var __webpackgi_module_cache__ = {};
function __webpackgi_require__2(e) {
  var t = __webpackgi_module_cache__[e];
  if (void 0 !== t)
    return t.exports;
  var r = __webpackgi_module_cache__[e] = { id: e, exports: {} };
  return __webpackgi_modules__[e].call(r.exports, r, r.exports, __webpackgi_require__2), r.exports;
}
__webpackgi_require__2.n = function(e) {
  var t = e && e.__esModule ? function() {
    return e.default;
  } : function() {
    return e;
  };
  return __webpackgi_require__2.d(t, { a: t }), t;
}, __webpackgi_require__2.d = function(e, t) {
  for (var r in t)
    __webpackgi_require__2.o(t, r) && !__webpackgi_require__2.o(e, r) && Object.defineProperty(e, r, { enumerable: true, get: t[r] });
}, __webpackgi_require__2.o = function(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}, __webpackgi_require__2.r = function(e) {
  "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: true });
}, __webpackgi_require__2.nc = void 0;
var __webpackgi_exports__2 = {};
!function() {
  __webpackgi_require__2.d(__webpackgi_exports__2, { LY2: function() {
    return n.LY2;
  }, HRj: function() {
    return rr;
  }, li4: function() {
    return Py;
  }, FO5: function() {
    return By;
  }, Nlh: function() {
    return My;
  }, QvI: function() {
    return ro;
  }, JHp: function() {
    return Eo;
  }, bGH: function() {
    return n.bGH;
  }, NDo: function() {
    return n.NDo;
  }, gSk: function() {
    return n.gSk;
  }, WMw: function() {
    return n.WMw;
  }, OTo: function() {
    return n.OTo;
  }, Se2: function() {
    return n.Se2;
  }, cum: function() {
    return n.cum;
  }, Mig: function() {
    return n.Mig;
  }, B$7: function() {
    return Ys;
  }, i_9: function() {
    return n.i_9;
  }, m7l: function() {
    return n.m7l;
  }, sYA: function() {
    return n.sYA;
  }, Xcj: function() {
    return n.Xcj;
  }, mzJ: function() {
    return n.mzJ;
  }, ZZA: function() {
    return n.ZZA;
  }, $Ph: function() {
    return xu;
  }, T__: function() {
    return n.T__;
  }, HkE: function() {
    return n.HkE;
  }, tGC: function() {
    return n.tGC;
  }, g1S: function() {
    return eg;
  }, I$C: function() {
    return tg;
  }, QIH: function() {
    return Js;
  }, _JE: function() {
    return vp;
  }, ksm: function() {
    return to;
  }, jl_: function() {
    return Ji;
  }, b7R: function() {
    return ds;
  }, BDV: function() {
    return Vi;
  }, Ea_: function() {
    return ts;
  }, qff: function() {
    return Ji;
  }, tmC: function() {
    return qi;
  }, BON: function() {
    return js;
  }, P40: function() {
    return cs;
  }, wLL: function() {
    return Rs;
  }, iHO: function() {
    return ss;
  }, BbS: function() {
    return n.BbS;
  }, kqm: function() {
    return n.kqm;
  }, Hmr: function() {
    return n.Hmr;
  }, SJI: function() {
    return n.SJI;
  }, mTL: function() {
    return n.mTL;
  }, y8_: function() {
    return n.y8_;
  }, _Li: function() {
    return n._Li;
  }, g56: function() {
    return fu;
  }, bj3: function() {
    return K;
  }, z81: function() {
    return n.z81;
  }, _MY: function() {
    return n._MY;
  }, yEv: function() {
    return A_;
  }, dFZ: function() {
    return bu;
  }, N$j: function() {
    return n.N$j;
  }, _YM: function() {
    return n._YM;
  }, TUj: function() {
    return n.TUj;
  }, ZzF: function() {
    return n.ZzF;
  }, qzb: function() {
    return k;
  }, GQ: function() {
    return n.GQ;
  }, nvb: function() {
    return n.nvb;
  }, DvJ: function() {
    return n.DvJ;
  }, fQA: function() {
    return n.fQA;
  }, cPz: function() {
    return za;
  }, TlE: function() {
    return n.TlE;
  }, u9r: function() {
    return n.u9r;
  }, s4_: function() {
    return n.s4_;
  }, T95: function() {
    return n.T95;
  }, F5w: function() {
    return sS;
  }, NlP: function() {
    return TM;
  }, $8Z: function() {
    return nS;
  }, YYN: function() {
    return vy;
  }, CtF: function() {
    return n.CtF;
  }, V1s: function() {
    return n.V1s;
  }, jOv: function() {
    return _t;
  }, Rki: function() {
    return n.Rki;
  }, pzV: function() {
    return UT;
  }, itZ: function() {
    return rh;
  }, qKx: function() {
    return nh;
  }, vlJ: function() {
    return Fy;
  }, nPO: function() {
    return Ny;
  }, zcQ: function() {
    return Ju;
  }, GH1: function() {
    return $u;
  }, ROQ: function() {
    return n.ROQ;
  }, YN5: function() {
    return n.YN5;
  }, BVQ: function() {
    return n.BVQ;
  }, YT8: function() {
    return n.YT8;
  }, _DE: function() {
    return zp;
  }, YGz: function() {
    return n.YGz;
  }, trn: function() {
    return n.trn;
  }, zf8: function() {
    return n.zf8;
  }, uWy: function() {
    return n.uWy;
  }, wYQ: function() {
    return zu;
  }, SUY: function() {
    return n.SUY;
  }, Ilk: function() {
    return n.Ilk;
  }, R2R: function() {
    return n.R2R;
  }, epp: function() {
    return n.epp;
  }, xmJ: function() {
    return bp;
  }, GD$: function() {
    return Ki;
  }, EB7: function() {
    return n.EB7;
  }, DqL: function() {
    return n.DqL;
  }, _3: function() {
    return n._3;
  }, b_z: function() {
    return n.b_z;
  }, OCn: function() {
    return Vy;
  }, _am: function() {
    return n._am;
  }, kB7: function() {
    return Ho;
  }, fY$: function() {
    return n.fY$;
  }, vxC: function() {
    return n.vxC;
  }, BtG: function() {
    return n.BtG;
  }, cBK: function() {
    return n.cBK;
  }, g8_: function() {
    return n.g8_;
  }, AXT: function() {
    return n.AXT;
  }, yj7: function() {
    return n.yj7;
  }, dYG: function() {
    return n.dYG;
  }, tm_: function() {
    return n.tm_;
  }, S2y: function() {
    return n.S2y;
  }, B02: function() {
    return n.B02;
  }, PeU: function() {
    return n.PeU;
  }, Hyl: function() {
    return n.Hyl;
  }, Wqd: function() {
    return n.Wqd;
  }, Xaj: function() {
    return n.Xaj;
  }, DUb: function() {
    return Fu;
  }, dZ3: function() {
    return n.dZ3;
  }, m_w: function() {
    return n.m_w;
  }, fHI: function() {
    return n.fHI;
  }, LBq: function() {
    return n.LBq;
  }, dHf: function() {
    return Ey;
  }, Qww: function() {
    return wn.Q;
  }, CGV: function() {
    return Sy;
  }, JUT: function() {
    return n.JUT;
  }, p3g: function() {
    return n.p3g;
  }, IEO: function() {
    return n.IEO;
  }, CN8: function() {
    return n.CN8;
  }, zob: function() {
    return n.zob;
  }, yxD: function() {
    return n.yxD;
  }, CUS: function() {
    return b_;
  }, A5E: function() {
    return n.A5E;
  }, zqG: function() {
    return Yc;
  }, PfX: function() {
    return ys;
  }, Q1o: function() {
    return ps;
  }, jfJ: function() {
    return n.jfJ;
  }, T_J: function() {
    return n.T_J;
  }, tEQ: function() {
    return n.tEQ;
  }, gb4: function() {
    return Gi;
  }, qkB: function() {
    return n.qkB;
  }, cvk: function() {
    return vh;
  }, HWo: function() {
    return bh;
  }, brP: function() {
    return n.brP;
  }, $YQ: function() {
    return n.$YQ;
  }, X8d: function() {
    return OM;
  }, Zdt: function() {
    return UM;
  }, yNB: function() {
    return Zo;
  }, h7x: function() {
    return Gc;
  }, Ox3: function() {
    return n.Ox3;
  }, qtn: function() {
    return Ws;
  }, cBI: function() {
    return n.cBI;
  }, cU9: function() {
    return n.cU9;
  }, DT1: function() {
    return n.DT1;
  }, Kgo: function() {
    return n.Kgo;
  }, ehD: function() {
    return n.ehD;
  }, fhJ: function() {
    return xo;
  }, y1s: function() {
    return wo;
  }, fSK: function() {
    return n.fSK;
  }, Vdb: function() {
    return n.Vdb;
  }, l8J: function() {
    return n.l8J;
  }, dj0: function() {
    return n.dj0;
  }, QM0: function() {
    return n.QM0;
  }, OIS: function() {
    return ym;
  }, q8b: function() {
    return kc;
  }, TOt: function() {
    return n.TOt;
  }, xaN: function() {
    return d;
  }, Ny0: function() {
    return n.Ny0;
  }, NeD: function() {
    return PE;
  }, Zof: function() {
    return xs;
  }, eD: function() {
    return n.eD;
  }, jwo: function() {
    return n.jwo;
  }, dSO: function() {
    return n.dSO;
  }, Bf4: function() {
    return n.Bf4;
  }, USm: function() {
    return n.USm;
  }, pBf: function() {
    return n.pBf;
  }, $Vf: function() {
    return n.$Vf;
  }, O7d: function() {
    return n.O7d;
  }, ksq: function() {
    return qm;
  }, gXf: function() {
    return au;
  }, hH6: function() {
    return n.hH6;
  }, kpi: function() {
    return Hp;
  }, DwZ: function() {
    return QM;
  }, kN3: function() {
    return HM;
  }, e62: function() {
    return n.e62;
  }, a$l: function() {
    return n.a$l;
  }, OM3: function() {
    return n.OM3;
  }, VzW: function() {
    return n.VzW;
  }, ybr: function() {
    return n.ybr;
  }, yo9: function() {
    return n.yo9;
  }, $Bt: function() {
    return Oc;
  }, Wzm: function() {
    return n.Wzm;
  }, Wl3: function() {
    return n.Wl3;
  }, iWj: function() {
    return n.iWj;
  }, DNz: function() {
    return yo;
  }, m1M: function() {
    return lo;
  }, ylh: function() {
    return n.ylh;
  }, v9Y: function() {
    return n.v9Y;
  }, LSk: function() {
    return n.LSk;
  }, LHE: function() {
    return Wc;
  }, KE0: function() {
    return Vb;
  }, KCF: function() {
    return Gb;
  }, a4n: function() {
    return V_;
  }, zIH: function() {
    return rn;
  }, Hfk: function() {
    return gn;
  }, png: function() {
    return mn;
  }, tAj: function() {
    return _n;
  }, Eb_: function() {
    return vn;
  }, BT2: function() {
    return $m;
  }, _8p: function() {
    return G_;
  }, V5Z: function() {
    return wp;
  }, s5b: function() {
    return Ep;
  }, hkn: function() {
    return Vt;
  }, GFY: function() {
    return io;
  }, w$m: function() {
    return n.w$m;
  }, ksN: function() {
    return n.ksN;
  }, j4z: function() {
    return n.j4z;
  }, OAl: function() {
    return n.OAl;
  }, VLJ: function() {
    return n.VLJ;
  }, C73: function() {
    return _u;
  }, ZAu: function() {
    return n.ZAu;
  }, ibP: function() {
    return es;
  }, _fI: function() {
    return Ki;
  }, hUN: function() {
    return fh;
  }, cLu: function() {
    return n.cLu;
  }, vmT: function() {
    return n.vmT;
  }, Qpg: function() {
    return n.Qpg;
  }, So8: function() {
    return n.So8;
  }, eOv: function() {
    return PT;
  }, Wjw: function() {
    return n.Wjw;
  }, cJO: function() {
    return n.cJO;
  }, QRU: function() {
    return n.QRU;
  }, S3k: function() {
    return n.S3k;
  }, PpQ: function() {
    return n.PpQ;
  }, AHu: function() {
    return n.AHu;
  }, q_9: function() {
    return ir;
  }, ZRs: function() {
    return n.ZRs;
  }, oqc: function() {
    return n.oqc;
  }, T_x: function() {
    return Wi;
  }, lb7: function() {
    return n.lb7;
  }, L5s: function() {
    return n.L5s;
  }, $TI: function() {
    return n.$TI;
  }, SPe: function() {
    return n.SPe;
  }, aVm: function() {
    return n.aVm;
  }, j87: function() {
    return n.j87;
  }, RNb: function() {
    return n.RNb;
  }, Kz5: function() {
    return n.Kz5;
  }, vpT: function() {
    return n.vpT;
  }, kB5: function() {
    return n.kB5;
  }, _C8: function() {
    return n._C8;
  }, Syv: function() {
    return n.Syv;
  }, NMF: function() {
    return n.NMF;
  }, pIN: function() {
    return n.pIN;
  }, eMJ: function() {
    return n.eMJ;
  }, rN7: function() {
    return Gh;
  }, iUp: function() {
    return Vh;
  }, GFd: function() {
    return v_;
  }, x5V: function() {
    return n.x5V;
  }, tUh: function() {
    return n.tUh;
  }, z8B: function() {
    return n.z8B;
  }, vcl: function() {
    return Bp;
  }, GZb: function() {
    return n.GZb;
  }, p7y: function() {
    return n.p7y;
  }, S9g: function() {
    return n.S9g;
  }, Zr5: function() {
    return n.Zr5;
  }, vCF: function() {
    return n.vCF;
  }, yt0: function() {
    return n.yt0;
  }, uXU: function() {
    return n.uXU;
  }, _kC: function() {
    return n._kC;
  }, lk7: function() {
    return n.lk7;
  }, USc: function() {
    return BT;
  }, x12: function() {
    return n.x12;
  }, Zzh: function() {
    return n.Zzh;
  }, nls: function() {
    return n.nls;
  }, g_z: function() {
    return n.g_z;
  }, U7: function() {
    return n.U7;
  }, FT0: function() {
    return n.FT0;
  }, blk: function() {
    return n.blk;
  }, ejS: function() {
    return n.ejS;
  }, rnI: function() {
    return n.rnI;
  }, wem: function() {
    return n.wem;
  }, lfu: function() {
    return n.lfu;
  }, FDw: function() {
    return n.FDw;
  }, lRj: function() {
    return n.lRj;
  }, D1R: function() {
    return n.D1R;
  }, qyh: function() {
    return n.qyh;
  }, GUF: function() {
    return n.GUF;
  }, EoG: function() {
    return n.EoG;
  }, aNw: function() {
    return n.aNw;
  }, Zp0: function() {
    return n.Zp0;
  }, lLk: function() {
    return n.lLk;
  }, jAl: function() {
    return n.jAl;
  }, uEv: function() {
    return n.uEv;
  }, YKA: function() {
    return n.YKA;
  }, cRx: function() {
    return n.cRx;
  }, Y8D: function() {
    return n.Y8D;
  }, RsA: function() {
    return n.RsA;
  }, Y0m: function() {
    return r_;
  }, F5T: function() {
    return n.F5T;
  }, EDU: function() {
    return qy;
  }, z$Q: function() {
    return dE;
  }, KA8: function() {
    return Ft;
  }, XUj: function() {
    return fE;
  }, Me$: function() {
    return mE;
  }, u7G: function() {
    return n.u7G;
  }, PEk: function() {
    return nr;
  }, BG4: function() {
    return Wy;
  }, M8C: function() {
    return n.M8C;
  }, Vkp: function() {
    return n.Vkp;
  }, yGw: function() {
    return n.yGw;
  }, Sm8: function() {
    return n.Sm8;
  }, Kj0: function() {
    return n.Kj0;
  }, vBJ: function() {
    return n.vBJ;
  }, QfV: function() {
    return Zt;
  }, lRF: function() {
    return n.lRF;
  }, Lun: function() {
    return n.Lun;
  }, YBo: function() {
    return n.YBo;
  }, kaV: function() {
    return n.kaV;
  }, RSm: function() {
    return n.RSm;
  }, xoR: function() {
    return n.xoR;
  }, EJi: function() {
    return n.EJi;
  }, Wid: function() {
    return n.Wid;
  }, iuj: function() {
    return Kt;
  }, IKL: function() {
    return n.IKL;
  }, r_: function() {
    return n.r_;
  }, OoA: function() {
    return n.OoA;
  }, qhX: function() {
    return n.qhX;
  }, qPT: function() {
    return So;
  }, M5h: function() {
    return n.M5h;
  }, Ns1: function() {
    return n.Ns1;
  }, TyD: function() {
    return n.TyD;
  }, vZf: function() {
    return n.vZf;
  }, HTd: function() {
    return n.HTd;
  }, aH4: function() {
    return n.aH4;
  }, YLQ: function() {
    return n.YLQ;
  }, BVF: function() {
    return n.BVF;
  }, MyG: function() {
    return n.MyG;
  }, jFi: function() {
    return n.jFi;
  }, aCh: function() {
    return n.aCh;
  }, uL9: function() {
    return n.uL9;
  }, TNj: function() {
    return Du;
  }, IFH: function() {
    return n.IFH;
  }, bdR: function() {
    return n.bdR;
  }, kM_: function() {
    return Wo;
  }, M6v: function() {
    return n.M6v;
  }, RvT: function() {
    return n.RvT;
  }, dUE: function() {
    return n.dUE;
  }, oe_: function() {
    return f_;
  }, BuN: function() {
    return m_;
  }, Tme: function() {
    return n.Tme;
  }, N9P: function() {
    return ar;
  }, Gql: function() {
    return n.Gql;
  }, $XY: function() {
    return sn;
  }, O9d: function() {
    return $o;
  }, zEO: function() {
    return cr;
  }, qfx: function() {
    return bE;
  }, PA7: function() {
    return n.PA7;
  }, REq: function() {
    return n.REq;
  }, pQR: function() {
    return n.pQR;
  }, ghN: function() {
    return n.ghN;
  }, Hy8: function() {
    return n.Hy8;
  }, Wpd: function() {
    return n.Wpd;
  }, LgZ: function() {
    return n.LgZ;
  }, iWC: function() {
    return n.iWC;
  }, mqn: function() {
    return AI;
  }, SKe: function() {
    return ft;
  }, iKG: function() {
    return n.iKG;
  }, _iA: function() {
    return n._iA;
  }, ntZ: function() {
    return n.ntZ;
  }, anP: function() {
    return n.anP;
  }, X2e: function() {
    return ly;
  }, FCo: function() {
    return wE;
  }, y$t: function() {
    return n.y$t;
  }, cPb: function() {
    return n.cPb;
  }, lmx: function() {
    return Nc;
  }, JOQ: function() {
    return n.JOQ;
  }, BKK: function() {
    return n.BKK;
  }, _12: function() {
    return n._12;
  }, tJx: function() {
    return n.tJx;
  }, cek: function() {
    return n.cek;
  }, qD0: function() {
    return Xs;
  }, xG9: function() {
    return n.xG9;
  }, wI8: function() {
    return $M;
  }, Sgv: function() {
    return eT;
  }, woe: function() {
    return n.woe;
  }, UY4: function() {
    return n.UY4;
  }, aq0: function() {
    return n.aq0;
  }, ujx: function() {
    return n.ujx;
  }, Uol: function() {
    return n.Uol;
  }, JiH: function() {
    return BE;
  }, VYz: function() {
    return n.VYz;
  }, _Pm: function() {
    return Jh;
  }, EsW: function() {
    return To;
  }, iUV: function() {
    return n.iUV;
  }, tf: function() {
    return n.tf;
  }, ZQ6: function() {
    return n.ZQ6;
  }, mXe: function() {
    return n.mXe;
  }, _fP: function() {
    return n._fP;
  }, iLg: function() {
    return n.iLg;
  }, zbs: function() {
    return n.zbs;
  }, UZH: function() {
    return n.UZH;
  }, mSO: function() {
    return n.mSO;
  }, wk1: function() {
    return n.wk1;
  }, E2K: function() {
    return n.E2K;
  }, FUD: function() {
    return n.FUD;
  }, pKu: function() {
    return n.pKu;
  }, GG6: function() {
    return n.GG6;
  }, Gih: function() {
    return n.Gih;
  }, iiP: function() {
    return n.iiP;
  }, SvJ: function() {
    return n.SvJ;
  }, ptH: function() {
    return n.ptH;
  }, jZA: function() {
    return n.jZA;
  }, y2t: function() {
    return n.y2t;
  }, gi4: function() {
    return n.gi4;
  }, Djp: function() {
    return n.Djp;
  }, BG$: function() {
    return n.BG$;
  }, NYV: function() {
    return n.NYV;
  }, xJs: function() {
    return n.xJs;
  }, bsb: function() {
    return n.bsb;
  }, ekQ: function() {
    return n.ekQ;
  }, CaW: function() {
    return n.CaW;
  }, eaV: function() {
    return n.eaV;
  }, BFQ: function() {
    return n.BFQ;
  }, v3W: function() {
    return n.v3W;
  }, ILR: function() {
    return n.ILR;
  }, UCm: function() {
    return n.UCm;
  }, Inb: function() {
    return n.Inb;
  }, U1$: function() {
    return R;
  }, LgE: function() {
    return n.LgE;
  }, fto: function() {
    return n.fto;
  }, l0P: function() {
    return n.l0P;
  }, vCx: function() {
    return n.vCx;
  }, _AM: function() {
    return n._AM;
  }, wuA: function() {
    return n.wuA;
  }, av9: function() {
    return n.av9;
  }, CtA: function() {
    return n.CtA;
  }, BvQ: function() {
    return su;
  }, FZJ: function() {
    return hh;
  }, FIo: function() {
    return n.FIo;
  }, zHn: function() {
    return n.zHn;
  }, iMs: function() {
    return n.iMs;
  }, T_f: function() {
    return n.T_f;
  }, hEm: function() {
    return n.hEm;
  }, D9w: function() {
    return n.D9w;
  }, sHH: function() {
    return pu;
  }, CdI: function() {
    return n.CdI;
  }, rkc: function() {
    return FT;
  }, rpg: function() {
    return n.rpg;
  }, ce8: function() {
    return n.ce8;
  }, rOj: function() {
    return n.rOj;
  }, P6m: function() {
    return Zm;
  }, JA6: function() {
    return Jm;
  }, V4E: function() {
    return n.V4E;
  }, o8S: function() {
    return n.o8S;
  }, flB: function() {
    return vt;
  }, DUH: function() {
    return wy;
  }, KI_: function() {
    return n.KI_;
  }, iLN: function() {
    return Qo;
  }, jsw: function() {
    return wh;
  }, srG: function() {
    return CE;
  }, i6Z: function() {
    return No;
  }, vfv: function() {
    return t_;
  }, xsS: function() {
    return n.xsS;
  }, or: function() {
    return RT;
  }, EQj: function() {
    return $h;
  }, ov0: function() {
    return ja;
  }, WdD: function() {
    return n.WdD;
  }, Vj0: function() {
    return n.Vj0;
  }, jyz: function() {
    return n.jyz;
  }, mTM: function() {
    return Ut;
  }, Mn1: function() {
    return Nt;
  }, Hlq: function() {
    return zt;
  }, Fi7: function() {
    return cu;
  }, Tn7: function() {
    return n.Tn7;
  }, bnF: function() {
    return n.bnF;
  }, HW6: function() {
    return n.HW6;
  }, oa8: function() {
    return n.oa8;
  }, T_1: function() {
    return n.T_1;
  }, zHJ: function() {
    return DE;
  }, iDF: function() {
    return n.iDF;
  }, iAb: function() {
    return n.iAb;
  }, d4E: function() {
    return Kp;
  }, lBg: function() {
    return TT;
  }, JeJ: function() {
    return Jp;
  }, FKY: function() {
    return r;
  }, zlZ: function() {
    return y_;
  }, vkg: function() {
    return ur;
  }, brh: function() {
    return x_;
  }, kZK: function() {
    return WE;
  }, puG: function() {
    return IT;
  }, OdW: function() {
    return n.OdW;
  }, _YX: function() {
    return n._YX;
  }, TUv: function() {
    return n.TUv;
  }, Hw6: function() {
    return n.Hw6;
  }, aLr: function() {
    return n.aLr;
  }, Aip: function() {
    return n.Aip;
  }, xo$: function() {
    return n.xo$;
  }, bIn: function() {
    return bI;
  }, $V: function() {
    return n.$V;
  }, lDi: function() {
    return n.lDi;
  }, gti: function() {
    return n.gti;
  }, PMe: function() {
    return n.PMe;
  }, iwP: function() {
    return qs;
  }, FvO: function() {
    return n.FvO;
  }, jyi: function() {
    return n.jyi;
  }, xeV: function() {
    return n.xeV;
  }, k74: function() {
    return n.k74;
  }, RlZ: function() {
    return n.RlZ;
  }, KhW: function() {
    return n.KhW;
  }, HgB: function() {
    return n.HgB;
  }, W2J: function() {
    return n.W2J;
  }, JWc: function() {
    return n.JWc;
  }, u37: function() {
    return n.u37;
  }, Z6B: function() {
    return n.Z6B;
  }, QZ1: function() {
    return n.QZ1;
  }, Ir4: function() {
    return n.Ir4;
  }, NwF: function() {
    return n.NwF;
  }, Wbm: function() {
    return n.Wbm;
  }, N4l: function() {
    return n.N4l;
  }, ej9: function() {
    return ME;
  }, QmN: function() {
    return n.QmN;
  }, IOt: function() {
    return n.IOt;
  }, NOD: function() {
    return Ku;
  }, L5g: function() {
    return n.L5g;
  }, H$k: function() {
    return n.H$k;
  }, cuP: function() {
    return VE;
  }, xEZ: function() {
    return n.xEZ;
  }, dpR: function() {
    return n.dpR;
  }, wOD: function() {
    return Cu;
  }, KNb: function() {
    return eo;
  }, IiN: function() {
    return Ip;
  }, Cne: function() {
    return n.Cne;
  }, XvJ: function() {
    return n.XvJ;
  }, XZw: function() {
    return n.XZw;
  }, FE5: function() {
    return n.FE5;
  }, lVp: function() {
    return jc;
  }, CJI: function() {
    return n.CJI;
  }, z$h: function() {
    return n.z$h;
  }, UlW: function() {
    return n.UlW;
  }, WwZ: function() {
    return n.WwZ;
  }, Lcc: function() {
    return n.Lcc;
  }, WXh: function() {
    return n.WXh;
  }, Vjr: function() {
    return TE;
  }, LuM: function() {
    return MT;
  }, LP5: function() {
    return pT;
  }, xfE: function() {
    return n.xfE;
  }, qlB: function() {
    return n.qlB;
  }, lCJ: function() {
    return n.lCJ;
  }, WTc: function() {
    return n.WTc;
  }, rAo: function() {
    return n.rAo;
  }, LZj: function() {
    return Mp;
  }, xWb: function() {
    return n.xWb;
  }, gH0: function() {
    return n.gH0;
  }, rBU: function() {
    return n.rBU;
  }, rDY: function() {
    return n.rDY;
  }, ywz: function() {
    return n.ywz;
  }, wJv: function() {
    return n.wJv;
  }, JQ4: function() {
    return n.JQ4;
  }, k0A: function() {
    return n.k0A;
  }, irR: function() {
    return n.irR;
  }, LsT: function() {
    return n.LsT;
  }, q5h: function() {
    return zs;
  }, TKh: function() {
    return Ns;
  }, tyg: function() {
    return Us;
  }, Ro5: function() {
    return ls;
  }, dwk: function() {
    return n.dwk;
  }, FM8: function() {
    return n.FM8;
  }, Pa4: function() {
    return n.Pa4;
  }, Ltg: function() {
    return n.Ltg;
  }, yC1: function() {
    return n.yC1;
  }, lHq: function() {
    return Xu;
  }, fO1: function() {
    return n.fO1;
  }, oMA: function() {
    return go;
  }, JzW: function() {
    return e;
  }, QEt: function() {
    return Fp;
  }, b5g: function() {
    return n.b5g;
  }, Ywn: function() {
    return n.Ywn;
  }, GVz: function() {
    return n.GVz;
  }, oAp: function() {
    return n.oAp;
  }, kFz: function() {
    return n.kFz;
  }, p7A: function() {
    return n.p7A;
  }, dd2: function() {
    return n.dd2;
  }, CP7: function() {
    return n.CP7;
  }, fQK: function() {
    return n.fQK;
  }, Wd$: function() {
    return Yp;
  }, t1_: function() {
    return oI;
  }, Uk6: function() {
    return n.Uk6;
  }, _sL: function() {
    return n._sL;
  }, Pnf: function() {
    return n.Pnf;
  }, c8b: function() {
    return n.c8b;
  }, _lf: function() {
    return n._lf;
  }, ad5: function() {
    return n.ad5;
  }, sZV: function() {
    return Ls;
  }, TfA: function() {
    return Bs;
  }, sKX: function() {
    return Qs;
  }, UdM: function() {
    return Ps;
  }, P0y: function() {
    return is;
  }, L_r: function() {
    return n.L_r;
  }, Bve: function() {
    return Wp;
  }, UeO: function() {
    return En;
  }, $nx: function() {
    return W_;
  }, Bk6: function() {
    return an;
  }, y4l: function() {
    return pr;
  }, pQ0: function() {
    return Hs;
  }, wXW: function() {
    return zx;
  }, r5x: function() {
    return Ux;
  }, MSI: function() {
    return Qx;
  }, EUu: function() {
    return II;
  }, jtH: function() {
    return Ic;
  }, T0T: function() {
    return Lc;
  }, gAb: function() {
    return wI;
  }, iwT: function() {
    return ih;
  }, je_: function() {
    return EI;
  }, wBP: function() {
    return Rc;
  }, LU2: function() {
    return nl;
  }, wQL: function() {
    return kI;
  }, Zs7: function() {
    return aw;
  }, x7s: function() {
    return xw;
  }, Mnd: function() {
    return BI;
  }, A0_: function() {
    return RI;
  }, d73: function() {
    return Cx;
  }, HCD: function() {
    return q;
  }, RG9: function() {
    return X;
  }, G2P: function() {
    return el;
  }, XLf: function() {
    return rl;
  }, CGN: function() {
    return tl;
  }, mvg: function() {
    return Mx;
  }, Hiy: function() {
    return Jt;
  }, XMc: function() {
    return Nx;
  }, N7M: function() {
    return Ox;
  }, iv: function() {
    return Gx;
  }, n55: function() {
    return xt;
  }, IaC: function() {
    return wx;
  }, h9t: function() {
    return sl;
  }, yDW: function() {
    return ol;
  }, gJv: function() {
    return il;
  }, l$g: function() {
    return iS;
  }, vQi: function() {
    return MM;
  }, $MY: function() {
    return fo;
  }, wJl: function() {
    return ho;
  }, Z7Y: function() {
    return Ja;
  }, X7D: function() {
    return $a;
  }, BnX: function() {
    return Za;
  }, uZ5: function() {
    return cl;
  }, zVI: function() {
    return kx;
  }, DpF: function() {
    return _h;
  }, nNb: function() {
    return Zi;
  }, cqZ: function() {
    return $i;
  }, pKN: function() {
    return by;
  }, d_$: function() {
    return Yo;
  }, DdI: function() {
    return yy;
  }, rrX: function() {
    return xy;
  }, KlC: function() {
    return Xo;
  }, KVn: function() {
    return B;
  }, oau: function() {
    return ow;
  }, aw9: function() {
    return xe;
  }, Aap: function() {
    return je;
  }, Dxg: function() {
    return b;
  }, MjT: function() {
    return Ee;
  }, F7Q: function() {
    return Wa;
  }, IFq: function() {
    return PI;
  }, IJl: function() {
    return Ha;
  }, O5A: function() {
    return At;
  }, wCn: function() {
    return St;
  }, gGT: function() {
    return Qa;
  }, pEc: function() {
    return Ay;
  }, Bi6: function() {
    return Ct;
  }, fi_: function() {
    return Cw;
  }, TT: function() {
    return Kx;
  }, q2Z: function() {
    return aI;
  }, NyK: function() {
    return J;
  }, bgu: function() {
    return Tt;
  }, kcS: function() {
    return Mt;
  }, rRN: function() {
    return rS;
  }, ivY: function() {
    return E;
  }, _s1: function() {
    return $I;
  }, _HO: function() {
    return Q;
  }, tpL: function() {
    return H;
  }, DMK: function() {
    return cc;
  }, LjN: function() {
    return fs;
  }, iFs: function() {
    return ms;
  }, qTg: function() {
    return g;
  }, Wtl: function() {
    return Qi;
  }, DmK: function() {
    return Hi;
  }, Htt: function() {
    return LI;
  }, Hx7: function() {
    return De;
  }, imt: function() {
    return Ie;
  }, US6: function() {
    return vw;
  }, vZs: function() {
    return Ko;
  }, TE$: function() {
    return NI;
  }, lmu: function() {
    return yt;
  }, SvO: function() {
    return wt;
  }, YQY: function() {
    return Xa;
  }, mZN: function() {
    return Ka;
  }, VvG: function() {
    return Ya;
  }, omp: function() {
    return LE;
  }, utz: function() {
    return Ix;
  }, TFV: function() {
    return vo;
  }, hrz: function() {
    return y;
  }, JKM: function() {
    return Zx;
  }, jZf: function() {
    return yI;
  }, RjL: function() {
    return dT;
  }, RRI: function() {
    return Aw;
  }, RUq: function() {
    return QE;
  }, _t4: function() {
    return ot;
  }, YHh: function() {
    return at;
  }, R8g: function() {
    return L;
  }, Bbl: function() {
    return or;
  }, V9r: function() {
    return v;
  }, PZ2: function() {
    return A;
  }, w7A: function() {
    return f;
  }, N6S: function() {
    return U;
  }, Uxp: function() {
    return N;
  }, tAz: function() {
    return F;
  }, R$F: function() {
    return z;
  }, N33: function() {
    return j;
  }, gw2: function() {
    return Zs;
  }, KlU: function() {
    return O;
  }, wo6: function() {
    return Bt;
  }, H4P: function() {
    return w;
  }, swA: function() {
    return rs;
  }, _Z3: function() {
    return ns;
  }, ivc: function() {
    return Zi;
  }, rZ1: function() {
    return $i;
  }, CpZ: function() {
    return Sw;
  }, dyc: function() {
    return S;
  }, MxZ: function() {
    return FE;
  }, btp: function() {
    return UE;
  }, mXy: function() {
    return OE;
  }, Ej0: function() {
    return Ue;
  }, ep4: function() {
    return ye;
  }, DQP: function() {
    return Ne;
  }, VNr: function() {
    return we;
  }, V7q: function() {
    return It;
  }, zEk: function() {
    return Ot;
  }, qfq: function() {
    return kt;
  }, piB: function() {
    return T;
  }, IIc: function() {
    return MI;
  }, rrF: function() {
    return Xi;
  }, naq: function() {
    return Yi;
  }, sXR: function() {
    return oc;
  }, p5I: function() {
    return Bc;
  }, wps: function() {
    return OI;
  }, wuo: function() {
    return FI;
  }, GpE: function() {
    return m;
  }, F4b: function() {
    return lc;
  }, t$v: function() {
    return Sx;
  }, tdn: function() {
    return oh;
  }, Y9t: function() {
    return ah;
  }, GEo: function() {
    return qa;
  }, DH3: function() {
    return jx;
  }, uxM: function() {
    return Xy;
  }, zH3: function() {
    return Yy;
  }, MLs: function() {
    return no;
  }, xXG: function() {
    return be;
  }, YM4: function() {
    return Pc;
  }, B3r: function() {
    return xI;
  }, iAx: function() {
    return Ky;
  }, lDn: function() {
    return V;
  }, oaQ: function() {
    return Va;
  }, CD7: function() {
    return gl;
  }, Rc0: function() {
    return Nl;
  }, iPG: function() {
    return ic;
  }, TIc: function() {
    return Pt;
  }, xsC: function() {
    return Hx;
  }, zOc: function() {
    return Dt;
  }, r46: function() {
    return lw;
  }, z2C: function() {
    return M;
  }, _X$: function() {
    return sr;
  }, _yn: function() {
    return jt;
  }, Dyg: function() {
    return bt;
  }, cUc: function() {
    return Yt;
  }, zGw: function() {
    return $l;
  }, Ctq: function() {
    return Lx;
  }, $ch: function() {
    return jI;
  }, k5b: function() {
    return Px;
  }, kZl: function() {
    return Yx;
  }, OCg: function() {
    return nw;
  }, YjH: function() {
    return yw;
  }, Ui8: function() {
    return Q_;
  }, YD2: function() {
    return _l;
  }, vi9: function() {
    return TI;
  }, ij3: function() {
    return Fx;
  }, YPW: function() {
    return Bx;
  }, Bg1: function() {
    return uI;
  }, kon: function() {
    return x;
  }, M3g: function() {
    return Ga;
  }, F2z: function() {
    return Ex;
  }, pJF: function() {
    return gE;
  }, knz: function() {
    return n.knz;
  }, Ejo: function() {
    return _;
  }, BgY: function() {
    return Be;
  }, qCG: function() {
    return Ce;
  }, HD9: function() {
    return ke;
  }, fEB: function() {
    return Me;
  }, Udc: function() {
    return Fe;
  }, ZQg: function() {
    return Oe;
  }, ofC: function() {
    return W;
  }, yRy: function() {
    return Rt;
  }, _NL: function() {
    return qp;
  }, LCA: function() {
    return Le;
  }, j1w: function() {
    return lr;
  }, i8J: function() {
    return tk;
  }, p7C: function() {
    return qt;
  }, ZAS: function() {
    return ch;
  }, ipH: function() {
    return VI;
  }, $TF: function() {
    return GI;
  }, uZI: function() {
    return QI;
  }, VWG: function() {
    return Hy;
  }, pQ7: function() {
    return sh;
  }, STw: function() {
    return fl;
  }, jc8: function() {
    return Xt;
  }, BL_: function() {
    return Tx;
  }, S6: function() {
    return ek;
  }, T8U: function() {
    return Es;
  }, TD6: function() {
    return ws;
  }, akS: function() {
    return Jy;
  }, QKE: function() {
    return Zy;
  }, dKx: function() {
    return C;
  }, OvX: function() {
    return SI;
  }, VsW: function() {
    return Dc;
  }, YMc: function() {
    return zI;
  }, aPg: function() {
    return Y;
  }, LFn: function() {
    return Lt;
  }, wey: function() {
    return xx;
  }, MaE: function() {
    return rt;
  }, s4x: function() {
    return it;
  }, FJA: function() {
    return Ke;
  }, vIA: function() {
    return tt;
  }, Spv: function() {
    return lt;
  }, w8l: function() {
    return st;
  }, riG: function() {
    return nt;
  }, Kbh: function() {
    return Ze;
  }, t8K: function() {
    return $e;
  }, Q7n: function() {
    return Je;
  }, KGF: function() {
    return et;
  }, e5: function() {
    return G;
  }, Rik: function() {
    return Gs;
  }, GZo: function() {
    return Vs;
  }, Bds: function() {
    return us;
  }, HTu: function() {
    return hs;
  }, cTq: function() {
    return Et;
  }, X_Y: function() {
    return po;
  }, dA8: function() {
    return uo;
  }, bwS: function() {
    return Rx;
  }, Lks: function() {
    return HI;
  }, Rvq: function() {
    return CI;
  }, P4F: function() {
    return Oy;
  }, Pd0: function() {
    return on;
  }, Pjo: function() {
    return Dx;
  }, Tum: function() {
    return ln;
  }, dRH: function() {
    return un;
  }, RX0: function() {
    return cn;
  }, reQ: function() {
    return WI;
  }, cWm: function() {
    return Vx;
  }, NC9: function() {
    return Ly;
  }, $Re: function() {
    return Os;
  }, Xo9: function() {
    return Fs;
  }, LNO: function() {
    return os;
  }, iZP: function() {
    return as;
  } });
  var e, t = {};
  __webpackgi_require__2.r(t), __webpackgi_require__2.d(t, { AsyncCompress: function() {
    return Mf;
  }, AsyncDecompress: function() {
    return Vf;
  }, AsyncDeflate: function() {
    return Af;
  }, AsyncGunzip: function() {
    return Df;
  }, AsyncGzip: function() {
    return Mf;
  }, AsyncInflate: function() {
    return wf;
  }, AsyncUnzipInflate: function() {
    return _m;
  }, AsyncUnzlib: function() {
    return Nf;
  }, AsyncZipDeflate: function() {
    return um;
  }, AsyncZlib: function() {
    return Lf;
  }, Compress: function() {
    return Cf;
  }, DecodeUTF8: function() {
    return Jf;
  }, Decompress: function() {
    return Gf;
  }, Deflate: function() {
    return vf;
  }, EncodeUTF8: function() {
    return Zf;
  }, Gunzip: function() {
    return kf;
  }, Gzip: function() {
    return Cf;
  }, Inflate: function() {
    return xf;
  }, Unzip: function() {
    return gm;
  }, UnzipInflate: function() {
    return mm;
  }, UnzipPassThrough: function() {
    return fm;
  }, Unzlib: function() {
    return Uf;
  }, Zip: function() {
    return hm;
  }, ZipDeflate: function() {
    return cm;
  }, ZipPassThrough: function() {
    return lm;
  }, Zlib: function() {
    return Rf;
  }, compress: function() {
    return Tf;
  }, compressSync: function() {
    return If;
  }, decompress: function() {
    return Qf;
  }, decompressSync: function() {
    return Hf;
  }, deflate: function() {
    return bf;
  }, deflateSync: function() {
    return yf;
  }, gunzip: function() {
    return Pf;
  }, gunzipSync: function() {
    return Bf;
  }, gzip: function() {
    return Tf;
  }, gzipSync: function() {
    return If;
  }, inflate: function() {
    return Ef;
  }, inflateSync: function() {
    return Sf;
  }, strFromU8: function() {
    return em;
  }, strToU8: function() {
    return $f;
  }, unzip: function() {
    return vm;
  }, unzipSync: function() {
    return Am;
  }, unzlib: function() {
    return jf;
  }, unzlibSync: function() {
    return zf;
  }, zip: function() {
    return pm;
  }, zipSync: function() {
    return dm;
  }, zlib: function() {
    return Of;
  }, zlibSync: function() {
    return Ff;
  } }), function(e2) {
    e2[e2.Error = -2] = "Error", e2[e2.Destroyed = -1] = "Destroyed", e2[e2.None = 0] = "None", e2[e2.Running = 1] = "Running", e2[e2.Paused = 2] = "Paused";
  }(e || (e = {}));
  class r {
    constructor() {
      this._eventListeners = {}, this.dispatchEvent = this.dispatchEvent.bind(this), this.addEventListener = this.addEventListener.bind(this), this.removeEventListener = this.removeEventListener.bind(this), this.hasEventListener = this.hasEventListener.bind(this);
    }
    addEventListener(e2, t2) {
      const r2 = this._eventListeners;
      void 0 === r2[e2] && (r2[e2] = []), r2[e2].includes(t2) || r2[e2].push(t2);
    }
    hasEventListener(e2, t2) {
      const r2 = this._eventListeners;
      return void 0 !== r2[e2] && r2[e2].includes(t2);
    }
    removeEventListener(e2, t2) {
      const r2 = this._eventListeners[e2];
      if (void 0 !== r2) {
        const e3 = r2.indexOf(t2);
        -1 !== e3 && r2.splice(e3, 1);
      }
    }
    dispatchEvent(e2) {
      const t2 = this._eventListeners[e2.type];
      if (void 0 !== t2) {
        e2.target = this;
        const r2 = t2.slice(0);
        for (let t3 = 0, n2 = r2.length; t3 < n2; t3++)
          r2[t3].call(this, e2);
      }
    }
  }
  var n = __webpackgi_require__2(988);
  const i = { uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}", fragmentShader: "\n\n		uniform float opacity;\n\n		uniform sampler2D tDiffuse;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			gl_FragColor = texture2D( tDiffuse, vUv );\n			gl_FragColor.a *= opacity;\n\n\n		}" };
  class s {
    constructor() {
      this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
    }
    setSize() {
    }
    render() {
      console.error("THREE.Pass: .render() must be implemented in derived pass.");
    }
  }
  const o = new n.iKG(-1, 1, 1, -1, 0, 1), a = new n.u9r();
  a.setAttribute("position", new n.a$l([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), a.setAttribute("uv", new n.a$l([0, 2, 0, 0, 2, 0], 2));
  class l {
    constructor(e2) {
      this._mesh = new n.Kj0(a, e2);
    }
    dispose() {
      this._mesh.geometry.dispose();
    }
    render(e2) {
      e2.render(this._mesh, o);
    }
    get material() {
      return this._mesh.material;
    }
    set material(e2) {
      this._mesh.material = e2;
    }
  }
  class c extends s {
    constructor(e2, t2) {
      super(), this.textureID = void 0 !== t2 ? t2 : "tDiffuse", e2 instanceof n.jyz ? (this.uniforms = e2.uniforms, this.material = e2) : e2 && (this.uniforms = n.rDY.clone(e2.uniforms), this.material = new n.jyz({ defines: Object.assign({}, e2.defines), uniforms: this.uniforms, vertexShader: e2.vertexShader, fragmentShader: e2.fragmentShader })), this.fsQuad = new l(this.material), this.useExistingRenderTarget = false;
    }
    render(e2, t2, r2) {
      this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = r2.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e2.setRenderTarget(null), this.fsQuad.render(e2)) : (this.useExistingRenderTarget || e2.setRenderTarget(t2), this.clear && e2.clear(e2.autoClearColor, e2.autoClearDepth, e2.autoClearStencil), this.fsQuad.render(e2));
    }
  }
  class u extends s {
    constructor(e2, t2) {
      super(), this.scene = e2, this.camera = t2, this.clear = true, this.needsSwap = false, this.inverse = false;
    }
    render(e2, t2, r2) {
      const n2 = e2.getContext(), i2 = e2.state;
      let s2, o2;
      i2.buffers.color.setMask(false), i2.buffers.depth.setMask(false), i2.buffers.color.setLocked(true), i2.buffers.depth.setLocked(true), this.inverse ? (s2 = 0, o2 = 1) : (s2 = 1, o2 = 0), i2.buffers.stencil.setTest(true), i2.buffers.stencil.setOp(n2.REPLACE, n2.REPLACE, n2.REPLACE), i2.buffers.stencil.setFunc(n2.ALWAYS, s2, 4294967295), i2.buffers.stencil.setClear(o2), i2.buffers.stencil.setLocked(true), e2.setRenderTarget(r2), this.clear && e2.clear(), e2.render(this.scene, this.camera), e2.setRenderTarget(t2), this.clear && e2.clear(), e2.render(this.scene, this.camera), i2.buffers.color.setLocked(false), i2.buffers.depth.setLocked(false), i2.buffers.stencil.setLocked(false), i2.buffers.stencil.setFunc(n2.EQUAL, 1, 4294967295), i2.buffers.stencil.setOp(n2.KEEP, n2.KEEP, n2.KEEP), i2.buffers.stencil.setLocked(true);
    }
  }
  class h extends s {
    constructor() {
      super(), this.needsSwap = false;
    }
    render(e2) {
      e2.state.buffers.stencil.setLocked(false), e2.state.buffers.stencil.setTest(false);
    }
  }
  new n.iKG(-1, 1, 1, -1, 0, 1);
  const p = new n.u9r();
  p.setAttribute("position", new n.a$l([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), p.setAttribute("uv", new n.a$l([0, 2, 0, 0, 2, 0], 2));
  class d extends class {
    constructor(e2, t2) {
      if (this.renderer = e2, void 0 === t2) {
        const r2 = e2.getSize(new n.FM8());
        this._pixelRatio = e2.getPixelRatio(), this._width = r2.width, this._height = r2.height, (t2 = new n.dd2(this._width * this._pixelRatio, this._height * this._pixelRatio)).texture.name = "EffectComposer.rt1";
      } else
        this._pixelRatio = 1, this._width = t2.width, this._height = t2.height;
      this.renderTarget1 = t2, this.renderTarget2 = t2.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], void 0 === i && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === c && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new c(i), this.clock = new n.SUY();
    }
    swapBuffers() {
      const e2 = this.readBuffer;
      this.readBuffer = this.writeBuffer, this.writeBuffer = e2;
    }
    addPass(e2) {
      this.passes.push(e2), e2.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    insertPass(e2, t2) {
      this.passes.splice(t2, 0, e2), e2.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    removePass(e2) {
      const t2 = this.passes.indexOf(e2);
      -1 !== t2 && this.passes.splice(t2, 1);
    }
    isLastEnabledPass(e2) {
      for (let t2 = e2 + 1; t2 < this.passes.length; t2++)
        if (this.passes[t2].enabled)
          return false;
      return true;
    }
    render(e2) {
      void 0 === e2 && (e2 = this.clock.getDelta());
      const t2 = this.renderer.getRenderTarget();
      let r2 = false;
      for (let t3 = 0, n2 = this.passes.length; t3 < n2; t3++) {
        const n3 = this.passes[t3];
        if (false !== n3.enabled) {
          if (n3.renderToScreen = this.renderToScreen && this.isLastEnabledPass(t3), n3.render(this.renderer, this.writeBuffer, this.readBuffer, e2, r2), n3.needsSwap) {
            if (r2) {
              const t4 = this.renderer.getContext(), r3 = this.renderer.state.buffers.stencil;
              r3.setFunc(t4.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e2), r3.setFunc(t4.EQUAL, 1, 4294967295);
            }
            this.swapBuffers();
          }
          void 0 !== u && (n3 instanceof u ? r2 = true : n3 instanceof h && (r2 = false));
        }
      }
      this.renderer.setRenderTarget(t2);
    }
    reset(e2) {
      if (void 0 === e2) {
        const t2 = this.renderer.getSize(new n.FM8());
        this._pixelRatio = this.renderer.getPixelRatio(), this._width = t2.width, this._height = t2.height, (e2 = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }
      this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e2, this.renderTarget2 = e2.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
    }
    setSize(e2, t2) {
      this._width = e2, this._height = t2;
      const r2 = this._width * this._pixelRatio, n2 = this._height * this._pixelRatio;
      this.renderTarget1.setSize(r2, n2), this.renderTarget2.setSize(r2, n2);
      for (let e3 = 0; e3 < this.passes.length; e3++)
        this.passes[e3].setSize(r2, n2);
    }
    setPixelRatio(e2) {
      this._pixelRatio = e2, this.setSize(this._width, this._height);
    }
  } {
    constructor(e2, t2) {
      super(e2, t2);
    }
    setPixelRatio(e2, t2 = true) {
      const r2 = this.setSize;
      t2 || (this.setSize = () => {
      }), super.setPixelRatio(e2), t2 || (this.setSize = r2);
    }
  }
  function f(e2, t2) {
    let r2;
    do {
      r2 = Object.getOwnPropertyDescriptor(e2, t2);
    } while (!r2 && (e2 = Object.getPrototypeOf(e2)));
    return r2;
  }
  function m(e2, t2, r2 = false, n2 = false) {
    const i2 = f(e2, t2);
    return !!(null == i2 ? void 0 : i2.set) || r2 && false !== (null == i2 ? void 0 : i2.writable) && void 0 === (null == i2 ? void 0 : i2.get) || n2 && !i2;
  }
  function _(e2, t2, r2, n2 = false, i2 = false) {
    return !(!e2 || !m(e2, t2, n2, i2) || (e2[t2] = r2, 0));
  }
  function g(e2, t2) {
    for (; e2.length > 0; ) {
      if (!t2)
        return;
      const r2 = e2.splice(0, 1)[0];
      if (!(r2.length < 1)) {
        if (!(r2 in t2))
          return console.error("invalid access, check", r2, t2), t2;
        t2 = t2[r2];
      }
    }
    return t2;
  }
  function v(e2, t2) {
    return Object.keys(e2).find((r2) => e2[r2] === t2);
  }
  function A(e2, ...t2) {
    return "function" == typeof e2 && (e2 = e2(...t2)), e2;
  }
  function b(e2, t2, r2) {
    for (const n2 of r2) {
      const r3 = e2[n2];
      void 0 !== r3 && _(t2, n2, r3, true);
    }
  }
  function y(e2) {
    return e2.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
  }
  function x(e2, t2, r2) {
    return e2.replace(new RegExp(y(t2), "g"), r2);
  }
  String.raw;
  const w = (e2, ...t2) => String.raw({ raw: e2 }, ...t2), E = (e2, ...t2) => String.raw({ raw: e2 }, ...t2), S = (e2, ...t2) => String.raw({ raw: e2 }, ...t2), C = (e2, ...t2) => {
    let r2 = String.raw({ raw: e2 }, ...t2);
    return r2 = x(r2, "%", "%25"), r2 = x(r2, "> <", "><"), r2 = x(r2, "; }", ";}"), r2 = x(r2, "<", "%3c"), r2 = x(r2, ">", "%3e"), r2 = x(r2, '"', "'"), r2 = x(r2, "#", "%23"), r2 = x(r2, "{", "%7b"), r2 = x(r2, "}", "%7d"), r2 = x(r2, "|", "%7c"), r2 = x(r2, "^", "%5e"), r2 = x(r2, "`", "%60"), r2 = x(r2, "@", "%40"), r2 = x(r2, "&", "&amp;"), r2 = x(r2, "\n", "%0A"), "data:image/svg+xml;charset=UTF-8," + r2;
  };
  function M(e2) {
    if (!e2)
      throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
    return (t2, r2) => {
      let n2 = t2[r2];
      Object.defineProperty(t2, r2, { get: () => n2, set(t3) {
        var i2;
        if (n2 === t3)
          return;
        n2 = t3;
        const s2 = [r2, t3];
        if ("string" == typeof e2)
          null === (i2 = this[e2]) || void 0 === i2 || i2.call(this, ...s2);
        else if ("function" == typeof e2) {
          let t4 = false;
          if (e2.name) {
            let r3 = this;
            for (; r3; ) {
              if (r3[e2.name] === e2) {
                e2.call(this, ...s2), t4 = true;
                break;
              }
              r3 = Object.getPrototypeOf(r3);
            }
          }
          t4 || (e2.name && this[e2.name].name === `bound ${e2.name}` ? this[e2.name](...s2) : e2(...s2));
        }
      } });
    };
  }
  function T(e2, t2) {
    for (const r2 of t2)
      if (!e2.includes(r2))
        return false;
    return true;
  }
  String.prototype.replaceAll || (String.prototype.replaceAll = function(e2, t2) {
    return "[object regexp]" === Object.prototype.toString.call(e2).toLowerCase() ? this.replace(e2, t2) : this.replace(new RegExp(e2, "g"), t2);
  });
  class I {
    constructor(e2 = 0, t2 = 0) {
      I.prototype.isVector2 = true, this.x = e2, this.y = t2;
    }
    get width() {
      return this.x;
    }
    set width(e2) {
      this.x = e2;
    }
    get height() {
      return this.y;
    }
    set height(e2) {
      this.y = e2;
    }
    set(e2, t2) {
      return this.x = e2, this.y = t2, this;
    }
    setScalar(e2) {
      return this.x = e2, this.y = e2, this;
    }
    setX(e2) {
      return this.x = e2, this;
    }
    setY(e2) {
      return this.y = e2, this;
    }
    setComponent(e2, t2) {
      switch (e2) {
        case 0:
          this.x = t2;
          break;
        case 1:
          this.y = t2;
          break;
        default:
          throw new Error("index is out of range: " + e2);
      }
      return this;
    }
    getComponent(e2) {
      switch (e2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this;
    }
    add(e2) {
      return this.x += e2.x, this.y += e2.y, this;
    }
    addScalar(e2) {
      return this.x += e2, this.y += e2, this;
    }
    addVectors(e2, t2) {
      return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this;
    }
    addScaledVector(e2, t2) {
      return this.x += e2.x * t2, this.y += e2.y * t2, this;
    }
    sub(e2) {
      return this.x -= e2.x, this.y -= e2.y, this;
    }
    subScalar(e2) {
      return this.x -= e2, this.y -= e2, this;
    }
    subVectors(e2, t2) {
      return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this;
    }
    multiply(e2) {
      return this.x *= e2.x, this.y *= e2.y, this;
    }
    multiplyScalar(e2) {
      return this.x *= e2, this.y *= e2, this;
    }
    divide(e2) {
      return this.x /= e2.x, this.y /= e2.y, this;
    }
    divideScalar(e2) {
      return this.multiplyScalar(1 / e2);
    }
    applyMatrix3(e2) {
      const t2 = this.x, r2 = this.y, n2 = e2.elements;
      return this.x = n2[0] * t2 + n2[3] * r2 + n2[6], this.y = n2[1] * t2 + n2[4] * r2 + n2[7], this;
    }
    min(e2) {
      return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this;
    }
    max(e2) {
      return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this;
    }
    clamp(e2, t2) {
      return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this;
    }
    clampScalar(e2, t2) {
      return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this;
    }
    clampLength(e2, t2) {
      const r2 = this.length();
      return this.divideScalar(r2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, r2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(e2) {
      return this.x * e2.x + this.y * e2.y;
    }
    cross(e2) {
      return this.x * e2.y - this.y * e2.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(e2) {
      return Math.sqrt(this.distanceToSquared(e2));
    }
    distanceToSquared(e2) {
      const t2 = this.x - e2.x, r2 = this.y - e2.y;
      return t2 * t2 + r2 * r2;
    }
    manhattanDistanceTo(e2) {
      return Math.abs(this.x - e2.x) + Math.abs(this.y - e2.y);
    }
    setLength(e2) {
      return this.normalize().multiplyScalar(e2);
    }
    lerp(e2, t2) {
      return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this;
    }
    lerpVectors(e2, t2, r2) {
      return this.x = e2.x + (t2.x - e2.x) * r2, this.y = e2.y + (t2.y - e2.y) * r2, this;
    }
    equals(e2) {
      return e2.x === this.x && e2.y === this.y;
    }
    fromArray(e2, t2 = 0) {
      return this.x = e2[t2], this.y = e2[t2 + 1], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.x, e2[t2 + 1] = this.y, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this.x = e2.getX(t2), this.y = e2.getY(t2), this;
    }
    rotateAround(e2, t2) {
      const r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = this.x - e2.x, s2 = this.y - e2.y;
      return this.x = i2 * r2 - s2 * n2 + e2.x, this.y = i2 * n2 + s2 * r2 + e2.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  class k extends n.ZzF {
    expandByObject(e2, t2 = false, r2 = false) {
      var n2;
      if (false === (null === (n2 = e2.userData) || void 0 === n2 ? void 0 : n2.bboxVisible))
        return this;
      if (!e2.visible && r2)
        return this;
      e2.updateWorldMatrix(false, false);
      const i2 = e2.geometry;
      if (void 0 !== i2)
        if (t2 && null != i2.attributes && void 0 !== i2.attributes.position) {
          const t3 = i2.attributes.position;
          for (let r3 = 0, n3 = t3.count; r3 < n3; r3++)
            P.fromBufferAttribute(t3, r3).applyMatrix4(e2.matrixWorld), this.expandByPoint(P);
        } else
          null === i2.boundingBox && i2.computeBoundingBox(), D.copy(i2.boundingBox), D.applyMatrix4(e2.matrixWorld), this.union(D);
      const s2 = e2.children;
      for (let e3 = 0, n3 = s2.length; e3 < n3; e3++)
        this.expandByObject(s2[e3], t2, r2);
      return this;
    }
    expandByObjects(e2, t2 = false, r2 = false) {
      for (let n2 = 0, i2 = e2.length; n2 < i2; n2++)
        this.expandByObject(e2[n2], t2, r2);
      return this;
    }
    getPoints() {
      return [new n.Pa4(this.min.x, this.min.y, this.min.z), new n.Pa4(this.min.x, this.min.y, this.max.z), new n.Pa4(this.min.x, this.max.y, this.min.z), new n.Pa4(this.min.x, this.max.y, this.max.z), new n.Pa4(this.max.x, this.min.y, this.min.z), new n.Pa4(this.max.x, this.min.y, this.max.z), new n.Pa4(this.max.x, this.max.y, this.min.z), new n.Pa4(this.max.x, this.max.y, this.max.z)];
    }
    getScreenSpaceBounds(e2) {
      const t2 = this.getPoints(), r2 = new n.TUj();
      for (const n2 of t2) {
        const t3 = n2.project(e2);
        r2.min.min(t3), r2.max.max(t3);
      }
      return r2;
    }
  }
  const D = new k(), P = new n.Pa4();
  function B(e2, t2) {
    let r2, i2;
    if (Array.isArray(e2))
      for (const n2 of e2) {
        const e3 = B(n2, t2);
        void 0 === r2 || void 0 === i2 ? (r2 = e3.min.clone(), i2 = e3.max.clone()) : (r2.min(e3.min), i2.max(e3.max));
      }
    const s2 = e2;
    if (void 0 !== s2.geometry) {
      const o2 = s2.geometry.vertices;
      if (void 0 === o2 && void 0 !== s2.geometry.attributes && "position" in s2.geometry.attributes) {
        const o3 = new n.Pa4(), a2 = s2.geometry.attributes.position;
        for (let n2 = 0; n2 < a2.count * a2.itemSize; n2 += a2.itemSize) {
          o3.set(a2.array[n2], a2.array[n2 + 1], a2.array[3]);
          const s3 = o3.applyMatrix4(e2.matrixWorld).project(t2), l2 = new I(s3.x, s3.y);
          void 0 === r2 || void 0 === i2 ? (r2 = l2.clone(), i2 = l2.clone()) : (r2.min(l2), i2.max(l2));
        }
      } else
        for (const n2 of o2) {
          const s3 = n2.clone().applyMatrix4(e2.matrixWorld).project(t2), o3 = new I(s3.x, s3.y);
          void 0 === r2 || void 0 === i2 ? (r2 = o3.clone(), i2 = o3.clone()) : (r2.min(o3), i2.max(o3));
        }
    }
    if (void 0 !== e2.children)
      for (const n2 of e2.children) {
        const e3 = B(n2, t2);
        void 0 === r2 || void 0 === i2 ? (r2 = e3.min.clone(), i2 = e3.max.clone()) : (r2.min(e3.min), i2.max(e3.max));
      }
    return new n.TUj(r2, i2);
  }
  const R = 3005;
  function L(e2) {
    switch (e2) {
      case n.rnI:
        return ["Linear", "( value )"];
      case n.knz:
        return ["sRGB", "( value )"];
      case R:
        return ["RGBM", "( value, 16.0 )"];
      default:
        return console.warn("utils: Unsupported encoding:", e2), ["Linear", "( value )"];
    }
  }
  function O(e2, t2) {
    let r2;
    return e2 && e2.isTexture ? r2 = e2.encoding : e2 && e2.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), r2 = e2.texture.encoding) : r2 = n.rnI, t2 && e2 && e2.isTexture && e2.format === n.wk1 && e2.type === n.ywz && e2.encoding === n.knz && (r2 = n.rnI), r2;
  }
  function F(e2, t2) {
    const r2 = L(t2);
    return "vec4 " + e2 + "( vec4 value ) { return " + r2[0] + "ToLinear" + r2[1] + "; }";
  }
  function U(e2, t2, r2) {
    return F(e2 + "TexelToLinear", O(t2, r2)) + "\n";
  }
  function N(e2, t2) {
    return F(e2 + "TexelToLinear", t2) + "\n";
  }
  function j(e2, t2) {
    const r2 = L(t2);
    return "vec4 " + e2 + "( vec4 value ) { return LinearTo" + r2[0] + r2[1] + "; }";
  }
  function z(e2, t2, r2) {
    return j(e2, O(t2, r2));
  }
  function G({ uniforms: e2, propKey: t2, thisTarget: r2 = false } = {}) {
    const n2 = !!e2, i2 = !!t2, s2 = r2;
    return (r3, o2) => {
      const a2 = (r4) => {
        const a3 = s2 ? r4 : n2 ? e2 : r4.uniforms || r4._uniforms;
        let l2 = i2 ? t2 : o2;
        s2 && (l2 = "_" + l2);
        let c2 = a3[l2];
        return c2 || (c2 = { value: null }, a3[l2] = c2), c2;
      };
      Object.defineProperty(r3, o2, { get() {
        return a2(this).value;
      }, set(e3) {
        a2(this).value = e3, _(this, "uniformsNeedUpdate", true, true);
      } });
    };
  }
  function V(e2, t2, r2 = false, n2) {
    const i2 = !!t2, s2 = !!e2;
    return (o2, a2) => {
      const l2 = (r3) => ({ t: i2 ? t2 : r3.defines || r3._defines, p: s2 ? e2 : a2 });
      Object.defineProperty(o2, a2, { get() {
        const { t: e3, p: t3 } = l2(r2 ? this : this.material);
        return e3[t3];
      }, set(e3) {
        const { t: t3, p: i3 } = l2(r2 ? this : this.material);
        if (_(t3, i3, e3, true), "function" == typeof n2) {
          const t4 = [i3, e3];
          if (n2.name) {
            const e4 = this[n2.name];
            e4 === n2 ? n2.call(this, ...t4) : e4.name === `bound ${n2.name}` ? e4(...t4) : n2(...t4);
          } else
            n2(...t4);
        } else
          _(r2 ? this : this.material, "needsUpdate", true, true);
      } });
    };
  }
  function Q(e2) {
    const t2 = new n.IEO(new Uint8Array([Math.floor(255 * e2.r), Math.floor(255 * e2.g), Math.floor(255 * e2.b), 255]), 1, 1, n.wk1, n.ywz);
    return t2.needsUpdate = true, t2.encoding = n.rnI, t2;
  }
  function H(e2) {
    const t2 = new n.IEO(new Uint8Array([Math.floor(255 * e2.x), Math.floor(255 * e2.y), Math.floor(255 * e2.z), Math.floor(255 * e2.w)]), 1, 1, n.wk1, n.ywz);
    return t2.needsUpdate = true, t2;
  }
  function W(e2, t2, r2) {
    const n2 = e2.userData, { backgroundRender: i2, transparentRender: s2, shadowMapRender: o2, mainRenderPass: a2, opaqueRender: l2, transmissionRender: c2, sceneRender: u2, screenSpaceRendering: h2 } = n2;
    void 0 !== t2.backgroundRender && (n2.backgroundRender = t2.backgroundRender), void 0 !== t2.transparentRender && (n2.transparentRender = t2.transparentRender), void 0 !== t2.shadowMapRender && (n2.shadowMapRender = t2.shadowMapRender), void 0 !== t2.mainRenderPass && (n2.mainRenderPass = t2.mainRenderPass), void 0 !== t2.opaqueRender && (n2.opaqueRender = t2.opaqueRender), void 0 !== t2.sceneRender && (n2.sceneRender = t2.sceneRender), void 0 !== t2.transmissionRender && (n2.transmissionRender = t2.transmissionRender), void 0 !== t2.screenSpaceRendering && (n2.screenSpaceRendering = t2.screenSpaceRendering), r2(), n2.backgroundRender = i2, n2.transparentRender = s2, n2.shadowMapRender = o2, n2.mainRenderPass = a2, n2.opaqueRender = l2, n2.sceneRender = u2, n2.transmissionRender = c2, n2.screenSpaceRendering = h2;
  }
  function q(e2) {
    const t2 = new k().expandByObject(e2, true, true).getCenter(new n.Pa4());
    e2.position.sub(t2), e2.updateMatrix(), e2.userData.autoCentered = true;
  }
  function X(e2, t2) {
    const r2 = 0.5 * new k().expandByObject(e2, true, true).getSize(new n.Pa4()).length();
    void 0 === t2 && (t2 = e2.userData.autoScaleRadius || 1);
    const i2 = t2 / r2;
    return isFinite(i2) && (e2.userData.pseudoCentered ? e2.children.forEach((e3) => {
      e3.scale.multiplyScalar(i2);
    }) : e2.scale.multiplyScalar(i2)), e2.traverse((e3) => {
      var t3, r3;
      e3.isLight && (null === (r3 = null === (t3 = e3.shadow) || void 0 === t3 ? void 0 : t3.camera) || void 0 === r3 ? void 0 : r3.right) && (e3.shadow.camera.right *= i2, e3.shadow.camera.left *= i2, e3.shadow.camera.top *= i2, e3.shadow.camera.bottom *= i2), e3.isCamera && e3.right && (e3.right *= i2, e3.left *= i2, e3.top *= i2, e3.bottom *= i2);
    }), e2.userData.autoScaled = true, e2.userData.autoScaleRadius = t2, e2.dispatchEvent({ type: "objectUpdate" }), e2;
  }
  function Y(e2, t2 = -1) {
    return function(e3, t3 = 1e-4) {
      const r2 = t3 > 0;
      t3 = Math.max(t3, Number.EPSILON);
      const i2 = {}, s2 = e3.getIndex(), o2 = e3.getAttribute("position"), a2 = s2 ? s2.count : o2.count;
      let l2 = 0;
      const c2 = Object.keys(e3.attributes), u2 = {}, h2 = {}, p2 = [], d2 = ["getX", "getY", "getZ", "getW"];
      for (let t4 = 0, r3 = c2.length; t4 < r3; t4++) {
        const r4 = c2[t4];
        u2[r4] = [];
        const n2 = e3.morphAttributes[r4];
        n2 && (h2[r4] = new Array(n2.length).fill().map(() => []));
      }
      const f2 = Math.log10(1 / t3), m2 = Math.pow(10, f2);
      for (let t4 = 0; t4 < a2; t4++) {
        const n2 = s2 ? s2.getX(t4) : t4;
        let o3 = "";
        for (let t5 = 0, i3 = c2.length; t5 < i3 && r2; t5++) {
          const r3 = c2[t5], i4 = e3.getAttribute(r3), s3 = i4.itemSize;
          for (let e4 = 0; e4 < s3; e4++)
            o3 += ~~(i4[d2[e4]](n2) * m2) + ",";
        }
        if (r2 && o3 in i2)
          p2.push(i2[o3]);
        else {
          for (let t5 = 0, r3 = c2.length; t5 < r3; t5++) {
            const r4 = c2[t5], i3 = e3.getAttribute(r4), s3 = e3.morphAttributes[r4], o4 = i3.itemSize, a3 = u2[r4], l3 = h2[r4];
            for (let e4 = 0; e4 < o4; e4++) {
              const t6 = d2[e4];
              if (a3.push(i3[t6](n2)), s3)
                for (let e5 = 0, r5 = s3.length; e5 < r5; e5++)
                  l3[e5].push(s3[e5][t6](n2));
            }
          }
          r2 && (i2[o3] = l2), p2.push(l2), l2++;
        }
      }
      const _2 = e3.clone();
      for (let t4 = 0, r3 = c2.length; t4 < r3; t4++) {
        const r4 = c2[t4], i3 = e3.getAttribute(r4), s3 = new i3.array.constructor(u2[r4]), o3 = new n.TlE(s3, i3.itemSize, i3.normalized);
        if (_2.setAttribute(r4, o3), r4 in h2)
          for (let t5 = 0; t5 < h2[r4].length; t5++) {
            const i4 = e3.morphAttributes[r4][t5], s4 = new i4.array.constructor(h2[r4][t5]), o4 = new n.TlE(s4, i4.itemSize, i4.normalized);
            _2.morphAttributes[r4][t5] = o4;
          }
      }
      return _2.setIndex(p2), _2;
    }(e2, t2);
  }
  class K extends r {
    constructor({ animationLoop: e2, canvas: t2, alpha: r2 = true, targetOptions: i2 }) {
      super(), this._isWebGL2 = false, this._trackedTargets = [], this.dirty = true, this._lastTime = 0, this.frameWaitTime = 0, this._passes = [], this._pipeline = [], this._passesNeedsUpdate = true, this._displayCanvasScaling = 1, this._renderSize = new n.FM8(512, 512), this._frameCount = 0, this._tempTargets = {}, this.maxTempPerKey = 5, this._animationLoop = this._animationLoop.bind(this), this._processNewTarget = this._processNewTarget.bind(this), this._processNewTempTarget = this._processNewTempTarget.bind(this), this.trackTarget = this.trackTarget.bind(this), this.disposeTarget = this.disposeTarget.bind(this), this.createTarget = this.createTarget.bind(this), this.createTargetCustom = this.createTargetCustom.bind(this), this._renderer = new n.CP7({ canvas: t2, antialias: true, alpha: r2, premultipliedAlpha: false, preserveDrawingBuffer: true }), this._renderer.baseRenderer = this, this._renderer.setAnimationLoop(this._animationLoop), this._context = this._renderer.getContext(), this._isWebGL2 = this._renderer.capabilities.isWebGL2, this._renderSize = new n.FM8(t2.clientWidth, t2.clientHeight), this._renderer.setSize(this._renderSize.width, this._renderSize.height, false), this._renderer.setPixelRatio(this._displayCanvasScaling), this._renderer.toneMapping = n.uL9, this._renderer.toneMappingExposure = 1, this._renderer.outputEncoding = n.rnI, this._renderer.shadowMap.enabled = true, this._renderer.shadowMap.type = n._iA, this._renderer.shadowMap.autoUpdate = false, this.resetShadows(), this._composerTarget = this.createTarget(i2, false), this._composerTarget.texture.name = "EffectComposer.rt1", this._composer = new d(this._renderer, this._composerTarget), e2 && this.addEventListener("animationLoop", e2);
    }
    get composer() {
      return this._composer;
    }
    get passes() {
      return this._passes;
    }
    get isWebGL2() {
      return this._isWebGL2;
    }
    get composerTarget() {
      return this._composerTarget;
    }
    get renderSize() {
      return this._renderSize;
    }
    get displayCanvasScaling() {
      return this._displayCanvasScaling;
    }
    set displayCanvasScaling(e2) {
      e2 !== this._displayCanvasScaling && (this._displayCanvasScaling = e2, this.setSize(void 0, void 0, true));
    }
    get frameCount() {
      return this._frameCount;
    }
    set pipeline(e2) {
      this._pipeline = e2, this._passesNeedsUpdate = true;
    }
    get pipeline() {
      return this._pipeline;
    }
    refreshPipeline() {
      var e2, t2, r2;
      const n2 = this._passes, i2 = [], s2 = {};
      for (const i3 of n2) {
        if (false === i3.enabled)
          continue;
        const n3 = { after: null !== (e2 = i3.after) && void 0 !== e2 ? e2 : [], before: null !== (t2 = i3.before) && void 0 !== t2 ? t2 : [], dependencies: new Set(null !== (r2 = i3.required) && void 0 !== r2 ? r2 : []) };
        s2[i3.passId] = n3;
      }
      for (const [e3, t3] of Object.entries(s2)) {
        const r3 = /* @__PURE__ */ new Set([...t3.after, ...t3.before]);
        t3.dependencies.forEach((e4) => r3.has(e4) && r3.delete(e4)), r3.forEach((r4) => {
          const n3 = s2[r4];
          if (n3) {
            if (n3.dependencies.has(e3))
              throw console.error("cyclic", e3, r4), "Cyclic dependency";
            t3.dependencies.add(r4);
          }
        });
      }
      for (; ; ) {
        let e3 = false;
        const t3 = [...Object.entries(s2)];
        for (const [r3, o2] of t3)
          if (!i2.includes(r3) && T(i2, o2.dependencies.values())) {
            const t4 = Math.max(-1, ...o2.after.map((e4) => i2.indexOf(e4))), a2 = Math.min(i2.length, ...o2.before.map((e4) => {
              const t5 = i2.indexOf(e4);
              return t5 < 0 ? i2.length : t5;
            }));
            if (t4 >= a2)
              throw console.error(o2, n2, i2, t4, a2), "Not possible";
            i2.splice(o2.after.length > 0 ? t4 + 1 : a2, 0, r3), e3 = true, delete s2[r3];
          }
        if (Object.keys(s2).length < 1)
          break;
        if (!e3)
          throw console.log(t3, s2, i2), "Not possible 2";
      }
      return this.pipeline = i2, this.pipeline;
    }
    get context() {
      return this._context;
    }
    get rendererObject() {
      return this._renderer;
    }
    _animationLoop(e2, t2) {
      const r2 = e2 - this._lastTime;
      this._lastTime = e2, this.frameWaitTime -= r2, this.frameWaitTime > 0 || (this.frameWaitTime = 0, this.dispatchEvent({ type: "animationLoop", deltaTime: r2, time: e2, renderer: this, xrFrame: t2 }));
    }
    get clock() {
      return this._composer.clock;
    }
    registerPass(e2, t2 = true) {
      var r2;
      if (t2)
        for (const t3 of [...this._passes])
          e2.passId === t3.passId && this.unregisterPass(t3);
      this._passes.push(e2), null === (r2 = e2.onRegister) || void 0 === r2 || r2.call(e2, this), this._passesNeedsUpdate = true, this._updated();
    }
    unregisterPass(e2) {
      var t2;
      const r2 = this._passes.indexOf(e2);
      r2 >= 0 && (null === (t2 = e2.onUnregister) || void 0 === t2 || t2.call(e2, this), this._passes.splice(r2, 1), this._passesNeedsUpdate = true, this._updated());
    }
    setSize(e2, t2, r2 = false) {
      !r2 && (e2 ? Math.abs(e2 - this._renderSize.width) : 0) + (t2 ? Math.abs(t2 - this._renderSize.height) : 0) < 0.1 || (e2 && (this._renderSize.width = e2), t2 && (this._renderSize.height = t2), this.rendererObject.xr.enabled || (this._renderer.setSize(this._renderSize.width, this._renderSize.height, false), this._renderer.setPixelRatio(this._displayCanvasScaling)), this._composer.setPixelRatio(this._displayCanvasScaling, false), this._composer.setSize(this._renderSize.width, this._renderSize.height), this._trackedTargets.forEach((e3) => {
        const t3 = e3, r3 = t3.sizeMultiplier;
        if (r3) {
          const e4 = this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * r3);
          t3.setSize(e4.width, e4.height);
        }
      }), this.dispatchEvent({ type: "resize" }), this._updated(), this.reset());
    }
    blit(e2, t2, { viewport: r2, material: i2, shader: s2, pass: o2, clear: a2 = true } = {}) {
      const l2 = this._composer.copyPass, { renderToScreen: c2, material: u2, uniforms: h2, clear: p2 } = l2;
      i2 && (l2.material = i2);
      const d2 = this._renderer.getViewport(new n.Ltg()), f2 = this._renderer.autoClear, m2 = this._renderer.getRenderTarget();
      r2 && this._renderer.setViewport(new n.Ltg().fromArray(r2)), this._renderer.autoClear = false, l2.uniforms = l2.material.uniforms, l2.renderToScreen = false, l2.clear = a2, W(this._renderer, { sceneRender: true, opaqueRender: true, shadowMapRender: false, backgroundRender: false, transparentRender: true, transmissionRender: false }, () => {
        l2.render(this._renderer, null != t2 ? t2 : null, { texture: e2 }, 0, false);
      }), l2.renderToScreen = c2, l2.clear = p2, l2.material = u2, l2.uniforms = h2, this._renderer.autoClear = f2, r2 && this._renderer.setViewport(d2), this._renderer.setRenderTarget(m2);
    }
    clearColor({ r: e2, g: t2, b: r2, a: i2, target: s2, depth: o2 = true, stencil: a2 = true }) {
      var l2;
      const c2 = this._renderer.getClearColor(new n.Ilk()), u2 = this._renderer.getClearAlpha();
      this._renderer.setClearAlpha(null != i2 ? i2 : u2), this._renderer.setClearColor(new n.Ilk(null != e2 ? e2 : c2.r, null != t2 ? t2 : c2.g, null != r2 ? r2 : c2.b));
      const h2 = this._renderer.getRenderTarget(), p2 = this._renderer.getActiveCubeFace(), d2 = this._renderer.getActiveMipmapLevel();
      this._renderer.setRenderTarget(null !== (l2 = s2) && void 0 !== l2 ? l2 : null), this._renderer.clear(true, o2, a2), this._renderer.setRenderTarget(h2, p2, d2), this._renderer.setClearColor(c2), this._renderer.setClearAlpha(u2);
    }
    renderModel(e2, t2) {
      this._renderer.render(e2.modelObject, t2.cameraObject);
    }
    renderScene(e2) {
      const t2 = e2.activeCamera;
      t2 && this.renderModel(e2, t2);
    }
    _updated() {
      this.dispatchEvent({ type: "update" });
    }
    render() {
      var e2;
      this._passesNeedsUpdate && this.refreshPasses();
      for (const t2 of this._passes)
        t2.passObject.enabled && (null === (e2 = t2.update) || void 0 === e2 || e2.call(t2));
      this._composer.render(), this._frameCount += 1, this.dirty = false;
    }
    updateDirty() {
      this.dirty = this.dirty || this._passes.findIndex((e2) => e2.dirty) >= 0;
    }
    reset() {
      this._frameCount = 0, this.dirty = true;
    }
    resetShadows() {
      this._renderer.shadowMap.needsUpdate = true;
    }
    refreshPasses() {
      if (!this._passesNeedsUpdate)
        return;
      this._passesNeedsUpdate = false;
      const e2 = [];
      for (const t2 of this._pipeline) {
        const r2 = this._passes.find((e3) => e3.passId === t2);
        r2 ? e2.push(r2.passObject) : console.warn("Unable to find pass: ", t2);
      }
      [...this._composer.passes].forEach((e3) => this._composer.removePass(e3)), e2.forEach((e3) => this._composer.addPass(e3)), this._updated();
    }
    dispose() {
      this._renderer.dispose();
    }
    trackTarget(e2) {
      this._trackedTargets.push(e2);
    }
    removeTrackedTarget(e2) {
      const t2 = this._trackedTargets.indexOf(e2);
      t2 >= 0 && this._trackedTargets.splice(t2, 1);
    }
    createTarget({ sizeMultiplier: e2, samples: t2 = 0, encoding: r2 = n.rnI, type: i2 = n.ywz, format: s2 = n.wk1, depthBuffer: o2 = true, depthTexture: a2 = false, size: l2, textureCount: c2 = 1, ...u2 } = {}, h2 = true) {
      this.isWebGL2 || (t2 = 0), void 0 !== e2 && void 0 !== l2 && console.error("Both sizeMultiplier and size are defined. sizeMultiplier will be ignored."), l2 = l2 || this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * (e2 = e2 || 1));
      const p2 = a2 ? new n.$YQ(l2.width, l2.height, n.ywz) : void 0, d2 = this.createTargetCustom(c2 > 1 ? { width: l2.width, height: l2.height, count: c2 } : l2, { samples: t2, encoding: r2, type: i2, format: s2, depthBuffer: o2, depthTexture: p2 }, c2 > 1 ? n.kFz : n.dd2);
      return this._processNewTarget(d2, e2, h2), this._setTargetOptions(d2, u2), d2;
    }
    _processNewTarget(e2, t2, r2) {
      return void 0 !== t2 && (e2.sizeMultiplier = t2), r2 && this.trackTarget(e2), e2;
    }
    disposeTarget(e2) {
      if (e2) {
        if (e2.isTemporary)
          return this.releaseTempTarget(e2);
        this.removeTrackedTarget(e2), e2.dispose();
      }
    }
    createTargetCustom({ width: e2, height: t2, count: r2 }, i2 = {}, s2) {
      var o2;
      const a2 = this._processNewTarget;
      let l2 = [e2, t2];
      if (r2 && r2 > 1 && l2.push(r2), (null == s2 ? void 0 : s2.prototype) === n.oAp.prototype) {
        if (e2 !== t2)
          throw "Width and height of cube render target must be equal";
        l2 = [e2];
      }
      i2 = { format: n.wk1, minFilter: n.wem, magFilter: n.wem, generateMipmaps: false, type: n.ywz, encoding: n.rnI, ...i2 };
      const c2 = [...l2, i2];
      return new class extends (null !== (o2 = s2) && void 0 !== o2 ? o2 : n.dd2) {
        constructor(...e3) {
          super(...e3), Array.isArray(this.texture) ? this.texture.forEach((e4) => {
            e4.encoding = i2.encoding, e4.toJSON = () => ({});
          }) : this.texture.toJSON = () => ({});
        }
        clone(e3 = true) {
          if (this.isTemporary)
            throw "Cloning temporary render targets not supported";
          if (Array.isArray(this.texture))
            throw "Cloning multiple render targets not supported";
          const t3 = super.clone();
          return t3.texture.isRenderTargetTexture = true, a2(t3, this.sizeMultiplier || 1, e3);
        }
      }(...c2);
    }
    getTempTarget(e2 = {}) {
      var t2;
      const r2 = J(e2);
      let n2;
      return (null === (t2 = this._tempTargets[r2]) || void 0 === t2 ? void 0 : t2.length) && (n2 = this._tempTargets[r2].pop()), n2 ? this._setTargetOptions(n2, e2) : (n2 = this.createTarget(e2), this._processNewTempTarget(n2, r2)), n2;
    }
    _processNewTempTarget(e2, t2) {
      return e2.isTemporary = true, e2.targetKey = t2, void 0 === this._tempTargets[t2] && (this._tempTargets[t2] = []), e2;
    }
    releaseTempTarget(e2) {
      const t2 = e2.targetKey;
      if (!t2 || !e2.isTemporary)
        throw "Not a temp target";
      this._tempTargets[t2].length > this.maxTempPerKey ? e2.dispose() : this._tempTargets[t2].push(e2);
    }
    updateShaderProperties(e2) {
      return e2.uniforms.frameCount ? e2.uniforms.frameCount.value = this.frameCount : console.warn("BaseRenderer: no uniform: frameCount"), this;
    }
    _setTargetOptions(e2, t2) {
      var r2, i2, s2;
      e2.texture.minFilter = null !== (r2 = t2.minFilter) && void 0 !== r2 ? r2 : n.wem, e2.texture.magFilter = null !== (i2 = t2.magFilter) && void 0 !== i2 ? i2 : n.wem, e2.texture.generateMipmaps = null !== (s2 = t2.generateMipmaps) && void 0 !== s2 && s2, e2.texture.generateMipmaps && e2.texture.minFilter === n.wem && (e2.texture.minFilter = n.FDw), e2.texture.generateMipmaps || e2.texture.minFilter !== n.FDw || (e2.texture.minFilter = n.wem);
    }
  }
  function J(e2 = {}) {
    var t2, r2;
    return [e2.sizeMultiplier, e2.samples, e2.encoding, e2.type, e2.format, e2.depthBuffer, e2.depthTexture, null === (t2 = e2.size) || void 0 === t2 ? void 0 : t2.width, null === (r2 = e2.size) || void 0 === r2 ? void 0 : r2.height].join(";");
  }
  const Z = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
  function $() {
    const e2 = 4294967295 * Math.random() | 0, t2 = 4294967295 * Math.random() | 0, r2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0;
    return (Z[255 & e2] + Z[e2 >> 8 & 255] + Z[e2 >> 16 & 255] + Z[e2 >> 24 & 255] + "-" + Z[255 & t2] + Z[t2 >> 8 & 255] + "-" + Z[t2 >> 16 & 15 | 64] + Z[t2 >> 24 & 255] + "-" + Z[63 & r2 | 128] + Z[r2 >> 8 & 255] + "-" + Z[r2 >> 16 & 255] + Z[r2 >> 24 & 255] + Z[255 & n2] + Z[n2 >> 8 & 255] + Z[n2 >> 16 & 255] + Z[n2 >> 24 & 255]).toLowerCase();
  }
  function ee(e2, t2, r2) {
    return Math.max(t2, Math.min(r2, e2));
  }
  function te(e2, t2, r2) {
    return (1 - r2) * e2 + r2 * t2;
  }
  Math.PI, Math.PI;
  const re = 0, ne = 1, ie = 3, se = 4, oe = 1006, ae = "srgb", le = "srgb-linear";
  function ce(e2) {
    return e2 < 0.04045 ? 0.0773993808 * e2 : Math.pow(0.9478672986 * e2 + 0.0521327014, 2.4);
  }
  function ue(e2) {
    return e2 < 31308e-7 ? 12.92 * e2 : 1.055 * Math.pow(e2, 0.41666) - 0.055;
  }
  const he = { [ae]: { [le]: ce }, [le]: { [ae]: ue } }, pe = { legacyMode: true, get workingColorSpace() {
    return le;
  }, set workingColorSpace(e2) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  }, convert: function(e2, t2, r2) {
    if (this.legacyMode || t2 === r2 || !t2 || !r2)
      return e2;
    if (he[t2] && void 0 !== he[t2][r2]) {
      const n2 = he[t2][r2];
      return e2.r = n2(e2.r), e2.g = n2(e2.g), e2.b = n2(e2.b), e2;
    }
    throw new Error("Unsupported color space conversion.");
  }, fromWorkingColorSpace: function(e2, t2) {
    return this.convert(e2, this.workingColorSpace, t2);
  }, toWorkingColorSpace: function(e2, t2) {
    return this.convert(e2, t2, this.workingColorSpace);
  } }, de = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, fe = { r: 0, g: 0, b: 0 }, me = { h: 0, s: 0, l: 0 }, _e = { h: 0, s: 0, l: 0 };
  function ge(e2, t2, r2) {
    return r2 < 0 && (r2 += 1), r2 > 1 && (r2 -= 1), r2 < 1 / 6 ? e2 + 6 * (t2 - e2) * r2 : r2 < 0.5 ? t2 : r2 < 2 / 3 ? e2 + 6 * (t2 - e2) * (2 / 3 - r2) : e2;
  }
  function ve(e2, t2) {
    return t2.r = e2.r, t2.g = e2.g, t2.b = e2.b, t2;
  }
  class Ae {
    constructor(e2, t2, r2) {
      return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, void 0 === t2 && void 0 === r2 ? this.set(e2) : this.setRGB(e2, t2, r2);
    }
    set(e2) {
      return e2 && e2.isColor ? this.copy(e2) : "number" == typeof e2 ? this.setHex(e2) : "string" == typeof e2 && this.setStyle(e2), this;
    }
    setScalar(e2) {
      return this.r = e2, this.g = e2, this.b = e2, this;
    }
    setHex(e2, t2 = "srgb") {
      return e2 = Math.floor(e2), this.r = (e2 >> 16 & 255) / 255, this.g = (e2 >> 8 & 255) / 255, this.b = (255 & e2) / 255, pe.toWorkingColorSpace(this, t2), this;
    }
    setRGB(e2, t2, r2, n2 = "srgb-linear") {
      return this.r = e2, this.g = t2, this.b = r2, pe.toWorkingColorSpace(this, n2), this;
    }
    setHSL(e2, t2, r2, n2 = "srgb-linear") {
      if (e2 = function(e3, t3) {
        return (e3 % t3 + t3) % t3;
      }(e2, 1), t2 = ee(t2, 0, 1), r2 = ee(r2, 0, 1), 0 === t2)
        this.r = this.g = this.b = r2;
      else {
        const n3 = r2 <= 0.5 ? r2 * (1 + t2) : r2 + t2 - r2 * t2, i2 = 2 * r2 - n3;
        this.r = ge(i2, n3, e2 + 1 / 3), this.g = ge(i2, n3, e2), this.b = ge(i2, n3, e2 - 1 / 3);
      }
      return pe.toWorkingColorSpace(this, n2), this;
    }
    setStyle(e2, t2 = "srgb") {
      function r2(t3) {
        void 0 !== t3 && parseFloat(t3) < 1 && console.warn("THREE.Color: Alpha component of " + e2 + " will be ignored.");
      }
      let n2;
      if (n2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e2)) {
        let e3;
        const i2 = n2[1], s2 = n2[2];
        switch (i2) {
          case "rgb":
          case "rgba":
            if (e3 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2))
              return this.r = Math.min(255, parseInt(e3[1], 10)) / 255, this.g = Math.min(255, parseInt(e3[2], 10)) / 255, this.b = Math.min(255, parseInt(e3[3], 10)) / 255, pe.toWorkingColorSpace(this, t2), r2(e3[4]), this;
            if (e3 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2))
              return this.r = Math.min(100, parseInt(e3[1], 10)) / 100, this.g = Math.min(100, parseInt(e3[2], 10)) / 100, this.b = Math.min(100, parseInt(e3[3], 10)) / 100, pe.toWorkingColorSpace(this, t2), r2(e3[4]), this;
            break;
          case "hsl":
          case "hsla":
            if (e3 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2)) {
              const n3 = parseFloat(e3[1]) / 360, i3 = parseFloat(e3[2]) / 100, s3 = parseFloat(e3[3]) / 100;
              return r2(e3[4]), this.setHSL(n3, i3, s3, t2);
            }
        }
      } else if (n2 = /^\#([A-Fa-f\d]+)$/.exec(e2)) {
        const e3 = n2[1], r3 = e3.length;
        if (3 === r3)
          return this.r = parseInt(e3.charAt(0) + e3.charAt(0), 16) / 255, this.g = parseInt(e3.charAt(1) + e3.charAt(1), 16) / 255, this.b = parseInt(e3.charAt(2) + e3.charAt(2), 16) / 255, pe.toWorkingColorSpace(this, t2), this;
        if (6 === r3)
          return this.r = parseInt(e3.charAt(0) + e3.charAt(1), 16) / 255, this.g = parseInt(e3.charAt(2) + e3.charAt(3), 16) / 255, this.b = parseInt(e3.charAt(4) + e3.charAt(5), 16) / 255, pe.toWorkingColorSpace(this, t2), this;
      }
      return e2 && e2.length > 0 ? this.setColorName(e2, t2) : this;
    }
    setColorName(e2, t2 = "srgb") {
      const r2 = de[e2.toLowerCase()];
      return void 0 !== r2 ? this.setHex(r2, t2) : console.warn("THREE.Color: Unknown color " + e2), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(e2) {
      return this.r = e2.r, this.g = e2.g, this.b = e2.b, this;
    }
    copySRGBToLinear(e2) {
      return this.r = ce(e2.r), this.g = ce(e2.g), this.b = ce(e2.b), this;
    }
    copyLinearToSRGB(e2) {
      return this.r = ue(e2.r), this.g = ue(e2.g), this.b = ue(e2.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(e2 = "srgb") {
      return pe.fromWorkingColorSpace(ve(this, fe), e2), ee(255 * fe.r, 0, 255) << 16 ^ ee(255 * fe.g, 0, 255) << 8 ^ ee(255 * fe.b, 0, 255) << 0;
    }
    getHexString(e2 = "srgb") {
      return ("000000" + this.getHex(e2).toString(16)).slice(-6);
    }
    getHSL(e2, t2 = "srgb-linear") {
      pe.fromWorkingColorSpace(ve(this, fe), t2);
      const r2 = fe.r, n2 = fe.g, i2 = fe.b, s2 = Math.max(r2, n2, i2), o2 = Math.min(r2, n2, i2);
      let a2, l2;
      const c2 = (o2 + s2) / 2;
      if (o2 === s2)
        a2 = 0, l2 = 0;
      else {
        const e3 = s2 - o2;
        switch (l2 = c2 <= 0.5 ? e3 / (s2 + o2) : e3 / (2 - s2 - o2), s2) {
          case r2:
            a2 = (n2 - i2) / e3 + (n2 < i2 ? 6 : 0);
            break;
          case n2:
            a2 = (i2 - r2) / e3 + 2;
            break;
          case i2:
            a2 = (r2 - n2) / e3 + 4;
        }
        a2 /= 6;
      }
      return e2.h = a2, e2.s = l2, e2.l = c2, e2;
    }
    getRGB(e2, t2 = "srgb-linear") {
      return pe.fromWorkingColorSpace(ve(this, fe), t2), e2.r = fe.r, e2.g = fe.g, e2.b = fe.b, e2;
    }
    getStyle(e2 = "srgb") {
      return pe.fromWorkingColorSpace(ve(this, fe), e2), e2 !== ae ? `color(${e2} ${fe.r} ${fe.g} ${fe.b})` : `rgb(${255 * fe.r | 0},${255 * fe.g | 0},${255 * fe.b | 0})`;
    }
    offsetHSL(e2, t2, r2) {
      return this.getHSL(me), me.h += e2, me.s += t2, me.l += r2, this.setHSL(me.h, me.s, me.l), this;
    }
    add(e2) {
      return this.r += e2.r, this.g += e2.g, this.b += e2.b, this;
    }
    addColors(e2, t2) {
      return this.r = e2.r + t2.r, this.g = e2.g + t2.g, this.b = e2.b + t2.b, this;
    }
    addScalar(e2) {
      return this.r += e2, this.g += e2, this.b += e2, this;
    }
    sub(e2) {
      return this.r = Math.max(0, this.r - e2.r), this.g = Math.max(0, this.g - e2.g), this.b = Math.max(0, this.b - e2.b), this;
    }
    multiply(e2) {
      return this.r *= e2.r, this.g *= e2.g, this.b *= e2.b, this;
    }
    multiplyScalar(e2) {
      return this.r *= e2, this.g *= e2, this.b *= e2, this;
    }
    lerp(e2, t2) {
      return this.r += (e2.r - this.r) * t2, this.g += (e2.g - this.g) * t2, this.b += (e2.b - this.b) * t2, this;
    }
    lerpColors(e2, t2, r2) {
      return this.r = e2.r + (t2.r - e2.r) * r2, this.g = e2.g + (t2.g - e2.g) * r2, this.b = e2.b + (t2.b - e2.b) * r2, this;
    }
    lerpHSL(e2, t2) {
      this.getHSL(me), e2.getHSL(_e);
      const r2 = te(me.h, _e.h, t2), n2 = te(me.s, _e.s, t2), i2 = te(me.l, _e.l, t2);
      return this.setHSL(r2, n2, i2), this;
    }
    equals(e2) {
      return e2.r === this.r && e2.g === this.g && e2.b === this.b;
    }
    fromArray(e2, t2 = 0) {
      return this.r = e2[t2], this.g = e2[t2 + 1], this.b = e2[t2 + 2], this;
    }
    toArray(e2 = [], t2 = 0) {
      return e2[t2] = this.r, e2[t2 + 1] = this.g, e2[t2 + 2] = this.b, e2;
    }
    fromBufferAttribute(e2, t2) {
      return this.r = e2.getX(t2), this.g = e2.getY(t2), this.b = e2.getZ(t2), this;
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  }
  function be(e2, t2) {
    const r2 = "map" === t2;
    return { type: "folder", label: t2 + " Sampler", hidden: () => !e2[t2], children: [() => ({ type: "vec2", label: "Repeat", hidden: () => !r2 && e2.map, bounds: [-100, 100], stepSize: 1e-3, property: [e2[t2], "repeat"], onChange: null == e2 ? void 0 : e2.setDirty }), () => ({ type: "vec2", label: "Offset", hidden: () => !r2 && e2.map, bounds: [-2, 2], property: [e2[t2], "offset"], onChange: null == e2 ? void 0 : e2.setDirty }), () => ({ type: "vec2", label: "Center", hidden: () => !r2 && e2.map, bounds: [-2, 2], property: [e2[t2], "center"], onChange: null == e2 ? void 0 : e2.setDirty }), () => ({ type: "input", label: "Rotation", hidden: () => !r2 && e2.map, bounds: [-Math.PI, Math.PI], property: [e2[t2], "rotation"], onChange: null == e2 ? void 0 : e2.setDirty }), () => ({ type: "dropdown", label: "Encoding", property: [e2[t2], "encoding"], children: [["Linear", n.rnI], ["sRGB", n.knz]].map((e3) => ({ label: e3[0], value: e3[1] })), onChange: [() => {
      const r3 = e2[t2];
      r3 && (r3.needsUpdate = true);
    }, null == e2 ? void 0 : e2.setDirty] }), () => ({ type: "checkbox", label: "Flip Y", getValue: () => {
      var r3, n2;
      return null !== (n2 = null === (r3 = e2[t2]) || void 0 === r3 ? void 0 : r3.flipY) && void 0 !== n2 && n2;
    }, setValue: (r3) => {
      var n2;
      const i2 = e2[t2];
      if (i2 && i2.flipY !== r3)
        if (i2.image && ImageBitmap && i2.image instanceof ImageBitmap) {
          const t3 = i2, n3 = i2.source.data;
          createImageBitmap(n3, { imageOrientation: "flipY" }).then((i3) => {
            var s2;
            n3.close && n3.close(), t3.flipY = r3, t3.source.data = i3, t3.source.needsUpdate = true, t3.needsUpdate = true, null === (s2 = null == e2 ? void 0 : e2.setDirty) || void 0 === s2 || s2.call(e2);
          });
        } else
          i2.flipY = r3, i2.needsUpdate = true, null === (n2 = null == e2 ? void 0 : e2.setDirty) || void 0 === n2 || n2.call(e2);
    } }), () => ({ type: "dropdown", label: "Wrap S", property: [e2[t2], "wrapS"], children: [["ClampToEdge", n.uWy], ["MirroredRepeat", n.OoA], ["Repeat", n.rpg]].map((e3) => ({ label: e3[0], value: e3[1] })), onChange: [() => {
      e2[t2] && (e2[t2].needsUpdate = true);
    }, null == e2 ? void 0 : e2.setDirty] }), () => ({ type: "dropdown", label: "Wrap T", property: [e2[t2], "wrapT"], children: [["ClampToEdge", n.uWy], ["MirroredRepeat", n.OoA], ["Repeat", n.rpg]].map((e3) => ({ label: e3[0], value: e3[1] })), onChange: [() => {
      e2[t2] && (e2[t2].needsUpdate = true);
    }, null == e2 ? void 0 : e2.setDirty] }), () => ({ type: "input", label: "Anisotropy", bounds: [1, 6], stepSize: 1, property: [e2[t2], "anisotropy"], onChange: [() => {
      e2[t2] && (e2[t2].needsUpdate = true), e2.needsUpdate = true;
    }, null == e2 ? void 0 : e2.setDirty] }), () => ({ type: "dropdown", label: "Min Filter", property: [e2[t2], "minFilter"], children: [["Linear", oe], ["Nearest", n.TyD], ["NearestMipmapNearest", n.YLQ], ["NearestMipmapLinear", n.vZf], ["LinearMipmapNearest", n.qyh], ["LinearMipmapLinear", n.D1R]].map((e3) => ({ label: e3[0], value: e3[1] })), onChange: [() => {
      e2[t2] && (e2[t2].needsUpdate = true);
    }, null == e2 ? void 0 : e2.setDirty] }), () => ({ type: "dropdown", label: "Mag Filter", property: [e2[t2], "magFilter"], children: [["Linear", oe], ["Nearest", n.TyD]].map((e3) => ({ label: e3[0], value: e3[1] })), onChange: [() => {
      e2[t2] && (e2[t2].needsUpdate = true);
    }, null == e2 ? void 0 : e2.setDirty] })] };
  }
  Ae.NAMES = de;
  const ye = ["appliedMeshes", "imageLoadAwaiter", "inverseModelMatrix", "uvTransform", "uuid", "iMaterial"];
  function xe(e2, t2) {
    if (t2)
      for (const r2 of Object.keys(t2))
        ye.includes(r2) || r2.startsWith("__") || "function" != typeof e2[r2] && "function" != typeof t2[r2] && (e2[r2] = t2[r2]);
    return e2;
  }
  const we = ["appliedMaterials", "uuid"];
  function Ee(e2, t2) {
    if (t2)
      for (const r2 of Object.keys(t2))
        we.includes(r2) || r2.startsWith("__") || "function" != typeof e2[r2] && "function" != typeof t2[r2] && (e2[r2] = t2[r2]);
    return e2;
  }
  const Se = /* @__PURE__ */ new Map();
  function Ce(e2) {
    return (t2, r2) => {
      const n2 = t2.constructor;
      if (n2 === Object)
        throw new Error("All properties in an object are serialized by default");
      Se.has(n2) || Se.set(n2, []), Se.get(n2).push([e2 || r2, r2]);
    };
  }
  const Me = { obj: (e2, t2) => Object.fromEntries(Object.entries(e2).map(([e3, r2]) => [e3, ke(r2, false, t2)])), vec4: (e2) => ({ x: e2.x, y: e2.y, z: e2.z, w: e2.w, isVector4: true }), vec3: (e2) => ({ x: e2.x, y: e2.y, z: e2.z, isVector3: true }), vec2: (e2) => ({ x: e2.x, y: e2.y, isVector2: true }), color: (e2) => ({ r: e2.r, g: e2.g, b: e2.b, isColor: true }), quat: (e2) => ({ x: e2.x, y: e2.y, z: e2.z, w: e2.w, isQuaternion: true }), texture: (e2, t2) => {
    if (!(null == e2 ? void 0 : e2.isTexture))
      throw new Error("Expected a texture");
    if (e2.isRenderTargetTexture)
      return;
    if (null == t2 ? void 0 : t2.textures[e2.uuid])
      return { uuid: e2.uuid, resource: "textures" };
    const r2 = e2.source.data;
    e2.userData.rootPath && (e2.source.data = null);
    const n2 = e2.userData;
    e2.userData = {};
    let i2 = e2.toJSON(t2);
    return e2.userData = n2, i2.userData = ke(Ee({}, n2), false, t2), e2.userData.rootPath && (delete t2.images[e2.source.uuid], e2.source.data = r2), (null == t2 ? void 0 : t2.textures) && (t2.textures[i2.uuid] || (t2.textures[i2.uuid] = i2), i2 = { uuid: i2.uuid, resource: "textures" }), i2;
  }, material: (e2, t2) => {
    var r2;
    if (!(null == e2 ? void 0 : e2.isMaterial))
      throw new Error("Expected a material");
    if (null == t2 ? void 0 : t2.materials[e2.uuid])
      return { uuid: e2.uuid, resource: "materials" };
    e2.userData.rootPath && console.error("TODO: handle material with root path with material inheritance/hierarchy");
    const n2 = null != t2 ? t2 : { textures: {}, images: {} }, i2 = {}, s2 = {};
    for (const [t3, o3] of Object.entries(e2))
      if ((null === (r2 = o3) || void 0 === r2 ? void 0 : r2.isTexture) && !t3.startsWith("__")) {
        const r3 = Me.texture(o3, n2);
        i2[t3] = r3, s2[t3] = o3, e2[t3] = r3 ? { isTexture: true, toJSON: () => r3 } : null;
      }
    let o2 = e2.toJSON(t2);
    for (const [t3, r3] of Object.entries(s2))
      e2[t3] = r3, delete s2[t3];
    if (t2) {
      for (const [e3, t3] of Object.entries(i2))
        t3 && (o2[e3] = t3);
      (null == t2 ? void 0 : t2.materials) && (t2.materials[o2.uuid] || (t2.materials[o2.uuid] = o2), o2 = { uuid: o2.uuid, resource: "materials" });
    } else {
      for (const [e3, t3] of Object.entries(i2))
        o2[e3] = t3.uuid;
      o2.textures = Object.values(n2.textures), o2.images = Object.values(n2.images);
    }
    return o2;
  } }, Te = (e2) => (t2, r2) => {
    var n2, i2;
    return null !== (i2 = null === (n2 = null == r2 ? void 0 : r2.copy) || void 0 === n2 ? void 0 : n2.call(r2, t2)) && void 0 !== i2 ? i2 : new e2().copy(t2);
  }, Ie = { obj: (e2, t2, r2) => Object.assign(t2, Object.fromEntries(Object.entries(e2).map(([e3, n2]) => [e3, De(n2, null == t2 ? void 0 : t2[e3], false, r2)]))), vec4: Te(n.Ltg), vec3: Te(n.Pa4), vec2: Te(I), color: Te(Ae), quat: Te(n._fP) };
  function ke(e2, t2, r2) {
    var n2, i2;
    if ("function" == typeof e2)
      return;
    if (Array.isArray(e2))
      return e2.map((e3) => ke(e3, false, r2));
    if ("object" != typeof e2) {
      if ("number" == typeof e2) {
        if (e2 === 1 / 0)
          return "Infinity";
        if (e2 === -1 / 0)
          return "-Infinity";
        if (isNaN(e2))
          return "NaN";
      }
      return e2;
    }
    if (!e2)
      return e2;
    let s2 = null !== (n2 = e2.constructor) && void 0 !== n2 ? n2 : Object;
    if (s2 === Object)
      return Me.obj(e2, r2);
    if (e2.isVector2)
      return Me.vec2(e2);
    if (e2.isVector3)
      return Me.vec3(e2);
    if (e2.isVector4)
      return Me.vec4(e2);
    if (e2.isColor)
      return Me.color(e2);
    if (e2.isQuaternion)
      return Me.quat(e2);
    if (e2.isTexture)
      return Me.texture(e2, r2);
    if (e2.isMaterial)
      return Me.material(e2, r2);
    if (!t2 && "function" == typeof e2.toJSON)
      return e2.toJSON(r2);
    const o2 = {};
    for (; s2 && s2 !== Object; )
      null === (i2 = Se.get(s2)) || void 0 === i2 || i2.forEach(([t3, n3]) => {
        const i3 = e2[n3];
        o2[t3] = ke(i3, false, r2);
      }), s2 = Object.getPrototypeOf(s2);
    return e2.serializableClassId && (o2.serializableClassId = e2.serializableClassId), o2;
  }
  function De(e2, t2, r2, n2) {
    var i2, s2, o2;
    let a2 = t2;
    if (void 0 === e2)
      return a2;
    if ("number" == typeof t2) {
      if ("Infinity" === e2)
        return 1 / 0;
      if ("-Infinity" === e2)
        return -1 / 0;
      if ("NaN" === e2)
        return NaN;
      if ("number" == typeof e2 || !e2)
        return e2;
    }
    if (Array.isArray(e2)) {
      const t3 = e2.length;
      Array.isArray(a2) || (a2 = []);
      for (let r3 = 0; r3 < t3; r3++) {
        const t4 = e2[r3], i3 = a2.length > r3 ? De(t4, a2[r3], false, n2) : De(t4, void 0, false, n2);
        a2.length <= r3 ? a2.push(i3) : a2[r3] = i3;
      }
      return a2;
    }
    let l2 = false;
    if (e2 && e2.resource && "string" == typeof e2.resource && (e2 = null === (i2 = n2[e2.resource]) || void 0 === i2 ? void 0 : i2[e2.uuid], l2 = true), !a2 && e2 && !l2)
      if (e2.serializableClassId) {
        const t3 = Pe.get(e2.serializableClassId);
        t3 && (a2 = new t3());
      } else
        "object" != typeof e2 || e2.constructor && e2.constructor !== Object || (a2 = {});
    if ("function" == typeof a2)
      return console.error("cannot deserialize over function", a2, e2), a2;
    if (e2 && "object" == typeof e2 && !l2) {
      if (e2.isVector2)
        return Ie.vec2(e2, a2);
      if (e2.isVector3)
        return Ie.vec3(e2, a2);
      if (e2.isVector4)
        return Ie.vec4(e2, a2);
      if (e2.isColor)
        return Ie.color(e2, a2);
      if (e2.isQuaternion)
        return Ie.quat(e2, a2);
    }
    if (null == e2 || null == a2 || "object" != typeof a2 || a2.isTexture)
      return l2 && (e2 ? e2.__useCount = e2.__useCount ? e2.__useCount + 1 : 1 : console.warn("probable error deserialize: resource not found.")), e2;
    let c2 = null !== (s2 = a2.constructor) && void 0 !== s2 ? s2 : Object;
    if (c2 === Object)
      return Ie.obj(e2, a2, n2);
    if (!r2 && "function" == typeof a2.fromJSON)
      return a2.isMaterial && (Object.entries(e2).forEach(([t3, r3]) => {
        var i3;
        if (!r3 || !r3.resource || "string" != typeof r3.resource)
          return;
        const s3 = null === (i3 = n2[r3.resource]) || void 0 === i3 ? void 0 : i3[r3.uuid];
        e2[t3] = s3 || null;
      }), e2.userData && (e2.userData = De(e2.userData, void 0, false, n2))), a2.fromJSON(e2, n2), a2;
    for (; c2 && c2 !== Object; )
      null === (o2 = Se.get(c2)) || void 0 === o2 || o2.forEach(([t3, r3]) => {
        const i3 = a2[r3], s3 = De(e2[t3], i3, false, n2);
        s3 !== i3 && _(a2, r3, s3, true);
      }), c2 = Object.getPrototypeOf(c2);
    return a2;
  }
  const Pe = /* @__PURE__ */ new Map();
  function Be(e2) {
    return (t2) => (t2 = class extends t2 {
      constructor() {
        super(...arguments), this.serializableClassId = e2;
      }
    }, Pe.set(e2, t2), t2);
  }
  function Re(e2, t2) {
    if (e2.uiConfig)
      return e2.uiConfig;
    const r2 = { type: "folder", label: e2.name || "unnamed", expanded: true, limitedUi: true, children: [{ type: "checkbox", label: "Visible", property: [e2, "visible"], limitedUi: true }, { type: "button", label: "Pick/Focus", value: () => {
      e2.dispatchEvent({ type: "select", ui: true, value: e2, focusCamera: true });
    } }, { type: "button", label: "Pick Parent", hidden: () => !e2.parent, value: () => {
      const t3 = e2.parent;
      t3 && t3.dispatchEvent({ type: "select", ui: true, value: t3 });
    } }, { type: "input", label: "Name", property: [e2, "name"] }, { type: "checkbox", label: "Casts Shadow", hidden: () => !e2.isMesh, property: [e2, "castShadow"] }, { type: "checkbox", label: "Receive Shadow", hidden: () => !e2.isMesh, property: [e2, "receiveShadow"] }, { type: "vec3", label: "Position", property: [e2, "position"], limitedUi: true }, { type: "vec3", label: "Rotation", property: [e2, "rotation"], limitedUi: true }, { type: "vec3", label: "Scale", property: [e2, "scale"] }, { type: "button", label: "Auto Scale", prompt: ["Auto Scale Radius: Object will be scaled to the given radius", e2.userData.autoScaleRadius || "2", true], value: (t3) => {
      if (!t3)
        return;
      const r3 = parseFloat(t3);
      Math.abs(r3) > 0 && X(e2, r3);
    } }, void 0 !== e2.userData.license ? { type: "input", label: "License/Credits", property: [e2.userData, "license"], limitedUi: true } : {}] }, n2 = e2;
    if ((null == n2 ? void 0 : n2.isMesh) && false !== t2) {
      const e3 = [() => {
        var e4;
        return null === (e4 = n2.geometry) || void 0 === e4 ? void 0 : e4.uiConfig;
      }, () => {
        var e4;
        return Array.isArray(n2.material) ? n2.material.length < 1 ? void 0 : { label: "Materials", type: "folder", children: n2.material.map((e5) => null == e5 ? void 0 : e5.uiConfig).filter((e5) => e5) } : null === (e4 = n2.material) || void 0 === e4 ? void 0 : e4.uiConfig;
      }];
      r2.children.push(...e3);
    }
    if (null == e2 ? void 0 : e2.isCamera) {
      const t3 = [{ type: "button", label: "Set View", value: () => {
        e2.dispatchEvent({ type: "setView", ui: true, camera: e2 });
      } }, { type: "button", label: "Activate main", hidden: () => {
        var t4;
        return null === (t4 = e2.userData.iCamera) || void 0 === t4 ? void 0 : t4.isActiveCamera;
      }, value: () => {
        e2.dispatchEvent({ type: "activateMain", ui: true, camera: e2 });
      } }, { type: "button", label: "Deactivate main", hidden: () => {
        var t4;
        return !(null === (t4 = e2.userData.iCamera) || void 0 === t4 ? void 0 : t4.isActiveCamera);
      }, value: () => {
        e2.dispatchEvent({ type: "activateMain", ui: true, camera: void 0 });
      } }];
      r2.children.push(...t3);
    }
    return e2.uiConfig = r2, r2;
  }
  function Le(e2, t2, r2) {
    var n2;
    if (!e2)
      return void console.warn("setupIModel: object is undefined");
    if (e2.__disposed && (console.warn("re-init/re-add disposed object, things might not work as intended", e2), delete e2.__disposed), e2.userData || (e2.userData = {}), e2.userData.__iModelSetup && e2.modelObject)
      return e2;
    e2.userData.__iModelSetup = true;
    let i2 = [];
    i2.push(() => {
      [...e2.children].forEach((e3) => {
        var t3;
        null === (t3 = null == e3 ? void 0 : e3.dispose) || void 0 === t3 || t3.call(e3);
      }), e2.children = [], e2.parent && e2.removeFromParent();
    }), e2.isLight && !e2.assetType ? (e2.assetType = "light", e2.lightObject = e2) : e2.isCamera ? (e2.assetType = "camera", e2.cameraObject = e2) : e2.assetType || (e2.assetType = "model"), e2.modelObject || (e2.modelObject = e2), e2.setDirty || (e2.setDirty = (t3 = {}) => {
      e2.dispatchEvent({ ...t3, type: "objectUpdate", object: e2 });
    }, e2.userData.setDirty && console.warn("userData.setDirty already defined", e2.userData.setDirty, e2), e2.userData.setDirty = (t3) => {
      var r3;
      console.warn("userData.setDirty is deprecated, use setDirty directly"), null === (r3 = e2.setDirty) || void 0 === r3 || r3.call(e2, t3);
    });
    const s2 = (t3) => {
      var r3, n3, i3;
      const s3 = null !== (n3 = null === (r3 = e2.parent) || void 0 === r3 ? void 0 : r3.userData.parentRoot) && void 0 !== n3 ? n3 : e2.parent;
      s3 !== e2.userData.parentRoot && e2.traverse((e3) => {
        e3.userData.parentRoot = s3;
      }), null === (i3 = e2.setDirty) || void 0 === i3 || i3.call(e2, { change: "addedToParent" });
    }, o2 = () => {
      var t3;
      null === (t3 = e2.setDirty) || void 0 === t3 || t3.call(e2, { change: "removedFromParent" }), void 0 !== e2.userData.parentRoot && e2.traverse((e3) => {
        e3.userData.parentRoot = void 0;
      });
    };
    e2.addEventListener("added", s2), e2.addEventListener("removed", o2), i2.push(() => {
      e2.removeEventListener("added", s2), e2.removeEventListener("removed", o2);
    });
    const a2 = e2.dispose;
    e2.dispose = () => {
      e2.dispatchEvent({ type: "dispose" }), null == a2 || a2.call(e2);
    }, e2.userData.dispose && console.warn("userData.dispose already defined"), e2.userData.dispose = () => {
      var t3;
      console.warn("userData.dispose is deprecated, use dispose directly"), null === (t3 = e2.dispose) || void 0 === t3 || t3.call(e2);
    };
    const l2 = e2;
    !l2.isMesh && !l2.isLine || l2.userData.__meshSetup || (l2.userData.__meshSetup = true, l2.setMaterial || (l2.setMaterial = (e3) => Oe(l2, e3)), l2.setGeometry || (l2.setGeometry = (e3, t3 = false) => Fe(l2, e3, t3), l2.setGeometry(l2.geometry, true)), e2.userData.setMaterial && console.warn("userData.setMaterial already defined"), e2.userData.setMaterial = (t3) => {
      var r3;
      console.warn("userData.setMaterial is deprecated, use setMaterial directly"), null === (r3 = e2.setMaterial) || void 0 === r3 || r3.call(e2, t3);
    }, e2.userData.setGeometry && console.warn("userData.setGeometry already defined"), e2.userData.setGeometry = (t3, ...r3) => {
      var n3;
      console.warn("userData.setGeometry is deprecated, use setGeometry directly"), null === (n3 = e2.setGeometry) || void 0 === n3 || n3.call(e2, t3, ...r3);
    }, e2.userData.__keepShadowDef || (e2.castShadow = true, e2.receiveShadow = true, e2.userData.__keepShadowDef = true), i2.push(() => {
      var e3, t3;
      const r3 = (null === (e3 = l2.setMaterial) || void 0 === e3 ? void 0 : e3.call(l2, void 0)) || [], n3 = null === (t3 = l2.setGeometry) || void 0 === t3 ? void 0 : t3.call(l2, void 0);
      for (const e4 of r3)
        e4 && 0 === e4.userData.__appliedMeshes.size && false !== e4.userData.disposeOnIdle && e4.dispose();
      n3 && 0 === n3.userData.__appliedMeshes.size && false !== n3.userData.disposeOnIdle && n3.dispose();
    })), e2.uiConfig || "model" !== e2.assetType && "camera" !== e2.assetType || (Re(e2), i2.push(() => {
      e2.uiConfig = void 0;
    }));
    const c2 = () => {
      var t3, r3;
      return null === (r3 = null === (t3 = e2.uiConfig) || void 0 === t3 ? void 0 : t3.uiRefresh) || void 0 === r3 ? void 0 : r3.call(t3, "postFrame", true, 1);
    };
    e2.addEventListener("objectUpdate", c2), i2.push(() => e2.removeEventListener("objectUpdate", c2)), e2.userData.__autoParentDispatchEvents ? console.warn("object.userData.__autoParentDispatchEvents already set") : (e2.userData.__autoParentDispatchEvents = e2.userData.__autoParentDispatchEvents || ["objectUpdate", "materialUpdate", "select"], e2.isCamera && e2.userData.__autoParentDispatchEvents.push("activateMain", "setView")), t2 && (e2.userData.parentRoot = t2), i2.push(() => {
      delete e2.userData.parentRoot;
    });
    const u2 = e2.dispatchEvent;
    e2.dispatchEvent = (t3) => {
      var r3;
      (null === (r3 = e2.userData.__autoParentDispatchEvents) || void 0 === r3 ? void 0 : r3.includes(t3.type)) && (t3.parentDispatch = true), t3.parentDispatch && ((t4) => {
        var r4;
        const n3 = null !== (r4 = e2.userData.parentRoot) && void 0 !== r4 ? r4 : e2.parent;
        (null == n3 ? void 0 : n3.modelObject) && n3.dispatchEvent(t4);
      })(t3), u2.call(e2, t3);
    }, i2.push(() => {
      e2.dispatchEvent = u2;
    });
    const h2 = e2.clone;
    e2.clone = (...t3) => {
      const n3 = e2.userData;
      e2.userData = {};
      let i3 = h2.call(e2, ...t3);
      e2.userData = n3, je(i3.userData, n3);
      const s3 = e2.userData.parentRoot;
      return s3 && "model" !== s3.assetType && console.warn("Cloning an object with a parent that is not an IModel is not supported"), i3 = Le(i3, s3, r2), i3.userData.cloneParent = e2.uuid, i3;
    }, i2.push(() => {
      e2.clone = h2;
    });
    const p2 = e2.copy;
    e2.copy = (t3, ...r3) => {
      const n3 = t3.userData;
      t3.userData = {};
      const i3 = p2.call(e2, t3, ...r3);
      return t3.userData = n3, je(e2.userData, t3), i3;
    }, i2.push(() => {
      e2.copy = p2;
    });
    const d2 = e2.add;
    return e2.add = (...t3) => (t3.forEach((t4) => Le(t4, e2.userData.parentRoot || e2, r2)), d2.call(e2, ...t3)), i2.push(() => {
      e2.add = d2;
    }), e2 = null !== (n2 = null == r2 ? void 0 : r2(e2)) && void 0 !== n2 ? n2 : e2, i2.push(() => {
      _(e2, "modelObject", void 0, true), e2.userData = {};
    }), e2.addEventListener("dispose", () => {
      e2.__disposed ? console.warn("Object already disposed", e2) : (e2.__disposed = true, i2.forEach((e3) => e3()), i2 = []);
    }), [...e2.children].forEach((t3) => Le(t3, e2, r2)), e2;
  }
  function Oe(e2, t2) {
    var r2, n2, i2, s2, o2;
    const a2 = (Array.isArray(t2) ? t2 : [t2]).map((e3) => null == e3 ? void 0 : e3.materialObject).filter((e3) => e3);
    if (e2.material == a2 || 1 === a2.length && e2.material === a2[0])
      return [];
    e2.userData.__materialUpdater || (e2.userData.__materialUpdater = () => {
      e2.dispatchEvent({ type: "materialUpdate" });
    });
    const l2 = Array.isArray(e2.material) ? [...e2.material] : [e2.material];
    for (const t3 of l2)
      t3 && (t3.removeEventListener("materialUpdate", e2.userData.__materialUpdater), null === (n2 = null === (r2 = t3.userData) || void 0 === r2 ? void 0 : r2.__appliedMeshes) || void 0 === n2 || n2.delete(e2));
    const c2 = [];
    for (const t3 of a2)
      t3.userData.__appliedMeshes || (t3.userData.__appliedMeshes = /* @__PURE__ */ new Set()), c2.push(t3), t3 && (t3.addEventListener("materialUpdate", e2.userData.__materialUpdater), t3.userData.__appliedMeshes.add(e2));
    return e2.material = 1 !== c2.length ? c2 : null !== (i2 = c2[0]) && void 0 !== i2 ? i2 : void 0, e2.traverseAncestors((t3) => {
      t3.isRootScene && t3.refreshEnvMapIntensity(e2);
    }), e2.dispatchEvent({ type: "materialChanged", material: t2 }), null === (o2 = null === (s2 = e2.uiConfig) || void 0 === s2 ? void 0 : s2.uiRefresh) || void 0 === o2 || o2.call(s2, "postFrame", true), l2;
  }
  function Fe(e2, t2, r2 = false) {
    var n2, i2, s2, o2, a2, l2, c2;
    e2.userData.__objectUpdater || (e2.userData.__objectUpdater = (t3) => {
      e2.dispatchEvent({ ...t3, type: "objectUpdate" });
    });
    let u2 = e2.geometry;
    const h2 = u2;
    return (u2 !== t2 || r2) && (u2 && (u2.removeEventListener("geometryUpdate", e2.userData.__objectUpdater), null === (i2 = null === (n2 = u2.userData) || void 0 === n2 ? void 0 : n2.__appliedMeshes) || void 0 === i2 || i2.delete(e2)), u2 = t2, u2 && !u2.userData.__appliedMeshes && (u2.userData.__appliedMeshes = /* @__PURE__ */ new Set()), e2.geometry = null !== (s2 = u2) && void 0 !== s2 ? s2 : void 0, u2 && (u2.addEventListener("geometryUpdate", e2.userData.__objectUpdater), null === (a2 = null === (o2 = u2.userData) || void 0 === o2 ? void 0 : o2.__appliedMeshes) || void 0 === a2 || a2.add(e2))), t2 && !t2.uiConfig && (t2.uiConfig = function(e3) {
      return { label: "Geometry", type: "folder", children: [{ type: "input", property: [e3, "uuid"], disabled: true }, { type: "button", label: "Create uv2 from uv", value: () => {
        e3.hasAttribute("uv2") && !confirm("uv2 already exists, replace with uv data?") || e3.setAttribute("uv2", e3.getAttribute("uv"));
      } }, { type: "input", label: "Mesh count", get value() {
        var t3, r3, n3;
        return null !== (n3 = null === (r3 = null === (t3 = e3.userData) || void 0 === t3 ? void 0 : t3.__appliedMeshes) || void 0 === r3 ? void 0 : r3.size) && void 0 !== n3 ? n3 : 0;
      }, set value(e4) {
      }, disabled: true }] };
    }(e2.geometry)), e2.dispatchEvent({ type: "geometryChanged", geometry: t2 }), null === (c2 = null === (l2 = e2.uiConfig) || void 0 === l2 ? void 0 : l2.uiRefresh) || void 0 === c2 || c2.call(l2, "postFrame", true), h2 === u2 ? void 0 : h2 || void 0;
  }
  const Ue = ["appliedMeshes"], Ne = ["parentRoot", "iCamera", "iModel"];
  function je(e2, t2) {
    if (t2)
      for (const r2 of Object.keys(t2))
        Ne.includes(r2) || r2.startsWith("__") || "function" != typeof e2[r2] && "function" != typeof t2[r2] && (e2[r2] = t2[r2]);
    return e2;
  }
  var ze, Ge = new Uint8Array(16);
  function Ve() {
    if (!ze && !(ze = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto)))
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return ze(Ge);
  }
  for (var Qe = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, He = function(e2) {
    return "string" == typeof e2 && Qe.test(e2);
  }, We = [], qe = 0; qe < 256; ++qe)
    We.push((qe + 256).toString(16).substr(1));
  var Xe = function(e2, t2, r2) {
    var n2 = (e2 = e2 || {}).random || (e2.rng || Ve)();
    if (n2[6] = 15 & n2[6] | 64, n2[8] = 63 & n2[8] | 128, t2) {
      r2 = r2 || 0;
      for (var i2 = 0; i2 < 16; ++i2)
        t2[r2 + i2] = n2[i2];
      return t2;
    }
    return function(e3) {
      var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r3 = (We[e3[t3 + 0]] + We[e3[t3 + 1]] + We[e3[t3 + 2]] + We[e3[t3 + 3]] + "-" + We[e3[t3 + 4]] + We[e3[t3 + 5]] + "-" + We[e3[t3 + 6]] + We[e3[t3 + 7]] + "-" + We[e3[t3 + 8]] + We[e3[t3 + 9]] + "-" + We[e3[t3 + 10]] + We[e3[t3 + 11]] + We[e3[t3 + 12]] + We[e3[t3 + 13]] + We[e3[t3 + 14]] + We[e3[t3 + 15]]).toLowerCase();
      if (!He(r3))
        throw TypeError("Stringified UUID is invalid");
      return r3;
    }(n2);
  };
  const Ye = /* @__PURE__ */ new Map();
  function Ke(e2, t2) {
    return (r2, n2) => {
      const i2 = r2.constructor;
      if (i2 === Object)
        throw new Error("All properties in an object are serialized by default");
      Ye.has(i2) || Ye.set(i2, []);
      const s2 = Ye.get(i2);
      if (!(s2.findIndex((e3) => e3.propKey === n2) < 0))
        throw new Error(`Property ${n2} already has a uiConfig decorator`);
      s2.push({ params: t2 || {}, propKey: n2, uiType: e2 });
    };
  }
  function Je(e2, t2) {
    return Ke("checkbox", { label: e2, params: t2 });
  }
  function Ze(e2, t2) {
    return Ke("monitor", { label: e2, params: t2 });
  }
  function $e(e2, t2, r2, n2) {
    return Ke("slider", { label: e2, bounds: t2, stepSize: r2, params: n2 });
  }
  function et(e2, t2, r2, n2) {
    return Ke("vec", { label: e2, bounds: t2, stepSize: r2, params: n2 });
  }
  function tt(e2, t2, r2) {
    return Ke("dropdown", { label: e2, children: t2, params: r2 });
  }
  function rt(e2, t2) {
    return Ke("button", { label: e2, params: t2 });
  }
  function nt(e2, t2) {
    return Ke("input", { label: e2, params: t2 });
  }
  function it(e2, t2) {
    return Ke("color", { label: e2, params: t2 });
  }
  function st(e2, t2) {
    return Ke("image", { label: e2, params: t2 });
  }
  function ot(e2) {
    let t2 = null == e2 ? void 0 : e2.constructor;
    if (!e2 || !t2)
      return [];
    const r2 = [], n2 = [];
    for (; t2 && t2 !== Object; )
      n2.push(t2), t2 = Object.getPrototypeOf(t2);
    return n2.reverse().forEach((t3) => {
      var n3;
      null === (n3 = Ye.get(t3)) || void 0 === n3 || n3.forEach(({ params: t4, propKey: n4, uiType: i2 }) => {
        var s2;
        let o2;
        if (i2 || (o2 = null === (s2 = e2[n4]) || void 0 === s2 ? void 0 : s2.uiConfig), o2 || (o2 = { property: [e2, n4], type: i2 || "input" }), t4) {
          const r3 = "function" == typeof t4.params ? t4.params(e2) : t4.params || {};
          delete t4.params, Object.assign(o2, { ...t4, ...r3 });
        }
        r2.push(o2);
      });
    }), r2;
  }
  function at(e2, t2, r2 = {}) {
    return { type: "folder", label: e2, children: ot(t2), uuid: Xe(), ...r2 };
  }
  function lt(e2, t2) {
    return (r2) => class extends r2 {
      constructor() {
        super(...arguments), this.uiConfig = at(e2, this, t2 || {});
      }
    };
  }
  const ct = { type: "change" }, ut = { type: "start" }, ht = { type: "end" };
  class pt extends n.pBf {
    constructor(e2, t2) {
      super(), this.object = e2, this.domElement = t2, this.domElement.style.touchAction = "none", this.enabled = true, this.target = new n.Pa4(), this.minDistance = 0.01, this.maxDistance = 1 / 0, this.autoPushTarget = true, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = false, this.dampingFactor = 0.05, this.enableZoom = true, this.zoomSpeed = 1, this.maxZoomSpeed = 1, this.dollyZoom = false, this.enableRotate = true, this.rotateSpeed = 1, this.enablePan = true, this.panSpeed = 1, this.screenSpacePanning = true, this.keyPanSpeed = 7, this.autoRotate = false, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: n.RsA.ROTATE, MIDDLE: n.RsA.DOLLY, RIGHT: n.RsA.PAN }, this.touches = { ONE: n.QmN.ROTATE, TWO: n.QmN.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
        return a2.phi;
      }, this.getAzimuthalAngle = function() {
        return a2.theta;
      }, this.getDistance = function() {
        return this.object.position.distanceTo(this.target);
      }, this.listenToKeyEvents = function(e3) {
        e3.addEventListener("keydown", Q2), this._domElementKeyEvents = e3;
      }, this.saveState = function() {
        r2.target0.copy(r2.target), r2.position0.copy(r2.object.position), r2.zoom0 = r2.object.zoom;
      }, this.reset = function() {
        r2.target.copy(r2.target0), r2.object.position.copy(r2.position0), r2.object.zoom = r2.zoom0, r2.object.updateProjectionMatrix(), r2.dispatchEvent(ct), r2.update(), s2 = i2.NONE;
      }, this.update = function() {
        const t3 = new n.Pa4(), p3 = new n._fP().setFromUnitVectors(e2.up, new n.Pa4(0, 1, 0)), d3 = p3.clone().invert(), f3 = new n.Pa4(), m3 = new n._fP(), _3 = 2 * Math.PI;
        return function() {
          const e3 = r2.object.position;
          t3.copy(e3).sub(r2.target), t3.applyQuaternion(p3), a2.setFromVector3(t3), r2.autoRotate && s2 === i2.NONE && E2(2 * Math.PI / 60 / 60 * r2.autoRotateSpeed), r2.enableDamping ? (a2.theta += l2.theta * r2.dampingFactor, a2.phi += l2.phi * r2.dampingFactor) : (a2.theta += l2.theta, a2.phi += l2.phi);
          let n2 = r2.minAzimuthAngle, g3 = r2.maxAzimuthAngle;
          isFinite(n2) && isFinite(g3) && (n2 < -Math.PI ? n2 += _3 : n2 > Math.PI && (n2 -= _3), g3 < -Math.PI ? g3 += _3 : g3 > Math.PI && (g3 -= _3), a2.theta = n2 <= g3 ? Math.max(n2, Math.min(g3, a2.theta)) : a2.theta > (n2 + g3) / 2 ? Math.max(n2, a2.theta) : Math.min(g3, a2.theta)), a2.phi = Math.max(r2.minPolarAngle, Math.min(r2.maxPolarAngle, a2.phi)), a2.makeSafe(), Math.abs(l2.radius) > 0 && (r2.dollyZoom && (r2.object.zoom = Math.max(Math.max(r2.minZoom, 0.1), Math.min(Math.min(r2.maxZoom, 20), r2.object.zoom * (1 + l2.radius * (r2.enableDamping ? r2.dampingFactor : 1)))), r2.object.updateProjectionMatrix(), (r2.object.zoom >= Math.min(r2.maxZoom, 20) || r2.object.zoom <= Math.max(r2.minZoom, 0.1)) && (l2.radius = 0)), a2.radius *= 1 + l2.radius * (r2.enableDamping ? r2.dampingFactor : 1)), Math.abs(c2 - 1) > 1e-5 && (r2.dollyZoom && (r2.object.zoom = Math.max(Math.max(r2.minZoom, 0.1), Math.min(Math.min(r2.maxZoom, 20), r2.object.zoom * c2)), r2.object.updateProjectionMatrix(), (r2.object.zoom >= Math.min(r2.maxZoom, 20) || r2.object.zoom <= Math.max(r2.minZoom, 0.1)) && (c2 = 1)), a2.radius *= c2);
          let v3 = 0;
          r2.autoPushTarget && a2.radius < r2.minDistance && (v3 = r2.minDistance - a2.radius), a2.radius = Math.max(r2.minDistance, Math.min(r2.maxDistance, a2.radius)), true === r2.enableDamping ? r2.target.addScaledVector(u2, r2.dampingFactor) : r2.target.add(u2), t3.setFromSpherical(a2), t3.applyQuaternion(d3), e3.copy(r2.target).add(t3), r2.target.add(t3.normalize().multiplyScalar(-v3)), r2.object.lookAt(r2.target);
          let A3 = false;
          return true === r2.enableDamping && Math.abs(l2.theta) + Math.abs(l2.phi) + Math.abs(l2.radius) + u2.length() > 1e-3 ? (l2.theta *= 1 - r2.dampingFactor, l2.phi *= 1 - r2.dampingFactor, l2.radius *= 1 - r2.dampingFactor, u2.multiplyScalar(1 - r2.dampingFactor), A3 = true) : (l2.set(0, 0, 0), u2.set(0, 0, 0)), c2 = 1, !!(h2 || A3 || f3.distanceToSquared(r2.object.position) > o2 || 8 * (1 - m3.dot(r2.object.quaternion)) > o2) && (r2.dispatchEvent(ct), f3.copy(r2.object.position), m3.copy(r2.object.quaternion), h2 = false, true);
        };
      }(), this.stopDamping = function() {
        l2.set(0, 0, 0), u2.set(0, 0, 0);
      }, this.dispose = function() {
        r2.domElement.removeEventListener("contextmenu", H2), r2.domElement.removeEventListener("pointerdown", N2), r2.domElement.removeEventListener("pointercancel", G2), r2.domElement.removeEventListener("wheel", V2), r2.domElement.removeEventListener("pointermove", j2), r2.domElement.removeEventListener("pointerup", z2), null !== r2._domElementKeyEvents && r2._domElementKeyEvents.removeEventListener("keydown", Q2);
      };
      const r2 = this, i2 = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 };
      let s2 = i2.NONE;
      const o2 = 1e-6, a2 = new n.$V(), l2 = new n.$V(0, 0, 0);
      let c2 = 1;
      const u2 = new n.Pa4();
      let h2 = false;
      const p2 = new n.FM8(), d2 = new n.FM8(), f2 = new n.FM8(), m2 = new n.FM8(), _2 = new n.FM8(), g2 = new n.FM8(), v2 = new n.FM8(), A2 = new n.FM8(), b2 = new n.FM8(), y2 = [], x2 = {};
      function w2() {
        return r2.enableDamping ? 1 : Math.pow(0.95, r2.zoomSpeed);
      }
      function E2(e3) {
        l2.theta -= e3;
      }
      function S2(e3) {
        l2.phi -= e3;
      }
      this.rotateUp = S2, this.rotateLeft = E2;
      const C2 = function() {
        const e3 = new n.Pa4();
        return function(t3, r3) {
          e3.setFromMatrixColumn(r3, 0), e3.multiplyScalar(-t3), u2.add(e3);
        };
      }(), M2 = function() {
        const e3 = new n.Pa4();
        return function(t3, n2) {
          true === r2.screenSpacePanning ? e3.setFromMatrixColumn(n2, 1) : (e3.setFromMatrixColumn(n2, 0), e3.crossVectors(r2.object.up, e3)), e3.multiplyScalar(t3), u2.add(e3);
        };
      }(), T2 = function() {
        const e3 = new n.Pa4();
        return function(t3, n2) {
          const i3 = r2.domElement;
          if (r2.object.isPerspectiveCamera) {
            const s3 = r2.object.position;
            e3.copy(s3).sub(r2.target);
            let o3 = e3.length();
            o3 *= Math.tan(r2.object.fov / 2 * Math.PI / 180), C2(2 * t3 * o3 / i3.clientHeight, r2.object.matrix), M2(2 * n2 * o3 / i3.clientHeight, r2.object.matrix);
          } else
            r2.object.isOrthographicCamera ? (C2(t3 * (r2.object.right - r2.object.left) / r2.object.zoom / i3.clientWidth, r2.object.matrix), M2(n2 * (r2.object.top - r2.object.bottom) / r2.object.zoom / i3.clientHeight, r2.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), r2.enablePan = false);
        };
      }();
      function I2(e3, t3 = 0) {
        r2.object.isPerspectiveCamera ? (c2 /= e3, l2.radius = Math.max(-r2.maxZoomSpeed, Math.min(r2.maxZoomSpeed, l2.radius - t3))) : r2.object.isOrthographicCamera ? (r2.object.zoom = Math.max(r2.minZoom, Math.min(r2.maxZoom, r2.object.zoom * e3)), r2.object.updateProjectionMatrix(), h2 = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r2.enableZoom = false);
      }
      function k2(e3, t3 = 0) {
        r2.object.isPerspectiveCamera ? (c2 *= e3, l2.radius = Math.max(-r2.maxZoomSpeed, Math.min(r2.maxZoomSpeed, l2.radius + t3))) : r2.object.isOrthographicCamera ? (r2.object.zoom = Math.max(r2.minZoom, Math.min(r2.maxZoom, r2.object.zoom / e3)), r2.object.updateProjectionMatrix(), h2 = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r2.enableZoom = false);
      }
      function D2(e3) {
        p2.set(e3.clientX, e3.clientY);
      }
      function P2(e3) {
        m2.set(e3.clientX, e3.clientY);
      }
      function B2() {
        if (1 === y2.length)
          p2.set(y2[0].pageX, y2[0].pageY);
        else {
          const e3 = 0.5 * (y2[0].pageX + y2[1].pageX), t3 = 0.5 * (y2[0].pageY + y2[1].pageY);
          p2.set(e3, t3);
        }
      }
      function R2() {
        if (1 === y2.length)
          m2.set(y2[0].pageX, y2[0].pageY);
        else {
          const e3 = 0.5 * (y2[0].pageX + y2[1].pageX), t3 = 0.5 * (y2[0].pageY + y2[1].pageY);
          m2.set(e3, t3);
        }
      }
      function L2() {
        const e3 = y2[0].pageX - y2[1].pageX, t3 = y2[0].pageY - y2[1].pageY, r3 = Math.sqrt(e3 * e3 + t3 * t3);
        v2.set(0, r3);
      }
      function O2(e3) {
        if (1 == y2.length)
          d2.set(e3.pageX, e3.pageY);
        else {
          const t4 = X2(e3), r3 = 0.5 * (e3.pageX + t4.x), n2 = 0.5 * (e3.pageY + t4.y);
          d2.set(r3, n2);
        }
        f2.subVectors(d2, p2).multiplyScalar(r2.rotateSpeed);
        const t3 = r2.domElement;
        E2(2 * Math.PI * f2.x / t3.clientHeight), S2(2 * Math.PI * f2.y / t3.clientHeight), p2.copy(d2);
      }
      function F2(e3) {
        if (1 === y2.length)
          _2.set(e3.pageX, e3.pageY);
        else {
          const t3 = X2(e3), r3 = 0.5 * (e3.pageX + t3.x), n2 = 0.5 * (e3.pageY + t3.y);
          _2.set(r3, n2);
        }
        g2.subVectors(_2, m2).multiplyScalar(r2.panSpeed), T2(g2.x, g2.y), m2.copy(_2);
      }
      function U2(e3) {
        const t3 = X2(e3), n2 = e3.pageX - t3.x, i3 = e3.pageY - t3.y, s3 = Math.sqrt(n2 * n2 + i3 * i3);
        A2.set(0, s3), b2.set(0, Math.pow(A2.y / v2.y, r2.zoomSpeed)), I2(b2.y), v2.copy(A2);
      }
      function N2(e3) {
        false !== r2.enabled && (0 === y2.length && (r2.domElement.setPointerCapture(e3.pointerId), r2.domElement.addEventListener("pointermove", j2), r2.domElement.addEventListener("pointerup", z2)), function(e4) {
          y2.push(e4);
        }(e3), "touch" === e3.pointerType ? function(e4) {
          switch (q2(e4), y2.length) {
            case 1:
              switch (r2.touches.ONE) {
                case n.QmN.ROTATE:
                  if (false === r2.enableRotate)
                    return;
                  B2(), s2 = i2.TOUCH_ROTATE;
                  break;
                case n.QmN.PAN:
                  if (false === r2.enablePan)
                    return;
                  R2(), s2 = i2.TOUCH_PAN;
                  break;
                default:
                  s2 = i2.NONE;
              }
              break;
            case 2:
              switch (r2.touches.TWO) {
                case n.QmN.DOLLY_PAN:
                  if (false === r2.enableZoom && false === r2.enablePan)
                    return;
                  r2.enableZoom && L2(), r2.enablePan && R2(), s2 = i2.TOUCH_DOLLY_PAN;
                  break;
                case n.QmN.DOLLY_ROTATE:
                  if (false === r2.enableZoom && false === r2.enableRotate)
                    return;
                  r2.enableZoom && L2(), r2.enableRotate && B2(), s2 = i2.TOUCH_DOLLY_ROTATE;
                  break;
                default:
                  s2 = i2.NONE;
              }
              break;
            default:
              s2 = i2.NONE;
          }
          s2 !== i2.NONE && r2.dispatchEvent(ut);
        }(e3) : function(e4) {
          let t3;
          switch (e4.button) {
            case 0:
              t3 = r2.mouseButtons.LEFT;
              break;
            case 1:
              t3 = r2.mouseButtons.MIDDLE;
              break;
            case 2:
              t3 = r2.mouseButtons.RIGHT;
              break;
            default:
              t3 = -1;
          }
          switch (t3) {
            case n.RsA.DOLLY:
              if (false === r2.enableZoom)
                return;
              !function(e5) {
                v2.set(e5.clientX, e5.clientY);
              }(e4), s2 = i2.DOLLY;
              break;
            case n.RsA.ROTATE:
              if (e4.ctrlKey || e4.metaKey || e4.shiftKey) {
                if (false === r2.enablePan)
                  return;
                P2(e4), s2 = i2.PAN;
              } else {
                if (false === r2.enableRotate)
                  return;
                D2(e4), s2 = i2.ROTATE;
              }
              break;
            case n.RsA.PAN:
              if (e4.ctrlKey || e4.metaKey || e4.shiftKey) {
                if (false === r2.enableRotate)
                  return;
                D2(e4), s2 = i2.ROTATE;
              } else {
                if (false === r2.enablePan)
                  return;
                P2(e4), s2 = i2.PAN;
              }
              break;
            default:
              s2 = i2.NONE;
          }
          s2 !== i2.NONE && r2.dispatchEvent(ut);
        }(e3));
      }
      function j2(e3) {
        false !== r2.enabled && ("touch" === e3.pointerType ? function(e4) {
          switch (q2(e4), s2) {
            case i2.TOUCH_ROTATE:
              if (false === r2.enableRotate)
                return;
              O2(e4), r2.update();
              break;
            case i2.TOUCH_PAN:
              if (false === r2.enablePan)
                return;
              F2(e4), r2.update();
              break;
            case i2.TOUCH_DOLLY_PAN:
              if (false === r2.enableZoom && false === r2.enablePan)
                return;
              !function(e5) {
                r2.enableZoom && U2(e5), r2.enablePan && F2(e5);
              }(e4), r2.update();
              break;
            case i2.TOUCH_DOLLY_ROTATE:
              if (false === r2.enableZoom && false === r2.enableRotate)
                return;
              !function(e5) {
                r2.enableZoom && U2(e5), r2.enableRotate && O2(e5);
              }(e4), r2.update();
              break;
            default:
              s2 = i2.NONE;
          }
        }(e3) : function(e4) {
          switch (s2) {
            case i2.ROTATE:
              if (false === r2.enableRotate)
                return;
              !function(e5) {
                d2.set(e5.clientX, e5.clientY), f2.subVectors(d2, p2).multiplyScalar(r2.rotateSpeed);
                const t3 = r2.domElement;
                E2(2 * Math.PI * f2.x / t3.clientHeight), S2(2 * Math.PI * f2.y / t3.clientHeight), p2.copy(d2), r2.update();
              }(e4);
              break;
            case i2.DOLLY:
              if (false === r2.enableZoom)
                return;
              !function(e5) {
                A2.set(e5.clientX, e5.clientY), b2.subVectors(A2, v2), b2.y > 0 ? I2(w2()) : b2.y < 0 && k2(w2()), v2.copy(A2), r2.update();
              }(e4);
              break;
            case i2.PAN:
              if (false === r2.enablePan)
                return;
              !function(e5) {
                _2.set(e5.clientX, e5.clientY), g2.subVectors(_2, m2).multiplyScalar(r2.panSpeed), T2(g2.x, g2.y), m2.copy(_2), r2.update();
              }(e4);
          }
        }(e3));
      }
      function z2(e3) {
        W2(e3), 0 === y2.length && (r2.domElement.releasePointerCapture(e3.pointerId), r2.domElement.removeEventListener("pointermove", j2), r2.domElement.removeEventListener("pointerup", z2)), r2.dispatchEvent(ht), s2 = i2.NONE;
      }
      function G2(e3) {
        W2(e3);
      }
      function V2(e3) {
        false !== r2.enabled && false !== r2.enableZoom && s2 === i2.NONE && (e3.preventDefault(), r2.dispatchEvent(ut), function(e4) {
          let t3 = 0;
          switch (e4.deltaMode) {
            case 2:
              t3 += 1 * e4.deltaY;
              break;
            case 1:
              t3 += 0.4 * e4.deltaY;
              break;
            default:
              t3 += 0.01 * e4.deltaY;
          }
          e4.deltaY < 0 ? k2(1, t3 * r2.zoomSpeed) : e4.deltaY > 0 && I2(1, -t3 * r2.zoomSpeed), r2.update();
        }(e3), r2.dispatchEvent(ht));
      }
      function Q2(e3) {
        false !== r2.enabled && false !== r2.enablePan && function(e4) {
          let t3 = false;
          switch (e4.code) {
            case r2.keys.UP:
              T2(0, r2.keyPanSpeed), t3 = true;
              break;
            case r2.keys.BOTTOM:
              T2(0, -r2.keyPanSpeed), t3 = true;
              break;
            case r2.keys.LEFT:
              T2(r2.keyPanSpeed, 0), t3 = true;
              break;
            case r2.keys.RIGHT:
              T2(-r2.keyPanSpeed, 0), t3 = true;
          }
          t3 && (e4.preventDefault(), r2.update());
        }(e3);
      }
      function H2(e3) {
        false !== r2.enabled && e3.preventDefault();
      }
      function W2(e3) {
        delete x2[e3.pointerId];
        for (let t3 = 0; t3 < y2.length; t3++)
          if (y2[t3].pointerId == e3.pointerId)
            return void y2.splice(t3, 1);
      }
      function q2(e3) {
        let t3 = x2[e3.pointerId];
        void 0 === t3 && (t3 = new n.FM8(), x2[e3.pointerId] = t3), t3.set(e3.pageX, e3.pageY);
      }
      function X2(e3) {
        const t3 = e3.pointerId === y2[0].pointerId ? y2[1] : y2[0];
        return x2[t3.pointerId];
      }
      this.zoomIn = function(e3) {
        I2(1, e3 * r2.zoomSpeed);
      }, this.zoomOut = function(e3) {
        k2(1, e3 * r2.zoomSpeed);
      }, r2.domElement.addEventListener("contextmenu", H2), r2.domElement.addEventListener("pointerdown", N2), r2.domElement.addEventListener("pointercancel", G2), r2.domElement.addEventListener("wheel", V2, { passive: false }), this.update();
    }
  }
  var dt = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let ft = class extends pt {
    constructor() {
      super(...arguments), this.type = "OrbitControls", this.enabled = true, this.dollyZoom = false, this.enableDamping = true, this.dampingFactor = 0.08, this.autoRotate = false, this.autoRotateSpeed = 2, this.enableZoom = true, this.zoomSpeed = 0.15, this.maxZoomSpeed = 0.2, this.enableRotate = true, this.rotateSpeed = 2, this.enablePan = true, this.panSpeed = 1, this.autoPushTarget = false, this.minDistance = 0.35, this.maxDistance = 1e3, this.minZoom = 0.01, this.maxZoom = 1e3, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1e4, this.maxAzimuthAngle = 1e4, this.screenSpacePanning = true, this.keyPanSpeed = 7;
    }
    zoomIn(e2) {
      super.zoomIn(e2);
    }
    zoomOut(e2) {
      super.zoomOut(e2);
    }
    dispatchEvent(e2) {
      super.dispatchEvent(e2);
    }
  };
  dt([Ce()], ft.prototype, "type", void 0), dt([Je()], ft.prototype, "enabled", void 0), dt([Je(), Ce()], ft.prototype, "dollyZoom", void 0), dt([Je(), Ce()], ft.prototype, "enableDamping", void 0), dt([nt(), Ce()], ft.prototype, "dampingFactor", void 0), dt([Je(), Ce()], ft.prototype, "autoRotate", void 0), dt([nt(), Ce()], ft.prototype, "autoRotateSpeed", void 0), dt([Je(), Ce()], ft.prototype, "enableZoom", void 0), dt([nt(), Ce()], ft.prototype, "zoomSpeed", void 0), dt([nt(), Ce()], ft.prototype, "maxZoomSpeed", void 0), dt([Je(), Ce()], ft.prototype, "enableRotate", void 0), dt([nt(), Ce()], ft.prototype, "rotateSpeed", void 0), dt([Je(), Ce()], ft.prototype, "enablePan", void 0), dt([nt(), Ce()], ft.prototype, "panSpeed", void 0), dt([nt(), Ce()], ft.prototype, "autoPushTarget", void 0), dt([nt(), Ce()], ft.prototype, "minDistance", void 0), dt([nt(), Ce()], ft.prototype, "maxDistance", void 0), dt([nt(), Ce()], ft.prototype, "minZoom", void 0), dt([nt(), Ce()], ft.prototype, "maxZoom", void 0), dt([nt(), Ce()], ft.prototype, "minPolarAngle", void 0), dt([nt(), Ce()], ft.prototype, "maxPolarAngle", void 0), dt([nt(), Ce()], ft.prototype, "minAzimuthAngle", void 0), dt([nt(), Ce()], ft.prototype, "maxAzimuthAngle", void 0), dt([Ce()], ft.prototype, "screenSpacePanning", void 0), dt([Ce()], ft.prototype, "keyPanSpeed", void 0), ft = dt([lt("Orbit Controls")], ft);
  var mt = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class _t extends r {
    constructor(e2, t2, r2) {
      super(), this._controlsMode = "", this._isActiveCamera = false, this.userData = {}, this._cameraObjectUpdate = (e3) => {
        this.setDirty(e3);
      }, this._interactionsEnabled = true, this.autoLookAtTarget = true, this.near = 0.01, this.far = 50, this._options = { type: "PerspectiveCamera", aspect: "auto", focus: 10, fov: 25, zoom: 1, frustumSize: 1, top: 1, bottom: -1, left: -1, right: 1, controlsMode: "orbit", controlsEnabled: true }, this._position = new n.Pa4(0, 0, 10), this._target = new n.Pa4(0, 0, 0), this._controlsCtors = /* @__PURE__ */ new Map([["orbit", (e3, t3) => {
        const r3 = new ft(e3, t3.ownerDocument ? t3 : t3.documentElement);
        return r3.screenSpacePanning = true, r3;
      }]]), this._camUi = [{ type: "vec3", label: "Position", property: [this, "position"], onChange: () => this.positionUpdated(true) }, { type: "vec3", label: "Target", property: [this, "target"], onChange: () => this.targetUpdated(true) }, { type: "slider", bounds: [1, 180], label: "Field Of View", hidden: () => !this._camera.modelObject.isPerspectiveCamera, property: [this._options, "fov"], onChange: () => {
        this.refreshCameraOptions();
      }, limitedUi: true }, { type: "slider", bounds: [1e-3, 20], label: "Zoom", property: [this._options, "zoom"], onChange: () => {
        this.refreshCameraOptions();
      } }, () => ({ type: "dropdown", label: "Controls Mode", property: [this._options, "controlsMode"], children: ["", "orbit", "firstPerson", "pointerLock", ...this._controlsCtors.keys()].map((e3) => ({ label: "" === e3 ? "none" : e3, value: e3 })), onChange: () => {
        this.refreshCameraOptions();
      } })], this.uiConfig = { type: "folder", label: "Camera", limitedUi: true, children: [...this._camUi, () => {
        var e3;
        return null === (e3 = this._controls) || void 0 === e3 ? void 0 : e3.uiConfig;
      }, () => {
        var e3;
        return (null === (e3 = this._controls) || void 0 === e3 ? void 0 : e3.zoomIn) ? { type: "button", label: "Zoom in", value: () => {
          var e4;
          null === (e4 = this._controls) || void 0 === e4 || e4.zoomIn(1);
        } } : {};
      }, () => {
        var e3;
        return (null === (e3 = this._controls) || void 0 === e3 ? void 0 : e3.zoomOut) ? { type: "button", label: "Zoom out", value: () => {
          var e4;
          null === (e4 = this._controls) || void 0 === e4 || e4.zoomOut(1);
        } } : {};
      }] }, this.assetType = "model", this.uuid = $(), this.setDirty = this.setDirty.bind(this), this.targetUpdated = this.targetUpdated.bind(this), this._refreshCameraOptions = this._refreshCameraOptions.bind(this), this._container = null != r2 ? r2 : document.body;
      const i2 = null != t2 ? t2 : this._options;
      this._camera = this._setCameraObject(null != e2 ? e2 : "OrthographicCamera" === i2.type ? new n.iKG(-1, 1, 1, -1) : new n.cPb()), this._camera.modelObject.userData.iCamera = this;
      const s2 = e2;
      e2 && (s2.isPerspectiveCamera ? (i2.fov = s2.fov, i2.focus = s2.focus, i2.aspect = s2.aspect <= 0 || s2.userData.autoAspect ? "auto" : s2.aspect, i2.zoom = s2.zoom) : s2.isOrthographicCamera && (i2.left = s2.left, i2.right = s2.right, i2.top = s2.top, i2.bottom = s2.bottom, i2.zoom = s2.zoom), i2.near = s2.near, i2.far = s2.far, this._position.copy(e2.position), this.refreshTarget()), this.positionUpdated(false), e2 || this.targetUpdated(false), this.setCameraOptions(i2);
    }
    get controls() {
      return this._controls;
    }
    getControls() {
      return this._controls;
    }
    get isActiveCamera() {
      return this._isActiveCamera;
    }
    get target() {
      return this._target;
    }
    set target(e2) {
      const t2 = this._target.sub(e2).length() > 1e-5;
      this._target.copy(e2), t2 && this.targetUpdated();
    }
    get position() {
      return this._position;
    }
    set position(e2) {
      const t2 = this._position.sub(e2).length() > 1e-5;
      this._position.copy(e2), t2 && this.positionUpdated();
    }
    get name() {
      return this._camera.name;
    }
    set name(e2) {
      this._camera.name = e2;
    }
    getCameraOptions() {
      return { ...this._options, position: this._position.toArray(), target: this._target.toArray() };
    }
    setCameraOptions(e2, t2 = true) {
      var r2, n2;
      const i2 = { ...e2 };
      (null === (r2 = i2.position) || void 0 === r2 ? void 0 : r2.isVector3) && (i2.position = [i2.position.x, i2.position.y, i2.position.z]), (null === (n2 = i2.target) || void 0 === n2 ? void 0 : n2.isVector3) && (i2.target = [i2.target.x, i2.target.y, i2.target.z]), Object.keys(i2).forEach((e3) => "frustumSize" !== e3 && void 0 === i2[e3] && delete i2[e3]), Object.assign(this._options, i2), this._refreshCameraOptions(false), this.refreshCameraControls(false), t2 && this.setDirty();
    }
    _refreshCameraOptions(e2 = true) {
      let t2 = this._camera.modelObject;
      if (this._options.type !== t2.type) {
        const e3 = "PerspectiveCamera" === this._options.type ? new n.cPb() : new n.iKG();
        e3.name = this._camera.name, e3.near = this._camera.modelObject.near, e3.far = this._camera.modelObject.far, e3.zoom = this._camera.modelObject.zoom, e3.scale.copy(this._camera.modelObject.scale);
        const r3 = this._isActiveCamera;
        r3 && this.deactivateMain(), this._camera = this._setCameraObject(e3), t2 = this._camera.modelObject, r3 && this.activateMain(), this._camera.modelObject.updateProjectionMatrix();
      }
      let r2 = this._options.aspect;
      if ("auto" === r2 && (r2 = this._container.clientWidth / this._container.clientHeight), this._options.position && (this.position.set(...this._options.position), delete this._options.position), this._options.target && (this.target.set(...this._options.target), delete this._options.target), this.positionTargetUpdated(false), "PerspectiveCamera" === this._options.type && (t2.fov = this._options.fov, t2.focus = this._options.focus, t2.aspect = r2), "OrthographicCamera" === this._options.type) {
        const e3 = this._options.frustumSize;
        void 0 !== e3 ? (t2.top = e3 / 2, t2.bottom = -e3 / 2, t2.left = r2 * e3 / 2, t2.right = -r2 * e3 / 2) : (t2.top = this._options.top, t2.bottom = this._options.bottom, t2.left = this._options.left, t2.right = this._options.right);
      }
      t2.zoom = this._options.zoom, this._nearFarChanged(), e2 && this.setDirty();
    }
    _setCameraObject(e2) {
      return this._camera && this._camera.removeEventListener("objectUpdate", this._cameraObjectUpdate), this._camera = Le(e2), this._camera.addEventListener("objectUpdate", this._cameraObjectUpdate), this._camera;
    }
    get interactionsEnabled() {
      return this._interactionsEnabled && this._isActiveCamera && this._options.controlsEnabled;
    }
    set interactionsEnabled(e2) {
      this._interactionsEnabled !== e2 && (this._interactionsEnabled = e2, this.refreshCameraControls(true));
    }
    _nearFarChanged() {
      this._camera && (this._camera.modelObject.near = this.near, this._camera.modelObject.far = this.far, this._camera.modelObject.updateProjectionMatrix());
    }
    refreshAspect(e2 = true) {
      "auto" === this._options.aspect && this._refreshCameraOptions(e2);
    }
    refreshTarget() {
      var e2;
      (null === (e2 = this._controls) || void 0 === e2 ? void 0 : e2.enabled) && this._controls.target ? this._target.copy(this._controls.target) : this._target.set(0, 0, -1).applyQuaternion(this._camera.modelObject.getWorldQuaternion(new n._fP()));
    }
    setControlsCtor(e2, t2, r2 = false) {
      r2 || !this._controlsCtors.has(e2) ? this._controlsCtors.set(e2, t2) : console.error(e2 + " already exists.");
    }
    removeControlsCtor(e2) {
      this._controlsCtors.delete(e2);
    }
    _initCameraControls() {
      var e2, t2, r2;
      const n2 = this._options.controlsMode;
      this._controls = null !== (t2 = null === (e2 = this._controlsCtors.get(n2)) || void 0 === e2 ? void 0 : e2(this._camera.modelObject, this._container)) && void 0 !== t2 ? t2 : void 0, this._controls || console.error("Unable to create controls with mode " + n2 + ". Are you missing a plugin?"), null === (r2 = this._controls) || void 0 === r2 || r2.addEventListener("change", this.setDirty), this._controlsMode = this._controls ? n2 : "";
    }
    _disposeCameraControls() {
      var e2, t2;
      this._controlsMode, null === (e2 = this._controls) || void 0 === e2 || e2.removeEventListener("change", this.setDirty), null === (t2 = this._controls) || void 0 === t2 || t2.dispose(), this._controlsMode = "", this._controls = void 0;
    }
    refreshCameraControls(e2 = true) {
      var t2, r2;
      if (this._options.controlsEnabled) {
        const e3 = this._options.controlsMode;
        this._controls ? this._controlsMode === e3 && this._camera.modelObject === this._controls.object || (this._disposeCameraControls(), this._initCameraControls()) : this._initCameraControls(), this._controlsMode = e3;
      }
      if (this._controls) {
        const e3 = this.interactionsEnabled;
        this._controls.enabled = e3, e3 && this._camera.modelObject.up.copy(n.Tme.DefaultUp);
      }
      e2 && this.setDirty(), null === (r2 = (t2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(t2, "postFrame", true);
    }
    setDirty(e2) {
      this._position.copy(this._camera.modelObject.position), this._controls && this._controls.enabled && this._controls.target && this._target.copy(this._controls.target), void 0 !== this._camera.modelObject.fov && (this._options.fov = this._camera.modelObject.fov), void 0 !== this._camera.modelObject.focus && (this._options.focus = this._camera.modelObject.focus), void 0 !== this._camera.modelObject.zoom && (this._options.zoom = this._camera.modelObject.zoom), this.dispatchEvent({ ...e2, type: "update" }), this._camUi.forEach((e3) => {
        var t2;
        return null === (t2 = null == e3 ? void 0 : e3.uiRefresh) || void 0 === t2 ? void 0 : t2.call(e3, "postFrame", false, 1);
      });
    }
    activateMain(e2 = true) {
      var t2, r2;
      this._isActiveCamera || (this._isActiveCamera = true, this._camera.modelObject.userData.__lastScale = this._camera.modelObject.scale.clone(), this._camera.modelObject.scale.divide(this._camera.modelObject.getWorldScale(new n.Pa4())), e2 && (this.refreshCameraControls(true), this.refreshAspect()), null === (r2 = (t2 = this._camera).setDirty) || void 0 === r2 || r2.call(t2, { change: "activateMain" }));
    }
    deactivateMain(e2 = true) {
      this._isActiveCamera && (this._isActiveCamera = false, this._camera.modelObject.userData.__lastScale && (this._camera.modelObject.scale.copy(this._camera.modelObject.userData.__lastScale), delete this._camera.modelObject.userData.__lastScale), e2 && this.refreshCameraControls(true));
    }
    get cameraObject() {
      return this._camera.modelObject;
    }
    get modelObject() {
      return this._camera.modelObject;
    }
    dispose() {
      this._disposeCameraControls();
    }
    targetUpdated(e2 = true) {
      var t2, r2;
      const n2 = this.target;
      null === (r2 = null === (t2 = this._controls) || void 0 === t2 ? void 0 : t2.target) || void 0 === r2 || r2.set(n2.x, n2.y, n2.z), this._controls && this._controls.enabled && this._controls.target ? e2 && this.setDirty() : this._camera && (this.autoLookAtTarget && this._camera.modelObject.lookAt(n2), e2 && this.setDirty());
    }
    positionUpdated(e2 = true) {
      const t2 = this.position;
      this._camera.modelObject.position.set(t2.x, t2.y, t2.z), e2 && this.setDirty();
    }
    positionTargetUpdated(e2 = true) {
      this.positionUpdated(false), this.targetUpdated(e2);
    }
    copyFromCamera(e2, t2 = 4) {
      e2.getWorldPosition(this._position), e2.getWorldDirection(this._target).multiplyScalar(t2).add(this._position), this.positionTargetUpdated(false), this.setCameraOptions({ fov: e2.fov, focus: e2.focus, zoom: e2.zoom, type: e2.type }, true);
    }
    updateShaderProperties(e2) {
      var t2;
      return (null === (t2 = e2.uniforms.cameraPositionWorld) || void 0 === t2 ? void 0 : t2.value) && this._camera.modelObject.getWorldPosition(e2.uniforms.cameraPositionWorld.value), e2.uniforms.cameraNearFar ? e2.uniforms.cameraNearFar.value.set(this._camera.modelObject.near, this._camera.modelObject.far) : console.warn("BaseRenderer: no uniform: cameraNearFar"), e2.uniforms.projection && (e2.uniforms.projection.value = this._camera.modelObject.projectionMatrix), e2.defines.PERSPECTIVE_CAMERA = "PerspectiveCamera" === this._camera.modelObject.type ? "1" : "0", e2.defines.ORTHOGRAPHIC_CAMERA = "OrthographicCamera" === this._camera.modelObject.type ? "1" : "0", this;
    }
    toJSON(e2) {
      return Object.assign({}, ke(this, true, e2));
    }
    fromJSON(e2, t2) {
      return De(e2, this, true, t2), this.positionTargetUpdated(false), this.refreshCameraOptions(), this.setDirty(), this;
    }
    refreshCameraOptions(e2 = true) {
      this.setCameraOptions(this._options, e2);
    }
    get visible() {
      return true;
    }
    set visible(e2) {
      console.error("Cannot set visible on camera", e2);
    }
  }
  mt([Ce("camControls")], _t.prototype, "_controls", void 0), mt([Ce()], _t.prototype, "userData", void 0), mt([M(_t.prototype._nearFarChanged)], _t.prototype, "near", void 0), mt([M(_t.prototype._nearFarChanged)], _t.prototype, "far", void 0), mt([Ce("camOptions")], _t.prototype, "_options", void 0), mt([Ce("position")], _t.prototype, "_position", void 0), mt([Ce("target")], _t.prototype, "_target", void 0);
  var gt = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class vt extends n.xsS {
    constructor(e2) {
      super(), this.isRootScene = true, this.assetType = "model", this._sceneBounds = new k(), this._sceneBoundingRadius = 0, this._cameras = [], this._activeCamera = -1, this.envMapIntensity = 1, this._dummyCam = new _t(new n.cPb(), { controlsMode: "", controlsEnabled: false }), this.environment = null, this.background = null, this.minNearDistance = 0.2, this.setDirty = this.setDirty.bind(this), this.updateScene = this.updateScene.bind(this), this.refreshActiveCameraNearFar = this.refreshActiveCameraNearFar.bind(this), this._activeCameraUpdate = this._activeCameraUpdate.bind(this), this._onSceneMaterialUpdate = this._onSceneMaterialUpdate.bind(this), this._onSceneUpdate = this._onSceneUpdate.bind(this), this.addEventListener("materialUpdate", this._onSceneMaterialUpdate), this.addEventListener("objectUpdate", this._onSceneUpdate), this.defaultCamera = e2, this.modelRoot = Le(new n.ZAu(), void 0), this.modelRoot.userData.rootSceneModelRoot = true, this.modelRoot.name = "Scene", this.modelRoot.addEventListener("update", this.setDirty), this.addSceneObject(this.modelRoot, { addToRoot: true, autoScale: false }), this.addSceneObject(this.defaultCamera, { addToRoot: true }), this.activeCamera = this.defaultCamera, this.boxHelper = new n.GQ(this.getBounds());
    }
    refreshEnvMapIntensity(e2) {
      return (null == e2 ? void 0 : e2.isObject3D) || (e2 = this), (null != e2 ? e2 : this).traverse((e3) => {
        (Array.isArray(e3.material) ? e3.material : [e3.material]).forEach((e4) => {
          e4 && void 0 !== e4.envMapIntensity && !e4.userData.separateEnvMapIntensity && (e4.envMapIntensity = this.envMapIntensity, e4.needsUpdate = true);
        });
      }), this.setDirty(), this;
    }
    get activeCamera() {
      return this._activeCamera >= 0 ? this._cameras[this._activeCamera] : this._dummyCam;
    }
    set activeCamera(e2) {
      const t2 = this.activeCamera;
      if (e2 || (e2 = this.defaultCamera), t2 !== e2) {
        if (t2 && (t2.deactivateMain(), t2.removeEventListener("update", this._activeCameraUpdate)), e2) {
          e2.activateMain(), e2.addEventListener("update", this._activeCameraUpdate);
          let t3 = this._cameras.indexOf(e2);
          t3 < 0 && (this._cameras.push(e2), t3 = this._cameras.length - 1), this._activeCamera = t3;
        } else
          this._activeCamera = -1;
        this.dispatchEvent({ type: "activeCameraChange", lastCamera: t2, camera: e2 }), this.setDirty();
      }
    }
    get modelObject() {
      return this;
    }
    addModel(e2, t2 = {}) {
      return "model" !== e2.assetType && console.error("Invalid asset type for ", e2, ", adding anyway"), this.addSceneObject(e2, t2);
    }
    addWidget(e2, t2 = {}) {
      "widget" !== e2.assetType && console.warn("Invalid asset type for ", e2, ", adding anyway"), this.add(e2.modelObject);
    }
    _addModel(e2, t2 = {}) {
      return this._addObject3D(null == e2 ? void 0 : e2.modelObject, t2);
    }
    addSceneObject(e2, t2) {
      if (!e2)
        return e2;
      const r2 = e2.assetType;
      let n2 = false;
      switch (r2) {
        case "model":
          n2 = e2.modelObject.isCamera, n2 && (t2 = { ...t2, autoScale: false }), this._addModel(e2, t2);
          break;
        case "material":
          break;
        case "texture":
          this.dispatchEvent({ type: "textureAdded", texture: e2 });
          break;
        case "light":
          this._addLight(e2, t2);
          break;
        default:
          console.warn("Unknown asset imported", e2, r2);
      }
      return this.dispatchEvent({ type: "addSceneObject", object: e2 }), e2;
    }
    _addObject3D(e2, { autoScale: t2 = true, autoScaleRadius: r2 = 2, addToRoot: n2 = false } = {}) {
      const i2 = e2;
      i2 ? (t2 && !i2.userData.autoScaled && X(i2, i2.userData.autoScaleRadius || r2), i2.traverse((e3) => {
        e3.isMesh && !e3.userData.__keepShadowDef && (e3.castShadow = true, e3.receiveShadow = true, e3.userData.__keepShadowDef = true);
      }), this.refreshEnvMapIntensity(i2), n2 ? this.modelObject.add(i2) : this.modelRoot.add(i2), this.setDirty()) : console.error("Invalid Model, cannot add.");
    }
    removeSceneModels() {
      this.modelRoot.clear(), this.modelRoot.children = [], this.setDirty({ sceneUpdate: true });
    }
    disposeSceneModels() {
      this.modelRoot.children.forEach((e2) => {
        var t2, r2;
        (null !== (t2 = e2.dispose) && void 0 !== t2 ? t2 : null === (r2 = e2.modelObject) || void 0 === r2 ? void 0 : r2.removeFromParent)();
      }), this.setDirty({ sceneUpdate: true });
    }
    _onEnvironmentChange() {
      this.dispatchEvent({ type: "environmentChanged", environment: this.getEnvironment() }), this._onSceneUpdate();
    }
    add(...e2) {
      return super.add(...e2.map((e3) => Le(e3))), this._onSceneUpdate(), this;
    }
    setEnvironment(e2) {
      if (!e2)
        return this.environment = null, this.dispatchEvent({ type: "environmentChanged" }), void this._onSceneUpdate();
      if ("texture" !== (null == e2 ? void 0 : e2.assetType))
        return void console.error("Unknown Environment type", e2);
      e2.mapping === n.xfE && (e2.mapping = n.dSO, e2.needsUpdate = true);
      const t2 = e2.textureObject || e2;
      this.environment = t2, this._onEnvironmentChange();
    }
    getEnvironment() {
      return this.environment;
    }
    setBackground(e2) {
      var t2;
      let r2;
      if (!e2 || "texture" === e2.assetType || e2.isColor || e2.isVector4)
        r2 = "texture" === (null === (t2 = e2) || void 0 === t2 ? void 0 : t2.assetType) && e2.textureObject || e2;
      else {
        if ("string" != typeof e2 && "number" != typeof e2)
          return void console.error("Unknown Background type", e2);
        r2 = new n.Ilk(e2);
      }
      this.background = r2, this._onSceneUpdate({ geometryChanged: false });
    }
    getBackground() {
      return this.background;
    }
    setDirty(e2) {
      return (null == e2 ? void 0 : e2.sceneUpdate) ? this._onSceneUpdate(e2) : this.dispatchEvent({ type: "update" }), this;
    }
    updateScene(e2) {
      return this._onSceneUpdate(e2);
    }
    _activeCameraUpdate() {
      this.setDirty(), this.refreshActiveCameraNearFar(), this.dispatchEvent({ type: "activeCameraUpdate" });
    }
    _onSceneUpdate(e2 = {}) {
      var t2, r2, i2;
      return false === e2.sceneUpdate ? this.setDirty(e2) : (this.refreshActiveCameraNearFar(), this._sceneBounds = this.getBounds(false, true), null === (i2 = null === (r2 = null === (t2 = this.boxHelper) || void 0 === t2 ? void 0 : t2.box) || void 0 === r2 ? void 0 : r2.copy) || void 0 === i2 || i2.call(r2, this._sceneBounds), this._sceneBoundingRadius = this._sceneBounds.getSize(new n.Pa4()).length() / 2, this.dispatchEvent({ ...e2, type: "sceneUpdate", hierarchyChanged: ["addedToParent", "removedFromParent"].includes(e2.change || "") }), this);
    }
    _onSceneMaterialUpdate() {
      this.dispatchEvent({ type: "sceneMaterialUpdate" });
    }
    dispose() {
      this.clear();
    }
    findObjectsByName(e2, t2) {
      const r2 = [];
      return (null != t2 ? t2 : this.modelObject).traverse((t3) => {
        t3.name === e2 && r2.push(t3);
      }), r2;
    }
    addLight(e2, t2 = {}) {
      this.addSceneObject(e2, t2);
    }
    _addLight(e2, { addToRoot: t2 = false } = {}) {
      var r2;
      const n2 = e2.lightObject;
      n2 && (null === (r2 = n2.children) || void 0 === r2 || r2.length, t2 ? this.add(n2) : this.modelRoot.add(n2));
    }
    getBounds(e2 = false, t2 = true) {
      return new k().expandByObject(this.modelObject, e2, t2);
    }
    refreshActiveCameraNearFar() {
      const e2 = this.activeCamera;
      if (!e2)
        return;
      const t2 = this.getBounds(false), r2 = e2.cameraObject.getWorldPosition(new n.Pa4()).sub(t2.getCenter(new n.Pa4())), i2 = 1.5 * t2.getSize(new n.Pa4()).length() / 2, s2 = r2.length(), o2 = Math.max(this.minNearDistance, s2 - i2), a2 = Math.max(o2 + 1, s2 + i2);
      e2.near = o2, e2.far = a2;
    }
    updateShaderProperties(e2) {
      return e2.uniforms.sceneBoundingRadius ? e2.uniforms.sceneBoundingRadius.value = this._sceneBoundingRadius : console.warn("BaseRenderer: no uniform: frameCount"), this;
    }
    toJSON(e2) {
      return ke(this, true, e2);
    }
    fromJSON(e2, t2) {
      const r2 = e2.environment;
      return void 0 !== r2 && (this.setEnvironment(De(r2, this.getEnvironment(), false, t2)), delete e2.environment), De(e2, this, true, t2), e2.environment = r2, this;
    }
    addEventListener(e2, t2) {
      super.addEventListener(e2, t2);
    }
    removeEventListener(e2, t2) {
      super.removeEventListener(e2, t2);
    }
  }
  function At() {
    const e2 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    return e2.style.display = "block", e2;
  }
  function bt(e2, t2) {
    const r2 = t2 || "/";
    return new RegExp(r2 + "{1,}", "g"), e2.join(r2);
  }
  function yt(e2, t2) {
    const r2 = window.URL.createObjectURL(e2), n2 = document.createElement("a");
    n2.style.display = "none", n2.href = r2, n2.download = t2, document.body.appendChild(n2), n2.click(), setTimeout(() => {
      document.body.removeChild(n2), window.URL.revokeObjectURL(r2);
    }, 1e3);
  }
  async function xt(e2) {
    return new Promise((t2, r2) => {
      const n2 = new FileReader();
      n2.onload = (e3) => t2(n2.result), n2.onerror = (e3) => r2(n2.error), n2.onabort = (e3) => r2(new Error("Read aborted")), n2.readAsDataURL(e2);
    });
  }
  function wt(e2, t2) {
    return yt(e2, null != t2 ? t2 : e2.name);
  }
  async function Et(e2 = false, t2 = false, r2) {
    const n2 = document.createElement("input");
    n2.type = "file", n2.multiple = e2, n2.accept = r2 || "*", n2.webkitdirectory = t2, n2.style.display = "none", document.body.appendChild(n2), n2.click();
    const i2 = await new Promise((e3) => {
      n2.onchange = (t3) => {
        e3(Array.from(n2.files || []));
      };
    });
    return document.body.removeChild(n2), i2;
  }
  function St({ innerHTML: e2 = "", id: t2, classList: r2, addToBody: n2 = true, elementTag: i2 = "div" }) {
    const s2 = document.createElement(i2);
    return t2 && (s2.id = t2), s2.innerHTML = e2, r2 && s2.classList.add(...r2), n2 && document.body.appendChild(s2), s2;
  }
  async function Ct(e2) {
    return new Promise((t2, r2) => {
      const n2 = new Image();
      n2.onload = () => t2(n2), n2.onerror = r2, n2.crossOrigin = "anonymous", n2.decoding = "sync", n2.src = e2;
    });
  }
  function Mt(e2) {
    const t2 = document.createElement("style");
    return t2.type = "text/css", t2.innerText = e2, document.head.appendChild(t2), t2;
  }
  async function Tt(e2) {
    return new Promise((t2, r2) => {
      const n2 = document.createElement("script");
      n2.setAttribute("src", e2), n2.addEventListener("load", t2), n2.addEventListener("error", r2), document.body.appendChild(n2);
    });
  }
  function It(e2, t2 = 8192, r2 = false) {
    var n2;
    if (!e2.width || !e2.height)
      return "";
    const i2 = document.createElement("canvas");
    i2.width = Math.min(t2, e2.width), i2.height = Math.floor(1 + i2.width * e2.height / e2.width);
    const s2 = e2 instanceof ImageBitmap, o2 = s2 && r2 && Math.abs(i2.width - e2.width) < 0.5 ? i2.getContext("bitmaprenderer") : void 0;
    o2 ? o2.transferFromImageBitmap(e2) : null === (n2 = i2.getContext("2d")) || void 0 === n2 || n2.drawImage(e2, 0, 0, i2.width, i2.height);
    const a2 = i2.toDataURL("image/png");
    return i2.remove(), s2 && r2 && e2.close(), a2;
  }
  async function kt(e2) {
    return new Promise((t2, r2) => {
      const n2 = new Image();
      n2.addEventListener("load", () => {
        const e3 = document.createElement("canvas");
        e3.width = n2.width, e3.height = n2.height;
        const i2 = e3.getContext("2d");
        if (!i2)
          return void r2(new Error("Could not get 2d context"));
        i2.drawImage(n2, 0, 0, e3.width, e3.height);
        const s2 = i2.getImageData(0, 0, e3.width, e3.height);
        t2(s2), e3.remove(), n2.remove();
      }, false), n2.addEventListener("error", (e3) => {
        n2.remove(), r2(e3);
      }, false), n2.src = e2;
    });
  }
  function Dt() {
    return ("undefined" == typeof performance ? Date : performance).now();
  }
  function Pt() {
    let e2 = false;
    return t2 = navigator.userAgent || navigator.vendor || window.opera, (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t2) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t2.substr(0, 4))) && (e2 = true), e2;
    var t2;
  }
  function Bt(e2, t2 = null) {
    var r2;
    return null !== (r2 = new URL(window.location.href).searchParams.get(e2)) && void 0 !== r2 ? r2 : t2;
  }
  function Rt(e2, t2, r2 = false) {
    const n2 = new URLSearchParams(location.search);
    null == t2 ? n2.has(e2) && n2.delete(e2) : n2.set(e2, t2), r2 ? window.location.search = n2.toString() : window.history.replaceState({}, "", "?" + n2.toString());
  }
  function Lt(e2) {
    return e2.replace(/\w\S*/g, function(e3) {
      return e3.charAt(0).toUpperCase() + e3.substr(1).toLowerCase();
    });
  }
  function Ot(e2, { backgroundColor: t2 = "", displayPixelRatio: r2 = 1, width: n2 = 512, height: i2 = 512 }) {
    const s2 = document.createElement("canvas"), o2 = s2.getContext("2d"), a2 = r2, l2 = n2, c2 = i2;
    return s2.width = l2 * a2, s2.height = c2 * a2, s2.style.width = `${l2}`, s2.style.height = `${c2}`, (null == t2 ? void 0 : t2.length) > 0 && (o2.fillStyle = t2, o2.fillRect(0, 0, s2.width, s2.height)), o2.drawImage(e2, 0, 0, s2.width, s2.height), s2;
  }
  gt([Ce()], vt.prototype, "defaultCamera", void 0), gt([M(vt.prototype.refreshEnvMapIntensity), Ce()], vt.prototype, "envMapIntensity", void 0), gt([Ce()], vt.prototype, "environment", void 0), ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = function(e2, t2) {
    const r2 = new Uint8Array(this);
    null == t2 && (t2 = r2.length);
    const n2 = new ArrayBuffer(t2 - e2), i2 = new Uint8Array(n2);
    for (let t3 = 0; t3 < i2.length; t3++)
      i2[t3] = r2[t3 + e2];
    return n2;
  });
  class Ft {
    static ApplyMaterialExtensions(e2, t2, r2, n2) {
      for (const i2 of r2)
        this.ApplyMaterialExtension(e2, t2, i2, n2);
    }
    static ApplyMaterialExtension(e2, t2, r2, n2) {
      var i2, s2;
      let o2 = null !== (i2 = A(r2.parsFragmentSnippet, n2, e2)) && void 0 !== i2 ? i2 : "";
      o2.length && (t2.fragmentShader = t2.fragmentShader.replace(this.FragVoidMain, `
${o2}
${this.FragVoidMain}`)), o2 = null !== (s2 = A(r2.parsVertexSnippet, n2, e2)) && void 0 !== s2 ? s2 : "", o2.length && (t2.vertexShader = t2.vertexShader.replace(this.VertVoidMain, `
${o2}
${this.VertVoidMain}`)), r2.extraUniforms && (t2.uniforms = Object.assign(t2.uniforms, r2.extraUniforms)), r2.shaderExtender && r2.shaderExtender(t2, e2, n2), e2.lastShader = t2;
    }
    static CacheKeyForExtensions(e2, t2) {
      let r2 = "";
      for (const n2 of t2)
        r2 += this.CacheKeyForExtension(e2, n2);
      return r2;
    }
    static CacheKeyForExtension(e2, t2) {
      let r2 = "";
      return t2.customCacheKey && (r2 += t2.customCacheKey), t2.computeCacheKey && (r2 += t2.computeCacheKey(e2)), r2;
    }
    static RegisterExtensions(e2, t2) {
      const r2 = [];
      if (t2)
        for (const n2 of t2)
          n2.isCompatible && n2.isCompatible(e2) && (r2.push(n2), n2.uuid || (n2.uuid = Xe()), n2.setDirty || (n2.setDirty = () => {
            n2.updateVersion || (n2.updateVersion = 0), n2.updateVersion++;
          }));
      return e2.materialExtensions = r2, e2.__ext_beforeRenderListen || (e2.__ext_beforeRenderListen = true, e2.addEventListener("beforeRender", (t3) => function(e3, { object: t4, renderer: r3 }) {
        var n2;
        null === (n2 = e3.materialExtensions) || void 0 === n2 || n2.forEach((n3) => {
          var i2, s2;
          null === (i2 = n3.onObjectRender) || void 0 === i2 || i2.call(n3, t4, e3, r3), e3.lastShader && (null === (s2 = A(n3.updaters)) || void 0 === s2 || s2.forEach((t5) => null == t5 ? void 0 : t5.updateShaderProperties(e3.lastShader))), n3.updateVersion !== e3.materialObject.userData["_" + n3.uuid + "_version"] && (e3.materialObject.userData["_" + n3.uuid + "_version"] = n3.updateVersion, e3.materialObject.needsUpdate = true);
        });
      }(e2, t3))), e2.__ext_afterRenderListen || (e2.__ext_afterRenderListen = true, e2.addEventListener("afterRender", (t3) => function(e3, { object: t4, renderer: r3 }) {
        var n2;
        null === (n2 = e3.materialExtensions) || void 0 === n2 || n2.forEach((n3) => {
          var i2;
          null === (i2 = n3.onAfterRender) || void 0 === i2 || i2.call(n3, t4, e3, r3);
        });
      }(e2, t3))), r2;
    }
  }
  Ft.FragVoidMain = "void main() {", Ft.VertVoidMain = "void main() {";
  class Ut extends n.jyz {
    constructor(e2) {
      var t2;
      super(e2), this.typeSlug = "shaderMat", this.assetType = "material", this.materialObject = this, this.materialExtensions = [], this.extraUniformsToUpload = {}, this.materialExtensions = Ft.RegisterExtensions(this, null !== (t2 = null == e2 ? void 0 : e2.customMaterialExtensions) && void 0 !== t2 ? t2 : []);
    }
    registerMaterialExtensions(e2) {
      this.materialExtensions = [...this.materialExtensions, ...Ft.RegisterExtensions(this, e2)];
    }
    unregisterMaterialExtensions(e2) {
    }
    onBeforeCompile(e2, t2) {
      Ft.ApplyMaterialExtensions(this, e2, this.materialExtensions, t2), e2.fragmentShader = e2.fragmentShader.replaceAll("#glMarker", "// "), this.dispatchEvent({ type: "beforeCompile", shader: e2, renderer: t2 }), super.onBeforeCompile(e2, t2);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey() + Ft.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap;
    }
    onBeforeRender(e2, t2, r2, n2, i2) {
      super.onBeforeRender(e2, t2, r2, n2, i2), this.dispatchEvent({ type: "beforeRender", renderer: e2, scene: t2, camera: r2, geometry: n2, object: i2 });
    }
    onAfterRender(e2, t2, r2, n2, i2) {
      super.onAfterRender(e2, t2, r2, n2, i2), this.dispatchEvent({ type: "afterRender", renderer: e2, scene: t2, camera: r2, geometry: n2, object: i2 });
    }
    toJSON(e2) {
      throw new Error("Method not supported for this material.");
    }
    fromJSON(e2, t2) {
      throw new Error("Method not supported for this material.");
    }
    copyProps(e2) {
      throw new Error("Method not supported for this material.");
    }
    setDirty(e2) {
    }
  }
  class Nt extends Ut {
    constructor(e2, t2) {
      super(e2), this.typeSlug = "shaderMat", this.textures = [], this.setTextureIds(t2);
    }
    setTextureIds(e2) {
      this.textures.map((e3) => e3.id).join(";") !== e2.join(";") && (this.textures = e2.map((e3) => ({ id: e3, encoding: n.rnI })), this.setDirty());
    }
    _setUniformTexSize(e2, t2) {
      var r2, n2, i2, s2;
      if (!t2 || !e2)
        return;
      const o2 = null !== (n2 = null === (r2 = t2.image) || void 0 === r2 ? void 0 : r2.width) && void 0 !== n2 ? n2 : 512, a2 = null !== (s2 = null === (i2 = t2.image) || void 0 === i2 ? void 0 : i2.height) && void 0 !== s2 ? s2 : 512, l2 = e2.value;
      l2.isVector2 || console.warn("uniform is not a Vector2"), l2 && Math.abs(l2.x - o2) + Math.abs(l2.y - a2) > 0.1 && (l2.x = o2, l2.y = a2, this.uniformsNeedUpdate = true);
    }
    onBeforeRender(e2, t2, r2, n2, i2) {
      var s2, o2;
      this._setUniformTexSize(this.uniforms.screenSize, null === (s2 = e2.getRenderTarget()) || void 0 === s2 ? void 0 : s2.texture);
      for (const e3 of this.textures) {
        const t3 = e3.id, r3 = null === (o2 = this.uniforms[t3]) || void 0 === o2 ? void 0 : o2.value;
        r3 && (this._setUniformTexSize(this.uniforms[t3 + "Size"], r3), r3.encoding !== e3.encoding && (e3.encoding = r3.encoding, this.needsUpdate = true));
      }
      super.onBeforeRender(e2, t2, r2, n2, i2);
    }
    onBeforeCompile(e2, t2) {
      e2.fragmentShader = this.textures.map((e3) => {
        var t3, r2;
        return `uniform sampler2D ${e3.id}; 
` + N(null !== (t3 = e3.id) && void 0 !== t3 ? t3 : "input", null !== (r2 = e3.encoding) && void 0 !== r2 ? r2 : n.rnI);
      }).join("\n") + e2.fragmentShader, super.onBeforeCompile(e2, t2);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey() + this.textures.map((e2) => e2.id + e2.encoding).join(";");
    }
    toJSON(e2) {
      throw new Error("Method not supported for this material.");
    }
    fromJSON(e2, t2) {
      throw new Error("Method not supported for this material.");
    }
    copyProps(e2) {
      throw new Error("Method not supported for this material.");
    }
    setDirty(e2) {
      this.needsUpdate = true, this.dispatchEvent({ ...e2, type: "materialUpdate" });
    }
  }
  function jt(e2, ...t2) {
    const r2 = e2.fragmentShader;
    return new Nt({ defines: Object.assign({}, e2.defines), uniforms: e2.uniforms, vertexShader: e2.vertexShader, fragmentShader: r2 }, t2);
  }
  class zt extends c {
    constructor(e2, ...t2) {
      super(e2.isMaterial ? e2 : jt(e2, ...t2), t2.length < 1 ? zt.DEFAULT_TEX_ID : t2[0]), this.onDirty = [], this.isShaderPass2 = true, this.enabled = true, this.setDirty = this.setDirty.bind(this);
    }
    dispose() {
      var e2, t2, r2, n2;
      null === (t2 = null === (e2 = this.material) || void 0 === e2 ? void 0 : e2.dispose) || void 0 === t2 || t2.call(e2), null === (n2 = null === (r2 = this.fsQuad) || void 0 === r2 ? void 0 : r2.dispose) || void 0 === n2 || n2.call(r2), this.onDirty = [];
    }
    setDirty() {
      this.onDirty.forEach((e2) => e2());
    }
    updateShaderProperties(e2) {
      e2 && (Array.isArray(e2) || (e2 = [e2]), e2.forEach((e3) => null == e3 ? void 0 : e3.updateShaderProperties(this.material)));
    }
    render(e2, t2, r2, n2, i2) {
      this.enabled && super.render(e2, t2, r2, n2, i2);
    }
  }
  zt.DEFAULT_TEX_ID = "tDiffuse", function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, r2, o2);
  }([Je("Enabled"), Ce()], zt.prototype, "enabled", void 0);
  class Gt extends s {
    constructor(e2, t2, r2, i2, s2) {
      super(), this.scene = e2, this.camera = t2, this.overrideMaterial = r2, this.clearColor = i2, this.clearAlpha = void 0 !== s2 ? s2 : 0, this.clear = true, this.clearDepth = false, this.needsSwap = false, this._oldClearColor = new n.Ilk();
    }
    render(e2, t2, r2, n2, i2, s2) {
      const o2 = e2.autoClear;
      let a2, l2;
      if (e2.autoClear = false, void 0 !== this.overrideMaterial && (l2 = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e2.getClearColor(this._oldClearColor), a2 = e2.getClearAlpha(), e2.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e2.clearDepth(), e2.setRenderTarget(this.renderToScreen ? null : r2), s2) {
        const t3 = e2.getContext();
        t3.framebufferRenderbuffer(t3.FRAMEBUFFER, t3.DEPTH_ATTACHMENT, t3.RENDERBUFFER, s2);
      }
      if (this.clear && e2.clear(e2.autoClearColor, e2.autoClearDepth, e2.autoClearStencil), e2.render(this.scene, this.camera), s2) {
        const t3 = e2.getContext();
        t3.framebufferRenderbuffer(t3.FRAMEBUFFER, t3.DEPTH_ATTACHMENT, t3.RENDERBUFFER, null);
      }
      this.clearColor && e2.setClearColor(this._oldClearColor, a2), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = l2), e2.autoClear = o2;
    }
  }
  class Vt extends zt {
    constructor(e2, t2 = "c = a + b;", r2 = "", n2) {
      super({ vertexShader: i.vertexShader, fragmentShader: w`
                varying vec2 vUv;
                
                ${r2}
                
                void blend(in vec4 a, in vec4 b, inout vec4 c){
                
                ${t2}
                
                }
                void main() {
                    vec4 texel = vec4(0);
                    blend(tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ), tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), texel);
                    texel = clamp(texel, vec4(0), vec4(8));
                    gl_FragColor = texel;
                    #include <encodings_fragment>
                }
            `, uniforms: { tDiffuse: { value: null }, tDiffuse2: { value: n2 }, ...e2 } }, "tDiffuse", "tDiffuse2"), this.clear = false, this.needsSwap = true;
    }
  }
  class Qt extends n.jyz {
    constructor(e2 = true) {
      super({ vertexShader: "#ifdef USE_ALPHAMAP\n#define USE_UV \n#endif\n#include <uv_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nout vec3 vViewPosition;void main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;}", fragmentShader: "#ifdef USE_ALPHAMAP\n#define USE_UV \n#include <packing>\nuniform float alphaTest;\n#endif\n#ifndef gl_FragColor \nlayout(location=0)out vec4 A;layout(location=1)out vec4 B;\n#endif\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <alphamap_pars_fragment>\nuniform vec2 cameraNearFar;uniform vec4 flags;in vec3 vViewPosition;vec2 pack16(float value){float sMax=65535.;int v=int(clamp(value,0.,1.)*sMax+0.5);int digit0=v/256;int digit1=v-digit0*256;return vec2(float(digit0)/255.,float(digit1)/255.);}vec2 packNormal(vec3 n){float p=sqrt(n.z*8.+8.);return vec2(n.xy/p+0.5);}float linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}void main(){\n#ifdef USE_ALPHAMAP\n#ifdef ALPHA_I_RGBA_PACKING\nif(1.-unpackRGBAToDepth(texture2D(alphaMap,vUv))<alphaTest)\n#else\nif(texture2D(alphaMap,vUv).g<alphaTest)\n#endif\ndiscard;\n#endif\n#include <normal_fragment_begin>\n#ifdef FORCED_LINEAR_DEPTH\nfloat linearZ=float(FORCED_LINEAR_DEPTH);\n#else\nfloat linearZ=linstep(-cameraNearFar.x,-cameraNearFar.y,-vViewPosition.z);\n#endif\nvec2 packedZ=pack16(pow(linearZ,0.5));vec2 packedNormal=packNormal(normal);\n#ifndef gl_FragColor \nA=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);B=flags;\n#else\ngl_FragColor=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);\n#endif\n}", uniforms: { cameraNearFar: { value: new n.FM8(0.1, 1e3) }, alphaMap: { value: null }, alphaTest: { value: null }, flags: { value: new n.Ltg(1, 1, 1, 1) } }, glslVersion: e2 ? n.LSk : n.v9Y });
    }
    onBeforeRender(e2, t2, r2, i2, s2) {
      var o2, a2, l2;
      let c2 = s2.material;
      Array.isArray(c2) && (c2 = c2[0]), this.uniforms.alphaMap.value = null !== (o2 = null == c2 ? void 0 : c2.alphaMap) && void 0 !== o2 ? o2 : null, this.uniforms.alphaTest.value = !c2 || !c2.alphaTest || c2.alphaTest < 1e-7 ? 1e-3 : c2.alphaTest, this.uniforms.flags.value.x = false === (null == c2 ? void 0 : c2.userData.postTonemap) ? 0 : 1, this.uniforms.flags.value.y = (null == c2 ? void 0 : c2.userData._ssBevel) ? (null == c2 ? void 0 : c2.userData._ssBevel.radius) / 255 : 0, this.uniforms.flags.value.z = ((null == c2 ? void 0 : c2.userData.matId) ? null == c2 ? void 0 : c2.userData.matId : 0) / 255, this.uniforms.flags.value.w = (null == c2 ? void 0 : c2.userData.enableLUT) ? null == c2 ? void 0 : c2.userData.enableLUT : 0, this.uniformsNeedUpdate = true;
      let u2 = this.uniforms.alphaMap.value ? 1 : void 0;
      u2 !== this.defines.USE_ALPHAMAP && (void 0 === u2 ? delete this.defines.USE_ALPHAMAP : this.defines.USE_ALPHAMAP = u2, this.needsUpdate = true), u2 = c2.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0, u2 !== this.defines.ALPHA_I_RGBA_PACKING && (void 0 === u2 ? delete this.defines.ALPHA_I_RGBA_PACKING : this.defines.ALPHA_I_RGBA_PACKING = u2, this.needsUpdate = true), u2 = null !== (a2 = c2.userData.forcedLinearDepth) && void 0 !== a2 ? a2 : void 0, u2 !== this.defines.FORCED_LINEAR_DEPTH && (void 0 === u2 ? delete this.defines.FORCED_LINEAR_DEPTH : this.defines.FORCED_LINEAR_DEPTH = u2, this.needsUpdate = true), this.side = null !== (l2 = c2.side) && void 0 !== l2 ? l2 : n.ehD;
    }
  }
  var Ht = "#ifndef UNPACK_GBUFFER_SNIPPET\n#define UNPACK_GBUFFER_SNIPPET \nuniform sampler2D tNormalDepth;float unpack16(vec2 value){return(value.x*0.996108949416342426275150501169264316558837890625+value.y*0.00389105058365758760263730664519243873655796051025390625);}vec3 unpackNormal(vec2 enc){vec2 fenc=enc*4.-2.;float f=dot(fenc,fenc);float g=sqrt(1.-f/4.);return vec3(fenc*g,1.-f/2.);}float unpackDepth(vec2 uncodedDepth){float x=unpack16(uncodedDepth.xy);return x*x;}float getDepth(vec2 uv){vec4 uncodedDepth=texture2D(tNormalDepth,uv);return unpackDepth(uncodedDepth.xy);}void getDepthNormal(const in vec2 uv,out float depth,out vec3 normal){vec4 uncodedDepth=texture2D(tNormalDepth,uv);depth=unpackDepth(uncodedDepth.xy);normal=unpackNormal(uncodedDepth.zw);}vec3 getViewNormal(const in vec2 uv){return unpackNormal(texture2D(tNormalDepth,uv).zw);}\n#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1\nuniform sampler2D tGBufferFlags;\n#endif\nvec4 getGBufferFlags(const in vec2 uv){\n#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1\nreturn texture2D(tGBufferFlags,uv);\n#else\nreturn vec4(1.);\n#endif\n}\n#endif\n";
  const Wt = { name: "", fog: true, blending: n.bdR, side: n.Wl3, vertexColors: false, opacity: 1, transparent: false, blendSrc: n.k74, blendDst: n.LgZ, blendEquation: n.bGH, blendSrcAlpha: null, blendDstAlpha: null, blendEquationAlpha: null, depthFunc: n.vCF, depthTest: true, depthWrite: true, stencilWriteMask: 255, stencilFunc: n.cum, stencilRef: 0, stencilFuncMask: 255, stencilFail: n.x5V, stencilZFail: n.x5V, stencilZPass: n.x5V, stencilWrite: false, clippingPlanes: null, clipIntersection: false, clipShadows: false, shadowSide: null, colorWrite: true, precision: null, polygonOffset: false, polygonOffsetFactor: 0, polygonOffsetUnits: 0, dithering: false, alphaTest: 0, alphaToCoverage: false, premultipliedAlpha: false, visible: true, toneMapped: true, userData: {}, wireframeLinecap: "round", wireframeLinejoin: "round" };
  function qt(e2, t2, r2, { replaceAll: n2 = false, prepend: i2 = false, append: s2 = false } = {}) {
    if (!e2.includes(t2))
      return console.error(`${t2} not found in shader`), e2;
    let o2 = r2;
    return i2 ? o2 = r2 + t2 : s2 && (o2 = t2 + r2), n2 ? e2.replaceAll(t2, o2) : e2.replace(t2, o2);
  }
  const Xt = { ...Wt, color: "#000000", roughness: 0, metalness: 0, map: null, lightMap: null, lightMapIntensity: 0, aoMap: null, aoMapIntensity: 0, emissive: "#000000", emissiveIntensity: 0, emissiveMap: null, bumpMap: null, bumpScale: 0, normalMap: null, normalMapType: n.IOt, normalScale: new n.FM8(1, 1), displacementMap: null, displacementScale: 0, displacementBias: 0, roughnessMap: null, metalnessMap: null, alphaMap: null, envMap: null, envMapIntensity: 0, refractionRatio: 0, wireframe: false, wireframeLinewidth: 0, skinning: false, morphTargets: false, morphNormals: false, flatShading: false, glossiness: 0, glossinessMap: null, specularColor: new Ae(0), specularColorMap: null }, Yt = { ...Xt, clearcoat: 0, clearcoatMap: null, clearcoatRoughness: 0, clearcoatRoughnessMap: null, clearcoatNormalScale: new n.FM8(1, 1), clearcoatNormalMap: null, reflectivity: 0.5, sheen: 0, sheenColor: new Ae(0), sheenColorMap: null, sheenRoughness: 1, sheenRoughnessMap: null, specularIntensity: 1, specularIntensityMap: null, specularColor: new Ae(1, 1, 1), specularColorMap: null, transmission: 0, transmissionMap: null, thickness: 0, thicknessMap: null, attenuationDistance: 0, attenuationColor: new Ae(1, 1, 1), iridescenceMap: null, iridescenceIOR: 1.3, iridescenceThicknessRange: [100, 400], iridescenceThicknessMap: null };
  class Kt extends n.EJi {
    constructor(e2) {
      var t2;
      super(e2), this.typeSlug = Kt.TypeSlug, this.assetType = "material", this.materialObject = this, this.isMeshStandardMaterial2 = true, this.extraUniformsToUpload = {}, this.setDirty = this.setDirty.bind(this), this.userData.setDirty = (e3) => {
        console.warn("userData.setDirty is deprecated. Use setDirty instead."), this.setDirty(e3);
      }, this.fog = false, this.userData.enableLUT = true, this.materialExtensions = Ft.RegisterExtensions(this, null !== (t2 = null == e2 ? void 0 : e2.customMaterialExtensions) && void 0 !== t2 ? t2 : []);
    }
    setDirty(e2) {
      var t2, r2;
      this.needsUpdate = true, this.dispatchEvent({ ...e2, type: "materialUpdate" }), null === (r2 = null === (t2 = this._uiConfig) || void 0 === t2 ? void 0 : t2.uiRefresh) || void 0 === r2 || r2.call(t2, "postFrame", true, 1);
    }
    registerMaterialExtensions(e2) {
      this.materialExtensions = [...this.materialExtensions, ...Ft.RegisterExtensions(this, e2)];
    }
    unregisterMaterialExtensions(e2) {
    }
    get uiConfig() {
      return this._uiConfigChildren || (this._uiConfigChildren = [{ type: "input", property: [this, "name"] }, { type: "checkbox", property: [this, "wireframe"] }, { type: "color", property: [this, "color"], limitedUi: true }, { type: "image", property: [this, "map"] }, be(this, "map"), { type: "folder", label: "Rough/Metal", limitedUi: true, children: [{ type: "slider", bounds: [0, 1], property: [this, "roughness"], limitedUi: true }, { type: "slider", bounds: [0, 1], property: [this, "metalness"], limitedUi: true }, { type: "image", property: [this, "roughnessMap"] }, be(this, "roughnessMap"), { type: "image", property: [this, "metalnessMap"] }, be(this, "metalnessMap")] }, { type: "folder", label: "Bump/Normal", limitedUi: true, children: [{ type: "slider", bounds: [0, 0.2], stepSize: 1e-3, property: [this, "bumpScale"], hidden: () => !this.bumpMap }, { type: "image", property: [this, "bumpMap"] }, be(this, "bumpMap"), { type: "image", property: [this, "normalMap"] }, { type: "vec2", property: [this, "normalScale"], hidden: () => !this.normalMap }, { type: "dropdown", hidden: () => !this.normalMap, property: [this, "normalMapType"], children: [["TangentSpace", n.IOt], ["ObjectSpace", n.PA7]].map((e2) => ({ label: e2[0], value: e2[1] })) }, be(this, "normalMap"), { type: "input", property: [this, "displacementScale"], hidden: () => !this.displacementMap }, { type: "image", property: [this, "displacementMap"] }, be(this, "displacementMap")] }, { type: "folder", label: "Sheen", children: [{ type: "slider", bounds: [0, 1], property: [this, "sheen"] }, { type: "color", hidden: () => this.sheen < 1e-3, property: [this, "sheenColor"] }, { type: "image", property: [this, "sheenColorMap"] }, be(this, "sheenColorMap"), { type: "slider", bounds: [0, 1], property: [this, "sheenRoughness"] }, { type: "image", property: [this, "sheenRoughnessMap"] }, be(this, "sheenRoughnessMap")] }, { type: "folder", label: "Clearcoat", children: [{ type: "slider", bounds: [0, 1], property: [this, "clearcoat"] }, { type: "slider", bounds: [0, 1], hidden: () => this.clearcoat < 1e-3, property: [this, "clearcoatRoughness"] }, { type: "image", property: [this, "clearcoatMap"] }, be(this, "clearcoatMap"), { type: "slider", bounds: [0, 1], property: [this, "clearcoatRoughness"] }, { type: "image", property: [this, "clearcoatRoughnessMap"] }, be(this, "clearcoatRoughnessMap"), { type: "image", property: [this, "clearcoatNormalMap"] }, { type: "vec2", property: [this, "clearcoatNormalScale"], hidden: () => !this.clearcoatNormalMap }, be(this, "clearcoatNormalMap")] }, { type: "folder", label: "Emission", children: [{ type: "color", property: [this, "emissive"] }, { type: "slider", bounds: [0, 10], property: [this, "emissiveIntensity"] }, { type: "image", property: [this, "emissiveMap"] }, be(this, "emissiveMap")] }, { type: "folder", label: "Refraction", children: [{ type: "slider", bounds: [0, 1], property: [this, "reflectivity"] }, { type: "slider", bounds: [0, 1], property: [this, "transmission"], limitedUi: true }, { type: "slider", bounds: [0, 1], stepSize: 1e-3, property: [this, "thickness"] }, { type: "image", property: [this, "transmissionMap"] }, be(this, "transmissionMap"), { type: "image", property: [this, "thicknessMap"] }, be(this, "thicknessMap")] }, { type: "folder", label: "Blending", children: [{ type: "slider", bounds: [0, 1], property: [this, "opacity"] }, { type: "checkbox", property: [this, "transparent"], onChange: this.setDirty }, { type: "dropdown", property: [this, "depthFunc"], children: [["Never", n.BVF], ["Always", n.Se2], ["Less", n.Zr5], ["LessEqual", n.vCF], ["Equal", n.eD], ["GreaterEqual", n.ksN], ["Greater", n.w$m], ["NotEqual", n.M6v]].map((e2) => ({ label: e2[0], value: e2[1] })) }, { type: "checkbox", property: [this, "depthTest"], onChange: this.setDirty }, { type: "checkbox", property: [this, "depthWrite"], onChange: this.setDirty }, { type: "slider", bounds: [0, 1], property: [this, "alphaTest"] }, { type: "checkbox", property: [this, "dithering"] }, { type: "dropdown", label: "Blending", property: [this, "blending"], children: [["None", re], ["Normal", ne], ["Additive", n.WMw], ["Subtractive", ie], ["Multiply", se]].map((e2) => ({ label: e2[0], value: e2[1] })) }, { type: "image", property: [this, "alphaMap"] }, be(this, "alphaMap"), { type: "checkbox", label: "Render to Depth", getValue: () => true === this.userData.renderToDepth, setValue: (e2) => {
        this.userData.renderToDepth = e2 || void 0, this.setDirty();
      } }, { type: "checkbox", label: "Inverse AlphaMap", hidden: () => !this.transparent, getValue: () => true === this.userData.inverseAlphaMap, setValue: (e2) => {
        this.userData.inverseAlphaMap = e2 || void 0, this.setDirty();
      } }] }, { type: "folder", label: "AO/Lightmap", children: [{ type: "slider", bounds: [0, 2], property: [this, "aoMapIntensity"] }, { type: "image", property: [this, "aoMap"] }, be(this, "aoMap"), { type: "slider", bounds: [0, 2], property: [this, "lightMapIntensity"] }, { type: "image", property: [this, "lightMap"] }, be(this, "lightMap")] }, { type: "dropdown", label: "Side", property: [this, "side"], children: [["Front", n.Wl3], ["Back", n._Li], ["Double", n.ehD]].map((e2) => ({ label: e2[0], value: e2[1] })) }, { type: "checkbox", property: [this, "flatShading"] }, { type: "checkbox", label: "Enable LUT", getValue: () => true === this.userData.enableLUT, setValue: (e2) => {
        this.userData.enableLUT = e2 || void 0, this.setDirty();
      } }, { type: "input", label: "Mesh count", getValue: () => {
        var e2, t2, r2;
        return null !== (r2 = null === (t2 = null === (e2 = this.userData) || void 0 === e2 ? void 0 : e2.__appliedMeshes) || void 0 === t2 ? void 0 : t2.size) && void 0 !== r2 ? r2 : 0;
      }, setValue: (e2) => {
      }, disabled: true }, { type: "button", label: `Download ${this.typeSlug}`, value: () => {
        yt(new Blob([JSON.stringify(this.toJSON(), null, 2)], { type: "application/json" }), `physical-material.${this.typeSlug}`);
      } }]), this._uiConfig || (this._uiConfig = { type: "folder", label: "Physical Material", expanded: true, children: this._uiConfigChildren, uuid: "MSM2_" + this.uuid, limitedUi: true }), this._uiConfig.children = [...this._uiConfigChildren, ...this.materialExtensions.map((e2) => {
        var t2;
        return null === (t2 = e2.getUiConfig) || void 0 === t2 ? void 0 : t2.call(e2, this);
      })].filter((e2) => e2), this._uiConfig;
    }
    onBeforeCompile(e2, t2) {
      const r2 = [["vec3 totalDiffuse = ", "afterModulation"], ["#include <aomap_fragment>", "beforeModulation"], ["#include <lights_physical_fragment>", "beforeAccumulation"], ["#include <clipping_planes_fragment>", "mainStart"]], n2 = [["#include <uv_vertex>", "mainStart"]];
      for (const t3 of n2)
        e2.vertexShader = qt(e2.vertexShader, t3[0], "#glMarker " + t3[1] + "\n" + t3[0]);
      for (const t3 of r2)
        e2.fragmentShader = qt(e2.fragmentShader, t3[0], "#glMarker " + t3[1] + "\n" + t3[0]);
      Ft.ApplyMaterialExtensions(this, e2, this.materialExtensions, t2), e2.fragmentShader = e2.fragmentShader.replaceAll("#glMarker", "// "), e2.vertexShader = e2.vertexShader.replaceAll("#glMarker", "// "), e2.defines.INVERSE_ALPHAMAP = this.userData.inverseAlphaMap ? 1 : 0, super.onBeforeCompile(e2, t2);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey() + Ft.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap;
    }
    onBeforeRender(e2, t2, r2, n2, i2) {
      super.onBeforeRender(e2, t2, r2, n2, i2), this.dispatchEvent({ type: "beforeRender", renderer: e2, scene: t2, camera: r2, geometry: n2, object: i2 });
      const s2 = this.userData.inverseAlphaMap ? 1 : 0;
      s2 !== this.defines.INVERSE_ALPHAMAP && (this.defines.INVERSE_ALPHAMAP = s2, this.needsUpdate = true);
    }
    copyProps(e2, t2 = false) {
      if (!t2 && !["MeshStandardMaterial", Kt.TYPE, "MeshPhysicalMaterial"].includes(e2.type))
        return console.error("Material type is not supported:", e2.type), this;
      const r2 = {};
      b(e2, r2, Array.from(Object.keys(Yt)));
      const n2 = r2.userData;
      delete r2.userData;
      for (const e3 of Object.keys(r2))
        void 0 === r2[e3] && delete r2[e3];
      return this.setValues(r2), n2 && xe(this.userData, n2), this.setDirty(), this;
    }
    toJSON(e2) {
      var t2, r2;
      const n2 = this.userData;
      this.userData = {};
      const i2 = super.toJSON(e2);
      this.userData = n2, i2.userData = {}, xe(i2.userData, n2), i2.userData.uuid = this.userData.uuid;
      const s2 = e2 || { textures: Object.fromEntries((null === (t2 = i2.textures) || void 0 === t2 ? void 0 : t2.map((e3) => [e3.uuid, e3])) || []), images: Object.fromEntries((null === (r2 = i2.images) || void 0 === r2 ? void 0 : r2.map((e3) => [e3.uuid, e3])) || []) };
      i2.userData = ke(i2.userData, false, s2), e2 || (Object.keys(s2.textures).length > 0 && (i2.textures = Object.values(s2.textures)), Object.keys(s2.images).length > 0 && (i2.images = Object.values(s2.images))), i2.type = Kt.TYPE;
      for (const e3 of Object.keys(i2))
        void 0 === i2[e3] && delete i2[e3];
      return i2;
    }
    fromJSON(e2, t2, r2 = false) {
      return Array.isArray(e2.normalScale) && (e2.normalScale = new n.FM8().fromArray(e2.normalScale)), Array.isArray(e2.clearcoatNormalScale) && (e2.clearcoatNormalScale = new n.FM8().fromArray(e2.clearcoatNormalScale)), this.copyProps(e2, r2);
    }
    clone() {
      return super.clone();
    }
  }
  Kt.TypeSlug = "pmat", Kt.TYPE = "MeshStandardMaterial2";
  const Jt = { ...Wt, color: "#000000", map: null, lightMap: null, lightMapIntensity: 1, aoMap: null, aoMapIntensity: 1, alphaMap: null, envMap: null, combine: n.Ns1, reflectivity: 1, refractionRatio: 0.98, wireframe: false, wireframeLinewidth: 0, skinning: false };
  class Zt extends n.vBJ {
    constructor(e2) {
      var t2;
      super(e2), this.typeSlug = Zt.TypeSlug, this.assetType = "material", this.materialObject = this, this.isMeshBasicMaterial2 = true, this.extraUniformsToUpload = {}, this.fog = false, this.setDirty = this.setDirty.bind(this), this.userData.setDirty = (e3) => {
        console.warn("userData.setDirty is deprecated. Use setDirty instead."), this.setDirty(e3);
      }, this.materialExtensions = Ft.RegisterExtensions(this, null !== (t2 = null == e2 ? void 0 : e2.customMaterialExtensions) && void 0 !== t2 ? t2 : []);
    }
    setDirty(e2) {
      var t2, r2;
      this.needsUpdate = true, this.dispatchEvent({ ...e2, type: "materialUpdate" }), null === (r2 = null === (t2 = this._uiConfig) || void 0 === t2 ? void 0 : t2.uiRefresh) || void 0 === r2 || r2.call(t2, "postFrame", true, 1);
    }
    registerMaterialExtensions(e2) {
      this.materialExtensions = [...this.materialExtensions, ...Ft.RegisterExtensions(this, e2)];
    }
    unregisterMaterialExtensions(e2) {
    }
    get uiConfig() {
      return this._uiConfigChildren || (this._uiConfigChildren = [{ type: "input", property: [this, "name"] }, { type: "checkbox", property: [this, "wireframe"] }, { type: "color", property: [this, "color"], limitedUi: true }, { type: "image", property: [this, "map"] }, be(this, "map"), { type: "folder", label: "Blending", children: [{ type: "slider", bounds: [0, 1], property: [this, "opacity"] }, { type: "checkbox", property: [this, "transparent"], onChange: this.setDirty }, { type: "checkbox", property: [this, "depthWrite"], onChange: this.setDirty }, { type: "slider", bounds: [0, 1], property: [this, "alphaTest"] }, { type: "checkbox", property: [this, "dithering"] }, { type: "dropdown", label: "Blending", property: [this, "blending"], children: [["None", re], ["Normal", ne], ["Additive", n.WMw], ["Subtractive", ie], ["Multiply", se]].map((e2) => ({ label: e2[0], value: e2[1] })) }, { type: "image", property: [this, "alphaMap"] }, be(this, "alphaMap"), { type: "checkbox", label: "Render to Depth", getValue: () => true === this.userData.renderToDepth, setValue: (e2) => {
        this.userData.renderToDepth = e2 || void 0, this.setDirty();
      } }] }, { type: "folder", label: "AO/Lightmap", children: [{ type: "slider", bounds: [0, 2], property: [this, "aoMapIntensity"] }, { type: "image", property: [this, "aoMap"] }, be(this, "aoMap"), { type: "slider", bounds: [0, 2], property: [this, "lightMapIntensity"] }, { type: "image", property: [this, "lightMap"] }, be(this, "lightMap")] }, { type: "dropdown", label: "Side", property: [this, "side"], children: [["Front", n.Wl3], ["Back", n._Li], ["Double", n.ehD]].map((e2) => ({ label: e2[0], value: e2[1] })) }, { type: "input", label: "Mesh count", getValue: () => {
        var e2, t2, r2;
        return null !== (r2 = null === (t2 = null === (e2 = this.userData) || void 0 === e2 ? void 0 : e2.__appliedMeshes) || void 0 === t2 ? void 0 : t2.size) && void 0 !== r2 ? r2 : 0;
      }, setValue: (e2) => {
      }, disabled: true }, { type: "button", label: `Download ${this.typeSlug}`, value: () => {
        yt(new Blob([JSON.stringify(this.toJSON(), null, 2)], { type: "application/json" }), `unlit-material.${this.typeSlug}`);
      } }]), this._uiConfig || (this._uiConfig = { type: "folder", label: "Unlit Material", expanded: true, children: this._uiConfigChildren, uuid: "MBM2_" + this.uuid, limitedUi: true }), this._uiConfig.children = [...this._uiConfigChildren, ...this.materialExtensions.map((e2) => {
        var t2;
        return null === (t2 = e2.getUiConfig) || void 0 === t2 ? void 0 : t2.call(e2, this);
      })].filter((e2) => e2), this._uiConfig;
    }
    onBeforeCompile(e2, t2) {
      const r2 = [["vec3 outgoingLight = ", "afterModulation"], ["#include <aomap_fragment>", "beforeModulation"], ["ReflectedLight reflectedLight = ", "beforeAccumulation"], ["#include <clipping_planes_fragment>", "mainStart"]], n2 = [["#include <uv_vertex>", "mainStart"]];
      for (const t3 of n2)
        e2.vertexShader = qt(e2.vertexShader, t3[0], "#glMarker " + t3[1] + "\n" + t3[0]);
      for (const t3 of r2)
        e2.fragmentShader = qt(e2.fragmentShader, t3[0], "#glMarker " + t3[1] + "\n" + t3[0]);
      Ft.ApplyMaterialExtensions(this, e2, this.materialExtensions, t2), e2.fragmentShader = e2.fragmentShader.replaceAll("#glMarker", "// "), e2.vertexShader = e2.vertexShader.replaceAll("#glMarker", "// "), super.onBeforeCompile(e2, t2);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey() + Ft.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap;
    }
    onBeforeRender(e2, t2, r2, n2, i2) {
      super.onBeforeRender(e2, t2, r2, n2, i2), this.dispatchEvent({ type: "beforeRender", renderer: e2, scene: t2, camera: r2, geometry: n2, object: i2 });
    }
    copyProps(e2, t2 = false) {
      if (!t2 && !["MeshBasicMaterial", Zt.TYPE].includes(e2.type))
        return console.error("Material type is not supported:", e2.type), this;
      const r2 = {};
      b(e2, r2, Array.from(Object.keys(Jt)));
      const n2 = r2.userData;
      delete r2.userData;
      for (const e3 of Object.keys(r2))
        void 0 === r2[e3] && delete r2[e3];
      return this.setValues(r2), n2 && xe(this.userData, n2), this.setDirty(), this;
    }
    toJSON(e2) {
      var t2, r2;
      const n2 = this.userData;
      this.userData = {};
      const i2 = super.toJSON(e2);
      this.userData = n2, i2.userData = {}, xe(i2.userData, n2), i2.userData.uuid = this.userData.uuid;
      const s2 = e2 || { textures: Object.fromEntries((null === (t2 = i2.textures) || void 0 === t2 ? void 0 : t2.map((e3) => [e3.uuid, e3])) || []), images: Object.fromEntries((null === (r2 = i2.images) || void 0 === r2 ? void 0 : r2.map((e3) => [e3.uuid, e3])) || []) };
      i2.userData = ke(i2.userData, false, s2), e2 || (Object.keys(s2.textures).length > 0 && (i2.textures = Object.values(s2.textures)), Object.keys(s2.images).length > 0 && (i2.images = Object.values(s2.images))), i2.type = Zt.TYPE;
      for (const e3 of Object.keys(i2))
        void 0 === i2[e3] && delete i2[e3];
      return i2;
    }
    fromJSON(e2, t2, r2 = false) {
      return this.copyProps(e2, r2);
    }
    clone() {
      return super.clone();
    }
  }
  Zt.TypeSlug = "bmat", Zt.TYPE = "MeshBasicMaterial2";
  const $t = { materialType: Kt.TYPE, name: "standard", color: "#ffffff" }, er = { materialType: Zt.TYPE, name: "basic", color: "#ffffff" }, tr = { [Kt.TYPE]: $t.name, MeshStandardMaterial: $t.name, MeshPhysicalMaterial: $t.name, [Zt.TYPE]: er.name, MeshBasicMaterial: er.name };
  class rr extends r {
    constructor() {
      super(), this._templates = [$t, er], this._materials = [], this._disposeMaterial = (e2) => {
        const t2 = e2.target;
        if (!t2 || "material" !== t2.assetType)
          return;
        this._refreshTextureRefs();
        const r2 = this._getMapsForMaterial(t2), n2 = [];
        r2.forEach((e3) => {
          const r3 = e3.userData.__appliedMaterials;
          null == r3 || r3.delete(t2), r3 && false !== e3.userData.disposeOnIdle && 0 === r3.size && n2.push(e3);
        }), n2.forEach((e3) => {
          e3.dispose();
        }), this.unregisterMaterial(t2);
      }, this._materialExtensions = [], this.processModel = this.processModel.bind(this), this.processMaterial = this.processMaterial.bind(this);
    }
    findOrCreate(e2, t2) {
      let r2 = this.findMaterial(e2);
      return r2 || (r2 = this.generateFromTemplate(e2, t2)), r2;
    }
    generateFromTemplate(e2, t2) {
      const r2 = this.findTemplate(e2);
      if (r2)
        return this._generateFromTemplate(r2, null != t2 ? t2 : {});
    }
    generateFromTemplateType(e2, t2) {
      const r2 = this._templates.find((t3) => t3.materialType === e2);
      if (r2)
        return this._generateFromTemplate(r2, null != t2 ? t2 : {});
    }
    findTemplate(e2) {
      return this._templates.find((t2) => t2.name === e2);
    }
    _refreshTextureRefs() {
      this.getAllMaterials().forEach((e2) => {
        this._getMapsForMaterial(e2).forEach((t2) => {
          let r2 = t2.userData.__appliedMaterials;
          r2 || (t2.userData.__appliedMaterials = r2 = /* @__PURE__ */ new Set()), r2.add(e2);
        });
      });
    }
    _getMapsForMaterial(e2) {
      var t2;
      const r2 = /* @__PURE__ */ new Set();
      for (const t3 of Object.values(e2))
        t3 && t3.isTexture && r2.add(t3);
      for (const n2 of Object.values(null !== (t2 = e2.userData) && void 0 !== t2 ? t2 : {}))
        n2 && n2.isTexture && r2.add(n2);
      return r2;
    }
    registerMaterial(e2) {
      if (this._materials.includes(e2))
        return;
      const t2 = this.findMaterial(e2.uuid);
      t2 ? console.warn("Material UUID already exists", e2, t2) : (e2.addEventListener("dispose", this._disposeMaterial), this._materials.push(e2));
    }
    registerMaterialObject(e2) {
      const t2 = e2.materialObject ? e2 : Object.assign(e2, { assetType: "material", materialObject: e2 });
      return this.registerMaterial(t2), t2;
    }
    unregisterMaterial(e2) {
      this._materials = this._materials.filter((t2) => t2.uuid !== e2.uuid), e2.removeEventListener("dispose", this._disposeMaterial);
    }
    registerMaterialTemplate(e2) {
      e2.templateUUID || (e2.templateUUID = Xe());
      const t2 = this._templates.find((t3) => t3.templateUUID === e2.templateUUID);
      t2 ? console.warn("MaterialTemplate already exists", e2, t2) : this._templates.push(e2);
    }
    unregisterMaterialTemplate(e2) {
      this._templates = this._templates.filter((t2) => t2.templateUUID !== e2.templateUUID);
    }
    dispose() {
    }
    findMaterial(e2) {
      return e2 ? this._materials.find((t2) => t2.uuid === e2) : void 0;
    }
    findMaterialsByName(e2) {
      return this._materials.filter((t2) => t2.name === e2);
    }
    getMaterialsOfType(e2) {
      return e2 ? this._materials.filter((t2) => t2.typeSlug === e2) : [];
    }
    getAllMaterials() {
      return [...this._materials];
    }
    processModel(e2, t2) {
      return _(e2, "modelObject", this._processModel(e2, t2)), e2;
    }
    _processMaterial(e2, t2) {
      var r2, n2, i2;
      if (!e2)
        return;
      if (null === (r2 = e2.materialObject) || void 0 === r2 ? void 0 : r2.isMaterial)
        return e2;
      let s2 = e2.mmMaterial;
      if (!s2) {
        const r3 = (null === (n2 = e2.userData) || void 0 === n2 ? void 0 : n2.uuid) || e2.uuid;
        if (s2 = this.findMaterial(r3), s2)
          s2.copyProps(e2);
        else {
          const r4 = false === t2.useSourceMaterial || !e2.isMaterial, n3 = null !== (i2 = t2.materialTemplate) && void 0 !== i2 ? i2 : r4 ? "standard" : tr[e2.type] || "standard";
          s2 = this.generateFromTemplate(n3, r4 ? {} : e2);
        }
        e2.mmMaterial = s2;
      }
      return s2;
    }
    processMaterial(e2, t2) {
      return false !== t2.register && this.registerMaterial(e2), e2.materialObject || (e2 = this._processMaterial(e2, { ...t2, register: false })), e2;
    }
    registerMaterialExtension(e2) {
      this._materialExtensions.includes(e2) || this._materialExtensions.push(e2);
    }
    unregisterMaterialExtension(e2) {
      const t2 = this._materialExtensions.indexOf(e2);
      t2 >= 0 && this._materialExtensions.splice(t2, 1);
    }
    exportMaterial(e2, t2, r2 = true, n2 = false) {
      const i2 = ke(e2, false), s2 = JSON.stringify(i2, null, r2 ? 0 : 2), o2 = (t2 || e2.name || "physical_material") + "." + e2.typeSlug, a2 = new File([s2], o2, { type: "application/json" });
      return n2 && wt(a2), a2;
    }
  }
  class nr extends rr {
    _generateFromTemplate(e2, t2) {
      var r2, n2, i2, s2, o2, a2;
      let l2;
      const c2 = { ...e2 };
      c2.customMaterialExtensions = [...null !== (r2 = c2.customMaterialExtensions) && void 0 !== r2 ? r2 : [], ...this._materialExtensions];
      let u2 = {};
      switch (e2.materialType) {
        case "MeshStandardMaterial2":
        case "standard":
          t2 && b(t2, c2, Array.from(Object.keys(Yt))), "MeshBasicMaterial" === (null == t2 ? void 0 : t2.type) && (c2.roughness = 0.9, c2.metalness = 0, (null === (n2 = c2.userData) || void 0 === n2 ? void 0 : n2.uuid) && delete c2.userData.uuid), u2 = null === (i2 = c2.userData) || void 0 === i2 ? void 0 : i2.uuid, u2 && delete c2.userData.uuid, l2 = new Kt({ customMaterialExtensions: c2.customMaterialExtensions }).fromJSON(c2, void 0, true), u2 && (l2.uuid = u2), l2.userData.uuid = l2.uuid, l2.setDirty(), (null == t2 ? void 0 : t2.isMaterial) && void 0 !== t2.userData && (t2.userData.iMaterial = l2);
          break;
        case "MeshBasicMaterial2":
        case "basic":
        case "unlit":
          t2 && b(t2, c2, Array.from(Object.keys(Jt))), u2 = null === (s2 = c2.userData) || void 0 === s2 ? void 0 : s2.uuid, u2 && delete c2.userData.uuid, l2 = new Zt({ customMaterialExtensions: c2.customMaterialExtensions }).fromJSON(c2, void 0, true), u2 && (l2.uuid = u2), l2.userData.uuid = l2.uuid, l2.setDirty();
          break;
        case "shadow":
          throw "TODO: Not implemented shadow material";
        default:
          u2 = null, t2 && t2.userData && (u2 = t2.userData, delete t2.userData), l2 = (null === (o2 = e2.generator) || void 0 === o2 ? void 0 : o2.call(e2, c2, t2)) || void 0, t2 && u2 && (t2.userData = u2), u2 && l2 && (xe(l2.userData, u2), (null == u2 ? void 0 : u2.uuid) && (l2.uuid = u2.uuid), u2 = null), l2 && (l2.userData.uuid = l2.uuid);
      }
      if (l2) {
        t2.runtimeMaterial && (l2.userData.__runtimeMaterial = true);
        const r3 = l2;
        if (l2.clone = () => {
          r3.userData.cloneId || (r3.userData.cloneId = "0", r3.userData.cloneCount = 0), r3.userData.cloneCount += 1;
          const t3 = this.generateFromTemplate(e2.name);
          return t3 && (t3.copyProps(r3), t3.userData.cloneId = t3.userData.cloneId + "_" + r3.userData.cloneCount, t3.userData.cloneCount = 0, t3.name = t3.name + "_" + t3.userData.cloneId), null == t3 ? void 0 : t3.materialObject;
        }, t2) {
          let e3 = this.findMaterial(null == t2 ? void 0 : t2.uuid);
          e3 && this.unregisterMaterial(e3), e3 = this.findMaterial(null === (a2 = null == t2 ? void 0 : t2.materialObject) || void 0 === a2 ? void 0 : a2.uuid), e3 && this.unregisterMaterial(e3);
        }
        return this.registerMaterialObject(r3);
      }
    }
    _processModel(e2, t2) {
      if (!e2.modelObject)
        return console.error("MaterialManager: No modelObject found for ", e2), e2;
      let r2 = e2.material;
      if (!r2 && e2.geometry && (this._defaultMaterial || (this._defaultMaterial = this.generateFromTemplate("standard")), r2 = this._defaultMaterial, e2.material = r2), r2) {
        let n2 = true;
        Array.isArray(r2) || (r2 = [r2], n2 = false);
        const i2 = [];
        for (const e3 of r2) {
          const r3 = this._processMaterial(e3, t2);
          i2.push(null == r3 ? void 0 : r3.materialObject);
        }
        e2.setMaterial && (e2.modelObject.material = null, e2.setMaterial(n2 ? i2 : i2[0]));
      }
      if (false !== t2.recursive)
        for (let r3 = 0; r3 < e2.modelObject.children.length; r3++)
          e2.modelObject.children[r3] = this._processModel(e2.modelObject.children[r3], t2);
      return e2;
    }
  }
  class ir {
    constructor(e2, t2, r2, n2) {
      this.cls = e2, this.ext = t2, this.root = r2, this.onCtor = n2;
    }
    ctor(e2) {
      const t2 = this.cls && new this.cls(e2.loadingManager);
      return "function" == typeof this.onCtor ? this.onCtor(t2, e2) : t2;
    }
  }
  function sr(e2) {
    var t2;
    if (!e2 || "" === e2 || e2.match(/__MACOSX\/.*\._/))
      return "";
    const r2 = null !== (t2 = (e2 = e2.replace(/\?.*$/, "")).split(/[\\/]/).pop()) && void 0 !== t2 ? t2 : "", n2 = r2.lastIndexOf(".");
    return "" === r2 || n2 < 1 ? "" : r2.slice(n2 + 1);
  }
  function or(e2) {
    return e2.substring(e2.lastIndexOf("/") + 1);
  }
  class ar {
    constructor(e2, { pseudoCenter: t2 = false, autoCenter: r2 = false, autoScale: i2 = false, autoScaleRadius: s2 = 2, license: o2 = "" } = {}) {
      if (this.assetType = "model", this._modelObject = Le(new n.Tme()), this.setDirty = this.setDirty.bind(this), this.updateBounds = this.updateBounds.bind(this), e2 || (e2 = this._modelObject), !t2 || e2.userData.pseudoCentered || e2.userData.isCentered)
        !r2 || e2.userData.autoCentered || e2.userData.isCentered || e2.userData.pseudoCentered ? t2 || r2 || (e2.userData.isCentered = true) : q(e2), this._modelObject = e2;
      else {
        r2 && console.error("cannot use pseudoCenter and autoCenter at the same time");
        const t3 = new k().expandByObject(e2, true, true).getCenter(new n.Pa4());
        this._modelObject.position.copy(t3).negate(), this._modelObject.updateMatrix(), this._modelObject.add(e2), this._modelObject.name = e2.name + "-centered", this._modelObject.userData.pseudoCentered = true, e2.userData.iModel = this;
      }
      i2 && !this._modelObject.userData.autoScaled ? X(this._modelObject, e2.userData.autoScaleRadius || s2) : this._modelObject.userData.autoScaled = true, this._modelObject.addEventListener("dispose", () => {
        this.__disposed = true;
      }), this._modelObject.userData.iModel = this, this.license = o2;
    }
    get visible() {
      return this._modelObject.visible;
    }
    set visible(e2) {
      this._modelObject.visible = e2;
    }
    get uuid() {
      return this._modelObject.uuid;
    }
    get modelObject() {
      return this._modelObject;
    }
    get name() {
      return this._modelObject.name;
    }
    set name(e2) {
      this._modelObject.name = e2;
    }
    get license() {
      return this._modelObject.userData.license;
    }
    set license(e2) {
      this._modelObject.userData.license = e2;
    }
    addEventListener(e2, t2) {
      this._modelObject.addEventListener(e2, t2);
    }
    dispatchEvent(e2) {
      this._modelObject.dispatchEvent(e2);
    }
    hasEventListener(e2, t2) {
      return this._modelObject.hasEventListener(e2, t2);
    }
    removeEventListener(e2, t2) {
      this._modelObject.removeEventListener(e2, t2);
    }
    traverse(e2) {
      this._modelObject.traverse(e2);
    }
    dispose() {
      const e2 = this._modelObject.dispose;
      e2 && "function" == typeof e2 ? e2() : (console.warn("no dispose in modelObject"), this._modelObject.removeFromParent());
    }
    setDirty(e2) {
      var t2, r2, n2, i2;
      null === (r2 = null === (t2 = this._modelObject) || void 0 === t2 ? void 0 : t2.setDirty) || void 0 === r2 || r2.call(t2, e2), null === (i2 = null === (n2 = this._uiConfig) || void 0 === n2 ? void 0 : n2.uiRefresh) || void 0 === i2 || i2.call(n2, "postFrame", true);
    }
    setMaterial(e2) {
      var t2, r2;
      return this._modelObject.isMesh ? (null === (r2 = (t2 = this._modelObject).setMaterial) || void 0 === r2 ? void 0 : r2.call(t2, e2)) || [] : (console.error("setMaterial only works on meshes"), []);
    }
    get material() {
      return this._modelObject.material;
    }
    get geometry() {
      return this._modelObject.geometry;
    }
    setGeometry(e2, t2 = false) {
      var r2, n2;
      if (this._modelObject.isMesh)
        return null === (n2 = (r2 = this._modelObject).setGeometry) || void 0 === n2 ? void 0 : n2.call(r2, e2, t2);
      console.error("setGeometry only works on meshes");
    }
    get userData() {
      return this._modelObject.userData;
    }
    set userData(e2) {
      this._modelObject.userData = e2;
    }
    updateBounds() {
      console.warn("updateBounds: NOT IMPLEMENTED"), this.setDirty();
    }
    get uiConfig() {
      return this._uiConfig || (this._uiConfig = Re(this._modelObject, false)), this._uiConfig;
    }
    clone() {
      return new ar(this._modelObject.clone(), { pseudoCenter: false, autoScale: false, autoCenter: false, license: this.license });
    }
  }
  function lr(e2, t2) {
    return [e2.modelObject, ...e2.modelObject.children].forEach((r2) => {
      Le(r2, r2 !== e2.modelObject ? e2 : void 0, t2);
    }), e2;
  }
  class cr {
    constructor() {
      this._processors = /* @__PURE__ */ new Map();
    }
    add(e2, t2) {
      var r2;
      this._processors.has(e2) || this._processors.set(e2, []), null === (r2 = this._processors.get(e2)) || void 0 === r2 || r2.push(t2);
    }
    remove(e2, t2) {
      const r2 = this._processors.get(e2), n2 = (null == r2 ? void 0 : r2.indexOf(t2)) || (null == r2 ? void 0 : r2.findIndex((e3) => e3.process && e3.process === t2.process || e3.processAsync && e3.processAsync === t2.processAsync));
      !r2 || !n2 || n2 < 0 || r2.splice(n2, 1);
    }
    get(e2) {
      var t2;
      return null !== (t2 = this._processors.get(e2)) && void 0 !== t2 ? t2 : [];
    }
    async process(e2, t2, r2) {
      var n2, i2, s2, o2;
      const a2 = this.get(e2), l2 = t2.assetType;
      for (const e3 of a2)
        e3.forAssetType === l2 && (t2 = null !== (i2 = null === (n2 = e3.process) || void 0 === n2 ? void 0 : n2.call(e3, t2, r2)) && void 0 !== i2 ? i2 : t2, t2 = null !== (o2 = await (null === (s2 = e3.processAsync) || void 0 === s2 ? void 0 : s2.call(e3, t2, r2))) && void 0 !== o2 ? o2 : t2);
      return t2;
    }
    dispose() {
      this._processors.clear();
    }
  }
  class ur extends n.hH6 {
    load(e2, t2, r2, n2) {
      return super.load(e2, (e3) => {
        try {
          if ("string" != typeof e3)
            throw new Error("Invalid JSON");
          null == t2 || t2(JSON.parse(e3));
        } catch (e4) {
          null == n2 || n2(e4);
        }
      }, r2, n2);
    }
  }
  class hr extends n.yxD {
    constructor(e2) {
      super(e2), this.type = n.cLu;
    }
    parse(e2) {
      const t2 = function(e3, t3) {
        switch (e3) {
          case 1:
            console.error("THREE.RGBELoader Read Error: " + (t3 || ""));
            break;
          case 2:
            console.error("THREE.RGBELoader Write Error: " + (t3 || ""));
            break;
          case 3:
            console.error("THREE.RGBELoader Bad File Format: " + (t3 || ""));
            break;
          default:
            console.error("THREE.RGBELoader: Error: " + (t3 || ""));
        }
        return -1;
      }, r2 = function(e3, t3, r3) {
        t3 = t3 || 1024;
        let n2 = e3.pos, i3 = -1, s3 = 0, o3 = "", a3 = String.fromCharCode.apply(null, new Uint16Array(e3.subarray(n2, n2 + 128)));
        for (; 0 > (i3 = a3.indexOf("\n")) && s3 < t3 && n2 < e3.byteLength; )
          o3 += a3, s3 += a3.length, n2 += 128, a3 += String.fromCharCode.apply(null, new Uint16Array(e3.subarray(n2, n2 + 128)));
        return -1 < i3 && (false !== r3 && (e3.pos += s3 + i3 + 1), o3 + a3.slice(0, i3));
      }, i2 = function(e3, t3, r3, n2) {
        const i3 = e3[t3 + 3], s3 = Math.pow(2, i3 - 128) / 255;
        r3[n2 + 0] = e3[t3 + 0] * s3, r3[n2 + 1] = e3[t3 + 1] * s3, r3[n2 + 2] = e3[t3 + 2] * s3, r3[n2 + 3] = 1;
      }, s2 = function(e3, t3, r3, i3) {
        const s3 = e3[t3 + 3], o3 = Math.pow(2, s3 - 128) / 255;
        r3[i3 + 0] = n.A5E.toHalfFloat(Math.min(e3[t3 + 0] * o3, 65504)), r3[i3 + 1] = n.A5E.toHalfFloat(Math.min(e3[t3 + 1] * o3, 65504)), r3[i3 + 2] = n.A5E.toHalfFloat(Math.min(e3[t3 + 2] * o3, 65504)), r3[i3 + 3] = n.A5E.toHalfFloat(1);
      }, o2 = new Uint8Array(e2);
      o2.pos = 0;
      const a2 = function(e3) {
        const n2 = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, i3 = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, s3 = /^\s*FORMAT=(\S+)\s*$/, o3 = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, a3 = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 };
        let l2, c2;
        if (e3.pos >= e3.byteLength || !(l2 = r2(e3)))
          return t2(1, "no header found");
        if (!(c2 = l2.match(/^#\?(\S+)/)))
          return t2(3, "bad initial token");
        for (a3.valid |= 1, a3.programtype = c2[1], a3.string += l2 + "\n"; l2 = r2(e3), false !== l2; )
          if (a3.string += l2 + "\n", "#" !== l2.charAt(0)) {
            if ((c2 = l2.match(n2)) && (a3.gamma = parseFloat(c2[1])), (c2 = l2.match(i3)) && (a3.exposure = parseFloat(c2[1])), (c2 = l2.match(s3)) && (a3.valid |= 2, a3.format = c2[1]), (c2 = l2.match(o3)) && (a3.valid |= 4, a3.height = parseInt(c2[1], 10), a3.width = parseInt(c2[2], 10)), 2 & a3.valid && 4 & a3.valid)
              break;
          } else
            a3.comments += l2 + "\n";
        return 2 & a3.valid ? 4 & a3.valid ? a3 : t2(3, "missing image size specifier") : t2(3, "missing format specifier");
      }(o2);
      if (-1 !== a2) {
        const e3 = a2.width, r3 = a2.height, l2 = function(e4, r4, n2) {
          const i3 = r4;
          if (i3 < 8 || i3 > 32767 || 2 !== e4[0] || 2 !== e4[1] || 128 & e4[2])
            return new Uint8Array(e4);
          if (i3 !== (e4[2] << 8 | e4[3]))
            return t2(3, "wrong scanline width");
          const s3 = new Uint8Array(4 * r4 * n2);
          if (!s3.length)
            return t2(4, "unable to allocate buffer space");
          let o3 = 0, a3 = 0;
          const l3 = 4 * i3, c2 = new Uint8Array(4), u2 = new Uint8Array(l3);
          let h2 = n2;
          for (; h2 > 0 && a3 < e4.byteLength; ) {
            if (a3 + 4 > e4.byteLength)
              return t2(1);
            if (c2[0] = e4[a3++], c2[1] = e4[a3++], c2[2] = e4[a3++], c2[3] = e4[a3++], 2 != c2[0] || 2 != c2[1] || (c2[2] << 8 | c2[3]) != i3)
              return t2(3, "bad rgbe scanline format");
            let r5, n3 = 0;
            for (; n3 < l3 && a3 < e4.byteLength; ) {
              r5 = e4[a3++];
              const i4 = r5 > 128;
              if (i4 && (r5 -= 128), 0 === r5 || n3 + r5 > l3)
                return t2(3, "bad scanline data");
              if (i4) {
                const t3 = e4[a3++];
                for (let e5 = 0; e5 < r5; e5++)
                  u2[n3++] = t3;
              } else
                u2.set(e4.subarray(a3, a3 + r5), n3), n3 += r5, a3 += r5;
            }
            const p2 = i3;
            for (let e5 = 0; e5 < p2; e5++) {
              let t3 = 0;
              s3[o3] = u2[e5 + t3], t3 += i3, s3[o3 + 1] = u2[e5 + t3], t3 += i3, s3[o3 + 2] = u2[e5 + t3], t3 += i3, s3[o3 + 3] = u2[e5 + t3], o3 += 4;
            }
            h2--;
          }
          return s3;
        }(o2.subarray(o2.pos), e3, r3);
        if (-1 !== l2) {
          let t3, o3, c2;
          switch (this.type) {
            case n.VzW:
              c2 = l2.length / 4;
              const e4 = new Float32Array(4 * c2);
              for (let t4 = 0; t4 < c2; t4++)
                i2(l2, 4 * t4, e4, 4 * t4);
              t3 = e4, o3 = n.VzW;
              break;
            case n.cLu:
              c2 = l2.length / 4;
              const r4 = new Uint16Array(4 * c2);
              for (let e5 = 0; e5 < c2; e5++)
                s2(l2, 4 * e5, r4, 4 * e5);
              t3 = r4, o3 = n.cLu;
              break;
            default:
              console.error("THREE.RGBELoader: unsupported type: ", this.type);
          }
          return { width: e3, height: r3, data: t3, header: a2.string, gamma: a2.gamma, exposure: a2.exposure, type: o3 };
        }
      }
      return null;
    }
    setDataType(e2) {
      return this.type = e2, this;
    }
    load(e2, t2, r2, i2) {
      return super.load(e2, function(e3, r3) {
        switch (e3.type) {
          case n.VzW:
          case n.cLu:
            e3.encoding = n.rnI, e3.minFilter = n.wem, e3.magFilter = n.wem, e3.generateMipmaps = false, e3.flipY = true;
        }
        t2 && t2(e3, r3);
      }, r2, i2);
    }
  }
  function pr(e2) {
    Js.Importers.push(new ir(class extends hr {
      constructor(t2) {
        super(t2), this.setDataType(Zs(e2));
      }
    }, ["hdr"], false));
  }
  class dr extends n.aNw {
    constructor(e2) {
      super(e2), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e3) {
        return new Ar(e3);
      }), this.register(function(e3) {
        return new Cr(e3);
      }), this.register(function(e3) {
        return new Mr(e3);
      }), this.register(function(e3) {
        return new yr(e3);
      }), this.register(function(e3) {
        return new xr(e3);
      }), this.register(function(e3) {
        return new wr(e3);
      }), this.register(function(e3) {
        return new Er(e3);
      }), this.register(function(e3) {
        return new vr(e3);
      }), this.register(function(e3) {
        return new Sr(e3);
      }), this.register(function(e3) {
        return new br(e3);
      }), this.register(function(e3) {
        return new _r(e3);
      }), this.register(function(e3) {
        return new Tr(e3);
      });
    }
    load(e2, t2, r2, i2) {
      const s2 = this;
      let o2;
      o2 = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : n.Zp0.extractUrlBase(e2), this.manager.itemStart(e2);
      const a2 = function(t3) {
        i2 ? i2(t3) : console.error(t3), s2.manager.itemError(e2), s2.manager.itemEnd(e2);
      }, l2 = new n.hH6(this.manager);
      l2.setPath(this.path), l2.setResponseType("arraybuffer"), l2.setRequestHeader(this.requestHeader), l2.setWithCredentials(this.withCredentials), l2.load(e2, function(r3) {
        try {
          s2.parse(r3, o2, function(r4) {
            t2(r4), s2.manager.itemEnd(e2);
          }, a2);
        } catch (e3) {
          a2(e3);
        }
      }, r2, a2);
    }
    setDRACOLoader(e2) {
      return this.dracoLoader = e2, this;
    }
    setDDSLoader() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }
    setKTX2Loader(e2) {
      return this.ktx2Loader = e2, this;
    }
    setMeshoptDecoder(e2) {
      return this.meshoptDecoder = e2, this;
    }
    register(e2) {
      return -1 === this.pluginCallbacks.indexOf(e2) && this.pluginCallbacks.push(e2), this;
    }
    unregister(e2) {
      return -1 !== this.pluginCallbacks.indexOf(e2) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e2), 1), this;
    }
    parse(e2, t2, r2, i2) {
      let s2;
      const o2 = {}, a2 = {};
      if ("string" == typeof e2)
        s2 = e2;
      else if (n.Zp0.decodeText(new Uint8Array(e2, 0, 4)) === Ir) {
        try {
          o2[mr.KHR_BINARY_GLTF] = new kr(e2);
        } catch (e3) {
          return void (i2 && i2(e3));
        }
        s2 = o2[mr.KHR_BINARY_GLTF].content;
      } else
        s2 = n.Zp0.decodeText(new Uint8Array(e2));
      const l2 = JSON.parse(s2);
      if (void 0 === l2.asset || l2.asset.version[0] < 2)
        return void (i2 && i2(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
      const c2 = new Zr(l2, { path: t2 || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
      c2.fileLoader.setRequestHeader(this.requestHeader);
      for (let e3 = 0; e3 < this.pluginCallbacks.length; e3++) {
        const t3 = this.pluginCallbacks[e3](c2);
        a2[t3.name] = t3, o2[t3.name] = true;
      }
      if (l2.extensionsUsed)
        for (let e3 = 0; e3 < l2.extensionsUsed.length; ++e3) {
          const t3 = l2.extensionsUsed[e3], r3 = l2.extensionsRequired || [];
          switch (t3) {
            case mr.KHR_MATERIALS_UNLIT:
              o2[t3] = new gr();
              break;
            case mr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              o2[t3] = new Rr();
              break;
            case mr.KHR_DRACO_MESH_COMPRESSION:
              o2[t3] = new Dr(l2, this.dracoLoader);
              break;
            case mr.KHR_TEXTURE_TRANSFORM:
              o2[t3] = new Pr();
              break;
            case mr.KHR_MESH_QUANTIZATION:
              o2[t3] = new Lr();
              break;
            default:
              r3.indexOf(t3) >= 0 && void 0 === a2[t3] && console.warn('THREE.GLTFLoader: Unknown extension "' + t3 + '".');
          }
        }
      c2.setExtensions(o2), c2.setPlugins(a2), c2.parse(r2, i2);
    }
    parseAsync(e2, t2) {
      const r2 = this;
      return new Promise(function(n2, i2) {
        r2.parse(e2, t2, n2, i2);
      });
    }
  }
  function fr() {
    let e2 = {};
    return { get: function(t2) {
      return e2[t2];
    }, add: function(t2, r2) {
      e2[t2] = r2;
    }, remove: function(t2) {
      delete e2[t2];
    }, removeAll: function() {
      e2 = {};
    } };
  }
  const mr = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" };
  class _r {
    constructor(e2) {
      this.parser = e2, this.name = mr.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
    }
    _markDefs() {
      const e2 = this.parser, t2 = this.parser.json.nodes || [];
      for (let r2 = 0, n2 = t2.length; r2 < n2; r2++) {
        const n3 = t2[r2];
        n3.extensions && n3.extensions[this.name] && void 0 !== n3.extensions[this.name].light && e2._addNodeRef(this.cache, n3.extensions[this.name].light);
      }
    }
    _loadLight(e2) {
      const t2 = this.parser, r2 = "light:" + e2;
      let i2 = t2.cache.get(r2);
      if (i2)
        return i2;
      const s2 = t2.json, o2 = ((s2.extensions && s2.extensions[this.name] || {}).lights || [])[e2];
      let a2;
      const l2 = new n.Ilk(16777215);
      void 0 !== o2.color && l2.fromArray(o2.color);
      const c2 = void 0 !== o2.range ? o2.range : 0;
      switch (o2.type) {
        case "directional":
          a2 = new n.Ox3(l2), a2.target.position.set(0, 0, -1), a2.add(a2.target);
          break;
        case "point":
          a2 = new n.cek(l2), a2.distance = c2;
          break;
        case "spot":
          a2 = new n.PMe(l2), a2.distance = c2, o2.spot = o2.spot || {}, o2.spot.innerConeAngle = void 0 !== o2.spot.innerConeAngle ? o2.spot.innerConeAngle : 0, o2.spot.outerConeAngle = void 0 !== o2.spot.outerConeAngle ? o2.spot.outerConeAngle : Math.PI / 4, a2.angle = o2.spot.outerConeAngle, a2.penumbra = 1 - o2.spot.innerConeAngle / o2.spot.outerConeAngle, a2.target.position.set(0, 0, -1), a2.add(a2.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + o2.type);
      }
      return a2.position.set(0, 0, 0), a2.decay = 2, void 0 !== o2.intensity && (a2.intensity = o2.intensity), a2.name = t2.createUniqueName(o2.name || "light_" + e2), i2 = Promise.resolve(a2), t2.cache.add(r2, i2), i2;
    }
    createNodeAttachment(e2) {
      const t2 = this, r2 = this.parser, n2 = r2.json.nodes[e2], i2 = (n2.extensions && n2.extensions[this.name] || {}).light;
      return void 0 === i2 ? null : this._loadLight(i2).then(function(e3) {
        return r2._getNodeRef(t2.cache, i2, e3);
      });
    }
  }
  class gr {
    constructor() {
      this.name = mr.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return n.vBJ;
    }
    extendParams(e2, t2, r2) {
      const i2 = [];
      e2.color = new n.Ilk(1, 1, 1), e2.opacity = 1;
      const s2 = t2.pbrMetallicRoughness;
      if (s2) {
        if (Array.isArray(s2.baseColorFactor)) {
          const t3 = s2.baseColorFactor;
          e2.color.fromArray(t3), e2.opacity = t3[3];
        }
        void 0 !== s2.baseColorTexture && i2.push(r2.assignTexture(e2, "map", s2.baseColorTexture, n.knz));
      }
      return Promise.all(i2);
    }
  }
  class vr {
    constructor(e2) {
      this.parser = e2, this.name = mr.KHR_MATERIALS_EMISSIVE_STRENGTH;
    }
    extendMaterialParams(e2, t2) {
      const r2 = this.parser.json.materials[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return Promise.resolve();
      const n2 = r2.extensions[this.name].emissiveStrength;
      return void 0 !== n2 && (t2.emissiveIntensity = n2), Promise.resolve();
    }
  }
  class Ar {
    constructor(e2) {
      this.parser = e2, this.name = mr.KHR_MATERIALS_CLEARCOAT;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e2, t2) {
      const r2 = this.parser, i2 = r2.json.materials[e2];
      if (!i2.extensions || !i2.extensions[this.name])
        return Promise.resolve();
      const s2 = [], o2 = i2.extensions[this.name];
      if (void 0 !== o2.clearcoatFactor && (t2.clearcoat = o2.clearcoatFactor), void 0 !== o2.clearcoatTexture && s2.push(r2.assignTexture(t2, "clearcoatMap", o2.clearcoatTexture)), void 0 !== o2.clearcoatRoughnessFactor && (t2.clearcoatRoughness = o2.clearcoatRoughnessFactor), void 0 !== o2.clearcoatRoughnessTexture && s2.push(r2.assignTexture(t2, "clearcoatRoughnessMap", o2.clearcoatRoughnessTexture)), void 0 !== o2.clearcoatNormalTexture && (s2.push(r2.assignTexture(t2, "clearcoatNormalMap", o2.clearcoatNormalTexture)), void 0 !== o2.clearcoatNormalTexture.scale)) {
        const e3 = o2.clearcoatNormalTexture.scale;
        t2.clearcoatNormalScale = new n.FM8(e3, e3);
      }
      return Promise.all(s2);
    }
  }
  class br {
    constructor(e2) {
      this.parser = e2, this.name = mr.KHR_MATERIALS_IRIDESCENCE;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e2, t2) {
      const r2 = this.parser, n2 = r2.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const i2 = [], s2 = n2.extensions[this.name];
      return void 0 !== s2.iridescenceFactor && (t2.iridescence = s2.iridescenceFactor), void 0 !== s2.iridescenceTexture && i2.push(r2.assignTexture(t2, "iridescenceMap", s2.iridescenceTexture)), void 0 !== s2.iridescenceIor && (t2.iridescenceIOR = s2.iridescenceIor), void 0 === t2.iridescenceThicknessRange && (t2.iridescenceThicknessRange = [100, 400]), void 0 !== s2.iridescenceThicknessMinimum && (t2.iridescenceThicknessRange[0] = s2.iridescenceThicknessMinimum), void 0 !== s2.iridescenceThicknessMaximum && (t2.iridescenceThicknessRange[1] = s2.iridescenceThicknessMaximum), void 0 !== s2.iridescenceThicknessTexture && i2.push(r2.assignTexture(t2, "iridescenceThicknessMap", s2.iridescenceThicknessTexture)), Promise.all(i2);
    }
  }
  class yr {
    constructor(e2) {
      this.parser = e2, this.name = mr.KHR_MATERIALS_SHEEN;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e2, t2) {
      const r2 = this.parser, i2 = r2.json.materials[e2];
      if (!i2.extensions || !i2.extensions[this.name])
        return Promise.resolve();
      const s2 = [];
      t2.sheenColor = new n.Ilk(0, 0, 0), t2.sheenRoughness = 0, t2.sheen = 1;
      const o2 = i2.extensions[this.name];
      return void 0 !== o2.sheenColorFactor && t2.sheenColor.fromArray(o2.sheenColorFactor), void 0 !== o2.sheenRoughnessFactor && (t2.sheenRoughness = o2.sheenRoughnessFactor), void 0 !== o2.sheenColorTexture && s2.push(r2.assignTexture(t2, "sheenColorMap", o2.sheenColorTexture, n.knz)), void 0 !== o2.sheenRoughnessTexture && s2.push(r2.assignTexture(t2, "sheenRoughnessMap", o2.sheenRoughnessTexture)), i2.extras && void 0 !== i2.extras.sheenFactor && (t2.sheen = i2.extras.sheenFactor, delete i2.extras.sheenFactor), Promise.all(s2);
    }
  }
  class xr {
    constructor(e2) {
      this.parser = e2, this.name = mr.KHR_MATERIALS_TRANSMISSION;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e2, t2) {
      const r2 = this.parser, n2 = r2.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const i2 = [], s2 = n2.extensions[this.name];
      return void 0 !== s2.transmissionFactor && (t2.transmission = s2.transmissionFactor), void 0 !== s2.transmissionTexture && i2.push(r2.assignTexture(t2, "transmissionMap", s2.transmissionTexture)), Promise.all(i2);
    }
  }
  class wr {
    constructor(e2) {
      this.parser = e2, this.name = mr.KHR_MATERIALS_VOLUME;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e2, t2) {
      const r2 = this.parser, i2 = r2.json.materials[e2];
      if (!i2.extensions || !i2.extensions[this.name])
        return Promise.resolve();
      const s2 = [], o2 = i2.extensions[this.name];
      t2.thickness = void 0 !== o2.thicknessFactor ? o2.thicknessFactor : 0, void 0 !== o2.thicknessTexture && s2.push(r2.assignTexture(t2, "thicknessMap", o2.thicknessTexture)), t2.attenuationDistance = o2.attenuationDistance || 0;
      const a2 = o2.attenuationColor || [1, 1, 1];
      return t2.attenuationColor = new n.Ilk(a2[0], a2[1], a2[2]), Promise.all(s2);
    }
  }
  class Er {
    constructor(e2) {
      this.parser = e2, this.name = mr.KHR_MATERIALS_IOR;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e2, t2) {
      const r2 = this.parser.json.materials[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return Promise.resolve();
      const n2 = r2.extensions[this.name];
      return t2.ior = void 0 !== n2.ior ? n2.ior : 1.5, Promise.resolve();
    }
  }
  class Sr {
    constructor(e2) {
      this.parser = e2, this.name = mr.KHR_MATERIALS_SPECULAR;
    }
    getMaterialType(e2) {
      const t2 = this.parser.json.materials[e2];
      return t2.extensions && t2.extensions[this.name] ? n.EJi : null;
    }
    extendMaterialParams(e2, t2) {
      const r2 = this.parser, i2 = r2.json.materials[e2];
      if (!i2.extensions || !i2.extensions[this.name])
        return Promise.resolve();
      const s2 = [], o2 = i2.extensions[this.name];
      t2.specularIntensity = void 0 !== o2.specularFactor ? o2.specularFactor : 1, void 0 !== o2.specularTexture && s2.push(r2.assignTexture(t2, "specularIntensityMap", o2.specularTexture));
      const a2 = o2.specularColorFactor || [1, 1, 1];
      return t2.specularColor = new n.Ilk(a2[0], a2[1], a2[2]), void 0 !== o2.specularColorTexture && s2.push(r2.assignTexture(t2, "specularColorMap", o2.specularColorTexture, n.knz)), Promise.all(s2);
    }
  }
  class Cr {
    constructor(e2) {
      this.parser = e2, this.name = mr.KHR_TEXTURE_BASISU;
    }
    loadTexture(e2) {
      const t2 = this.parser, r2 = t2.json, n2 = r2.textures[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return null;
      const i2 = n2.extensions[this.name], s2 = t2.options.ktx2Loader;
      if (!s2) {
        if (r2.extensionsRequired && r2.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        return null;
      }
      return t2.loadTextureImage(e2, i2.source, s2);
    }
  }
  class Mr {
    constructor(e2) {
      this.parser = e2, this.name = mr.EXT_TEXTURE_WEBP, this.isSupported = null;
    }
    loadTexture(e2) {
      const t2 = this.name, r2 = this.parser, n2 = r2.json, i2 = n2.textures[e2];
      if (!i2.extensions || !i2.extensions[t2])
        return null;
      const s2 = i2.extensions[t2], o2 = n2.images[s2.source];
      let a2 = r2.textureLoader;
      if (o2.uri) {
        const e3 = r2.options.manager.getHandler(o2.uri);
        null !== e3 && (a2 = e3);
      }
      return this.detectSupport().then(function(i3) {
        if (i3)
          return r2.loadTextureImage(e2, s2.source, a2);
        if (n2.extensionsRequired && n2.extensionsRequired.indexOf(t2) >= 0)
          throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        return r2.loadTexture(e2);
      });
    }
    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function(e2) {
        const t2 = new Image();
        t2.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t2.onload = t2.onerror = function() {
          e2(1 === t2.height);
        };
      })), this.isSupported;
    }
  }
  class Tr {
    constructor(e2) {
      this.name = mr.EXT_MESHOPT_COMPRESSION, this.parser = e2;
    }
    loadBufferView(e2) {
      const t2 = this.parser.json, r2 = t2.bufferViews[e2];
      if (r2.extensions && r2.extensions[this.name]) {
        const e3 = r2.extensions[this.name], n2 = this.parser.getDependency("buffer", e3.buffer), i2 = this.parser.options.meshoptDecoder;
        if (!i2 || !i2.supported) {
          if (t2.extensionsRequired && t2.extensionsRequired.indexOf(this.name) >= 0)
            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          return null;
        }
        return n2.then(function(t3) {
          const r3 = e3.byteOffset || 0, n3 = e3.byteLength || 0, s2 = e3.count, o2 = e3.byteStride, a2 = new Uint8Array(t3, r3, n3);
          return i2.decodeGltfBufferAsync ? i2.decodeGltfBufferAsync(s2, o2, a2, e3.mode, e3.filter).then(function(e4) {
            return e4.buffer;
          }) : i2.ready.then(function() {
            const t4 = new ArrayBuffer(s2 * o2);
            return i2.decodeGltfBuffer(new Uint8Array(t4), s2, o2, a2, e3.mode, e3.filter), t4;
          });
        });
      }
      return null;
    }
  }
  const Ir = "glTF";
  class kr {
    constructor(e2) {
      this.name = mr.KHR_BINARY_GLTF, this.content = null, this.body = null;
      const t2 = new DataView(e2, 0, 12);
      if (this.header = { magic: n.Zp0.decodeText(new Uint8Array(e2.slice(0, 4))), version: t2.getUint32(4, true), length: t2.getUint32(8, true) }, this.header.magic !== Ir)
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2)
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const r2 = this.header.length - 12, i2 = new DataView(e2, 12);
      let s2 = 0;
      for (; s2 < r2; ) {
        const t3 = i2.getUint32(s2, true);
        s2 += 4;
        const r3 = i2.getUint32(s2, true);
        if (s2 += 4, 1313821514 === r3) {
          const r4 = new Uint8Array(e2, 12 + s2, t3);
          this.content = n.Zp0.decodeText(r4);
        } else if (5130562 === r3) {
          const r4 = 12 + s2;
          this.body = e2.slice(r4, r4 + t3);
        }
        s2 += t3;
      }
      if (null === this.content)
        throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  class Dr {
    constructor(e2, t2) {
      if (!t2)
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      this.name = mr.KHR_DRACO_MESH_COMPRESSION, this.json = e2, this.dracoLoader = t2, this.dracoLoader.preload();
    }
    decodePrimitive(e2, t2) {
      const r2 = this.json, n2 = this.dracoLoader, i2 = e2.extensions[this.name].bufferView, s2 = e2.extensions[this.name].attributes, o2 = {}, a2 = {}, l2 = {};
      for (const e3 in s2) {
        const t3 = Vr[e3] || e3.toLowerCase();
        o2[t3] = s2[e3];
      }
      for (const t3 in e2.attributes) {
        const n3 = Vr[t3] || t3.toLowerCase();
        if (void 0 !== s2[t3]) {
          const i3 = r2.accessors[e2.attributes[t3]], s3 = Nr[i3.componentType];
          l2[n3] = s3.name, a2[n3] = true === i3.normalized;
        }
      }
      return t2.getDependency("bufferView", i2).then(function(e3) {
        return new Promise(function(t3) {
          n2.decodeDracoFile(e3, function(e4) {
            for (const t4 in e4.attributes) {
              const r3 = e4.attributes[t4], n3 = a2[t4];
              void 0 !== n3 && (r3.normalized = n3);
            }
            t3(e4);
          }, o2, l2);
        });
      });
    }
  }
  class Pr {
    constructor() {
      this.name = mr.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(e2, t2) {
      return void 0 !== t2.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t2.offset && void 0 === t2.rotation && void 0 === t2.scale || (e2 = e2.clone(), void 0 !== t2.offset && e2.offset.fromArray(t2.offset), void 0 !== t2.rotation && (e2.rotation = t2.rotation), void 0 !== t2.scale && e2.repeat.fromArray(t2.scale), e2.needsUpdate = true), e2;
    }
  }
  class Br extends n.Wid {
    constructor(e2) {
      super(), this.isGLTFSpecularGlossinessMaterial = true;
      const t2 = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join("\n"), r2 = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join("\n"), i2 = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), s2 = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), o2 = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), a2 = { specular: { value: new n.Ilk().setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } };
      this._extraUniforms = a2, this.onBeforeCompile = function(e3) {
        for (const t3 in a2)
          e3.uniforms[t3] = a2[t3];
        e3.fragmentShader = e3.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t2).replace("#include <metalnessmap_pars_fragment>", r2).replace("#include <roughnessmap_fragment>", i2).replace("#include <metalnessmap_fragment>", s2).replace("#include <lights_physical_fragment>", o2);
      }, Object.defineProperties(this, { specular: { get: function() {
        return a2.specular.value;
      }, set: function(e3) {
        a2.specular.value = e3;
      } }, specularMap: { get: function() {
        return a2.specularMap.value;
      }, set: function(e3) {
        a2.specularMap.value = e3, e3 ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
      } }, glossiness: { get: function() {
        return a2.glossiness.value;
      }, set: function(e3) {
        a2.glossiness.value = e3;
      } }, glossinessMap: { get: function() {
        return a2.glossinessMap.value;
      }, set: function(e3) {
        a2.glossinessMap.value = e3, e3 ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
      } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e2);
    }
    copy(e2) {
      return super.copy(e2), this.specularMap = e2.specularMap, this.specular.copy(e2.specular), this.glossinessMap = e2.glossinessMap, this.glossiness = e2.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
    }
  }
  class Rr {
    constructor() {
      this.name = mr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"];
    }
    getMaterialType() {
      return Br;
    }
    extendParams(e2, t2, r2) {
      const i2 = t2.extensions[this.name];
      e2.color = new n.Ilk(1, 1, 1), e2.opacity = 1;
      const s2 = [];
      if (Array.isArray(i2.diffuseFactor)) {
        const t3 = i2.diffuseFactor;
        e2.color.fromArray(t3), e2.opacity = t3[3];
      }
      if (void 0 !== i2.diffuseTexture && s2.push(r2.assignTexture(e2, "map", i2.diffuseTexture, n.knz)), e2.emissive = new n.Ilk(0, 0, 0), e2.glossiness = void 0 !== i2.glossinessFactor ? i2.glossinessFactor : 1, e2.specular = new n.Ilk(1, 1, 1), Array.isArray(i2.specularFactor) && e2.specular.fromArray(i2.specularFactor), void 0 !== i2.specularGlossinessTexture) {
        const t3 = i2.specularGlossinessTexture;
        s2.push(r2.assignTexture(e2, "glossinessMap", t3)), s2.push(r2.assignTexture(e2, "specularMap", t3, n.knz));
      }
      return Promise.all(s2);
    }
    createMaterial(e2) {
      const t2 = new Br(e2);
      return t2.fog = true, t2.color = e2.color, t2.map = void 0 === e2.map ? null : e2.map, t2.lightMap = null, t2.lightMapIntensity = 1, t2.aoMap = void 0 === e2.aoMap ? null : e2.aoMap, t2.aoMapIntensity = 1, t2.emissive = e2.emissive, t2.emissiveIntensity = void 0 === e2.emissiveIntensity ? 1 : e2.emissiveIntensity, t2.emissiveMap = void 0 === e2.emissiveMap ? null : e2.emissiveMap, t2.bumpMap = void 0 === e2.bumpMap ? null : e2.bumpMap, t2.bumpScale = 1, t2.normalMap = void 0 === e2.normalMap ? null : e2.normalMap, t2.normalMapType = n.IOt, e2.normalScale && (t2.normalScale = e2.normalScale), t2.displacementMap = null, t2.displacementScale = 1, t2.displacementBias = 0, t2.specularMap = void 0 === e2.specularMap ? null : e2.specularMap, t2.specular = e2.specular, t2.glossinessMap = void 0 === e2.glossinessMap ? null : e2.glossinessMap, t2.glossiness = e2.glossiness, t2.alphaMap = null, t2.envMap = void 0 === e2.envMap ? null : e2.envMap, t2.envMapIntensity = 1, t2;
    }
  }
  class Lr {
    constructor() {
      this.name = mr.KHR_MESH_QUANTIZATION;
    }
  }
  class Or extends n._C8 {
    constructor(e2, t2, r2, n2) {
      super(e2, t2, r2, n2);
    }
    copySampleValue_(e2) {
      const t2 = this.resultBuffer, r2 = this.sampleValues, n2 = this.valueSize, i2 = e2 * n2 * 3 + n2;
      for (let e3 = 0; e3 !== n2; e3++)
        t2[e3] = r2[i2 + e3];
      return t2;
    }
    interpolate_(e2, t2, r2, n2) {
      const i2 = this.resultBuffer, s2 = this.sampleValues, o2 = this.valueSize, a2 = 2 * o2, l2 = 3 * o2, c2 = n2 - t2, u2 = (r2 - t2) / c2, h2 = u2 * u2, p2 = h2 * u2, d2 = e2 * l2, f2 = d2 - l2, m2 = -2 * p2 + 3 * h2, _2 = p2 - h2, g2 = 1 - m2, v2 = _2 - h2 + u2;
      for (let e3 = 0; e3 !== o2; e3++) {
        const t3 = s2[f2 + e3 + o2], r3 = s2[f2 + e3 + a2] * c2, n3 = s2[d2 + e3 + o2], l3 = s2[d2 + e3] * c2;
        i2[e3] = g2 * t3 + v2 * r3 + m2 * n3 + _2 * l3;
      }
      return i2;
    }
  }
  const Fr = new n._fP();
  class Ur extends Or {
    interpolate_(e2, t2, r2, n2) {
      const i2 = super.interpolate_(e2, t2, r2, n2);
      return Fr.fromArray(i2).normalize().toArray(i2), i2;
    }
  }
  const Nr = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, jr = { 9728: n.TyD, 9729: n.wem, 9984: n.YLQ, 9985: n.qyh, 9986: n.aH4, 9987: n.D1R }, zr = { 33071: n.uWy, 33648: n.OoA, 10497: n.rpg }, Gr = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, Vr = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, Qr = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, Hr = { CUBICSPLINE: void 0, LINEAR: n.NMF, STEP: n.Syv };
  function Wr(e2, t2, r2) {
    for (const n2 in r2.extensions)
      void 0 === e2[n2] && (t2.userData.gltfExtensions = t2.userData.gltfExtensions || {}, t2.userData.gltfExtensions[n2] = r2.extensions[n2]);
  }
  function qr(e2, t2) {
    void 0 !== t2.extras && ("object" == typeof t2.extras ? Object.assign(e2.userData, t2.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t2.extras));
  }
  function Xr(e2, t2) {
    if (e2.updateMorphTargets(), void 0 !== t2.weights)
      for (let r2 = 0, n2 = t2.weights.length; r2 < n2; r2++)
        e2.morphTargetInfluences[r2] = t2.weights[r2];
    if (t2.extras && Array.isArray(t2.extras.targetNames)) {
      const r2 = t2.extras.targetNames;
      if (e2.morphTargetInfluences.length === r2.length) {
        e2.morphTargetDictionary = {};
        for (let t3 = 0, n2 = r2.length; t3 < n2; t3++)
          e2.morphTargetDictionary[r2[t3]] = t3;
      } else
        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
  function Yr(e2) {
    const t2 = e2.extensions && e2.extensions[mr.KHR_DRACO_MESH_COMPRESSION];
    let r2;
    return r2 = t2 ? "draco:" + t2.bufferView + ":" + t2.indices + ":" + Kr(t2.attributes) : e2.indices + ":" + Kr(e2.attributes) + ":" + e2.mode, r2;
  }
  function Kr(e2) {
    let t2 = "";
    const r2 = Object.keys(e2).sort();
    for (let n2 = 0, i2 = r2.length; n2 < i2; n2++)
      t2 += r2[n2] + ":" + e2[r2[n2]] + ";";
    return t2;
  }
  function Jr(e2) {
    switch (e2) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
  }
  class Zr {
    constructor(e2 = {}, t2 = {}) {
      this.json = e2, this.extensions = {}, this.plugins = {}, this.options = t2, this.cache = new fr(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
      const r2 = true === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), i2 = navigator.userAgent.indexOf("Firefox") > -1, s2 = i2 ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
      "undefined" == typeof createImageBitmap || r2 || i2 && s2 < 98 ? this.textureLoader = new n.dpR(this.options.manager) : this.textureLoader = new n.QRU(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new n.hH6(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(true);
    }
    setExtensions(e2) {
      this.extensions = e2;
    }
    setPlugins(e2) {
      this.plugins = e2;
    }
    parse(e2, t2) {
      const r2 = this, n2 = this.json, i2 = this.extensions;
      this.cache.removeAll(), this._invokeAll(function(e3) {
        return e3._markDefs && e3._markDefs();
      }), Promise.all(this._invokeAll(function(e3) {
        return e3.beforeRoot && e3.beforeRoot();
      })).then(function() {
        return Promise.all([r2.getDependencies("scene"), r2.getDependencies("animation"), r2.getDependencies("camera")]);
      }).then(function(t3) {
        const s2 = { scene: t3[0][n2.scene || 0], scenes: t3[0], animations: t3[1], cameras: t3[2], asset: n2.asset, parser: r2, userData: {} };
        Wr(i2, s2, n2), qr(s2, n2), Promise.all(r2._invokeAll(function(e3) {
          return e3.afterRoot && e3.afterRoot(s2);
        })).then(function() {
          e2(s2);
        });
      }).catch(t2);
    }
    _markDefs() {
      const e2 = this.json.nodes || [], t2 = this.json.skins || [], r2 = this.json.meshes || [];
      for (let r3 = 0, n2 = t2.length; r3 < n2; r3++) {
        const n3 = t2[r3].joints;
        for (let t3 = 0, r4 = n3.length; t3 < r4; t3++)
          e2[n3[t3]].isBone = true;
      }
      for (let t3 = 0, n2 = e2.length; t3 < n2; t3++) {
        const n3 = e2[t3];
        void 0 !== n3.mesh && (this._addNodeRef(this.meshCache, n3.mesh), void 0 !== n3.skin && (r2[n3.mesh].isSkinnedMesh = true)), void 0 !== n3.camera && this._addNodeRef(this.cameraCache, n3.camera);
      }
    }
    _addNodeRef(e2, t2) {
      void 0 !== t2 && (void 0 === e2.refs[t2] && (e2.refs[t2] = e2.uses[t2] = 0), e2.refs[t2]++);
    }
    _getNodeRef(e2, t2, r2) {
      if (e2.refs[t2] <= 1)
        return r2;
      const n2 = r2.clone(), i2 = (e3, t3) => {
        const r3 = this.associations.get(e3);
        null != r3 && this.associations.set(t3, r3);
        for (const [r4, n3] of e3.children.entries())
          i2(n3, t3.children[r4]);
      };
      return i2(r2, n2), n2.name += "_instance_" + e2.uses[t2]++, n2;
    }
    _invokeOne(e2) {
      const t2 = Object.values(this.plugins);
      t2.push(this);
      for (let r2 = 0; r2 < t2.length; r2++) {
        const n2 = e2(t2[r2]);
        if (n2)
          return n2;
      }
      return null;
    }
    _invokeAll(e2) {
      const t2 = Object.values(this.plugins);
      t2.unshift(this);
      const r2 = [];
      for (let n2 = 0; n2 < t2.length; n2++) {
        const i2 = e2(t2[n2]);
        i2 && r2.push(i2);
      }
      return r2;
    }
    getDependency(e2, t2) {
      const r2 = e2 + ":" + t2;
      let n2 = this.cache.get(r2);
      if (!n2) {
        switch (e2) {
          case "scene":
            n2 = this.loadScene(t2);
            break;
          case "node":
            n2 = this.loadNode(t2);
            break;
          case "mesh":
            n2 = this._invokeOne(function(e3) {
              return e3.loadMesh && e3.loadMesh(t2);
            });
            break;
          case "accessor":
            n2 = this.loadAccessor(t2);
            break;
          case "bufferView":
            n2 = this._invokeOne(function(e3) {
              return e3.loadBufferView && e3.loadBufferView(t2);
            });
            break;
          case "buffer":
            n2 = this.loadBuffer(t2);
            break;
          case "material":
            n2 = this._invokeOne(function(e3) {
              return e3.loadMaterial && e3.loadMaterial(t2);
            });
            break;
          case "texture":
            n2 = this._invokeOne(function(e3) {
              return e3.loadTexture && e3.loadTexture(t2);
            });
            break;
          case "skin":
            n2 = this.loadSkin(t2);
            break;
          case "animation":
            n2 = this._invokeOne(function(e3) {
              return e3.loadAnimation && e3.loadAnimation(t2);
            });
            break;
          case "camera":
            n2 = this.loadCamera(t2);
            break;
          default:
            throw new Error("Unknown type: " + e2);
        }
        this.cache.add(r2, n2);
      }
      return n2;
    }
    getDependencies(e2) {
      let t2 = this.cache.get(e2);
      if (!t2) {
        const r2 = this, n2 = this.json[e2 + ("mesh" === e2 ? "es" : "s")] || [];
        t2 = Promise.all(n2.map(function(t3, n3) {
          return r2.getDependency(e2, n3);
        })), this.cache.add(e2, t2);
      }
      return t2;
    }
    loadBuffer(e2) {
      const t2 = this.json.buffers[e2], r2 = this.fileLoader;
      if (t2.type && "arraybuffer" !== t2.type)
        throw new Error("THREE.GLTFLoader: " + t2.type + " buffer type is not supported.");
      if (void 0 === t2.uri && 0 === e2)
        return Promise.resolve(this.extensions[mr.KHR_BINARY_GLTF].body);
      const i2 = this.options;
      return new Promise(function(e3, s2) {
        r2.load(n.Zp0.resolveURL(t2.uri, i2.path), e3, void 0, function() {
          s2(new Error('THREE.GLTFLoader: Failed to load buffer "' + t2.uri + '".'));
        });
      });
    }
    loadBufferView(e2) {
      const t2 = this.json.bufferViews[e2];
      return this.getDependency("buffer", t2.buffer).then(function(e3) {
        const r2 = t2.byteLength || 0, n2 = t2.byteOffset || 0;
        return e3.slice(n2, n2 + r2);
      });
    }
    loadAccessor(e2) {
      const t2 = this, r2 = this.json, i2 = this.json.accessors[e2];
      if (void 0 === i2.bufferView && void 0 === i2.sparse)
        return Promise.resolve(null);
      const s2 = [];
      return void 0 !== i2.bufferView ? s2.push(this.getDependency("bufferView", i2.bufferView)) : s2.push(null), void 0 !== i2.sparse && (s2.push(this.getDependency("bufferView", i2.sparse.indices.bufferView)), s2.push(this.getDependency("bufferView", i2.sparse.values.bufferView))), Promise.all(s2).then(function(e3) {
        const s3 = e3[0], o2 = Gr[i2.type], a2 = Nr[i2.componentType], l2 = a2.BYTES_PER_ELEMENT, c2 = l2 * o2, u2 = i2.byteOffset || 0, h2 = void 0 !== i2.bufferView ? r2.bufferViews[i2.bufferView].byteStride : void 0, p2 = true === i2.normalized;
        let d2, f2;
        if (h2 && h2 !== c2) {
          const e4 = Math.floor(u2 / h2), r3 = "InterleavedBuffer:" + i2.bufferView + ":" + i2.componentType + ":" + e4 + ":" + i2.count;
          let c3 = t2.cache.get(r3);
          c3 || (d2 = new a2(s3, e4 * h2, i2.count * h2 / l2), c3 = new n.vpT(d2, h2 / l2), t2.cache.add(r3, c3)), f2 = new n.kB5(c3, o2, u2 % h2 / l2, p2);
        } else
          d2 = null === s3 ? new a2(i2.count * o2) : new a2(s3, u2, i2.count * o2), f2 = new n.TlE(d2, o2, p2);
        if (void 0 !== i2.sparse) {
          const t3 = Gr.SCALAR, r3 = Nr[i2.sparse.indices.componentType], l3 = i2.sparse.indices.byteOffset || 0, c3 = i2.sparse.values.byteOffset || 0, u3 = new r3(e3[1], l3, i2.sparse.count * t3), h3 = new a2(e3[2], c3, i2.sparse.count * o2);
          null !== s3 && (f2 = new n.TlE(f2.array.slice(), f2.itemSize, f2.normalized));
          for (let e4 = 0, t4 = u3.length; e4 < t4; e4++) {
            const t5 = u3[e4];
            if (f2.setX(t5, h3[e4 * o2]), o2 >= 2 && f2.setY(t5, h3[e4 * o2 + 1]), o2 >= 3 && f2.setZ(t5, h3[e4 * o2 + 2]), o2 >= 4 && f2.setW(t5, h3[e4 * o2 + 3]), o2 >= 5)
              throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
          }
        }
        return f2;
      });
    }
    loadTexture(e2) {
      const t2 = this.json, r2 = this.options, n2 = t2.textures[e2].source, i2 = t2.images[n2];
      let s2 = this.textureLoader;
      if (i2.uri) {
        const e3 = r2.manager.getHandler(i2.uri);
        null !== e3 && (s2 = e3);
      }
      return this.loadTextureImage(e2, n2, s2);
    }
    loadTextureImage(e2, t2, r2) {
      const i2 = this, s2 = this.json, o2 = s2.textures[e2], a2 = s2.images[t2], l2 = (a2.uri || a2.bufferView) + ":" + o2.sampler;
      if (this.textureCache[l2])
        return this.textureCache[l2];
      const c2 = this.loadImageSource(t2, r2).then(function(t3) {
        o2.name && (t3.name = o2.name);
        const r3 = (s2.samplers || {})[o2.sampler] || {};
        return t3.magFilter = jr[r3.magFilter] || n.wem, t3.minFilter = jr[r3.minFilter] || n.D1R, t3.wrapS = zr[r3.wrapS] || n.rpg, t3.wrapT = zr[r3.wrapT] || n.rpg, r3.extras && void 0 !== r3.extras.uuid && (t3.uuid = r3.extras.uuid), i2.associations.set(t3, { textures: e2 }), t3;
      }).catch(function() {
        return null;
      });
      return this.textureCache[l2] = c2, c2;
    }
    loadImageSource(e2, t2) {
      const r2 = this, i2 = this.json, s2 = this.options;
      if (void 0 !== this.sourceCache[e2])
        return this.sourceCache[e2].then((e3) => e3.clone());
      const o2 = i2.images[e2], a2 = self.URL || self.webkitURL;
      let l2 = o2.uri || "", c2 = false;
      if (void 0 !== o2.bufferView)
        l2 = r2.getDependency("bufferView", o2.bufferView).then(function(e3) {
          c2 = true;
          const t3 = new Blob([e3], { type: o2.mimeType });
          return l2 = a2.createObjectURL(t3), l2;
        });
      else if (void 0 === o2.uri)
        throw new Error("THREE.GLTFLoader: Image " + e2 + " is missing URI and bufferView");
      const u2 = Promise.resolve(l2).then(function(e3) {
        return new Promise(function(i3, o3) {
          let a3 = i3;
          true === t2.isImageBitmapLoader && (a3 = function(e4) {
            const t3 = new n.xEZ(e4);
            t3.needsUpdate = true, i3(t3);
          }), t2.load(n.Zp0.resolveURL(e3, s2.path), a3, void 0, function(l3) {
            true === t2.isImageBitmapLoader ? (t2 = new n.dpR(r2.options.manager), a3 = i3, t2.setCrossOrigin(r2.options.crossOrigin), t2.setRequestHeader(r2.options.requestHeader), t2.load(n.Zp0.resolveURL(e3, s2.path), a3, void 0, o3)) : o3(l3);
          });
        });
      }).then(function(e3) {
        var r3;
        if (true === c2 && a2.revokeObjectURL(l2), e3.userData.mimeType = o2.mimeType || ((r3 = o2.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === r3.search(/^data\:image\/jpeg/) ? "image/jpeg" : r3.search(/\.webp($|\?)/i) > 0 || 0 === r3.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e3.flipY = false, o2.extras) {
          if (void 0 !== o2.extras.flipY) {
            if (true === t2.isImageBitmapLoader && void 0 !== typeof createImageBitmap) {
              const t3 = e3, r4 = o2.extras.flipY && !t3.flipY;
              createImageBitmap(t3.source.data, { imageOrientation: r4 ? "flipY" : "none" }).then(function(e4) {
                t3.source.data.close && t3.source.data.close(), t3.source.data = e4, t3.source.needsUpdate = true, t3.needsUpdate = true;
              });
            }
            e3.flipY = o2.extras.flipY, e3.needsUpdate = true, delete o2.extras.flipY;
          }
          void 0 !== o2.extras.uuid && (e3.source.uuid = o2.extras.uuid), void 0 !== o2.extras.t_uuid && (e3.uuid = o2.extras.t_uuid);
        }
        return o2.uri && "string" == typeof o2.uri && (e3.userData.rootPath = o2.uri), e3;
      }).catch(function(e3) {
        throw console.error("THREE.GLTFLoader: Couldn't load texture", l2), e3;
      });
      return this.sourceCache[e2] = u2, u2;
    }
    assignTexture(e2, t2, r2, n2) {
      const i2 = this;
      return this.getDependency("texture", r2.index).then(function(s2) {
        if (void 0 === r2.texCoord || 0 == r2.texCoord || "aoMap" === t2 && 1 == r2.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + r2.texCoord + " for texture " + t2 + " not yet supported."), i2.extensions[mr.KHR_TEXTURE_TRANSFORM]) {
          const e3 = void 0 !== r2.extensions ? r2.extensions[mr.KHR_TEXTURE_TRANSFORM] : void 0;
          if (e3) {
            const t3 = i2.associations.get(s2);
            s2 = i2.extensions[mr.KHR_TEXTURE_TRANSFORM].extendTexture(s2, e3), i2.associations.set(s2, t3);
          }
        }
        return void 0 !== n2 && (s2.encoding = n2), e2[t2] = s2, s2;
      });
    }
    assignFinalMaterial(e2) {
      const t2 = e2.geometry;
      let r2 = e2.material;
      const i2 = void 0 === t2.attributes.tangent, s2 = void 0 !== t2.attributes.color, o2 = void 0 === t2.attributes.normal;
      if (e2.isPoints) {
        const e3 = "PointsMaterial:" + r2.uuid;
        let t3 = this.cache.get(e3);
        t3 || (t3 = new n.UY4(), n.F5T.prototype.copy.call(t3, r2), t3.color.copy(r2.color), t3.map = r2.map, t3.sizeAttenuation = false, this.cache.add(e3, t3)), r2 = t3;
      } else if (e2.isLine) {
        const e3 = "LineBasicMaterial:" + r2.uuid;
        let t3 = this.cache.get(e3);
        t3 || (t3 = new n.nls(), n.F5T.prototype.copy.call(t3, r2), t3.color.copy(r2.color), this.cache.add(e3, t3)), r2 = t3;
      }
      if (i2 || s2 || o2) {
        let e3 = "ClonedMaterial:" + r2.uuid + ":";
        r2.isGLTFSpecularGlossinessMaterial && (e3 += "specular-glossiness:"), i2 && (e3 += "derivative-tangents:"), s2 && (e3 += "vertex-colors:"), o2 && (e3 += "flat-shading:");
        let t3 = this.cache.get(e3);
        t3 || (t3 = r2.clone(), s2 && (t3.vertexColors = true), o2 && (t3.flatShading = true), i2 && (t3.normalScale && (t3.normalScale.y *= -1), t3.clearcoatNormalScale && (t3.clearcoatNormalScale.y *= -1)), this.cache.add(e3, t3), this.associations.set(t3, this.associations.get(r2))), r2 = t3;
      }
      r2.aoMap && void 0 === t2.attributes.uv2 && void 0 !== t2.attributes.uv && t2.setAttribute("uv2", t2.attributes.uv), e2.material = r2;
    }
    getMaterialType() {
      return n.Wid;
    }
    loadMaterial(e2) {
      const t2 = this, r2 = this.json, i2 = this.extensions, s2 = r2.materials[e2];
      let o2;
      const a2 = {}, l2 = s2.extensions || {}, c2 = [];
      if (l2[mr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        const e3 = i2[mr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        o2 = e3.getMaterialType(), c2.push(e3.extendParams(a2, s2, t2));
      } else if (l2[mr.KHR_MATERIALS_UNLIT]) {
        const e3 = i2[mr.KHR_MATERIALS_UNLIT];
        o2 = e3.getMaterialType(), c2.push(e3.extendParams(a2, s2, t2));
      } else {
        const r3 = s2.pbrMetallicRoughness || {};
        if (a2.color = new n.Ilk(1, 1, 1), a2.opacity = 1, Array.isArray(r3.baseColorFactor)) {
          const e3 = r3.baseColorFactor;
          a2.color.fromArray(e3), a2.opacity = e3[3];
        }
        void 0 !== r3.baseColorTexture && c2.push(t2.assignTexture(a2, "map", r3.baseColorTexture, n.knz)), a2.metalness = void 0 !== r3.metallicFactor ? r3.metallicFactor : 1, a2.roughness = void 0 !== r3.roughnessFactor ? r3.roughnessFactor : 1, void 0 !== r3.metallicRoughnessTexture && (c2.push(t2.assignTexture(a2, "metalnessMap", r3.metallicRoughnessTexture)), c2.push(t2.assignTexture(a2, "roughnessMap", r3.metallicRoughnessTexture))), o2 = this._invokeOne(function(t3) {
          return t3.getMaterialType && t3.getMaterialType(e2);
        }), c2.push(Promise.all(this._invokeAll(function(t3) {
          return t3.extendMaterialParams && t3.extendMaterialParams(e2, a2);
        })));
      }
      true === s2.doubleSided && (a2.side = n.ehD);
      const u2 = s2.alphaMode || "OPAQUE";
      if ("BLEND" === u2 ? (a2.transparent = true, a2.depthWrite = false) : (a2.transparent = false, "MASK" === u2 && (a2.alphaTest = void 0 !== s2.alphaCutoff ? s2.alphaCutoff : 0.5)), void 0 !== s2.normalTexture && o2 !== n.vBJ && (c2.push(t2.assignTexture(a2, "normalMap", s2.normalTexture)), a2.normalScale = new n.FM8(1, 1), void 0 !== s2.normalTexture.scale)) {
        const e3 = s2.normalTexture.scale;
        a2.normalScale.set(e3, e3);
      }
      return void 0 !== s2.occlusionTexture && o2 !== n.vBJ && (c2.push(t2.assignTexture(a2, "aoMap", s2.occlusionTexture)), void 0 !== s2.occlusionTexture.strength && (a2.aoMapIntensity = s2.occlusionTexture.strength)), void 0 !== s2.emissiveFactor && o2 !== n.vBJ && (a2.emissive = new n.Ilk().fromArray(s2.emissiveFactor)), void 0 !== s2.emissiveTexture && o2 !== n.vBJ && c2.push(t2.assignTexture(a2, "emissiveMap", s2.emissiveTexture, n.knz)), Promise.all(c2).then(function() {
        let r3;
        return r3 = o2 === Br ? i2[mr.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a2) : new o2(a2), s2.name && (r3.name = s2.name), qr(r3, s2), t2.associations.set(r3, { materials: e2 }), s2.extensions && Wr(i2, r3, s2), r3;
      });
    }
    createUniqueName(e2) {
      const t2 = n.iUV.sanitizeNodeName(e2 || "");
      let r2 = t2;
      for (let e3 = 1; this.nodeNamesUsed[r2]; ++e3)
        r2 = t2 + "_" + e3;
      return this.nodeNamesUsed[r2] = true, r2;
    }
    loadGeometries(e2) {
      const t2 = this, r2 = this.extensions, i2 = this.primitiveCache;
      function s2(e3) {
        return r2[mr.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e3, t2).then(function(r3) {
          return en(r3, e3, t2);
        });
      }
      const o2 = [];
      for (let r3 = 0, a2 = e2.length; r3 < a2; r3++) {
        const a3 = e2[r3], l2 = Yr(a3), c2 = i2[l2];
        if (c2)
          o2.push(c2.promise);
        else {
          let e3;
          e3 = a3.extensions && a3.extensions[mr.KHR_DRACO_MESH_COMPRESSION] ? s2(a3) : en(new n.u9r(), a3, t2), i2[l2] = { primitive: a3, promise: e3 }, o2.push(e3);
        }
      }
      return Promise.all(o2);
    }
    loadMesh(e2) {
      const t2 = this, r2 = this.json, i2 = this.extensions, s2 = r2.meshes[e2], o2 = s2.primitives, a2 = [];
      for (let e3 = 0, t3 = o2.length; e3 < t3; e3++) {
        const t4 = void 0 === o2[e3].material ? (void 0 === (l2 = this.cache).DefaultMaterial && (l2.DefaultMaterial = new n.Wid({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: n.Wl3 })), l2.DefaultMaterial) : this.getDependency("material", o2[e3].material);
        a2.push(t4);
      }
      var l2;
      return a2.push(t2.loadGeometries(o2)), Promise.all(a2).then(function(r3) {
        const a3 = r3.slice(0, r3.length - 1), l3 = r3[r3.length - 1], c2 = [];
        for (let r4 = 0, u3 = l3.length; r4 < u3; r4++) {
          const u4 = l3[r4], h2 = o2[r4];
          let p2;
          const d2 = a3[r4];
          if (4 === h2.mode || 5 === h2.mode || 6 === h2.mode || void 0 === h2.mode)
            p2 = true === s2.isSkinnedMesh ? new n.TUv(u4, d2) : new n.Kj0(u4, d2), true !== p2.isSkinnedMesh || p2.geometry.attributes.skinWeight.normalized || p2.normalizeSkinWeights(), 5 === h2.mode ? p2.geometry = tn(p2.geometry, n.UlW) : 6 === h2.mode && (p2.geometry = tn(p2.geometry, n.z$h));
          else if (1 === h2.mode)
            p2 = new n.ejS(u4, d2);
          else if (3 === h2.mode)
            p2 = new n.x12(u4, d2);
          else if (2 === h2.mode)
            p2 = new n.blk(u4, d2);
          else {
            if (0 !== h2.mode)
              throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h2.mode);
            p2 = new n.woe(u4, d2);
          }
          Object.keys(p2.geometry.morphAttributes).length > 0 && Xr(p2, s2), p2.name = t2.createUniqueName(s2.name || "mesh_" + e2), qr(p2, s2), h2.extensions && Wr(i2, p2, h2), t2.assignFinalMaterial(p2), c2.push(p2);
        }
        s2.extensions && c2.forEach((e3) => Wr(i2, e3, s2));
        for (let r4 = 0, n2 = c2.length; r4 < n2; r4++)
          t2.associations.set(c2[r4], { meshes: e2, primitives: r4 });
        if (1 === c2.length)
          return c2[0];
        const u2 = new n.ZAu();
        t2.associations.set(u2, { meshes: e2 });
        for (let e3 = 0, t3 = c2.length; e3 < t3; e3++)
          u2.add(c2[e3]);
        return u2;
      });
    }
    loadCamera(e2) {
      let t2;
      const r2 = this.json.cameras[e2], i2 = r2[r2.type];
      if (i2)
        return "perspective" === r2.type ? t2 = new n.cPb(n.M8C.radToDeg(i2.yfov), i2.aspectRatio || 1, i2.znear || 1, i2.zfar || 2e6) : "orthographic" === r2.type && (t2 = new n.iKG(-i2.xmag, i2.xmag, i2.ymag, -i2.ymag, i2.znear, i2.zfar)), r2.name && (t2.name = this.createUniqueName(r2.name)), qr(t2, r2), Promise.resolve(t2);
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
    }
    loadSkin(e2) {
      const t2 = this.json.skins[e2], r2 = { joints: t2.joints };
      return void 0 === t2.inverseBindMatrices ? Promise.resolve(r2) : this.getDependency("accessor", t2.inverseBindMatrices).then(function(e3) {
        return r2.inverseBindMatrices = e3, r2;
      });
    }
    loadAnimation(e2) {
      const t2 = this.json.animations[e2], r2 = [], i2 = [], s2 = [], o2 = [], a2 = [];
      for (let e3 = 0, n2 = t2.channels.length; e3 < n2; e3++) {
        const n3 = t2.channels[e3], l2 = t2.samplers[n3.sampler], c2 = n3.target, u2 = c2.node, h2 = void 0 !== t2.parameters ? t2.parameters[l2.input] : l2.input, p2 = void 0 !== t2.parameters ? t2.parameters[l2.output] : l2.output;
        r2.push(this.getDependency("node", u2)), i2.push(this.getDependency("accessor", h2)), s2.push(this.getDependency("accessor", p2)), o2.push(l2), a2.push(c2);
      }
      return Promise.all([Promise.all(r2), Promise.all(i2), Promise.all(s2), Promise.all(o2), Promise.all(a2)]).then(function(r3) {
        const i3 = r3[0], s3 = r3[1], o3 = r3[2], a3 = r3[3], l2 = r3[4], c2 = [];
        for (let e3 = 0, t3 = i3.length; e3 < t3; e3++) {
          const t4 = i3[e3], r4 = s3[e3], u3 = o3[e3], h2 = a3[e3], p2 = l2[e3];
          if (void 0 === t4)
            continue;
          let d2;
          switch (t4.updateMatrix(), Qr[p2.path]) {
            case Qr.weights:
              d2 = n.dUE;
              break;
            case Qr.rotation:
              d2 = n.iLg;
              break;
            default:
              d2 = n.yC1;
          }
          const f2 = t4.name ? t4.name : t4.uuid, m2 = void 0 !== h2.interpolation ? Hr[h2.interpolation] : n.NMF, _2 = [];
          Qr[p2.path] === Qr.weights ? t4.traverse(function(e4) {
            e4.morphTargetInfluences && _2.push(e4.name ? e4.name : e4.uuid);
          }) : _2.push(f2);
          let g2 = u3.array;
          if (u3.normalized) {
            const e4 = Jr(g2.constructor), t5 = new Float32Array(g2.length);
            for (let r5 = 0, n2 = g2.length; r5 < n2; r5++)
              t5[r5] = g2[r5] * e4;
            g2 = t5;
          }
          for (let e4 = 0, t5 = _2.length; e4 < t5; e4++) {
            const t6 = new d2(_2[e4] + "." + Qr[p2.path], r4.array, g2, m2);
            "CUBICSPLINE" === h2.interpolation && (t6.createInterpolant = function(e5) {
              return new (this instanceof n.iLg ? Ur : Or)(this.times, this.values, this.getValueSize() / 3, e5);
            }, t6.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), c2.push(t6);
          }
        }
        const u2 = t2.name ? t2.name : "animation_" + e2;
        return new n.m7l(u2, void 0, c2);
      });
    }
    createNodeMesh(e2) {
      const t2 = this.json, r2 = this, n2 = t2.nodes[e2];
      return void 0 === n2.mesh ? null : r2.getDependency("mesh", n2.mesh).then(function(e3) {
        const t3 = r2._getNodeRef(r2.meshCache, n2.mesh, e3);
        return void 0 !== n2.weights && t3.traverse(function(e4) {
          if (e4.isMesh)
            for (let t4 = 0, r3 = n2.weights.length; t4 < r3; t4++)
              e4.morphTargetInfluences[t4] = n2.weights[t4];
        }), t3;
      });
    }
    loadNode(e2) {
      const t2 = this.json, r2 = this.extensions, i2 = this, s2 = t2.nodes[e2], o2 = s2.name ? i2.createUniqueName(s2.name) : "";
      return function() {
        const t3 = [], r3 = i2._invokeOne(function(t4) {
          return t4.createNodeMesh && t4.createNodeMesh(e2);
        });
        return r3 && t3.push(r3), void 0 !== s2.camera && t3.push(i2.getDependency("camera", s2.camera).then(function(e3) {
          return i2._getNodeRef(i2.cameraCache, s2.camera, e3);
        })), i2._invokeAll(function(t4) {
          return t4.createNodeAttachment && t4.createNodeAttachment(e2);
        }).forEach(function(e3) {
          t3.push(e3);
        }), Promise.all(t3);
      }().then(function(t3) {
        let a2;
        if (a2 = true === s2.isBone ? new n.N$j() : t3.length > 1 ? new n.ZAu() : 1 === t3.length ? t3[0] : new n.Tme(), a2 !== t3[0])
          for (let e3 = 0, r3 = t3.length; e3 < r3; e3++)
            a2.add(t3[e3]);
        if (s2.name && (a2.userData.name = s2.name, a2.name = o2), qr(a2, s2), s2.extensions && Wr(r2, a2, s2), void 0 !== s2.matrix) {
          const e3 = new n.yGw();
          e3.fromArray(s2.matrix), a2.applyMatrix4(e3);
        } else
          void 0 !== s2.translation && a2.position.fromArray(s2.translation), void 0 !== s2.rotation && a2.quaternion.fromArray(s2.rotation), void 0 !== s2.scale && a2.scale.fromArray(s2.scale);
        return i2.associations.has(a2) || i2.associations.set(a2, {}), i2.associations.get(a2).nodes = e2, a2;
      });
    }
    loadScene(e2) {
      const t2 = this.json, r2 = this.extensions, i2 = this.json.scenes[e2], s2 = this, o2 = new n.ZAu();
      i2.name && (o2.name = s2.createUniqueName(i2.name)), qr(o2, i2), i2.extensions && Wr(r2, o2, i2);
      const a2 = i2.nodes || [], l2 = [];
      for (let e3 = 0, r3 = a2.length; e3 < r3; e3++)
        l2.push($r(a2[e3], o2, t2, s2));
      return Promise.all(l2).then(function() {
        return s2.associations = ((e3) => {
          const t3 = /* @__PURE__ */ new Map();
          for (const [e4, r3] of s2.associations)
            (e4 instanceof n.F5T || e4 instanceof n.xEZ) && t3.set(e4, r3);
          return e3.traverse((e4) => {
            const r3 = s2.associations.get(e4);
            null != r3 && t3.set(e4, r3);
          }), t3;
        })(o2), o2;
      });
    }
  }
  function $r(e2, t2, r2, i2) {
    const s2 = r2.nodes[e2];
    return i2.getDependency("node", e2).then(function(e3) {
      if (void 0 === s2.skin)
        return e3;
      let t3;
      return i2.getDependency("skin", s2.skin).then(function(e4) {
        t3 = e4;
        const r3 = [];
        for (let e5 = 0, n2 = t3.joints.length; e5 < n2; e5++)
          r3.push(i2.getDependency("node", t3.joints[e5]));
        return Promise.all(r3);
      }).then(function(r3) {
        return e3.traverse(function(e4) {
          if (!e4.isMesh)
            return;
          const i3 = [], s3 = [];
          for (let e5 = 0, o2 = r3.length; e5 < o2; e5++) {
            const o3 = r3[e5];
            if (o3) {
              i3.push(o3);
              const r4 = new n.yGw();
              void 0 !== t3.inverseBindMatrices && r4.fromArray(t3.inverseBindMatrices.array, 16 * e5), s3.push(r4);
            } else
              console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t3.joints[e5]);
          }
          e4.bind(new n.OdW(i3, s3), e4.matrixWorld);
        }), e3;
      });
    }).then(function(e3) {
      t2.add(e3);
      const n2 = [];
      if (s2.children) {
        const t3 = s2.children;
        for (let s3 = 0, o2 = t3.length; s3 < o2; s3++) {
          const o3 = t3[s3];
          n2.push($r(o3, e3, r2, i2));
        }
      }
      return Promise.all(n2);
    });
  }
  function en(e2, t2, r2) {
    const i2 = t2.attributes, s2 = [];
    function o2(t3, n2) {
      return r2.getDependency("accessor", t3).then(function(t4) {
        e2.setAttribute(n2, t4);
      });
    }
    for (const t3 in i2) {
      const r3 = Vr[t3] || t3.toLowerCase();
      r3 in e2.attributes || s2.push(o2(i2[t3], r3));
    }
    if (void 0 !== t2.indices && !e2.index) {
      const n2 = r2.getDependency("accessor", t2.indices).then(function(t3) {
        e2.setIndex(t3);
      });
      s2.push(n2);
    }
    return qr(e2, t2), function(e3, t3, r3) {
      const i3 = t3.attributes, s3 = new n.ZzF();
      if (void 0 === i3.POSITION)
        return;
      {
        const e4 = r3.json.accessors[i3.POSITION], t4 = e4.min, o4 = e4.max;
        if (void 0 === t4 || void 0 === o4)
          return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        if (s3.set(new n.Pa4(t4[0], t4[1], t4[2]), new n.Pa4(o4[0], o4[1], o4[2])), e4.normalized) {
          const t5 = Jr(Nr[e4.componentType]);
          s3.min.multiplyScalar(t5), s3.max.multiplyScalar(t5);
        }
      }
      const o3 = t3.targets;
      if (void 0 !== o3) {
        const e4 = new n.Pa4(), t4 = new n.Pa4();
        for (let n2 = 0, i4 = o3.length; n2 < i4; n2++) {
          const i5 = o3[n2];
          if (void 0 !== i5.POSITION) {
            const n3 = r3.json.accessors[i5.POSITION], s4 = n3.min, o4 = n3.max;
            if (void 0 !== s4 && void 0 !== o4) {
              if (t4.setX(Math.max(Math.abs(s4[0]), Math.abs(o4[0]))), t4.setY(Math.max(Math.abs(s4[1]), Math.abs(o4[1]))), t4.setZ(Math.max(Math.abs(s4[2]), Math.abs(o4[2]))), n3.normalized) {
                const e5 = Jr(Nr[n3.componentType]);
                t4.multiplyScalar(e5);
              }
              e4.max(t4);
            } else
              console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }
        s3.expandByVector(e4);
      }
      e3.boundingBox = s3;
      const a2 = new n.aLr();
      s3.getCenter(a2.center), a2.radius = s3.min.distanceTo(s3.max) / 2, e3.boundingSphere = a2;
    }(e2, t2, r2), Promise.all(s2).then(function() {
      return void 0 !== t2.targets ? function(e3, t3, r3) {
        let n2 = false, i3 = false, s3 = false;
        for (let e4 = 0, r4 = t3.length; e4 < r4; e4++) {
          const r5 = t3[e4];
          if (void 0 !== r5.POSITION && (n2 = true), void 0 !== r5.NORMAL && (i3 = true), void 0 !== r5.COLOR_0 && (s3 = true), n2 && i3 && s3)
            break;
        }
        if (!n2 && !i3 && !s3)
          return Promise.resolve(e3);
        const o3 = [], a2 = [], l2 = [];
        for (let c2 = 0, u2 = t3.length; c2 < u2; c2++) {
          const u3 = t3[c2];
          if (n2) {
            const t4 = void 0 !== u3.POSITION ? r3.getDependency("accessor", u3.POSITION) : e3.attributes.position;
            o3.push(t4);
          }
          if (i3) {
            const t4 = void 0 !== u3.NORMAL ? r3.getDependency("accessor", u3.NORMAL) : e3.attributes.normal;
            a2.push(t4);
          }
          if (s3) {
            const t4 = void 0 !== u3.COLOR_0 ? r3.getDependency("accessor", u3.COLOR_0) : e3.attributes.color;
            l2.push(t4);
          }
        }
        return Promise.all([Promise.all(o3), Promise.all(a2), Promise.all(l2)]).then(function(t4) {
          const r4 = t4[0], o4 = t4[1], a3 = t4[2];
          return n2 && (e3.morphAttributes.position = r4), i3 && (e3.morphAttributes.normal = o4), s3 && (e3.morphAttributes.color = a3), e3.morphTargetsRelative = true, e3;
        });
      }(e2, t2.targets, r2) : e2;
    });
  }
  function tn(e2, t2) {
    let r2 = e2.getIndex();
    if (null === r2) {
      const t3 = [], n2 = e2.getAttribute("position");
      if (void 0 === n2)
        return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e2;
      for (let e3 = 0; e3 < n2.count; e3++)
        t3.push(e3);
      e2.setIndex(t3), r2 = e2.getIndex();
    }
    const i2 = r2.count - 2, s2 = [];
    if (t2 === n.z$h)
      for (let e3 = 1; e3 <= i2; e3++)
        s2.push(r2.getX(0)), s2.push(r2.getX(e3)), s2.push(r2.getX(e3 + 1));
    else
      for (let e3 = 0; e3 < i2; e3++)
        e3 % 2 == 0 ? (s2.push(r2.getX(e3)), s2.push(r2.getX(e3 + 1)), s2.push(r2.getX(e3 + 2))) : (s2.push(r2.getX(e3 + 2)), s2.push(r2.getX(e3 + 1)), s2.push(r2.getX(e3)));
    s2.length / 3 !== i2 && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const o2 = e2.clone();
    return o2.setIndex(s2), o2;
  }
  class rn extends dr {
    constructor(e2) {
      super(e2), this.isGLTFLoader2 = true;
    }
    async loadAsync(e2, t2) {
      const r2 = await super.loadAsync(e2, t2), n2 = r2 ? r2.scene || r2.scenes && r2.scenes.length > 0 && r2.scenes[0] : void 0;
      return n2 && r2.animations.length > 0 && (n2.animations = r2.animations), n2.traverse((e3) => {
        e3.userData.gltfUUID && (e3.uuid = e3.userData.gltfUUID, delete e3.userData.gltfUUID);
      }), n2;
    }
    register(e2) {
      return super.register(e2);
    }
  }
  class nn extends n.hH6 {
    constructor(e2) {
      super(e2), this.type = n.cLu;
    }
    async loadAsync(e2, t2) {
      const r2 = await this.parseAsync(e2, t2, false), i2 = new n.IEO(r2.data, r2.width, r2.height, n.wk1, this.type);
      return i2.needsUpdate = true, i2.flipY = true, i2.encoding = n.rnI, i2.minFilter = n.wem, i2.magFilter = n.wem, i2.source.data.complete = true, i2;
    }
    async parseAsync(e2, t2, r2 = false) {
      if (!e2.startsWith("data:")) {
        this.responseType = "blob";
        const r3 = await super.loadAsync(e2, t2);
        e2 = (e2 = await xt(r3)).replace("application/octet-stream", "image/png");
      }
      const i2 = await kt(e2);
      let s2 = Uint8Array;
      this.type === n.cLu ? s2 = Uint16Array : this.type === n.VzW && (s2 = Uint32Array);
      const o2 = function(e3, t3 = 3, r3 = Uint16Array, i3 = false) {
        let s3;
        const o3 = e3.byteLength >> 2, a2 = new r3(o3 * t3);
        for (let r4 = 0; r4 < o3; r4++)
          s3 = Math.pow(2, e3[4 * r4 + 3] - 136), i3 ? (a2[r4 * t3] = Math.min(e3[4 * r4] * s3, 65504), a2[r4 * t3 + 1] = Math.min(e3[4 * r4 + 1] * s3, 65504), a2[r4 * t3 + 2] = Math.min(e3[4 * r4 + 2] * s3, 65504)) : (a2[r4 * t3] = n.A5E.toHalfFloat(Math.min(e3[4 * r4] * s3, 65504)), a2[r4 * t3 + 1] = n.A5E.toHalfFloat(Math.min(e3[4 * r4 + 1] * s3, 65504)), a2[r4 * t3 + 2] = n.A5E.toHalfFloat(Math.min(e3[4 * r4 + 2] * s3, 65504))), 4 === t3 && (a2[r4 * t3 + 3] = n.A5E.toHalfFloat(1));
        return a2;
      }(i2.data, 4, s2, r2);
      return { data: o2, width: i2.width, height: i2.height };
    }
    setDataType(e2) {
      return this.type = e2, this;
    }
  }
  class sn extends n.Gql {
    constructor(e2) {
      super(e2), this._imageLoader = new n.S3k(e2);
    }
    parseTextures2(e2, t2, r2) {
      var i2;
      for (const s2 of e2) {
        const e3 = null === (i2 = null == s2 ? void 0 : s2.userData) || void 0 === i2 ? void 0 : i2.rootPath;
        if (e3 && (!s2.image || !t2[s2.image])) {
          const i3 = new n.Hw6(this._imageLoader.load(e3, r2));
          if (!i3)
            continue;
          s2.image && (i3.uuid = s2.image), t2[i3.uuid] = i3, s2.image = i3.uuid;
        }
        s2.userData = De(s2.userData, void 0, false, { images: t2 });
      }
      return super.parseTextures(e2, t2);
    }
    parseMaterials2(e2, t2, r2) {
      const n2 = {};
      return e2.forEach((e3) => {
        if (!e3)
          return;
        const i2 = { ...e3 }, s2 = Object.keys(i2);
        for (const e4 of s2)
          if ("map" === e4 || e4.endsWith("Map")) {
            const r3 = i2[e4];
            "string" == typeof r3 && (t2[r3] ? i2[e4] = t2[r3] : (console.warn(`Texture ${r3} not found`), delete i2[e4]));
          }
        i2.userData && (i2.userData = De(i2.userData, void 0, false, { textures: t2 }));
        const o2 = r2.generateFromTemplateType(i2.type, i2);
        o2 && (n2[e3.uuid] = o2);
      }), n2;
    }
  }
  const on = "WEBGI_viewer";
  function an(e2) {
    Js.Importers.push(new ir(rn, ["gltf", "glb", "data:model/gltf"], true, (t2, r2) => {
      if (!t2)
        return t2;
      const n2 = t2, i2 = new sn(r2.loadingManager);
      return n2.register(pn(i2, e2)), n2.register(hn(i2)), n2.register(dn(i2)), n2.register((e3) => new An(e3)), n2.register((e3) => new bn(e3)), n2.register((e3) => new yn(e3)), n2.register((e3) => new xn(e3)), n2.register((t3) => {
        var s2, o2, a2, l2, c2, u2, h2, p2, d2;
        const f2 = Xe() + ".drc", m2 = Xe() + ".ktx2", _2 = null === (a2 = null === (o2 = null === (s2 = t3.json) || void 0 === s2 ? void 0 : s2.extensionsRequired) || void 0 === o2 ? void 0 : o2.includes) || void 0 === a2 ? void 0 : a2.call(o2, "KHR_draco_mesh_compression");
        if (_2) {
          const e3 = r2.registerFile(f2);
          e3 && n2.setDRACOLoader(e3);
        }
        (null === (u2 = null === (c2 = null === (l2 = t3.json) || void 0 === l2 ? void 0 : l2.extensionsUsed) || void 0 === c2 ? void 0 : c2.includes) || void 0 === u2 ? void 0 : u2.call(c2, "EXT_meshopt_compression")) && (window.MeshoptDecoder ? (n2.setMeshoptDecoder(window.MeshoptDecoder), t3.options.meshoptDecoder = window.MeshoptDecoder) : console.error("Add GLTFMeshOptPlugin to viewer to enable EXT_meshopt_compression decode"));
        const g2 = null === (d2 = null === (p2 = null === (h2 = t3.json) || void 0 === h2 ? void 0 : h2.extensionsUsed) || void 0 === p2 ? void 0 : p2.includes) || void 0 === d2 ? void 0 : d2.call(p2, "KHR_texture_basisu");
        if (g2) {
          const e3 = r2.registerFile(m2);
          e3 && (n2.setKTX2Loader(e3), t3.options.ktx2Loader = e3);
        }
        return { name: "GLTF2_HELPER_PLUGIN", afterRoot: async (n3) => {
          _2 && r2.unregisterFile(f2), g2 && r2.unregisterFile(m2);
          const s3 = await fn(t3, e2, i2);
          n3.scene.__importedViewerConfig = s3;
        } };
      }), n2;
    }));
  }
  const ln = "WEBGI_light_extras", cn = "WEBGI_object3d_extras", un = "WEBGI_material_extras", hn = (e2) => (e3) => ({ name: "__" + cn, afterRoot: async (e4) => {
    (e4.scenes || (e4.scene ? [e4.scene] : [])).forEach((e5) => {
      e5.traverse((e6) => {
        var t2, r2;
        if (!e6.isObject3D)
          return;
        const n2 = null === (r2 = null === (t2 = e6.userData) || void 0 === t2 ? void 0 : t2.gltfExtensions) || void 0 === r2 ? void 0 : r2[cn];
        if (!n2)
          return void (e6.isLight && !e6.isAmbientLight && (e6.castShadow = true));
        const i2 = void 0 !== n2.castShadow || void 0 !== n2.receiveShadow;
        void 0 !== n2.castShadow && (e6.castShadow = n2.castShadow), void 0 !== n2.receiveShadow && (e6.receiveShadow = n2.receiveShadow), void 0 !== n2.visible && (e6.visible = n2.visible), void 0 !== n2.frustumCulled && (e6.frustumCulled = n2.frustumCulled), void 0 !== n2.renderOrder && (e6.renderOrder = n2.renderOrder), void 0 !== n2.layers && (e6.layers.mask = n2.layers), i2 && (e6.userData.__keepShadowDef = true), delete e6.userData.gltfExtensions[cn];
      });
    });
  } }), pn = (e2, t2) => (e3) => ({ name: "__" + un, afterRoot: async (e4) => {
    var r2, n2, i2;
    const s2 = e4.scenes || (e4.scene ? [e4.scene] : []);
    for (const e5 of s2) {
      const s3 = null === (n2 = null === (r2 = e5.userData) || void 0 === r2 ? void 0 : r2.gltfExtensions) || void 0 === n2 ? void 0 : n2[un], o2 = s3 && await (null === (i2 = t2.getPlugin(to)) || void 0 === i2 ? void 0 : i2.importConfigResources(s3.resources || {})) || {};
      e5.traverse((e6) => {
        var t3, r3;
        const n3 = null == e6 ? void 0 : e6.material;
        if (!(null == n3 ? void 0 : n3.isMaterial))
          return;
        const i3 = null === (r3 = null === (t3 = n3.userData) || void 0 === t3 ? void 0 : t3.gltfExtensions) || void 0 === r3 ? void 0 : r3[un];
        i3 && (void 0 !== i3.emissiveIntensity && (n3.emissiveIntensity = i3.emissiveIntensity), void 0 !== i3.fog && (n3.fog = i3.fog), void 0 !== i3.flatShading && (n3.flatShading = i3.flatShading), void 0 !== i3.blending && (n3.blending = i3.blending), void 0 !== i3.side && (n3.side = i3.side), void 0 !== i3.shadowSide && (n3.shadowSide = i3.shadowSide), void 0 !== i3.depthFunc && (n3.depthFunc = i3.depthFunc), void 0 !== i3.depthTest && (n3.depthTest = i3.depthTest), void 0 !== i3.depthWrite && (n3.depthWrite = i3.depthWrite), void 0 !== i3.colorWrite && (n3.colorWrite = i3.colorWrite), void 0 !== i3.wireframe && (n3.wireframe = i3.wireframe), void 0 !== i3.wireframeLinewidth && (n3.wireframeLinewidth = i3.wireframeLinewidth), void 0 !== i3.wireframeLinecap && (n3.wireframeLinecap = i3.wireframeLinecap), void 0 !== i3.wireframeLinejoin && (n3.wireframeLinejoin = i3.wireframeLinejoin), void 0 !== i3.rotation && (n3.rotation = i3.rotation), void 0 !== i3.polygonOffset && (n3.polygonOffset = i3.polygonOffset), void 0 !== i3.polygonOffsetFactor && (n3.polygonOffsetFactor = i3.polygonOffsetFactor), void 0 !== i3.polygonOffsetUnits && (n3.polygonOffsetUnits = i3.polygonOffsetUnits), void 0 !== i3.dithering && (n3.dithering = i3.dithering), void 0 !== i3.alphaToCoverage && (n3.alphaToCoverage = i3.alphaToCoverage), void 0 !== i3.premultipliedAlpha && (n3.premultipliedAlpha = i3.premultipliedAlpha), void 0 !== i3.toneMapped && (n3.toneMapped = i3.toneMapped), void 0 !== i3.reflectivity && (n3.reflectivity = i3.reflectivity), Object.entries(i3).forEach(([e7, t4]) => {
          e7.startsWith("_") || t4 && t4.resource && "string" == typeof t4.resource && (n3[e7] = De(t4, n3[e7], false, o2));
        }), delete n3.userData.gltfExtensions[un]);
      }), s3 && delete e5.userData.gltfExtensions[un];
    }
  } }), dn = (e2) => (t2) => ({ name: "__" + ln, afterRoot: async (t3) => {
    (t3.scenes || (t3.scene ? [t3.scene] : [])).forEach((t4) => {
      t4.traverse((t5) => {
        var r2, n2;
        if (!t5.isLight)
          return;
        const i2 = null === (n2 = null === (r2 = t5.userData) || void 0 === r2 ? void 0 : r2.gltfExtensions) || void 0 === n2 ? void 0 : n2[ln];
        i2 && (!t5.shadow && i2.shadow && console.error("Light has no shadow, cannot import", t5, i2), i2.shadow && t5.shadow && (void 0 !== i2.shadow.bias && (t5.shadow.bias = i2.shadow.bias), void 0 !== i2.shadow.normalBias && (t5.shadow.normalBias = i2.shadow.normalBias), void 0 !== i2.shadow.radius && (t5.shadow.radius = i2.shadow.radius), void 0 !== i2.shadow.mapSize && t5.shadow.mapSize.fromArray(i2.shadow.mapSize), void 0 !== i2.shadow.camera && (t5.shadow.camera = e2.parseObject(i2.shadow.camera))), delete t5.userData.gltfExtensions[ln]);
      });
    });
  } });
  async function fn(e2, t2, r2, n2) {
    var i2;
    if (!n2) {
      const r3 = e2.json.scenes || [];
      if (1 !== r3.length) {
        for (const n3 of r3)
          await fn(e2, t2, n3);
        return;
      }
      n2 = r3[0];
    }
    const s2 = null === (i2 = n2.extensions) || void 0 === i2 ? void 0 : i2[on];
    if (!s2)
      return;
    const o2 = [];
    Object.values(s2.resources).forEach((e3) => {
      Object.values(e3).forEach((e4) => {
        e4.url && ("Uint16Array" === e4.url.type && e4.url.data && o2.push(e4.url), "Uint8Array" === e4.url.type && e4.url.data && o2.push(e4.url));
      });
    });
    for (const t3 of o2) {
      const r3 = t3.data.image, n3 = e2.json.images[r3], i3 = await e2.getDependency("bufferView", n3.bufferView);
      if (n3.mimeType.startsWith("image/") && "Uint16Array" === t3.type && "rgbe" === t3.encoding) {
        const e3 = new Blob([i3], { type: n3.mimeType }), r4 = "data:image/png;base64," + btoa(await e3.text());
        t3.data = (await new nn().parseAsync(r4, void 0, true)).data, delete t3.encoding;
      } else
        t3.data = i3;
    }
    const a2 = { textures: {} };
    if (s2.resources.textures && e2.json.textures)
      for (const [t3, r3] of Object.entries(s2.resources.textures)) {
        if (r3.uuid || !t3)
          continue;
        delete s2.resources.textures[t3];
        const n3 = e2.json.textures.findIndex((r4) => {
          var n4, i3, s3, o3, a3, l2, c2;
          return (null === (n4 = r4.extras) || void 0 === n4 ? void 0 : n4.uuid) === t3 || (null === (o3 = null === (s3 = null === (i3 = e2.json.samplers) || void 0 === i3 ? void 0 : i3[r4.sampler]) || void 0 === s3 ? void 0 : s3.extras) || void 0 === o3 ? void 0 : o3.uuid) === t3 || (null === (c2 = null === (l2 = null === (a3 = e2.json.images) || void 0 === a3 ? void 0 : a3[r4.source]) || void 0 === l2 ? void 0 : l2.extras) || void 0 === c2 ? void 0 : c2.t_uuid) === t3;
        });
        n3 >= 0 && (a2.textures[t3] = await e2.getDependency("texture", n3));
      }
    if (s2.resources.materials && e2.json.materials)
      for (const [t3, r3] of Object.entries(s2.resources.materials)) {
        if (r3.uuid || !t3)
          continue;
        delete s2.resources.materials[t3];
        const n3 = e2.json.materials.findIndex((e3) => {
          var r4;
          return (null === (r4 = e3.extras) || void 0 === r4 ? void 0 : r4.uuid) === t3;
        });
        n3 >= 0 && (a2.materials[t3] = await e2.getDependency("material", n3));
      }
    return s2.resources = await t2.getPlugin(to).importConfigResources(s2.resources || {}, r2, a2), s2;
  }
  const mn = "WEBGI_materials_bumpmap", _n = "WEBGI_materials_displacementmap", gn = "WEBGI_materials_alphamap", vn = "WEBGI_materials_lightmap";
  class An {
    constructor(e2) {
      this.parser = e2, this.name = mn;
    }
    async extendMaterialParams(e2, t2) {
      const r2 = this.parser, n2 = r2.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const i2 = [], s2 = n2.extensions[this.name];
      return void 0 !== s2.bumpScale && (t2.bumpScale = s2.bumpScale), void 0 !== s2.bumpTexture && i2.push(r2.assignTexture(t2, "bumpMap", s2.bumpTexture)), Promise.all(i2);
    }
  }
  class bn {
    constructor(e2) {
      this.parser = e2, this.name = _n;
    }
    async extendMaterialParams(e2, t2) {
      const r2 = this.parser, n2 = r2.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const i2 = [], s2 = n2.extensions[this.name];
      return void 0 !== s2.displacementScale && (t2.displacementScale = s2.displacementScale), void 0 !== s2.displacementBias && (t2.displacementBias = s2.displacementBias), void 0 !== s2.displacementTexture && i2.push(r2.assignTexture(t2, "displacementMap", s2.displacementTexture)), Promise.all(i2);
    }
  }
  class yn {
    constructor(e2) {
      this.parser = e2, this.name = vn;
    }
    async extendMaterialParams(e2, t2) {
      const r2 = this.parser, n2 = r2.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const i2 = [], s2 = n2.extensions[this.name];
      return void 0 !== s2.lightMapIntensity && (t2.lightMapIntensity = s2.lightMapIntensity), void 0 !== s2.lightMapTexture && i2.push(r2.assignTexture(t2, "lightMap", s2.lightMapTexture)), Promise.all(i2);
    }
  }
  class xn {
    constructor(e2) {
      this.parser = e2, this.name = gn;
    }
    async extendMaterialParams(e2, t2) {
      const r2 = this.parser, n2 = r2.json.materials[e2];
      if (!n2.extensions || !n2.extensions[this.name])
        return Promise.resolve();
      const i2 = [], s2 = n2.extensions[this.name];
      return void 0 !== s2.alphaTexture && i2.push(r2.assignTexture(t2, "alphaMap", s2.alphaTexture)), Promise.all(i2);
    }
  }
  var wn = __webpackgi_require__2(23);
  function En() {
    Js.Importers.push(new ir(wn.Q, ["drc"], true));
  }
  var Sn = {}, Cn = Uint8Array, Mn = Uint16Array, Tn = Uint32Array, In = new Cn([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), kn = new Cn([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), Dn = new Cn([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Pn = function(e2, t2) {
    for (var r2 = new Mn(31), n2 = 0; n2 < 31; ++n2)
      r2[n2] = t2 += 1 << e2[n2 - 1];
    var i2 = new Tn(r2[30]);
    for (n2 = 1; n2 < 30; ++n2)
      for (var s2 = r2[n2]; s2 < r2[n2 + 1]; ++s2)
        i2[s2] = s2 - r2[n2] << 5 | n2;
    return [r2, i2];
  }, Bn = Pn(In, 2), Rn = Bn[0], Ln = Bn[1];
  Rn[28] = 258, Ln[258] = 28;
  for (var On = Pn(kn, 0), Fn = On[0], Un = On[1], Nn = new Mn(32768), jn = 0; jn < 32768; ++jn) {
    var zn = (43690 & jn) >>> 1 | (21845 & jn) << 1;
    zn = (61680 & (zn = (52428 & zn) >>> 2 | (13107 & zn) << 2)) >>> 4 | (3855 & zn) << 4, Nn[jn] = ((65280 & zn) >>> 8 | (255 & zn) << 8) >>> 1;
  }
  var Gn = function(e2, t2, r2) {
    for (var n2 = e2.length, i2 = 0, s2 = new Mn(t2); i2 < n2; ++i2)
      ++s2[e2[i2] - 1];
    var o2, a2 = new Mn(t2);
    for (i2 = 0; i2 < t2; ++i2)
      a2[i2] = a2[i2 - 1] + s2[i2 - 1] << 1;
    if (r2) {
      o2 = new Mn(1 << t2);
      var l2 = 15 - t2;
      for (i2 = 0; i2 < n2; ++i2)
        if (e2[i2])
          for (var c2 = i2 << 4 | e2[i2], u2 = t2 - e2[i2], h2 = a2[e2[i2] - 1]++ << u2, p2 = h2 | (1 << u2) - 1; h2 <= p2; ++h2)
            o2[Nn[h2] >>> l2] = c2;
    } else
      for (o2 = new Mn(n2), i2 = 0; i2 < n2; ++i2)
        e2[i2] && (o2[i2] = Nn[a2[e2[i2] - 1]++] >>> 15 - e2[i2]);
    return o2;
  }, Vn = new Cn(288);
  for (jn = 0; jn < 144; ++jn)
    Vn[jn] = 8;
  for (jn = 144; jn < 256; ++jn)
    Vn[jn] = 9;
  for (jn = 256; jn < 280; ++jn)
    Vn[jn] = 7;
  for (jn = 280; jn < 288; ++jn)
    Vn[jn] = 8;
  var Qn = new Cn(32);
  for (jn = 0; jn < 32; ++jn)
    Qn[jn] = 5;
  var Hn = Gn(Vn, 9, 0), Wn = Gn(Vn, 9, 1), qn = Gn(Qn, 5, 0), Xn = Gn(Qn, 5, 1), Yn = function(e2) {
    for (var t2 = e2[0], r2 = 1; r2 < e2.length; ++r2)
      e2[r2] > t2 && (t2 = e2[r2]);
    return t2;
  }, Kn = function(e2, t2, r2) {
    var n2 = t2 / 8 | 0;
    return (e2[n2] | e2[n2 + 1] << 8) >> (7 & t2) & r2;
  }, Jn = function(e2, t2) {
    var r2 = t2 / 8 | 0;
    return (e2[r2] | e2[r2 + 1] << 8 | e2[r2 + 2] << 16) >> (7 & t2);
  }, Zn = function(e2) {
    return (e2 / 8 | 0) + (7 & e2 && 1);
  }, $n = function(e2, t2, r2) {
    (null == t2 || t2 < 0) && (t2 = 0), (null == r2 || r2 > e2.length) && (r2 = e2.length);
    var n2 = new (e2 instanceof Mn ? Mn : e2 instanceof Tn ? Tn : Cn)(r2 - t2);
    return n2.set(e2.subarray(t2, r2)), n2;
  }, ei = function(e2, t2, r2) {
    var n2 = e2.length;
    if (!n2 || r2 && !r2.l && n2 < 5)
      return t2 || new Cn(0);
    var i2 = !t2 || r2, s2 = !r2 || r2.i;
    r2 || (r2 = {}), t2 || (t2 = new Cn(3 * n2));
    var o2 = function(e3) {
      var r3 = t2.length;
      if (e3 > r3) {
        var n3 = new Cn(Math.max(2 * r3, e3));
        n3.set(t2), t2 = n3;
      }
    }, a2 = r2.f || 0, l2 = r2.p || 0, c2 = r2.b || 0, u2 = r2.l, h2 = r2.d, p2 = r2.m, d2 = r2.n, f2 = 8 * n2;
    do {
      if (!u2) {
        r2.f = a2 = Kn(e2, l2, 1);
        var m2 = Kn(e2, l2 + 1, 3);
        if (l2 += 3, !m2) {
          var _2 = e2[(M2 = Zn(l2) + 4) - 4] | e2[M2 - 3] << 8, g2 = M2 + _2;
          if (g2 > n2) {
            if (s2)
              throw "unexpected EOF";
            break;
          }
          i2 && o2(c2 + _2), t2.set(e2.subarray(M2, g2), c2), r2.b = c2 += _2, r2.p = l2 = 8 * g2;
          continue;
        }
        if (1 == m2)
          u2 = Wn, h2 = Xn, p2 = 9, d2 = 5;
        else {
          if (2 != m2)
            throw "invalid block type";
          var v2 = Kn(e2, l2, 31) + 257, A2 = Kn(e2, l2 + 10, 15) + 4, b2 = v2 + Kn(e2, l2 + 5, 31) + 1;
          l2 += 14;
          for (var y2 = new Cn(b2), x2 = new Cn(19), w2 = 0; w2 < A2; ++w2)
            x2[Dn[w2]] = Kn(e2, l2 + 3 * w2, 7);
          l2 += 3 * A2;
          var E2 = Yn(x2), S2 = (1 << E2) - 1, C2 = Gn(x2, E2, 1);
          for (w2 = 0; w2 < b2; ) {
            var M2, T2 = C2[Kn(e2, l2, S2)];
            if (l2 += 15 & T2, (M2 = T2 >>> 4) < 16)
              y2[w2++] = M2;
            else {
              var I2 = 0, k2 = 0;
              for (16 == M2 ? (k2 = 3 + Kn(e2, l2, 3), l2 += 2, I2 = y2[w2 - 1]) : 17 == M2 ? (k2 = 3 + Kn(e2, l2, 7), l2 += 3) : 18 == M2 && (k2 = 11 + Kn(e2, l2, 127), l2 += 7); k2--; )
                y2[w2++] = I2;
            }
          }
          var D2 = y2.subarray(0, v2), P2 = y2.subarray(v2);
          p2 = Yn(D2), d2 = Yn(P2), u2 = Gn(D2, p2, 1), h2 = Gn(P2, d2, 1);
        }
        if (l2 > f2) {
          if (s2)
            throw "unexpected EOF";
          break;
        }
      }
      i2 && o2(c2 + 131072);
      for (var B2 = (1 << p2) - 1, R2 = (1 << d2) - 1, L2 = l2; ; L2 = l2) {
        var O2 = (I2 = u2[Jn(e2, l2) & B2]) >>> 4;
        if ((l2 += 15 & I2) > f2) {
          if (s2)
            throw "unexpected EOF";
          break;
        }
        if (!I2)
          throw "invalid length/literal";
        if (O2 < 256)
          t2[c2++] = O2;
        else {
          if (256 == O2) {
            L2 = l2, u2 = null;
            break;
          }
          var F2 = O2 - 254;
          if (O2 > 264) {
            var U2 = In[w2 = O2 - 257];
            F2 = Kn(e2, l2, (1 << U2) - 1) + Rn[w2], l2 += U2;
          }
          var N2 = h2[Jn(e2, l2) & R2], j2 = N2 >>> 4;
          if (!N2)
            throw "invalid distance";
          if (l2 += 15 & N2, P2 = Fn[j2], j2 > 3 && (U2 = kn[j2], P2 += Jn(e2, l2) & (1 << U2) - 1, l2 += U2), l2 > f2) {
            if (s2)
              throw "unexpected EOF";
            break;
          }
          i2 && o2(c2 + 131072);
          for (var z2 = c2 + F2; c2 < z2; c2 += 4)
            t2[c2] = t2[c2 - P2], t2[c2 + 1] = t2[c2 + 1 - P2], t2[c2 + 2] = t2[c2 + 2 - P2], t2[c2 + 3] = t2[c2 + 3 - P2];
          c2 = z2;
        }
      }
      r2.l = u2, r2.p = L2, r2.b = c2, u2 && (a2 = 1, r2.m = p2, r2.d = h2, r2.n = d2);
    } while (!a2);
    return c2 == t2.length ? t2 : $n(t2, 0, c2);
  }, ti = function(e2, t2, r2) {
    r2 <<= 7 & t2;
    var n2 = t2 / 8 | 0;
    e2[n2] |= r2, e2[n2 + 1] |= r2 >>> 8;
  }, ri = function(e2, t2, r2) {
    r2 <<= 7 & t2;
    var n2 = t2 / 8 | 0;
    e2[n2] |= r2, e2[n2 + 1] |= r2 >>> 8, e2[n2 + 2] |= r2 >>> 16;
  }, ni = function(e2, t2) {
    for (var r2 = [], n2 = 0; n2 < e2.length; ++n2)
      e2[n2] && r2.push({ s: n2, f: e2[n2] });
    var i2 = r2.length, s2 = r2.slice();
    if (!i2)
      return [ui, 0];
    if (1 == i2) {
      var o2 = new Cn(r2[0].s + 1);
      return o2[r2[0].s] = 1, [o2, 1];
    }
    r2.sort(function(e3, t3) {
      return e3.f - t3.f;
    }), r2.push({ s: -1, f: 25001 });
    var a2 = r2[0], l2 = r2[1], c2 = 0, u2 = 1, h2 = 2;
    for (r2[0] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 }; u2 != i2 - 1; )
      a2 = r2[r2[c2].f < r2[h2].f ? c2++ : h2++], l2 = r2[c2 != u2 && r2[c2].f < r2[h2].f ? c2++ : h2++], r2[u2++] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 };
    var p2 = s2[0].s;
    for (n2 = 1; n2 < i2; ++n2)
      s2[n2].s > p2 && (p2 = s2[n2].s);
    var d2 = new Mn(p2 + 1), f2 = ii(r2[u2 - 1], d2, 0);
    if (f2 > t2) {
      n2 = 0;
      var m2 = 0, _2 = f2 - t2, g2 = 1 << _2;
      for (s2.sort(function(e3, t3) {
        return d2[t3.s] - d2[e3.s] || e3.f - t3.f;
      }); n2 < i2; ++n2) {
        var v2 = s2[n2].s;
        if (!(d2[v2] > t2))
          break;
        m2 += g2 - (1 << f2 - d2[v2]), d2[v2] = t2;
      }
      for (m2 >>>= _2; m2 > 0; ) {
        var A2 = s2[n2].s;
        d2[A2] < t2 ? m2 -= 1 << t2 - d2[A2]++ - 1 : ++n2;
      }
      for (; n2 >= 0 && m2; --n2) {
        var b2 = s2[n2].s;
        d2[b2] == t2 && (--d2[b2], ++m2);
      }
      f2 = t2;
    }
    return [new Cn(d2), f2];
  }, ii = function(e2, t2, r2) {
    return -1 == e2.s ? Math.max(ii(e2.l, t2, r2 + 1), ii(e2.r, t2, r2 + 1)) : t2[e2.s] = r2;
  }, si = function(e2) {
    for (var t2 = e2.length; t2 && !e2[--t2]; )
      ;
    for (var r2 = new Mn(++t2), n2 = 0, i2 = e2[0], s2 = 1, o2 = function(e3) {
      r2[n2++] = e3;
    }, a2 = 1; a2 <= t2; ++a2)
      if (e2[a2] == i2 && a2 != t2)
        ++s2;
      else {
        if (!i2 && s2 > 2) {
          for (; s2 > 138; s2 -= 138)
            o2(32754);
          s2 > 2 && (o2(s2 > 10 ? s2 - 11 << 5 | 28690 : s2 - 3 << 5 | 12305), s2 = 0);
        } else if (s2 > 3) {
          for (o2(i2), --s2; s2 > 6; s2 -= 6)
            o2(8304);
          s2 > 2 && (o2(s2 - 3 << 5 | 8208), s2 = 0);
        }
        for (; s2--; )
          o2(i2);
        s2 = 1, i2 = e2[a2];
      }
    return [r2.subarray(0, n2), t2];
  }, oi = function(e2, t2) {
    for (var r2 = 0, n2 = 0; n2 < t2.length; ++n2)
      r2 += e2[n2] * t2[n2];
    return r2;
  }, ai = function(e2, t2, r2) {
    var n2 = r2.length, i2 = Zn(t2 + 2);
    e2[i2] = 255 & n2, e2[i2 + 1] = n2 >>> 8, e2[i2 + 2] = 255 ^ e2[i2], e2[i2 + 3] = 255 ^ e2[i2 + 1];
    for (var s2 = 0; s2 < n2; ++s2)
      e2[i2 + s2 + 4] = r2[s2];
    return 8 * (i2 + 4 + n2);
  }, li = function(e2, t2, r2, n2, i2, s2, o2, a2, l2, c2, u2) {
    ti(t2, u2++, r2), ++i2[256];
    for (var h2 = ni(i2, 15), p2 = h2[0], d2 = h2[1], f2 = ni(s2, 15), m2 = f2[0], _2 = f2[1], g2 = si(p2), v2 = g2[0], A2 = g2[1], b2 = si(m2), y2 = b2[0], x2 = b2[1], w2 = new Mn(19), E2 = 0; E2 < v2.length; ++E2)
      w2[31 & v2[E2]]++;
    for (E2 = 0; E2 < y2.length; ++E2)
      w2[31 & y2[E2]]++;
    for (var S2 = ni(w2, 7), C2 = S2[0], M2 = S2[1], T2 = 19; T2 > 4 && !C2[Dn[T2 - 1]]; --T2)
      ;
    var I2, k2, D2, P2, B2 = c2 + 5 << 3, R2 = oi(i2, Vn) + oi(s2, Qn) + o2, L2 = oi(i2, p2) + oi(s2, m2) + o2 + 14 + 3 * T2 + oi(w2, C2) + (2 * w2[16] + 3 * w2[17] + 7 * w2[18]);
    if (B2 <= R2 && B2 <= L2)
      return ai(t2, u2, e2.subarray(l2, l2 + c2));
    if (ti(t2, u2, 1 + (L2 < R2)), u2 += 2, L2 < R2) {
      I2 = Gn(p2, d2, 0), k2 = p2, D2 = Gn(m2, _2, 0), P2 = m2;
      var O2 = Gn(C2, M2, 0);
      for (ti(t2, u2, A2 - 257), ti(t2, u2 + 5, x2 - 1), ti(t2, u2 + 10, T2 - 4), u2 += 14, E2 = 0; E2 < T2; ++E2)
        ti(t2, u2 + 3 * E2, C2[Dn[E2]]);
      u2 += 3 * T2;
      for (var F2 = [v2, y2], U2 = 0; U2 < 2; ++U2) {
        var N2 = F2[U2];
        for (E2 = 0; E2 < N2.length; ++E2) {
          var j2 = 31 & N2[E2];
          ti(t2, u2, O2[j2]), u2 += C2[j2], j2 > 15 && (ti(t2, u2, N2[E2] >>> 5 & 127), u2 += N2[E2] >>> 12);
        }
      }
    } else
      I2 = Hn, k2 = Vn, D2 = qn, P2 = Qn;
    for (E2 = 0; E2 < a2; ++E2)
      if (n2[E2] > 255) {
        j2 = n2[E2] >>> 18 & 31, ri(t2, u2, I2[j2 + 257]), u2 += k2[j2 + 257], j2 > 7 && (ti(t2, u2, n2[E2] >>> 23 & 31), u2 += In[j2]);
        var z2 = 31 & n2[E2];
        ri(t2, u2, D2[z2]), u2 += P2[z2], z2 > 3 && (ri(t2, u2, n2[E2] >>> 5 & 8191), u2 += kn[z2]);
      } else
        ri(t2, u2, I2[n2[E2]]), u2 += k2[n2[E2]];
    return ri(t2, u2, I2[256]), u2 + k2[256];
  }, ci = new Tn([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), ui = new Cn(0), hi = function(e2, t2, r2, n2, i2, s2) {
    var o2 = e2.length, a2 = new Cn(n2 + o2 + 5 * (1 + Math.ceil(o2 / 7e3)) + i2), l2 = a2.subarray(n2, a2.length - i2), c2 = 0;
    if (!t2 || o2 < 8)
      for (var u2 = 0; u2 <= o2; u2 += 65535) {
        var h2 = u2 + 65535;
        h2 < o2 ? c2 = ai(l2, c2, e2.subarray(u2, h2)) : (l2[u2] = s2, c2 = ai(l2, c2, e2.subarray(u2, o2)));
      }
    else {
      for (var p2 = ci[t2 - 1], d2 = p2 >>> 13, f2 = 8191 & p2, m2 = (1 << r2) - 1, _2 = new Mn(32768), g2 = new Mn(m2 + 1), v2 = Math.ceil(r2 / 3), A2 = 2 * v2, b2 = function(t3) {
        return (e2[t3] ^ e2[t3 + 1] << v2 ^ e2[t3 + 2] << A2) & m2;
      }, y2 = new Tn(25e3), x2 = new Mn(288), w2 = new Mn(32), E2 = 0, S2 = 0, C2 = (u2 = 0, 0), M2 = 0, T2 = 0; u2 < o2; ++u2) {
        var I2 = b2(u2), k2 = 32767 & u2, D2 = g2[I2];
        if (_2[k2] = D2, g2[I2] = k2, M2 <= u2) {
          var P2 = o2 - u2;
          if ((E2 > 7e3 || C2 > 24576) && P2 > 423) {
            c2 = li(e2, l2, 0, y2, x2, w2, S2, C2, T2, u2 - T2, c2), C2 = E2 = S2 = 0, T2 = u2;
            for (var B2 = 0; B2 < 286; ++B2)
              x2[B2] = 0;
            for (B2 = 0; B2 < 30; ++B2)
              w2[B2] = 0;
          }
          var R2 = 2, L2 = 0, O2 = f2, F2 = k2 - D2 & 32767;
          if (P2 > 2 && I2 == b2(u2 - F2))
            for (var U2 = Math.min(d2, P2) - 1, N2 = Math.min(32767, u2), j2 = Math.min(258, P2); F2 <= N2 && --O2 && k2 != D2; ) {
              if (e2[u2 + R2] == e2[u2 + R2 - F2]) {
                for (var z2 = 0; z2 < j2 && e2[u2 + z2] == e2[u2 + z2 - F2]; ++z2)
                  ;
                if (z2 > R2) {
                  if (R2 = z2, L2 = F2, z2 > U2)
                    break;
                  var G2 = Math.min(F2, z2 - 2), V2 = 0;
                  for (B2 = 0; B2 < G2; ++B2) {
                    var Q2 = u2 - F2 + B2 + 32768 & 32767, H2 = Q2 - _2[Q2] + 32768 & 32767;
                    H2 > V2 && (V2 = H2, D2 = Q2);
                  }
                }
              }
              F2 += (k2 = D2) - (D2 = _2[k2]) + 32768 & 32767;
            }
          if (L2) {
            y2[C2++] = 268435456 | Ln[R2] << 18 | Un[L2];
            var W2 = 31 & Ln[R2], q2 = 31 & Un[L2];
            S2 += In[W2] + kn[q2], ++x2[257 + W2], ++w2[q2], M2 = u2 + R2, ++E2;
          } else
            y2[C2++] = e2[u2], ++x2[e2[u2]];
        }
      }
      c2 = li(e2, l2, s2, y2, x2, w2, S2, C2, T2, u2 - T2, c2), !s2 && 7 & c2 && (c2 = ai(l2, c2 + 1, ui));
    }
    return $n(a2, 0, n2 + Zn(c2) + i2);
  }, pi = function() {
    for (var e2 = new Int32Array(256), t2 = 0; t2 < 256; ++t2) {
      for (var r2 = t2, n2 = 9; --n2; )
        r2 = (1 & r2 && -306674912) ^ r2 >>> 1;
      e2[t2] = r2;
    }
    return e2;
  }(), di = function() {
    var e2 = -1;
    return { p: function(t2) {
      for (var r2 = e2, n2 = 0; n2 < t2.length; ++n2)
        r2 = pi[255 & r2 ^ t2[n2]] ^ r2 >>> 8;
      e2 = r2;
    }, d: function() {
      return ~e2;
    } };
  }, fi = function() {
    var e2 = 1, t2 = 0;
    return { p: function(r2) {
      for (var n2 = e2, i2 = t2, s2 = r2.length, o2 = 0; o2 != s2; ) {
        for (var a2 = Math.min(o2 + 2655, s2); o2 < a2; ++o2)
          i2 += n2 += r2[o2];
        n2 = (65535 & n2) + 15 * (n2 >> 16), i2 = (65535 & i2) + 15 * (i2 >> 16);
      }
      e2 = n2, t2 = i2;
    }, d: function() {
      return (255 & (e2 %= 65521)) << 24 | e2 >>> 8 << 16 | (255 & (t2 %= 65521)) << 8 | t2 >>> 8;
    } };
  }, mi = function(e2, t2, r2, n2, i2) {
    return hi(e2, null == t2.level ? 6 : t2.level, null == t2.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e2.length)))) : 12 + t2.mem, r2, n2, !i2);
  }, _i = function(e2, t2) {
    var r2 = {};
    for (var n2 in e2)
      r2[n2] = e2[n2];
    for (var n2 in t2)
      r2[n2] = t2[n2];
    return r2;
  }, gi = function(e2, t2, r2) {
    for (var n2 = e2(), i2 = e2.toString(), s2 = i2.slice(i2.indexOf("[") + 1, i2.lastIndexOf("]")).replace(/ /g, "").split(","), o2 = 0; o2 < n2.length; ++o2) {
      var a2 = n2[o2], l2 = s2[o2];
      if ("function" == typeof a2) {
        t2 += ";" + l2 + "=";
        var c2 = a2.toString();
        if (a2.prototype)
          if (-1 != c2.indexOf("[native code]")) {
            var u2 = c2.indexOf(" ", 8) + 1;
            t2 += c2.slice(u2, c2.indexOf("(", u2));
          } else
            for (var h2 in t2 += c2, a2.prototype)
              t2 += ";" + l2 + ".prototype." + h2 + "=" + a2.prototype[h2].toString();
        else
          t2 += c2;
      } else
        r2[l2] = a2;
    }
    return [t2, r2];
  }, vi = [], Ai = function(e2, t2, r2, n2) {
    var i2;
    if (!vi[r2]) {
      for (var s2 = "", o2 = {}, a2 = e2.length - 1, l2 = 0; l2 < a2; ++l2)
        s2 = (i2 = gi(e2[l2], s2, o2))[0], o2 = i2[1];
      vi[r2] = gi(e2[a2], s2, o2);
    }
    var c2 = _i({}, vi[r2][1]);
    return function(e3, t3, r3, n3, i3) {
      var s3 = new Worker(Sn[t3] || (Sn[t3] = URL.createObjectURL(new Blob([e3], { type: "text/javascript" }))));
      return s3.onerror = function(e4) {
        return i3(e4.error, null);
      }, s3.onmessage = function(e4) {
        return i3(null, e4.data);
      }, s3.postMessage(r3, n3), s3;
    }(vi[r2][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t2.toString() + "}", r2, c2, function(e3) {
      var t3 = [];
      for (var r3 in e3)
        (e3[r3] instanceof Cn || e3[r3] instanceof Mn || e3[r3] instanceof Tn) && t3.push((e3[r3] = new e3[r3].constructor(e3[r3])).buffer);
      return t3;
    }(c2), n2);
  }, bi = function() {
    return [Cn, Mn, Tn, In, kn, Dn, Rn, Fn, Wn, Xn, Nn, Gn, Yn, Kn, Jn, Zn, $n, ei, Yi, Ci, Mi];
  }, yi = function() {
    return [Cn, Mn, Tn, In, kn, Dn, Ln, Un, Hn, Vn, qn, Qn, Nn, ci, ui, Gn, ti, ri, ni, ii, si, oi, ai, li, Zn, $n, hi, mi, Hi, Ci];
  }, xi = function() {
    return [Li, Ui, Ri, di, pi];
  }, wi = function() {
    return [Oi, Fi];
  }, Ei = function() {
    return [Ni, Ri, fi];
  }, Si = function() {
    return [ji];
  }, Ci = function(e2) {
    return postMessage(e2, [e2.buffer]);
  }, Mi = function(e2) {
    return e2 && e2.size && new Cn(e2.size);
  }, Ti = function(e2, t2, r2, n2, i2, s2) {
    var o2 = Ai(r2, n2, i2, function(e3, t3) {
      o2.terminate(), s2(e3, t3);
    });
    return o2.postMessage([e2, t2], t2.consume ? [e2.buffer] : []), function() {
      o2.terminate();
    };
  }, Ii = function(e2) {
    return e2.ondata = function(e3, t2) {
      return postMessage([e3, t2], [e3.buffer]);
    }, function(t2) {
      return e2.push(t2.data[0], t2.data[1]);
    };
  }, ki = function(e2, t2, r2, n2, i2) {
    var s2, o2 = Ai(e2, n2, i2, function(e3, r3) {
      e3 ? (o2.terminate(), t2.ondata.call(t2, e3)) : (r3[1] && o2.terminate(), t2.ondata.call(t2, e3, r3[0], r3[1]));
    });
    o2.postMessage(r2), t2.push = function(e3, r3) {
      if (s2)
        throw "stream finished";
      if (!t2.ondata)
        throw "no stream handler";
      o2.postMessage([e3, s2 = r3], [e3.buffer]);
    }, t2.terminate = function() {
      o2.terminate();
    };
  }, Di = function(e2, t2) {
    return e2[t2] | e2[t2 + 1] << 8;
  }, Pi = function(e2, t2) {
    return (e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24) >>> 0;
  }, Bi = function(e2, t2) {
    return Pi(e2, t2) + 4294967296 * Pi(e2, t2 + 4);
  }, Ri = function(e2, t2, r2) {
    for (; r2; ++t2)
      e2[t2] = r2, r2 >>>= 8;
  }, Li = function(e2, t2) {
    var r2 = t2.filename;
    if (e2[0] = 31, e2[1] = 139, e2[2] = 8, e2[8] = t2.level < 2 ? 4 : 9 == t2.level ? 2 : 0, e2[9] = 3, 0 != t2.mtime && Ri(e2, 4, Math.floor(new Date(t2.mtime || Date.now()) / 1e3)), r2) {
      e2[3] = 8;
      for (var n2 = 0; n2 <= r2.length; ++n2)
        e2[n2 + 10] = r2.charCodeAt(n2);
    }
  }, Oi = function(e2) {
    if (31 != e2[0] || 139 != e2[1] || 8 != e2[2])
      throw "invalid gzip data";
    var t2 = e2[3], r2 = 10;
    4 & t2 && (r2 += e2[10] | 2 + (e2[11] << 8));
    for (var n2 = (t2 >> 3 & 1) + (t2 >> 4 & 1); n2 > 0; n2 -= !e2[r2++])
      ;
    return r2 + (2 & t2);
  }, Fi = function(e2) {
    var t2 = e2.length;
    return (e2[t2 - 4] | e2[t2 - 3] << 8 | e2[t2 - 2] << 16 | e2[t2 - 1] << 24) >>> 0;
  }, Ui = function(e2) {
    return 10 + (e2.filename && e2.filename.length + 1 || 0);
  }, Ni = function(e2, t2) {
    var r2 = t2.level, n2 = 0 == r2 ? 0 : r2 < 6 ? 1 : 9 == r2 ? 3 : 2;
    e2[0] = 120, e2[1] = n2 << 6 | (n2 ? 32 - 2 * n2 : 1);
  }, ji = function(e2) {
    if (8 != (15 & e2[0]) || e2[0] >>> 4 > 7 || (e2[0] << 8 | e2[1]) % 31)
      throw "invalid zlib data";
    if (32 & e2[1])
      throw "invalid zlib data: preset dictionaries not supported";
  };
  function zi(e2, t2) {
    return t2 || "function" != typeof e2 || (t2 = e2, e2 = {}), this.ondata = t2, e2;
  }
  var Gi = function() {
    function e2(e3, t2) {
      t2 || "function" != typeof e3 || (t2 = e3, e3 = {}), this.ondata = t2, this.o = e3 || {};
    }
    return e2.prototype.p = function(e3, t2) {
      this.ondata(mi(e3, this.o, 0, 0, !t2), t2);
    }, e2.prototype.push = function(e3, t2) {
      if (this.d)
        throw "stream finished";
      if (!this.ondata)
        throw "no stream handler";
      this.d = t2, this.p(e3, t2 || false);
    }, e2;
  }(), Vi = function() {
    return function(e2, t2) {
      ki([yi, function() {
        return [Ii, Gi];
      }], this, zi.call(this, e2, t2), function(e3) {
        var t3 = new Gi(e3.data);
        onmessage = Ii(t3);
      }, 6);
    };
  }();
  function Qi(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return Ti(e2, t2, [yi], function(e3) {
      return Ci(Hi(e3.data[0], e3.data[1]));
    }, 0, r2);
  }
  function Hi(e2, t2) {
    return mi(e2, t2 || {}, 0, 0);
  }
  var Wi = function() {
    function e2(e3) {
      this.s = {}, this.p = new Cn(0), this.ondata = e3;
    }
    return e2.prototype.e = function(e3) {
      if (this.d)
        throw "stream finished";
      if (!this.ondata)
        throw "no stream handler";
      var t2 = this.p.length, r2 = new Cn(t2 + e3.length);
      r2.set(this.p), r2.set(e3, t2), this.p = r2;
    }, e2.prototype.c = function(e3) {
      this.d = this.s.i = e3 || false;
      var t2 = this.s.b, r2 = ei(this.p, this.o, this.s);
      this.ondata($n(r2, t2, this.s.b), this.d), this.o = $n(r2, this.s.b - 32768), this.s.b = this.o.length, this.p = $n(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    }, e2.prototype.push = function(e3, t2) {
      this.e(e3), this.c(t2);
    }, e2;
  }(), qi = function() {
    return function(e2) {
      this.ondata = e2, ki([bi, function() {
        return [Ii, Wi];
      }], this, 0, function() {
        var e3 = new Wi();
        onmessage = Ii(e3);
      }, 7);
    };
  }();
  function Xi(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return Ti(e2, t2, [bi], function(e3) {
      return Ci(Yi(e3.data[0], Mi(e3.data[1])));
    }, 1, r2);
  }
  function Yi(e2, t2) {
    return ei(e2, t2);
  }
  var Ki = function() {
    function e2(e3, t2) {
      this.c = di(), this.l = 0, this.v = 1, Gi.call(this, e3, t2);
    }
    return e2.prototype.push = function(e3, t2) {
      Gi.prototype.push.call(this, e3, t2);
    }, e2.prototype.p = function(e3, t2) {
      this.c.p(e3), this.l += e3.length;
      var r2 = mi(e3, this.o, this.v && Ui(this.o), t2 && 8, !t2);
      this.v && (Li(r2, this.o), this.v = 0), t2 && (Ri(r2, r2.length - 8, this.c.d()), Ri(r2, r2.length - 4, this.l)), this.ondata(r2, t2);
    }, e2;
  }(), Ji = function() {
    return function(e2, t2) {
      ki([yi, xi, function() {
        return [Ii, Gi, Ki];
      }], this, zi.call(this, e2, t2), function(e3) {
        var t3 = new Ki(e3.data);
        onmessage = Ii(t3);
      }, 8);
    };
  }();
  function Zi(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return Ti(e2, t2, [yi, xi, function() {
      return [$i];
    }], function(e3) {
      return Ci($i(e3.data[0], e3.data[1]));
    }, 2, r2);
  }
  function $i(e2, t2) {
    t2 || (t2 = {});
    var r2 = di(), n2 = e2.length;
    r2.p(e2);
    var i2 = mi(e2, t2, Ui(t2), 8), s2 = i2.length;
    return Li(i2, t2), Ri(i2, s2 - 8, r2.d()), Ri(i2, s2 - 4, n2), i2;
  }
  var es = function() {
    function e2(e3) {
      this.v = 1, Wi.call(this, e3);
    }
    return e2.prototype.push = function(e3, t2) {
      if (Wi.prototype.e.call(this, e3), this.v) {
        var r2 = this.p.length > 3 ? Oi(this.p) : 4;
        if (r2 >= this.p.length && !t2)
          return;
        this.p = this.p.subarray(r2), this.v = 0;
      }
      if (t2) {
        if (this.p.length < 8)
          throw "invalid gzip stream";
        this.p = this.p.subarray(0, -8);
      }
      Wi.prototype.c.call(this, t2);
    }, e2;
  }(), ts = function() {
    return function(e2) {
      this.ondata = e2, ki([bi, wi, function() {
        return [Ii, Wi, es];
      }], this, 0, function() {
        var e3 = new es();
        onmessage = Ii(e3);
      }, 9);
    };
  }();
  function rs(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return Ti(e2, t2, [bi, wi, function() {
      return [ns];
    }], function(e3) {
      return Ci(ns(e3.data[0]));
    }, 3, r2);
  }
  function ns(e2, t2) {
    return ei(e2.subarray(Oi(e2), -8), t2 || new Cn(Fi(e2)));
  }
  var is = function() {
    function e2(e3, t2) {
      this.c = fi(), this.v = 1, Gi.call(this, e3, t2);
    }
    return e2.prototype.push = function(e3, t2) {
      Gi.prototype.push.call(this, e3, t2);
    }, e2.prototype.p = function(e3, t2) {
      this.c.p(e3);
      var r2 = mi(e3, this.o, this.v && 2, t2 && 4, !t2);
      this.v && (Ni(r2, this.o), this.v = 0), t2 && Ri(r2, r2.length - 4, this.c.d()), this.ondata(r2, t2);
    }, e2;
  }(), ss = function() {
    return function(e2, t2) {
      ki([yi, Ei, function() {
        return [Ii, Gi, is];
      }], this, zi.call(this, e2, t2), function(e3) {
        var t3 = new is(e3.data);
        onmessage = Ii(t3);
      }, 10);
    };
  }();
  function os(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return Ti(e2, t2, [yi, Ei, function() {
      return [as];
    }], function(e3) {
      return Ci(as(e3.data[0], e3.data[1]));
    }, 4, r2);
  }
  function as(e2, t2) {
    t2 || (t2 = {});
    var r2 = fi();
    r2.p(e2);
    var n2 = mi(e2, t2, 2, 4);
    return Ni(n2, t2), Ri(n2, n2.length - 4, r2.d()), n2;
  }
  var ls = function() {
    function e2(e3) {
      this.v = 1, Wi.call(this, e3);
    }
    return e2.prototype.push = function(e3, t2) {
      if (Wi.prototype.e.call(this, e3), this.v) {
        if (this.p.length < 2 && !t2)
          return;
        this.p = this.p.subarray(2), this.v = 0;
      }
      if (t2) {
        if (this.p.length < 4)
          throw "invalid zlib stream";
        this.p = this.p.subarray(0, -4);
      }
      Wi.prototype.c.call(this, t2);
    }, e2;
  }(), cs = function() {
    return function(e2) {
      this.ondata = e2, ki([bi, Si, function() {
        return [Ii, Wi, ls];
      }], this, 0, function() {
        var e3 = new ls();
        onmessage = Ii(e3);
      }, 11);
    };
  }();
  function us(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return Ti(e2, t2, [bi, Si, function() {
      return [hs];
    }], function(e3) {
      return Ci(hs(e3.data[0], Mi(e3.data[1])));
    }, 5, r2);
  }
  function hs(e2, t2) {
    return ei((ji(e2), e2.subarray(2, -4)), t2);
  }
  var ps = function() {
    function e2(e3) {
      this.G = es, this.I = Wi, this.Z = ls, this.ondata = e3;
    }
    return e2.prototype.push = function(e3, t2) {
      if (!this.ondata)
        throw "no stream handler";
      if (this.s)
        this.s.push(e3, t2);
      else {
        if (this.p && this.p.length) {
          var r2 = new Cn(this.p.length + e3.length);
          r2.set(this.p), r2.set(e3, this.p.length);
        } else
          this.p = e3;
        if (this.p.length > 2) {
          var n2 = this, i2 = function() {
            n2.ondata.apply(n2, arguments);
          };
          this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i2) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i2) : new this.Z(i2), this.s.push(this.p, t2), this.p = null;
        }
      }
    }, e2;
  }(), ds = function() {
    function e2(e3) {
      this.G = ts, this.I = qi, this.Z = cs, this.ondata = e3;
    }
    return e2.prototype.push = function(e3, t2) {
      ps.prototype.push.call(this, e3, t2);
    }, e2;
  }();
  function fs(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return 31 == e2[0] && 139 == e2[1] && 8 == e2[2] ? rs(e2, t2, r2) : 8 != (15 & e2[0]) || e2[0] >> 4 > 7 || (e2[0] << 8 | e2[1]) % 31 ? Xi(e2, t2, r2) : us(e2, t2, r2);
  }
  function ms(e2, t2) {
    return 31 == e2[0] && 139 == e2[1] && 8 == e2[2] ? ns(e2, t2) : 8 != (15 & e2[0]) || e2[0] >> 4 > 7 || (e2[0] << 8 | e2[1]) % 31 ? Yi(e2, t2) : hs(e2, t2);
  }
  var _s = function(e2, t2, r2, n2) {
    for (var i2 in e2) {
      var s2 = e2[i2], o2 = t2 + i2;
      s2 instanceof Cn ? r2[o2] = [s2, n2] : Array.isArray(s2) ? r2[o2] = [s2[0], _i(n2, s2[1])] : _s(s2, o2 + "/", r2, n2);
    }
  }, gs = "undefined" != typeof TextEncoder && new TextEncoder(), vs = "undefined" != typeof TextDecoder && new TextDecoder(), As = 0;
  try {
    vs.decode(ui, { stream: true }), As = 1;
  } catch (ru2) {
  }
  var bs = function(e2) {
    for (var t2 = "", r2 = 0; ; ) {
      var n2 = e2[r2++], i2 = (n2 > 127) + (n2 > 223) + (n2 > 239);
      if (r2 + i2 > e2.length)
        return [t2, $n(e2, r2 - 1)];
      i2 ? 3 == i2 ? (n2 = ((15 & n2) << 18 | (63 & e2[r2++]) << 12 | (63 & e2[r2++]) << 6 | 63 & e2[r2++]) - 65536, t2 += String.fromCharCode(55296 | n2 >> 10, 56320 | 1023 & n2)) : t2 += 1 & i2 ? String.fromCharCode((31 & n2) << 6 | 63 & e2[r2++]) : String.fromCharCode((15 & n2) << 12 | (63 & e2[r2++]) << 6 | 63 & e2[r2++]) : t2 += String.fromCharCode(n2);
    }
  }, ys = function() {
    function e2(e3) {
      this.ondata = e3, As ? this.t = new TextDecoder() : this.p = ui;
    }
    return e2.prototype.push = function(e3, t2) {
      if (!this.ondata)
        throw "no callback";
      if (t2 = !!t2, this.t) {
        if (this.ondata(this.t.decode(e3, { stream: true }), t2), t2) {
          if (this.t.decode().length)
            throw "invalid utf-8 data";
          this.t = null;
        }
      } else {
        if (!this.p)
          throw "stream finished";
        var r2 = new Cn(this.p.length + e3.length);
        r2.set(this.p), r2.set(e3, this.p.length);
        var n2 = bs(r2), i2 = n2[0], s2 = n2[1];
        if (t2) {
          if (s2.length)
            throw "invalid utf-8 data";
          this.p = null;
        } else
          this.p = s2;
        this.ondata(i2, t2);
      }
    }, e2;
  }(), xs = function() {
    function e2(e3) {
      this.ondata = e3;
    }
    return e2.prototype.push = function(e3, t2) {
      if (!this.ondata)
        throw "no callback";
      if (this.d)
        throw "stream finished";
      this.ondata(ws(e3), this.d = t2 || false);
    }, e2;
  }();
  function ws(e2, t2) {
    if (t2) {
      for (var r2 = new Cn(e2.length), n2 = 0; n2 < e2.length; ++n2)
        r2[n2] = e2.charCodeAt(n2);
      return r2;
    }
    if (gs)
      return gs.encode(e2);
    var i2 = e2.length, s2 = new Cn(e2.length + (e2.length >> 1)), o2 = 0, a2 = function(e3) {
      s2[o2++] = e3;
    };
    for (n2 = 0; n2 < i2; ++n2) {
      if (o2 + 5 > s2.length) {
        var l2 = new Cn(o2 + 8 + (i2 - n2 << 1));
        l2.set(s2), s2 = l2;
      }
      var c2 = e2.charCodeAt(n2);
      c2 < 128 || t2 ? a2(c2) : c2 < 2048 ? (a2(192 | c2 >> 6), a2(128 | 63 & c2)) : c2 > 55295 && c2 < 57344 ? (a2(240 | (c2 = 65536 + (1047552 & c2) | 1023 & e2.charCodeAt(++n2)) >> 18), a2(128 | c2 >> 12 & 63), a2(128 | c2 >> 6 & 63), a2(128 | 63 & c2)) : (a2(224 | c2 >> 12), a2(128 | c2 >> 6 & 63), a2(128 | 63 & c2));
    }
    return $n(s2, 0, o2);
  }
  function Es(e2, t2) {
    if (t2) {
      for (var r2 = "", n2 = 0; n2 < e2.length; n2 += 16384)
        r2 += String.fromCharCode.apply(null, e2.subarray(n2, n2 + 16384));
      return r2;
    }
    if (vs)
      return vs.decode(e2);
    var i2 = bs(e2), s2 = i2[0];
    if (i2[1].length)
      throw "invalid utf-8 data";
    return s2;
  }
  var Ss = function(e2) {
    return 1 == e2 ? 3 : e2 < 6 ? 2 : 9 == e2 ? 1 : 0;
  }, Cs = function(e2, t2) {
    return t2 + 30 + Di(e2, t2 + 26) + Di(e2, t2 + 28);
  }, Ms = function(e2, t2, r2) {
    var n2 = Di(e2, t2 + 28), i2 = Es(e2.subarray(t2 + 46, t2 + 46 + n2), !(2048 & Di(e2, t2 + 8))), s2 = t2 + 46 + n2, o2 = Pi(e2, t2 + 20), a2 = r2 && 4294967295 == o2 ? Ts(e2, s2) : [o2, Pi(e2, t2 + 24), Pi(e2, t2 + 42)], l2 = a2[0], c2 = a2[1], u2 = a2[2];
    return [Di(e2, t2 + 10), l2, c2, i2, s2 + Di(e2, t2 + 30) + Di(e2, t2 + 32), u2];
  }, Ts = function(e2, t2) {
    for (; 1 != Di(e2, t2); t2 += 4 + Di(e2, t2 + 2))
      ;
    return [Bi(e2, t2 + 12), Bi(e2, t2 + 4), Bi(e2, t2 + 20)];
  }, Is = function(e2) {
    var t2 = 0;
    if (e2)
      for (var r2 in e2) {
        var n2 = e2[r2].length;
        if (n2 > 65535)
          throw "extra field too long";
        t2 += n2 + 4;
      }
    return t2;
  }, ks = function(e2, t2, r2, n2, i2, s2, o2, a2) {
    var l2 = n2.length, c2 = r2.extra, u2 = a2 && a2.length, h2 = Is(c2);
    Ri(e2, t2, null != o2 ? 33639248 : 67324752), t2 += 4, null != o2 && (e2[t2++] = 20, e2[t2++] = r2.os), e2[t2] = 20, t2 += 2, e2[t2++] = r2.flag << 1 | (null == s2 && 8), e2[t2++] = i2 && 8, e2[t2++] = 255 & r2.compression, e2[t2++] = r2.compression >> 8;
    var p2 = new Date(null == r2.mtime ? Date.now() : r2.mtime), d2 = p2.getFullYear() - 1980;
    if (d2 < 0 || d2 > 119)
      throw "date not in range 1980-2099";
    if (Ri(e2, t2, d2 << 25 | p2.getMonth() + 1 << 21 | p2.getDate() << 16 | p2.getHours() << 11 | p2.getMinutes() << 5 | p2.getSeconds() >>> 1), t2 += 4, null != s2 && (Ri(e2, t2, r2.crc), Ri(e2, t2 + 4, s2), Ri(e2, t2 + 8, r2.size)), Ri(e2, t2 + 12, l2), Ri(e2, t2 + 14, h2), t2 += 16, null != o2 && (Ri(e2, t2, u2), Ri(e2, t2 + 6, r2.attrs), Ri(e2, t2 + 10, o2), t2 += 14), e2.set(n2, t2), t2 += l2, h2)
      for (var f2 in c2) {
        var m2 = c2[f2], _2 = m2.length;
        Ri(e2, t2, +f2), Ri(e2, t2 + 2, _2), e2.set(m2, t2 + 4), t2 += 4 + _2;
      }
    return u2 && (e2.set(a2, t2), t2 += u2), t2;
  }, Ds = function(e2, t2, r2, n2, i2) {
    Ri(e2, t2, 101010256), Ri(e2, t2 + 8, r2), Ri(e2, t2 + 10, r2), Ri(e2, t2 + 12, n2), Ri(e2, t2 + 16, i2);
  }, Ps = function() {
    function e2(e3) {
      this.filename = e3, this.c = di(), this.size = 0, this.compression = 0;
    }
    return e2.prototype.process = function(e3, t2) {
      this.ondata(null, e3, t2);
    }, e2.prototype.push = function(e3, t2) {
      if (!this.ondata)
        throw "no callback - add to ZIP archive before pushing";
      this.c.p(e3), this.size += e3.length, t2 && (this.crc = this.c.d()), this.process(e3, t2 || false);
    }, e2;
  }(), Bs = function() {
    function e2(e3, t2) {
      var r2 = this;
      t2 || (t2 = {}), Ps.call(this, e3), this.d = new Gi(t2, function(e4, t3) {
        r2.ondata(null, e4, t3);
      }), this.compression = 8, this.flag = Ss(t2.level);
    }
    return e2.prototype.process = function(e3, t2) {
      try {
        this.d.push(e3, t2);
      } catch (e4) {
        this.ondata(e4, null, t2);
      }
    }, e2.prototype.push = function(e3, t2) {
      Ps.prototype.push.call(this, e3, t2);
    }, e2;
  }(), Rs = function() {
    function e2(e3, t2) {
      var r2 = this;
      t2 || (t2 = {}), Ps.call(this, e3), this.d = new Vi(t2, function(e4, t3, n2) {
        r2.ondata(e4, t3, n2);
      }), this.compression = 8, this.flag = Ss(t2.level), this.terminate = this.d.terminate;
    }
    return e2.prototype.process = function(e3, t2) {
      this.d.push(e3, t2);
    }, e2.prototype.push = function(e3, t2) {
      Ps.prototype.push.call(this, e3, t2);
    }, e2;
  }(), Ls = function() {
    function e2(e3) {
      this.ondata = e3, this.u = [], this.d = 1;
    }
    return e2.prototype.add = function(e3) {
      var t2 = this;
      if (2 & this.d)
        throw "stream finished";
      var r2 = ws(e3.filename), n2 = r2.length, i2 = e3.comment, s2 = i2 && ws(i2), o2 = n2 != e3.filename.length || s2 && i2.length != s2.length, a2 = n2 + Is(e3.extra) + 30;
      if (n2 > 65535)
        throw "filename too long";
      var l2 = new Cn(a2);
      ks(l2, 0, e3, r2, o2);
      var c2 = [l2], u2 = function() {
        for (var e4 = 0, r3 = c2; e4 < r3.length; e4++) {
          var n3 = r3[e4];
          t2.ondata(null, n3, false);
        }
        c2 = [];
      }, h2 = this.d;
      this.d = 0;
      var p2 = this.u.length, d2 = _i(e3, { f: r2, u: o2, o: s2, t: function() {
        e3.terminate && e3.terminate();
      }, r: function() {
        if (u2(), h2) {
          var e4 = t2.u[p2 + 1];
          e4 ? e4.r() : t2.d = 1;
        }
        h2 = 1;
      } }), f2 = 0;
      e3.ondata = function(r3, n3, i3) {
        if (r3)
          t2.ondata(r3, n3, i3), t2.terminate();
        else if (f2 += n3.length, c2.push(n3), i3) {
          var s3 = new Cn(16);
          Ri(s3, 0, 134695760), Ri(s3, 4, e3.crc), Ri(s3, 8, f2), Ri(s3, 12, e3.size), c2.push(s3), d2.c = f2, d2.b = a2 + f2 + 16, d2.crc = e3.crc, d2.size = e3.size, h2 && d2.r(), h2 = 1;
        } else
          h2 && u2();
      }, this.u.push(d2);
    }, e2.prototype.end = function() {
      var e3 = this;
      if (2 & this.d) {
        if (1 & this.d)
          throw "stream finishing";
        throw "stream finished";
      }
      this.d ? this.e() : this.u.push({ r: function() {
        1 & e3.d && (e3.u.splice(-1, 1), e3.e());
      }, t: function() {
      } }), this.d = 3;
    }, e2.prototype.e = function() {
      for (var e3 = 0, t2 = 0, r2 = 0, n2 = 0, i2 = this.u; n2 < i2.length; n2++)
        r2 += 46 + (l2 = i2[n2]).f.length + Is(l2.extra) + (l2.o ? l2.o.length : 0);
      for (var s2 = new Cn(r2 + 22), o2 = 0, a2 = this.u; o2 < a2.length; o2++) {
        var l2 = a2[o2];
        ks(s2, e3, l2, l2.f, l2.u, l2.c, t2, l2.o), e3 += 46 + l2.f.length + Is(l2.extra) + (l2.o ? l2.o.length : 0), t2 += l2.b;
      }
      Ds(s2, e3, this.u.length, r2, t2), this.ondata(null, s2, true), this.d = 2;
    }, e2.prototype.terminate = function() {
      for (var e3 = 0, t2 = this.u; e3 < t2.length; e3++)
        t2[e3].t();
      this.d = 2;
    }, e2;
  }();
  function Os(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    var n2 = {};
    _s(e2, "", n2, t2);
    var i2 = Object.keys(n2), s2 = i2.length, o2 = 0, a2 = 0, l2 = s2, c2 = new Array(s2), u2 = [], h2 = function() {
      for (var e3 = 0; e3 < u2.length; ++e3)
        u2[e3]();
    }, p2 = function() {
      var e3 = new Cn(a2 + 22), t3 = o2, n3 = a2 - o2;
      a2 = 0;
      for (var i3 = 0; i3 < l2; ++i3) {
        var s3 = c2[i3];
        try {
          var u3 = s3.c.length;
          ks(e3, a2, s3, s3.f, s3.u, u3);
          var h3 = 30 + s3.f.length + Is(s3.extra), p3 = a2 + h3;
          e3.set(s3.c, p3), ks(e3, o2, s3, s3.f, s3.u, u3, a2, s3.m), o2 += 16 + h3 + (s3.m ? s3.m.length : 0), a2 = p3 + u3;
        } catch (e4) {
          return r2(e4, null);
        }
      }
      Ds(e3, o2, c2.length, n3, t3), r2(null, e3);
    };
    s2 || p2();
    for (var d2 = function(e3) {
      var t3 = i2[e3], l3 = n2[t3], d3 = l3[0], f3 = l3[1], m2 = di(), _2 = d3.length;
      m2.p(d3);
      var g2 = ws(t3), v2 = g2.length, A2 = f3.comment, b2 = A2 && ws(A2), y2 = b2 && b2.length, x2 = Is(f3.extra), w2 = 0 == f3.level ? 0 : 8, E2 = function(n3, i3) {
        if (n3)
          h2(), r2(n3, null);
        else {
          var l4 = i3.length;
          c2[e3] = _i(f3, { size: _2, crc: m2.d(), c: i3, f: g2, m: b2, u: v2 != t3.length || b2 && A2.length != y2, compression: w2 }), o2 += 30 + v2 + x2 + l4, a2 += 76 + 2 * (v2 + x2) + (y2 || 0) + l4, --s2 || p2();
        }
      };
      if (v2 > 65535 && E2("filename too long", null), w2)
        if (_2 < 16e4)
          try {
            E2(null, Hi(d3, f3));
          } catch (e4) {
            E2(e4, null);
          }
        else
          u2.push(Qi(d3, f3, E2));
      else
        E2(null, d3);
    }, f2 = 0; f2 < l2; ++f2)
      d2(f2);
    return h2;
  }
  function Fs(e2, t2) {
    t2 || (t2 = {});
    var r2 = {}, n2 = [];
    _s(e2, "", r2, t2);
    var i2 = 0, s2 = 0;
    for (var o2 in r2) {
      var a2 = r2[o2], l2 = a2[0], c2 = a2[1], u2 = 0 == c2.level ? 0 : 8, h2 = (w2 = ws(o2)).length, p2 = c2.comment, d2 = p2 && ws(p2), f2 = d2 && d2.length, m2 = Is(c2.extra);
      if (h2 > 65535)
        throw "filename too long";
      var _2 = u2 ? Hi(l2, c2) : l2, g2 = _2.length, v2 = di();
      v2.p(l2), n2.push(_i(c2, { size: l2.length, crc: v2.d(), c: _2, f: w2, m: d2, u: h2 != o2.length || d2 && p2.length != f2, o: i2, compression: u2 })), i2 += 30 + h2 + m2 + g2, s2 += 76 + 2 * (h2 + m2) + (f2 || 0) + g2;
    }
    for (var A2 = new Cn(s2 + 22), b2 = i2, y2 = s2 - i2, x2 = 0; x2 < n2.length; ++x2) {
      var w2 = n2[x2];
      ks(A2, w2.o, w2, w2.f, w2.u, w2.c.length);
      var E2 = 30 + w2.f.length + Is(w2.extra);
      A2.set(w2.c, w2.o + E2), ks(A2, i2, w2, w2.f, w2.u, w2.c.length, w2.o, w2.m), i2 += 16 + E2 + (w2.m ? w2.m.length : 0);
    }
    return Ds(A2, i2, n2.length, y2, b2), A2;
  }
  var Us = function() {
    function e2() {
    }
    return e2.prototype.push = function(e3, t2) {
      this.ondata(null, e3, t2);
    }, e2.compression = 0, e2;
  }(), Ns = function() {
    function e2() {
      var e3 = this;
      this.i = new Wi(function(t2, r2) {
        e3.ondata(null, t2, r2);
      });
    }
    return e2.prototype.push = function(e3, t2) {
      try {
        this.i.push(e3, t2);
      } catch (r2) {
        this.ondata(r2, e3, t2);
      }
    }, e2.compression = 8, e2;
  }(), js = function() {
    function e2(e3, t2) {
      var r2 = this;
      t2 < 32e4 ? this.i = new Wi(function(e4, t3) {
        r2.ondata(null, e4, t3);
      }) : (this.i = new qi(function(e4, t3, n2) {
        r2.ondata(e4, t3, n2);
      }), this.terminate = this.i.terminate);
    }
    return e2.prototype.push = function(e3, t2) {
      this.i.terminate && (e3 = $n(e3, 0)), this.i.push(e3, t2);
    }, e2.compression = 8, e2;
  }(), zs = function() {
    function e2(e3) {
      this.onfile = e3, this.k = [], this.o = { 0: Us }, this.p = ui;
    }
    return e2.prototype.push = function(e3, t2) {
      var r2 = this;
      if (!this.onfile)
        throw "no callback";
      if (!this.p)
        throw "stream finished";
      if (this.c > 0) {
        var n2 = Math.min(this.c, e3.length), i2 = e3.subarray(0, n2);
        if (this.c -= n2, this.d ? this.d.push(i2, !this.c) : this.k[0].push(i2), (e3 = e3.subarray(n2)).length)
          return this.push(e3, t2);
      } else {
        var s2 = 0, o2 = 0, a2 = void 0, l2 = void 0;
        this.p.length ? e3.length ? ((l2 = new Cn(this.p.length + e3.length)).set(this.p), l2.set(e3, this.p.length)) : l2 = this.p : l2 = e3;
        for (var c2 = l2.length, u2 = this.c, h2 = u2 && this.d, p2 = function() {
          var e4, t3 = Pi(l2, o2);
          if (67324752 == t3) {
            s2 = 1, a2 = o2, d2.d = null, d2.c = 0;
            var n3 = Di(l2, o2 + 6), i3 = Di(l2, o2 + 8), h3 = 2048 & n3, p3 = 8 & n3, f3 = Di(l2, o2 + 26), m2 = Di(l2, o2 + 28);
            if (c2 > o2 + 30 + f3 + m2) {
              var _2 = [];
              d2.k.unshift(_2), s2 = 2;
              var g2, v2 = Pi(l2, o2 + 18), A2 = Pi(l2, o2 + 22), b2 = Es(l2.subarray(o2 + 30, o2 += 30 + f3), !h3);
              4294967295 == v2 ? (e4 = p3 ? [-2] : Ts(l2, o2), v2 = e4[0], A2 = e4[1]) : p3 && (v2 = -1), o2 += m2, d2.c = v2;
              var y2 = { name: b2, compression: i3, start: function() {
                if (!y2.ondata)
                  throw "no callback";
                if (v2) {
                  var e5 = r2.o[i3];
                  if (!e5)
                    throw "unknown compression type " + i3;
                  (g2 = v2 < 0 ? new e5(b2) : new e5(b2, v2, A2)).ondata = function(e6, t5, r3) {
                    y2.ondata(e6, t5, r3);
                  };
                  for (var t4 = 0, n4 = _2; t4 < n4.length; t4++) {
                    var s3 = n4[t4];
                    g2.push(s3, false);
                  }
                  r2.k[0] == _2 && r2.c ? r2.d = g2 : g2.push(ui, true);
                } else
                  y2.ondata(null, ui, true);
              }, terminate: function() {
                g2 && g2.terminate && g2.terminate();
              } };
              v2 >= 0 && (y2.size = v2, y2.originalSize = A2), d2.onfile(y2);
            }
            return "break";
          }
          if (u2) {
            if (134695760 == t3)
              return a2 = o2 += 12 + (-2 == u2 && 8), s2 = 3, d2.c = 0, "break";
            if (33639248 == t3)
              return a2 = o2 -= 4, s2 = 3, d2.c = 0, "break";
          }
        }, d2 = this; o2 < c2 - 4 && "break" !== p2(); ++o2)
          ;
        if (this.p = ui, u2 < 0) {
          var f2 = s2 ? l2.subarray(0, a2 - 12 - (-2 == u2 && 8) - (134695760 == Pi(l2, a2 - 16) && 4)) : l2.subarray(0, o2);
          h2 ? h2.push(f2, !!s2) : this.k[+(2 == s2)].push(f2);
        }
        if (2 & s2)
          return this.push(l2.subarray(o2), t2);
        this.p = l2.subarray(o2);
      }
      if (t2) {
        if (this.c)
          throw "invalid zip file";
        this.p = null;
      }
    }, e2.prototype.register = function(e3) {
      this.o[e3.compression] = e3;
    }, e2;
  }();
  function Gs(e2, t2) {
    if ("function" != typeof t2)
      throw "no callback";
    for (var r2 = [], n2 = function() {
      for (var e3 = 0; e3 < r2.length; ++e3)
        r2[e3]();
    }, i2 = {}, s2 = e2.length - 22; 101010256 != Pi(e2, s2); --s2)
      if (!s2 || e2.length - s2 > 65558)
        return void t2("invalid zip file", null);
    var o2 = Di(e2, s2 + 8);
    o2 || t2(null, {});
    var a2 = o2, l2 = Pi(e2, s2 + 16), c2 = 4294967295 == l2;
    if (c2) {
      if (s2 = Pi(e2, s2 - 12), 101075792 != Pi(e2, s2))
        return void t2("invalid zip file", null);
      a2 = o2 = Pi(e2, s2 + 32), l2 = Pi(e2, s2 + 48);
    }
    for (var u2 = function(s3) {
      var a3 = Ms(e2, l2, c2), u3 = a3[0], h3 = a3[1], p2 = a3[2], d2 = a3[3], f2 = a3[4], m2 = a3[5], _2 = Cs(e2, m2);
      l2 = f2;
      var g2 = function(e3, r3) {
        e3 ? (n2(), t2(e3, null)) : (i2[d2] = r3, --o2 || t2(null, i2));
      };
      if (u3)
        if (8 == u3) {
          var v2 = e2.subarray(_2, _2 + h3);
          if (h3 < 32e4)
            try {
              g2(null, Yi(v2, new Cn(p2)));
            } catch (e3) {
              g2(e3, null);
            }
          else
            r2.push(Xi(v2, { size: p2 }, g2));
        } else
          g2("unknown compression type " + u3, null);
      else
        g2(null, $n(e2, _2, _2 + h3));
    }, h2 = 0; h2 < a2; ++h2)
      u2();
    return n2;
  }
  function Vs(e2) {
    for (var t2 = {}, r2 = e2.length - 22; 101010256 != Pi(e2, r2); --r2)
      if (!r2 || e2.length - r2 > 65558)
        throw "invalid zip file";
    var n2 = Di(e2, r2 + 8);
    if (!n2)
      return {};
    var i2 = Pi(e2, r2 + 16), s2 = 4294967295 == i2;
    if (s2) {
      if (r2 = Pi(e2, r2 - 12), 101075792 != Pi(e2, r2))
        throw "invalid zip file";
      n2 = Pi(e2, r2 + 32), i2 = Pi(e2, r2 + 48);
    }
    for (var o2 = 0; o2 < n2; ++o2) {
      var a2 = Ms(e2, i2, s2), l2 = a2[0], c2 = a2[1], u2 = a2[2], h2 = a2[3], p2 = a2[4], d2 = a2[5], f2 = Cs(e2, d2);
      if (i2 = p2, l2) {
        if (8 != l2)
          throw "unknown compression type " + l2;
        t2[h2] = Yi(e2.subarray(f2, f2 + c2), new Cn(u2));
      } else
        t2[h2] = $n(e2, f2, f2 + c2);
    }
    return t2;
  }
  class Qs extends n.hH6 {
    load(e2, t2, r2, n2) {
      return this.setResponseType("arraybuffer"), super.load(e2, (e3) => {
        const r3 = Vs(new Uint8Array(e3)), n3 = new Map(Object.entries(r3).map(([e4, t3]) => [e4, new File([t3], e4)]));
        null == t2 || t2(n3);
      }, r2, n2);
    }
  }
  function Hs() {
    Js.Importers.push(new ir(Qs, ["zip"], true));
  }
  class Ws extends n.Ox3 {
    constructor(e2, t2) {
      super(), this.assetType = "light", this.isDirectionalLight2 = true, this.color = new n.Ilk(e2), this.intensity = t2 || 1, this.target.position.set(0, 0, -1), this.add(this.target);
    }
    get lightObject() {
      return this;
    }
    get modelObject() {
      return this;
    }
    copy(e2, t2) {
      const r2 = this.target, n2 = e2.userData;
      return e2.userData = {}, super.copy(e2, t2), je(this.userData, n2), r2.position.copy(this.target.position), r2.updateMatrixWorld(), this.target = r2, this;
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = { type: "folder", label: "Directional Light", children: [{ type: "checkbox", label: "Enabled", property: [this, "visible"] }, { type: "color", label: "Color", property: [this, "color"] }, { type: "slider", label: "Intensity", bounds: [0, 20], property: [this, "intensity"] }, { type: "vec3", label: "Rotation", property: [this, "rotation"] }, { type: "vec3", label: "Position", property: [this, "position"] }, { type: "checkbox", label: "Shadow Enabled", property: [this, "castShadow"] }, { type: "vec2", label: "Shadow Map Size", property: [null == this ? void 0 : this.shadow, "mapSize"], onChange: () => {
        var e2, t2;
        null === (e2 = this.shadow.map) || void 0 === e2 || e2.dispose(), null === (t2 = this.shadow.mapPass) || void 0 === t2 || t2.dispose(), this.shadow.map = null, this.shadow.mapPass = null;
      } }, { type: "slider", bounds: [-1e-3, 1e-3], stepSize: 2e-5, label: "Shadow Bias", property: [null == this ? void 0 : this.shadow, "bias"], onChange: this.setDirty }, { type: "slider", bounds: [-0.1, 0.1], stepSize: 5e-3, label: "Shadow Normal Bias", property: [null == this ? void 0 : this.shadow, "normalBias"], onChange: this.setDirty }, { type: "slider", bounds: [0, 5], label: "Shadow radius", property: [null == this ? void 0 : this.shadow, "radius"], onChange: this.setDirty }, { type: "slider", bounds: [0.1, 50], label: "Shadow frustum", getValue: () => 2 * this.shadow.camera.right, setValue: (e2) => {
        this.shadow.camera.left = -e2 / 2, this.shadow.camera.right = e2 / 2, this.shadow.camera.top = e2 / 2, this.shadow.camera.bottom = -e2 / 2;
      }, onChange: this.setDirty }] };
    }
    toJSON(e2) {
      const { userData: t2, children: r2 } = this;
      this.userData = {}, this.children = [];
      const n2 = super.toJSON(e2);
      return n2.userData = ke(je({}, t2), false), this.userData = {}, this.children = r2, n2.type = "DirectionalLight2", n2.target = this.target.position.toArray(), Object.assign(n2, ke(this, true, e2));
    }
    fromJSON(e2, t2) {
      if ("DirectionalLight2" !== e2.type)
        return null;
      const r2 = e2.target, n2 = e2.object;
      return e2.target && (this.target.position.fromArray(e2.target), this.target.updateMatrixWorld(), delete e2.target), e2.object && delete e2.object, De(e2, this, true, t2), r2 && (e2.target = r2), n2 && (void 0 !== n2.color && this.color.set(n2.color), void 0 !== n2.intensity && (this.intensity = n2.intensity), e2.object = n2), this;
    }
  }
  class qs extends n.PMe {
    constructor(e2, t2, r2, n2, i2, s2) {
      super(e2, t2, r2, n2, i2, s2), this.assetType = "light", this.target.position.set(0, 0, -1), this.add(this.target);
    }
    get lightObject() {
      return this;
    }
    get modelObject() {
      return this;
    }
    copy(e2, t2) {
      const r2 = this.target, n2 = e2.userData;
      return e2.userData = {}, super.copy(e2, t2), je(this.userData, n2), r2.position.copy(this.target.position), r2.updateMatrixWorld(), this.target = r2, this;
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = { type: "folder", label: "Spot Light", children: [{ type: "checkbox", label: "Enabled", property: [this, "visible"] }, { type: "color", label: "Color", property: [this, "color"] }, { type: "slider", label: "Intensity", bounds: [0, 30], property: [this, "intensity"] }, { type: "slider", bounds: [0, 2], property: [this, "angle"] }, { type: "slider", bounds: [0, 0.9999], property: [this, "penumbra"] }, { type: "vec3", label: "Rotation", property: [this, "rotation"] }, { type: "vec3", label: "Position", property: [this, "position"] }, { type: "checkbox", label: "Shadow Enabled", property: [this, "castShadow"] }, { type: "vec2", label: "Shadow Map Size", property: [null == this ? void 0 : this.shadow, "mapSize"], onChange: () => {
        var e2, t2;
        null === (e2 = this.shadow.map) || void 0 === e2 || e2.dispose(), null === (t2 = this.shadow.mapPass) || void 0 === t2 || t2.dispose(), this.shadow.map = null, this.shadow.mapPass = null;
      } }, { type: "slider", bounds: [-1e-3, 1e-3], stepSize: 2e-5, label: "Shadow Bias", property: [null == this ? void 0 : this.shadow, "bias"], onChange: this.setDirty }, { type: "slider", bounds: [0, 5], label: "Shadow radius", property: [null == this ? void 0 : this.shadow, "radius"], onChange: this.setDirty }] };
    }
    toJSON(e2) {
      const { userData: t2, children: r2 } = this;
      this.userData = {}, this.children = [];
      const n2 = super.toJSON(e2);
      return n2.userData = ke(je({}, t2), false), this.userData = {}, this.children = r2, n2.type = "SpotLight2", n2.target = this.target.position.toArray(), Object.assign(n2, ke(this, true, e2));
    }
    fromJSON(e2, t2) {
      return "SpotLight2" !== e2.type ? null : (e2.target && (this.target.position.fromArray(e2.target), this.target.updateMatrixWorld()), e2.object ? (void 0 !== e2.object.color && this.color.set(e2.object.color), void 0 !== e2.object.intensity && (this.intensity = e2.object.intensity), void 0 !== e2.object.distance && (this.distance = e2.object.distance), void 0 !== e2.object.angle && (this.angle = e2.object.angle), void 0 !== e2.object.decay && (this.decay = e2.object.decay), void 0 !== e2.object.penumbra && (this.penumbra = e2.object.penumbra), De(e2, this, true, t2), this) : this);
    }
  }
  class Xs extends n.cek {
    constructor(e2, t2, r2, n2) {
      super(e2, t2, r2, n2), this.assetType = "light";
    }
    get lightObject() {
      return this;
    }
    get modelObject() {
      return this;
    }
    copy(e2, t2) {
      const r2 = e2.userData;
      return e2.userData = {}, super.copy(e2, t2), je(this.userData, r2), this;
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = { type: "folder", label: "Point Light", children: [{ type: "checkbox", label: "Enabled", property: [this, "visible"] }, { type: "color", label: "Color", property: [this, "color"] }, { type: "slider", label: "Intensity", bounds: [0, 30], property: [this, "intensity"] }, { type: "input", label: "Distance", property: [this, "distance"] }, { type: "input", property: [this, "decay"] }, { type: "vec3", label: "Position", property: [this, "position"] }, { type: "checkbox", label: "Shadow Enabled", property: [this, "castShadow"] }, { type: "vec2", label: "Shadow Map Size", property: [null == this ? void 0 : this.shadow, "mapSize"], onChange: () => {
        var e2, t2;
        null === (e2 = this.shadow.map) || void 0 === e2 || e2.dispose(), null === (t2 = this.shadow.mapPass) || void 0 === t2 || t2.dispose(), this.shadow.map = null, this.shadow.mapPass = null;
      } }, { type: "slider", bounds: [-1e-3, 1e-3], stepSize: 2e-5, label: "Shadow Bias", property: [null == this ? void 0 : this.shadow, "bias"], onChange: this.setDirty }, { type: "slider", bounds: [0, 5], label: "Shadow radius", property: [null == this ? void 0 : this.shadow, "radius"], onChange: this.setDirty }] };
    }
    toJSON(e2) {
      const { userData: t2 } = this;
      this.userData = {};
      const r2 = super.toJSON(e2);
      return r2.userData = ke(je({}, t2), false), this.userData = {}, r2.type = "PointLight2", Object.assign(r2, ke(this, true, e2));
    }
    fromJSON(e2, t2) {
      return "PointLight2" !== e2.type ? null : e2.object ? (void 0 !== e2.object.color && this.color.set(e2.object.color), void 0 !== e2.object.intensity && (this.intensity = e2.object.intensity), void 0 !== e2.object.distance && (this.distance = e2.object.distance), void 0 !== e2.object.decay && (this.decay = e2.object.decay), De(e2, this, true, t2), this) : this;
    }
  }
  class Ys extends n.Mig {
    constructor(e2, t2) {
      super(e2, t2), this.assetType = "light";
    }
    get lightObject() {
      return this;
    }
    get modelObject() {
      return this;
    }
    copy(e2, t2) {
      const r2 = e2.userData;
      return e2.userData = {}, super.copy(e2, t2), je(this.userData, r2), this;
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = { type: "folder", label: "Ambient Light", children: [{ type: "checkbox", label: "Enabled", property: [this, "visible"] }, { type: "color", label: "Color", property: [this, "color"] }, { type: "slider", label: "Intensity", bounds: [0, 20], property: [this, "intensity"] }] };
    }
    toJSON(e2) {
      const { userData: t2 } = this;
      this.userData = {};
      const r2 = super.toJSON(e2);
      return r2.userData = ke(je({}, t2), false), this.userData = {}, r2.type = "AmbientLight2", Object.assign(r2, ke(this, true, e2));
    }
    fromJSON(e2, t2) {
      return "AmbientLight2" !== e2.type ? null : e2.object ? (void 0 !== e2.object.color && this.color.set(e2.object.color), void 0 !== e2.object.intensity && (this.intensity = e2.object.intensity), De(e2, this, true, t2), this) : this;
    }
  }
  class Ks extends n.aNw {
    load(e2, t2, r2, i2) {
      const s2 = new n.hH6(this.manager);
      s2.setPath(this.path), s2.setResponseType("text"), s2.load(e2, (r3) => {
        try {
          t2(this.parse(r3));
        } catch (t3) {
          i2 ? i2(t3) : console.error(t3), this.manager.itemError(e2);
        }
      }, r2, i2);
    }
    parse(e2) {
      e2 = e2.replace(/^#.*?(\n|\r)/gm, "").replace(/^\s*?(\n|\r)/gm, "").trim();
      let t2 = null, r2 = null;
      const i2 = new n.Pa4(0, 0, 0), s2 = new n.Pa4(1, 1, 1), o2 = e2.split(/[\n\r]+/g);
      let a2 = null, l2 = 0;
      for (let e3 = 0, n2 = o2.length; e3 < n2; e3++) {
        const n3 = o2[e3].trim(), c3 = n3.split(/\s/g);
        switch (c3[0]) {
          case "TITLE":
            t2 = n3.substring(7, n3.length - 1);
            break;
          case "LUT_3D_SIZE":
            const e4 = c3[1];
            r2 = parseFloat(e4), a2 = new Uint8Array(r2 * r2 * r2 * 4);
            break;
          case "DOMAIN_MIN":
            i2.x = parseFloat(c3[1]), i2.y = parseFloat(c3[2]), i2.z = parseFloat(c3[3]);
            break;
          case "DOMAIN_MAX":
            s2.x = parseFloat(c3[1]), s2.y = parseFloat(c3[2]), s2.z = parseFloat(c3[3]);
            break;
          default:
            const o3 = parseFloat(c3[0]), u3 = parseFloat(c3[1]), h2 = parseFloat(c3[2]);
            if (o3 > 1 || o3 < 0 || u3 > 1 || u3 < 0 || h2 > 1 || h2 < 0)
              throw new Error("LUTCubeLoader : Non normalized values not supported.");
            a2[l2 + 0] = 255 * o3, a2[l2 + 1] = 255 * u3, a2[l2 + 2] = 255 * h2, a2[l2 + 3] = 255, l2 += 4;
        }
      }
      const c2 = new n.IEO();
      c2.image.data = a2, c2.image.width = r2, c2.image.height = r2 * r2, c2.type = n.ywz, c2.magFilter = n.wem, c2.minFilter = n.wem, c2.wrapS = n.uWy, c2.wrapT = n.uWy, c2.generateMipmaps = false, c2.needsUpdate = true;
      const u2 = new n.JUT();
      return u2.image.data = a2, u2.image.width = r2, u2.image.height = r2, u2.image.depth = r2, u2.type = n.ywz, u2.magFilter = n.wem, u2.minFilter = n.wem, u2.wrapS = n.uWy, u2.wrapT = n.uWy, u2.wrapR = n.uWy, u2.generateMipmaps = false, u2.needsUpdate = true, { title: t2, size: r2, domainMin: i2, domainMax: s2, texture: c2, texture3D: u2 };
    }
  }
  class Js extends r {
    constructor(e2, t2 = false) {
      super(), this._processors = new cr(), this._logger = console.log, this._loaderCache = [], this._fileDatabase = /* @__PURE__ */ new Map(), this._cachedAssets = [], t2 || (this._logger = () => {
      }), this._viewer = e2, this._onLoad = this._onLoad.bind(this), this._onProgress = this._onProgress.bind(this), this._onError = this._onError.bind(this), this._onStart = this._onStart.bind(this), this._urlModifier = this._urlModifier.bind(this), this._loadingManager = new n.lLk(this._onLoad, this._onProgress, this._onError), this._loadingManager.onStart = this._onStart, this._loadingManager.setURLModifier(this._urlModifier), Hs(), pr(e2.renderer.rendererObject), an(e2), En();
    }
    get processors() {
      return this._processors;
    }
    get loadingManager() {
      return this._loadingManager;
    }
    _onLoad() {
      this.dispatchEvent({ type: "onLoad" });
    }
    _onProgress(e2, t2, r2) {
      this.dispatchEvent({ type: "onProgress", url: e2, loaded: t2, total: r2 });
    }
    _onError(e2) {
      this.dispatchEvent({ type: "onError", url: e2 });
    }
    _onStart(e2, t2, r2) {
      this.dispatchEvent({ type: "onStart", url: e2, loaded: t2, total: r2 });
    }
    _urlModifier(e2) {
      var t2;
      let r2 = decodeURI(e2);
      const n2 = null === (t2 = this._rootContext) || void 0 === t2 ? void 0 : t2.rootUrl;
      r2.includes("://") || !n2 || r2.startsWith(n2) || (r2 = n2 + r2), r2 = r2.replace("./", ""), r2 = r2.replace(/^(\/\/)/, "/"), r2 = r2.replace(/\?.*$/, "");
      const i2 = this._fileDatabase.get(r2);
      return i2 ? i2.ext ? (i2.objectUrl || (i2.objectUrl = URL.createObjectURL(i2) + "#" + r2), i2.objectUrl) : (console.error("Unable to determine file extension", i2), e2) : e2;
    }
    _createLoader(e2) {
      const t2 = this._getImporter(e2), r2 = null == t2 ? void 0 : t2.ctor(this);
      return r2 && (null == t2 || t2.ext.forEach((e3) => {
        const t3 = new RegExp(e3.startsWith("data:") ? "^" + e3 + "\\/" : "\\." + e3 + "$", "i");
        this._loadingManager.addHandler(t3, r2);
      })), r2 && (this._loaderCache.push({ loader: r2, files: [] }), this.dispatchEvent({ type: "loaderCreate", loader: r2 })), r2;
    }
    async importFiles(e2, t2 = {}) {
      const r2 = /* @__PURE__ */ new Map();
      let { allowedExtensions: n2 } = t2;
      if (n2 && n2.length < 1 && (n2 = void 0), 0 === e2.size)
        return r2;
      this.dispatchEvent({ type: "importFiles", files: Object.keys(e2), state: "start" });
      const i2 = [], s2 = [];
      if (e2.forEach((e3, t3) => {
        var r3;
        this.registerFile(t3, e3);
        const o2 = e3.ext;
        o2 && (null === (r3 = null == n2 ? void 0 : n2.includes(o2.toLowerCase())) || void 0 === r3 || r3) && (this._isRootFileExtension(o2) ? i2.push(t3) : s2.push(t3));
      }), i2.length > 0)
        for (const e3 of i2) {
          let n3 = await this._importFile(e3, void 0, t2);
          n3 && (n3 = await this.processImported(n3, t2)), r2.set(e3, n3);
        }
      else
        for (const e3 of s2) {
          let n3 = await this._importFile(e3, void 0, t2);
          n3 && (n3 = await this.processImported(n3, t2)), r2.set(e3, n3);
        }
      return this.dispatchEvent({ type: "importFiles", files: Object.keys(e2), state: "end" }), e2.forEach((e3, t3) => {
        this.unregisterFile(t3);
      }), r2;
    }
    registerFile(e2, t2) {
      var r2, n2, i2;
      e2 = e2.replace(/\?.*$/, "");
      const s2 = null !== (r2 = null == t2 ? void 0 : t2.ext) && void 0 !== r2 ? r2 : null === (i2 = sr(null !== (n2 = null == t2 ? void 0 : t2.name) && void 0 !== n2 ? n2 : e2)) || void 0 === i2 ? void 0 : i2.toLowerCase();
      t2 && (t2.ext || (t2.ext = s2), this._fileDatabase.set(e2, t2));
      let o2 = this._getLoader(e2);
      if (o2 || (o2 = this._createLoader(null != t2 ? t2 : { name: e2, ext: s2 })), o2) {
        for (const t3 of this._loaderCache)
          if (t3.loader === o2) {
            t3.files.push(e2);
            break;
          }
      }
      return o2;
    }
    unregisterFile(e2) {
      e2 = e2.replace(/\?.*$/, "");
      const t2 = this._fileDatabase.get(e2);
      (null == t2 ? void 0 : t2.objectUrl) && (URL.revokeObjectURL(t2.objectUrl), t2.objectUrl = void 0), t2 && this._fileDatabase.delete(e2);
    }
    _isRootFileExtension(e2) {
      return null != Js.Importers.find((t2) => t2.root && t2.ext.includes(e2.toLowerCase()));
    }
    resolveURL(e2) {
      return this._loadingManager.resolveURL(e2);
    }
    async _importFile(e2, t2, r2 = {}, i2) {
      var s2, o2;
      if (null === (s2 = t2) || void 0 === s2 ? void 0 : s2.__imported)
        return t2.__imported;
      let a2;
      this.dispatchEvent({ type: "importFile", path: e2, state: "downloading", progress: 0 });
      try {
        this.registerFile(e2, t2), r2.rootPath = e2;
        const s3 = this.resolveURL(e2), l2 = e2.replace(/\?.*$/, ""), c2 = null !== (o2 = r2.fileHandler) && void 0 !== o2 ? o2 : await this._loadingManager.getHandler(l2) || (t2 ? await this._loadingManager.getHandler(t2.name || t2.ext || "") : void 0);
        if (!c2)
          throw new Error("AssetImporter: Unable to find loader for " + e2);
        this._rootContext = { path: e2, url: s3, rootUrl: n.Zp0.extractUrlBase(e2), baseUrl: n.Zp0.extractUrlBase(s3) }, a2 = await c2.loadAsync(e2 + (r2.queryString ? (e2.includes("?") ? "&" : "?") + r2.queryString : ""), (t3) => {
          i2 && i2(t3), this.dispatchEvent({ type: "importFile", path: e2, state: "downloading", progress: t3.loaded / t3.total });
        }), this._rootContext = void 0, this.dispatchEvent({ type: "importFile", path: e2, state: "downloading", progress: 1 }), this.dispatchEvent({ type: "importFile", path: e2, state: "adding" }), t2 ? this._logger("AssetImporter: loaded", e2) : this._logger("AssetImporter: downloaded", e2), t2 && this.unregisterFile(e2);
      } catch (r3) {
        return console.error("AssetImporter: Unable to import file", e2, t2), console.error(r3), console.error(null == r3 ? void 0 : r3.stack), this.dispatchEvent({ type: "importFile", path: e2, state: "error", error: r3 }), [];
      }
      return this.dispatchEvent({ type: "importFile", path: e2, state: "done" }), t2 && (t2.__imported = a2), a2;
    }
    _getImporter(e2, t2 = false) {
      return Js.Importers.find((r2) => {
        if (t2 && !r2.root)
          return false;
        const n2 = r2.ext.find((t3) => {
          var r3, n3, i2;
          return e2.ext && t3 === e2.ext.toLowerCase() || (null === (n3 = null === (r3 = e2.name) || void 0 === r3 ? void 0 : r3.toLowerCase()) || void 0 === n3 ? void 0 : n3.endsWith("." + t3.toLowerCase())) || (null == t3 ? void 0 : t3.startsWith("data:")) && (null === (i2 = e2.name) || void 0 === i2 ? void 0 : i2.startsWith(t3));
        });
        return !!n2 && (e2.ext = n2, true);
      });
    }
    _getLoader(e2) {
      var t2;
      return null !== (t2 = this._loadingManager.getHandler(e2)) && void 0 !== t2 ? t2 : void 0;
    }
    async importAsset(e2, t2 = {}, r2) {
      var n2;
      if (!e2)
        return [];
      if (!this._cachedAssets.includes(e2)) {
        if (1 === Object.entries(e2).length && e2.path) {
          const t4 = this._cachedAssets.find((t5) => t5.path === e2.path);
          t4 && Object.assign(e2, t4);
        }
        const t3 = this._cachedAssets.findIndex((t4) => t4.path === e2.path);
        t3 >= 0 && this._cachedAssets.splice(t3, 1), this._cachedAssets.push(e2);
      }
      let i2;
      if ((null == e2 ? void 0 : e2.preImported) && (i2 = await e2.preImported), !t2.forceImport && i2) {
        const e3 = await this.processImported(i2, t2);
        let r3 = false;
        for (const t3 of e3)
          if (t3.__disposed) {
            r3 = true;
            break;
          }
        if (!r3 || false === t2.reimportDisposed)
          return e3;
      }
      return e2.preImported = this._importFile(t2.pathOverride || e2.path, "function" == typeof (null === (n2 = e2.file) || void 0 === n2 ? void 0 : n2.arrayBuffer) ? e2.file : void 0, t2, r2), i2 = await e2.preImported, i2 && (i2 = await this.processImported(i2, t2)), i2;
    }
    async importSingle(e2, t2 = {}) {
      var r2;
      return null === (r2 = await this.importAsset(e2, t2)) || void 0 === r2 ? void 0 : r2[0];
    }
    async importSinglePath(e2, t2) {
      var r2;
      return null === (r2 = await this.importPath(e2, t2)) || void 0 === r2 ? void 0 : r2[0];
    }
    async importPath(e2, t2 = {}) {
      const r2 = { ...t2 };
      delete r2.pathOverride, delete r2.forceImport, delete r2.reimportDisposed;
      const n2 = JSON.stringify(r2);
      let i2;
      return i2 = this._cachedAssets.find((t3) => t3.path === e2 && t3._options === n2) || { path: e2 }, i2._options = n2, await this.importAsset(i2, t2);
    }
    async processImportedSingle(e2, t2 = {}) {
      return (await this.processImported(e2, t2))[0];
    }
    async processImported(e2, t2 = {}) {
      var r2, i2, s2, o2, a2, l2, c2, u2;
      let h2 = e2;
      if (!h2)
        return [];
      if (false === t2.processImported)
        return [h2];
      if (Array.isArray(h2)) {
        const e3 = [];
        for (const r3 of h2)
          e3.push(...await this.processImported(r3, t2));
        return e3;
      }
      if (null === (r2 = h2.userData) || void 0 === r2 ? void 0 : r2.rootSceneModelRoot) {
        if (t2._rootSceneImported = true, h2.__processedChildren && !t2.forceImporterReprocess)
          return h2.__processedChildren;
        if (!(h2.children.length < 1))
          return h2.animations && (h2.children[0].animations || (h2.children[0].animations = []), h2.children[0].animations.push(...h2.animations)), h2.__importedViewerConfig && (h2.children[0].__importedViewerConfig = h2.__importedViewerConfig), h2.__processedChildren = await this.processImported([...h2.children], t2), h2.__processedChildren;
        if ((null === (i2 = h2.animations) || void 0 === i2 ? void 0 : i2.length) > 0 && console.error("AssetImporter: animations in empty scene not supported yet. animations will be ignored", h2.animations), !h2.__importedViewerConfig)
          return [];
        h2 = h2.__importedViewerConfig;
      }
      if ((null === (s2 = h2.userData) || void 0 === s2 ? void 0 : s2.iModel) && (h2 = h2.userData.iModel), (null === (o2 = h2.userData) || void 0 === o2 ? void 0 : o2.iMaterial) && (h2 = h2.userData.iMaterial), h2.assetImporterProcessed && !t2.forceImporterReprocess)
        return [h2];
      if (!h2.assetType) {
        if (h2.isBufferGeometry && (h2 = new n.Kj0(h2, new n.Wid())), h2.isObject3D) {
          if (h2.isLight)
            h2 = $s(h2);
          else {
            const e3 = [];
            h2.traverse((t3) => {
              t3 !== h2 && t3.isLight && e3.push(t3);
            });
            for (const t3 of e3)
              $s(t3);
            h2 = new ar(h2, t2);
          }
          !t2.rootPath || h2.modelObject.userData.rootPath || t2.rootPath.startsWith("blob:") || t2.rootPath.startsWith("/") || (h2.modelObject.userData.rootPath = t2.rootPath);
        }
        h2.isTexture && (h2.assetType = "texture", t2._testDataTextureComplete && (h2.isDataTexture && (null === (a2 = h2.image) || void 0 === a2 ? void 0 : a2.data) && (h2.image.complete = true), (null === (l2 = h2.image) || void 0 === l2 ? void 0 : l2.complete) && (h2.needsUpdate = true)), void 0 !== t2.generateMipmaps && (h2.generateMipmaps = t2.generateMipmaps), h2.generateMipmaps || h2.isRenderTargetTexture || (h2.minFilter = h2.minFilter === n.D1R ? n.wem : h2.minFilter, h2.magFilter = h2.magFilter === n.D1R ? n.wem : h2.magFilter), !t2.rootPath || h2.userData.rootPath || t2.rootPath.startsWith("blob:") || t2.rootPath.startsWith("/") || (h2.userData.rootPath = t2.rootPath)), h2.isMaterial && (h2.assetType = "material", !t2.rootPath || h2.userData.rootPath || t2.rootPath.startsWith("blob:") || t2.rootPath.startsWith("/") || (h2.userData.rootPath = t2.rootPath));
      }
      if (null != h2.assetType)
        return h2 = await this._processors.process(h2.assetType, h2, {}), h2.assetImporterProcessed = true, [h2];
      if (h2 instanceof Map)
        return [...(await this.importFiles(h2, t2)).values()].flat();
      if (h2.type) {
        const e3 = this._viewer.getPluginByType(h2.type);
        if (e3) {
          let t3 = h2._importedResources || {};
          return h2.resources && (t3 = await (null === (c2 = this._viewer.getManager()) || void 0 === c2 ? void 0 : c2.importConfigResources(h2.resources)), delete h2.resources, h2._importedResources = t3), "function" == typeof e3.fromJSON && (await Promise.resolve(e3.fromJSON(h2, t3)), h2.assetImporterProcessed = false), [];
        }
      } else if (h2.plugins)
        return h2.resources = await (null === (u2 = this._viewer.getManager()) || void 0 === u2 ? void 0 : u2.importConfigResources(h2.resources)), await this._viewer.getManager().importViewerConfig(h2), h2.assetImporterProcessed = false, [];
      return console.warn("unknown asset type: ", h2), [h2];
    }
    dispose() {
      var e2;
      null === (e2 = this._processors) || void 0 === e2 || e2.dispose();
    }
  }
  function Zs(e2) {
    if (!e2)
      return n.ywz;
    const t2 = e2.extensions.has("EXT_color_buffer_half_float") || e2.capabilities.isWebGL2 && e2.extensions.has("EXT_color_buffer_float"), r2 = e2.capabilities.isWebGL2 || e2.extensions.has("OES_texture_float") || e2.extensions.has("WEBGL_color_buffer_float");
    return t2 ? n.cLu : r2 ? n.VzW : n.ywz;
  }
  function $s(e2) {
    var t2, r2, n2;
    if (!e2.isLight)
      return e2;
    if ("light" === e2.assetType)
      return e2;
    if (e2.uiConfig)
      return console.warn("ui config already exists, not supported", e2), e2;
    let i2;
    if (e2.children.length, e2.isDirectionalLight && (i2 = new Ws()), e2.isAmbientLight && (i2 = new Ys()), e2.isSpotLight && (i2 = new qs()), e2.isPointLight && (i2 = new Xs()), i2) {
      null === (r2 = (t2 = i2.lightObject).copy) || void 0 === r2 || r2.call(t2, e2);
      const s2 = e2.parent;
      (null === (n2 = s2) || void 0 === n2 ? void 0 : n2.isObject3D) && (s2.remove(e2), e2.dispose(), e2.userData.iModel = i2, s2.add(i2.lightObject), i2.uuid = e2.uuid), Le(i2.lightObject, s2);
    } else
      console.warn("unknown light type: ", e2);
    return i2;
  }
  Js.Importers = [new ir(ur, ["json"], false), new ir(n.hH6, ["txt"], false), new ir(nn, ["rgbe.png", "hdr.png", "hdrpng"], false), new ir(n.dpR, ["webp", "png", "jpeg", "jpg", "svg", "data:image"], false), new ir(Ks, ["CUBE"], false)];
  class eo extends n.u7G {
    constructor(e2) {
      super(e2);
    }
    async loadAsync(e2, t2) {
      var r2;
      const i2 = new n.hH6(this.manager);
      i2.setPath(this.path), i2.setRequestHeader(this.requestHeader), i2.setWithCredentials(this.withCredentials);
      const s2 = await i2.loadAsync(e2, t2);
      try {
        const e3 = JSON.parse(s2);
        if (e3.images && this.importer) {
          const t3 = {};
          let i3 = e3.images;
          Array.isArray(i3) || (i3 = Object.values(i3));
          for (const i4 of e3.images) {
            if (!i4.url || !i4.uuid)
              continue;
            const e4 = null === (r2 = await this.importer.importPath(i4.url, { processImported: false })) || void 0 === r2 ? void 0 : r2[0], s3 = null == e4 ? void 0 : e4.source;
            if (!e4 || !s3)
              continue;
            const o2 = new n.Hw6(s3.data);
            o2.uuid = i4.uuid, t3[o2.uuid] = o2, e4.dispose();
          }
          return this.parse(e3, t3);
        }
        return this.parse(e3);
      } catch (t3) {
        throw console.error(t3), this.manager.itemError(e2), t3;
      }
    }
    parse(e2, t2) {
      var r2, i2;
      let s2;
      const o2 = { p: new Promise((e3) => {
        s2 = e3;
      }) };
      if (e2.images || e2.textures) {
        const r3 = new sn(this.manager);
        let n2 = {};
        const i3 = (e3) => {
          s2(), o2.p = void 0, Object.values(n2).forEach((e4) => {
            var t3;
            e4.isTexture && (null === (t3 = e4.image) || void 0 === t3 ? void 0 : t3.complete) && (e4.needsUpdate = true);
          });
        };
        let a3 = e2.images || [];
        Array.isArray(a3) || (a3 = Object.values(a3));
        const l3 = t2 || r3.parseImages(a3, i3);
        let c3 = e2.textures;
        Array.isArray(c3) || (c3 = Object.values(c3)), n2 = r3.parseTextures2(c3, l3, i3), this.setTextures(n2);
      }
      this.materials || console.warn("A Material Manager is not set to import three materials, trying standard materials");
      const a2 = { ...e2 };
      if (Object.entries(a2).forEach(([e3, t3]) => {
        t3 && "string" == typeof t3 && this.textures[t3] && (a2[e3] = this.textures[t3]);
      }), void 0 !== e2.vertexColors && ("number" == typeof e2.vertexColors ? a2.vertexColors = e2.vertexColors > 0 : a2.vertexColors = e2.vertexColors), void 0 !== e2.normalScale) {
        let t3 = e2.normalScale;
        false === Array.isArray(t3) && (t3 = [t3, t3]), a2.normalScale = new n.FM8().fromArray(t3);
      }
      let l2 = e2.type;
      "MeshPhysicalMaterial" !== l2 && "MeshStandardMaterial" !== l2 || (l2 = Kt.TYPE), a2.userData = De(a2.userData, void 0, false, this);
      const c2 = null !== (i2 = null === (r2 = this.materials) || void 0 === r2 ? void 0 : r2.generateFromTemplateType(l2, a2)) && void 0 !== i2 ? i2 : super.parse(e2);
      return this.setTextures({}), c2.userData.imageLoadAwaiter = o2, c2;
    }
  }
  class to extends r {
    constructor(e2, t2, { simpleCache: r2 = false, storage: i2 } = {}) {
      if (super(), this._sceneUpdated = this._sceneUpdated.bind(this), this.addAsset = this.addAsset.bind(this), this.addProcessedAssets = this.addProcessedAssets.bind(this), this.addImported = this.addImported.bind(this), (r2 || i2) && (r2 && (n.CtF.enabled = true), i2 && window.Cache && "function" == typeof window.Cache && i2 instanceof window.Cache)) {
        const e3 = { ...n.CtF };
        n.CtF.get = (t3, r3, n2) => r3 ? t3.startsWith("data:") || t3.startsWith("blob") || t3.startsWith("chrome-extension") ? Promise.resolve(void 0) : i2.match(t3).then((e4) => {
          if (e4)
            switch (r3) {
              case "arraybuffer":
                return e4.arrayBuffer();
              case "blob":
                return e4.blob();
              case "document":
                return e4.text().then((e5) => new DOMParser().parseFromString(e5, null != n2 ? n2 : "text/html"));
              case "json":
                return e4.json();
              default:
                if (void 0 === n2)
                  return e4.text();
                {
                  const t4 = /charset="?([^;"\s]*)"?/i.exec(n2), r4 = t4 && t4[1] ? t4[1].toLowerCase() : void 0, i3 = new TextDecoder(r4);
                  return e4.arrayBuffer().then((e5) => i3.decode(e5));
                }
            }
        }) : e3.get(t3), n.CtF.add = (t3, r3, n2) => {
          n2 || e3.add(t3, r3), t3.startsWith("data:") || t3.startsWith("blob") || t3.startsWith("chrome-extension") || i2.put(t3, new Response(r3, { status: 200 }));
        }, n.CtF.remove = (t3, r3) => {
          r3 || e3.remove(t3), i2.delete(t3);
        };
      }
      this._importer = e2, this._materials = t2;
    }
    async addAsset(e2, t2 = {}) {
      if (!this._importer || !this._viewer)
        return [];
      const r2 = await this._importer.importAsset(e2, t2);
      return r2 ? (this.addProcessedAssets(r2, t2), r2) : (console.warn("Unable to import", e2, r2), []);
    }
    async addFromPath(e2, t2 = {}) {
      if (!this._importer || !this._viewer)
        return [];
      const r2 = await this._importer.importPath(e2, t2);
      return r2 ? (this.addProcessedAssets(r2, t2), r2) : (console.warn("Unable to import", e2, r2), []);
    }
    addProcessedAssets(e2, t2) {
      return e2.map((e3) => {
        var r2;
        return null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.scene.addSceneObject(e3, t2);
      });
    }
    async addAssetSingle(e2, t2 = {}) {
      var r2;
      return e2 ? null === (r2 = await ("string" == typeof e2 ? this.addFromPath : this.addAsset)(e2, t2)) || void 0 === r2 ? void 0 : r2[0] : void 0;
    }
    async addImported(e2, t2 = {}) {
      var r2;
      return null === (r2 = this._importer) || void 0 === r2 ? void 0 : r2.processImported(e2, t2).then((e3) => (this.addProcessedAssets(e3, t2), e3));
    }
    async addImportedSingle(e2, t2 = {}) {
      return this.addImported(e2, t2).then((e3) => null == e3 ? void 0 : e3[0]);
    }
    _sceneUpdated(e2) {
      var t2;
      if ("addSceneObject" === e2.type) {
        const r2 = e2.object;
        "material" === r2.assetType && (null === (t2 = this._materials) || void 0 === t2 || t2.processMaterial(r2, {}));
      } else
        console.error("Unexpected");
    }
    async onAdded(e2) {
      this._viewer = e2, this._materials || (this._materials = new nr(), this._viewer.scene.addEventListener("addSceneObject", this._sceneUpdated)), this._importer || (this._importer = new Js(e2, !!e2.getPluginByType("debug")), this._importer.processors.add("model", { forAssetType: "model", process: (e3, t3) => (lr(e3, (e4) => {
        var t4;
        return null === (t4 = this._materials) || void 0 === t4 ? void 0 : t4.processModel(e4, { recursive: false });
      }), e3) }), this._importer.processors.add("model", { forAssetType: "model", process: this._materials.processModel }), this._importer.processors.add("material", { forAssetType: "material", process: (e3, t3) => {
        var r2;
        return (null === (r2 = this.materials) || void 0 === r2 ? void 0 : r2.findMaterial(e3.uuid)) && (console.warn("imported material uuid already exists, creating new uuid"), e3.uuid = $(), e3.userData.uuid && (e3.userData.uuid = e3.uuid)), this._materials.processMaterial(e3, t3);
      } })), Js.Importers.push(new ir(eo, [Kt.TypeSlug], false, (e3) => (e3 && (e3.materials = this._materials), e3 && (e3.importer = this._importer), e3)));
      const t2 = this.importViewerConfig.bind(this);
      Js.Importers.push(new ir(class extends ur {
        async loadAsync(e3, r2) {
          return t2(await super.loadAsync(e3, r2));
        }
      }, [to.ViewerTypeSlug], true));
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      var t2, r2;
      e2 === this._viewer && (null === (t2 = this._importer) || void 0 === t2 || t2.dispose(), this._importer = void 0, this._viewer.scene.removeEventListener("addSceneObject", this._sceneUpdated), null === (r2 = this._materials) || void 0 === r2 || r2.dispose(), this._materials = void 0);
    }
    get importer() {
      return this._importer;
    }
    get exporter() {
      var e2, t2;
      return null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("AssetExporterPlugin")) || void 0 === t2 ? void 0 : t2.exporter;
    }
    get materials() {
      return this._materials;
    }
    exportViewerConfig(e2) {
      if (!this._viewer)
        return {};
      const t2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, ...e2 }, r2 = this._viewer.toJSON(t2);
      return r2.resources = t2, r2;
    }
    exportPluginPresets(e2) {
      var t2;
      const r2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} };
      return { plugins: null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.serializePlugins(r2, e2), resources: r2 };
    }
    exportPluginPreset(e2) {
      if (!e2.toJSON)
        return;
      const t2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, r2 = e2.toJSON(t2);
      return r2.resources = t2, r2;
    }
    async importPluginPreset(e2, t2) {
      var r2;
      const n2 = e2.type;
      if (!(t2 = t2 || (null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.getPluginByType(n2))))
        return void console.warn(`No plugin found for type ${n2} to import preset`);
      if (!t2.fromJSON)
        return void console.warn(`Plugin ${n2} does not support importing presets`);
      const i2 = e2.resources || {};
      return e2.resources && delete e2.resources, await t2.fromJSON(e2, i2), i2 && (e2.resources = i2), t2;
    }
    async importViewerConfig(e2, t2) {
      if (!this._viewer || !this._importer)
        return void console.warn("No viewer or importer");
      const r2 = await this.importConfigResources(e2.resources || {}, t2);
      this.applyViewerConfig(e2, r2);
    }
    applyViewerConfig(e2, t2) {
      var r2;
      if (this._viewer && this._importer)
        if ((t2 = t2 || e2.resources).__isLoadedResources) {
          this._viewer.fromJSON(e2, t2);
          for (const e3 of Object.values(t2.materials))
            e3.__useCount ? delete e3.__useCount : null === (r2 = this._materials) || void 0 === r2 || r2.unregisterMaterial(e3);
          for (const e3 of Object.values(t2.textures))
            e3.__useCount && delete e3.__useCount;
        } else
          console.error("Cannot load viewer config: resources not loaded", e2);
      else
        console.warn("No viewer or importer");
    }
    async importConfigResources(e2, t2, r2) {
      var i2, s2, o2;
      if (!this._importer)
        throw "Importer not initialized yet.";
      if (e2.__isLoadedResources)
        return e2;
      const a2 = {};
      t2 = null != t2 ? t2 : new sn(this._importer.loadingManager), a2.animations = e2.animations ? t2.parseAnimations(e2.animations) : {}, r2 && r2.animations && (a2.animations = { ...a2.animations, ...r2.animations }), a2.shapes = e2.shapes ? t2.parseShapes(e2.shapes) : {}, r2 && r2.shapes && (a2.shapes = { ...a2.shapes, ...r2.shapes }), a2.geometries = e2.geometries ? t2.parseGeometries(e2.geometries, a2.shapes) : {}, r2 && r2.geometries && (a2.geometries = { ...a2.geometries, ...r2.geometries }), a2.images = e2.images ? await t2.parseImagesAsync(Object.values(e2.images)) : {}, r2 && r2.images && (a2.images = { ...a2.images, ...r2.images });
      for (const t3 of Object.values(e2.textures)) {
        const e3 = null === (i2 = null == t3 ? void 0 : t3.userData) || void 0 === i2 ? void 0 : i2.rootPath;
        if (e3 && (!t3.image || !a2.images[t3.image])) {
          const r3 = null === (s2 = await this._importer.importPath(e3, { processImported: false })) || void 0 === s2 ? void 0 : s2[0], i3 = null == r3 ? void 0 : r3.source;
          if (!r3 || !i3)
            continue;
          const o3 = new n.Hw6(i3.data);
          t3.image && (o3.uuid = t3.image), a2.images[o3.uuid] = o3, t3.image = o3.uuid, r3.dispose();
        }
      }
      a2.textures = e2.textures ? t2.parseTextures2(Object.values(e2.textures), a2.images, () => {
        Object.values(a2.textures).forEach((e3) => {
          var t3;
          e3.isTexture && (null === (t3 = e3.image) || void 0 === t3 ? void 0 : t3.complete) && (e3.needsUpdate = true);
        });
      }) : {};
      for (const e3 of Object.entries(a2.textures))
        e3[1] = null === (o2 = await this._importer.processImported(e3[1], {})) || void 0 === o2 ? void 0 : o2[0], e3[1] ? a2.textures[e3[0]] = e3[1] : delete a2.textures[e3[0]];
      r2 && r2.textures && (a2.textures = { ...a2.textures, ...r2.textures });
      const l2 = e2.materials ? Object.values(e2.materials) : [];
      for (const e3 of l2)
        Object.entries(e3).forEach(([t3, r3]) => {
          r3 && r3.resource && r3.uuid && "textures" === r3.resource && (e3[t3] = r3.uuid);
        });
      return a2.materials = t2.parseMaterials2(l2, a2.textures, this._materials), r2 && r2.materials && (a2.materials = { ...a2.materials, ...r2.materials }), e2.object && (a2.object = t2.parseObject(e2.object, a2.geometries, a2.materials, a2.textures, a2.animations), e2.skeletons && (a2.skeletons = t2.parseSkeletons(e2.skeletons, a2.object), t2.bindSkeletons(a2.object, a2.skeletons))), a2.__isLoadedResources = true, a2;
    }
  }
  to.PluginType = "AssetManager", to.ViewerTypeSlug = "vjson";
  class ro extends r {
    constructor() {
      super(...arguments), this._dirty = false;
    }
    get dirty() {
      return this._dirty;
    }
    set dirty(e2) {
      this._dirty = e2;
    }
    async onAdded(e2) {
      this._viewer = e2;
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      this._viewer !== e2 && console.error("Wrong viewer"), this._viewer = void 0;
    }
    toJSON(e2) {
      const t2 = ke(this, true, e2);
      return t2.type = this.constructor.PluginType, this.dispatchEvent({ type: "serialize", data: t2 }), t2;
    }
    fromJSON(e2, t2) {
      return e2.type !== this.constructor.PluginType ? null : (De(e2, this, true, t2), this.dispatchEvent({ type: "deserialize", data: e2 }), this);
    }
  }
  function no(e2, t2, r2) {
    return { ...t2, get dirty() {
      return t2.dirty || false;
    }, set dirty(e3) {
      _(t2, "dirty", e3, true);
    }, update() {
      var e3, n2, i2;
      this.passObject.enabled && (null === (n2 = (e3 = this.passObject).updateShaderProperties) || void 0 === n2 || n2.call(e3, A(r2)), null === (i2 = t2.update) || void 0 === i2 || i2.call(this));
    }, onRegister(r3) {
      var n2, i2, s2;
      this.passObject.materialExtension && (null === (i2 = null === (n2 = e2.getPlugin(to)) || void 0 === n2 ? void 0 : n2.materials) || void 0 === i2 || i2.registerMaterialExtension(this.passObject.materialExtension)), null === (s2 = t2.onRegister) || void 0 === s2 || s2.call(this, r3);
    }, onUnregister(r3) {
      var n2, i2, s2;
      this.passObject.materialExtension && (null === (i2 = null === (n2 = e2.getPlugin(to)) || void 0 === n2 ? void 0 : n2.materials) || void 0 === i2 || i2.unregisterMaterialExtension(this.passObject.materialExtension)), null === (s2 = t2.onUnregister) || void 0 === s2 || s2.call(this, r3);
    }, dispose() {
      var e3, r3, n2;
      null === (r3 = (e3 = this.passObject).dispose) || void 0 === r3 || r3.call(e3), null === (n2 = t2.dispose) || void 0 === n2 || n2.call(this);
    } };
  }
  class io extends ro {
    constructor() {
      super(), this._enabledTemp = true;
    }
    _update(e2) {
      var t2;
      return (null === (t2 = this._pass) || void 0 === t2 ? void 0 : t2.enabled) && this.enabled || false;
    }
    get enabled() {
      var e2, t2;
      return (null === (t2 = null === (e2 = this._pass) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.enabled) || this._enabledTemp;
    }
    set enabled(e2) {
      var t2;
      (null === (t2 = this._pass) || void 0 === t2 ? void 0 : t2.passObject) && (this._pass.passObject.enabled = e2), this._enabledTemp = e2;
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const t2 = { enabled: true, passId: this.passId, passObject: this.passCtor(e2), after: this._afterFilters, before: this._beforeFilters, required: this._requiredFilters, set dirty(t3) {
        t3 && e2.setDirty();
      }, get dirty() {
        return false;
      }, update: () => this._update(e2) };
      this._pass = no(e2, t2), void 0 !== t2.passObject.onDirty && t2.passObject.onDirty.push(() => t2.dirty = true), e2.renderer.registerPass(this._pass), this.enabled = this._enabledTemp;
    }
    async onRemove(e2) {
      var t2, r2;
      this._pass && e2.renderer.unregisterPass(this._pass), null === (r2 = null === (t2 = this._pass) || void 0 === t2 ? void 0 : t2.dispose) || void 0 === r2 || r2.call(t2), this._pass = void 0, await super.onRemove(e2);
    }
    get pass() {
      return this._pass;
    }
    toJSON(e2) {
      var t2, r2;
      const n2 = super.toJSON(e2);
      if (!n2.type)
        return n2;
      const i2 = this.pass;
      return i2 && (n2.pass = ke(null !== (r2 = null === (t2 = i2) || void 0 === t2 ? void 0 : t2.passObject) && void 0 !== r2 ? r2 : i2, false, e2)), n2;
    }
    fromJSON(e2, t2) {
      var r2, n2;
      if (!super.fromJSON(e2, t2))
        return null;
      if (e2.pass) {
        const i2 = this.pass;
        i2 && De(e2.pass, null !== (n2 = null === (r2 = i2) || void 0 === r2 ? void 0 : r2.passObject) && void 0 !== n2 ? n2 : i2, false, t2);
      }
      return this;
    }
  }
  !function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, r2, o2);
  }([Ce()], io.prototype, "enabled", null);
  const so = /* @__PURE__ */ new Set(), oo = /* @__PURE__ */ new Set();
  class ao extends Gt {
    constructor(e2, t2, r2, n2) {
      super(void 0, void 0, t2, new Ae(1, 1, 1), 1), this.target = e2;
    }
    render(e2, t2, r2, n2, i2) {
      const s2 = e2.getRenderTarget(), o2 = e2.getActiveCubeFace(), a2 = e2.getActiveMipmapLevel();
      this.scene.traverse(({ material: e3 }) => {
        e3 && ((e3.transparent && e3.userData.renderToDepth || !e3.transparent && 0 === e3.transmission && false === e3.userData.renderToDepth) && (so.add(e3), e3.transparent = !e3.transparent), Math.abs(e3.transmission || 0) > 0 && e3.userData.renderToDepth && (oo.add([e3, e3.transmission]), e3.transmission = 0));
      }), W(e2, { shadowMapRender: false, backgroundRender: false, opaqueRender: true, transparentRender: false, transmissionRender: false, mainRenderPass: false }, () => super.render(e2, t2, this.target, n2, i2)), so.forEach((e3) => e3.transparent = !e3.transparent), so.clear(), oo.forEach(([e3, t3]) => e3.transmission = t3), oo.clear(), e2.setRenderTarget(s2, o2, a2);
    }
  }
  class lo extends io {
    constructor(e2 = true) {
      super(), this.renderFlagsBuffer = e2, this.passId = "gbuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this._gbufferTextures = [];
    }
    passCtor(e2) {
      var t2, r2;
      const i2 = (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.renderer.isWebGL2) && this.renderFlagsBuffer, s2 = e2.renderer.createTarget({ depthBuffer: true, type: n.ywz, textureCount: i2 ? 2 : 1 });
      Array.isArray(s2.texture) ? (s2.texture[0].name = "gbufferDepthNormal", s2.texture[1].name = "gbufferFlags", this._gbufferTextures = s2.texture) : (s2.texture.name = "gbufferDepthNormal", this._gbufferTextures.push(s2.texture)), this._gbufferTarget = s2;
      const o2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.getPluginByType("debug");
      return o2 && (o2.addTexture("gbuffer depth normal", () => this.getDepthNormal(), [40, 110, 300, 200]), this._gbufferTextures.length > 1 && o2.addTexture("gbuffer flags", () => this.getFlagsTexture(), [40, 310, 200, 100])), new ao(s2, new Qt(i2));
    }
    _update(e2) {
      if (!super._update(e2))
        return false;
      const t2 = this.pass.passObject;
      return t2.scene = e2.scene.modelObject, e2.scene.activeCamera.updateShaderProperties(t2.overrideMaterial), t2.camera = e2.scene.activeCamera.cameraObject, true;
    }
    getDepthNormal() {
      return this._gbufferTextures.length > 0 ? this._gbufferTextures[0] : void 0;
    }
    getFlagsTexture() {
      return this._gbufferTextures.length > 1 ? this._gbufferTextures[1] : void 0;
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      return this._gbufferTarget && (e2.renderer.disposeTarget(this._gbufferTarget), this._gbufferTarget = void 0), super.onRemove(e2);
    }
    getTarget() {
      return this._gbufferTarget;
    }
    getUnpackSnippet() {
      return Ht;
    }
    updateShaderProperties(e2) {
      var t2, r2;
      if (e2.uniforms.tNormalDepth ? e2.uniforms.tNormalDepth.value = null !== (t2 = this.getDepthNormal()) && void 0 !== t2 ? t2 : void 0 : console.warn("BaseRenderer: no uniform: tNormalDepth"), e2.uniforms.tGBufferFlags) {
        e2.uniforms.tGBufferFlags.value = null !== (r2 = this.getFlagsTexture()) && void 0 !== r2 ? r2 : void 0;
        const t3 = e2.uniforms.tGBufferFlags.value ? 1 : 0;
        t3 !== e2.defines.GBUFFER_HAS_FLAGS && (e2.defines.GBUFFER_HAS_FLAGS = t3, e2.needsUpdate = true);
      }
      return this;
    }
  }
  lo.PluginType = "GBuffer";
  class co extends Gt {
    constructor(e2, t2 = true) {
      super(), this.blurTransmissionTarget = false, this._viewer = e2, this._doTransmissionFix = t2, this.clear = true, this.clearColor = new Ae(0, 0, 0), this.clearAlpha = 0, this.clearDepth = false, this._blendPass = new Vt({}, "c = vec4(a.rgb * (1. - b.a) + b.rgb * b.a, 1.);");
    }
    get transparentTarget() {
      return this._transparentTarget || (this._transparentTarget = this._viewer.renderer.getTempTarget({ sizeMultiplier: 1, samples: this._viewer.renderer.composerTarget.samples || 0, encoding: n.rnI, type: n.cLu, format: n.wk1, minFilter: n.wem, magFilter: n.wem, depthBuffer: false })), this._transparentTarget;
    }
    _releaseTransparentTarget() {
      this._transparentTarget && this._viewer.renderer.releaseTempTarget(this._transparentTarget), this._transparentTarget = void 0;
    }
    render(e2, t2, r2, n2, i2) {
      var s2;
      let o2 = false;
      if (e2.userData.mainRenderPass = true, !this._doTransmissionFix)
        return super.render(e2, t2, r2, n2, i2), this.needsSwap = o2, void (e2.userData.mainRenderPass = void 0);
      const a2 = e2.userData;
      a2 || console.error("threejs is not patched?");
      const l2 = this._viewer.useGBufferDepth;
      let c2;
      if (l2) {
        const t3 = null === (s2 = this._viewer.getPlugin(lo)) || void 0 === s2 ? void 0 : s2.getTarget();
        if (t3) {
          const r3 = e2.properties.get(t3);
          c2 = r3.__webglDepthRenderbuffer || r3.__webglDepthbuffer;
        } else
          console.warn("No Gbuffer present for depth prepass.");
      }
      let u2 = () => {
        super.render(e2, void 0, r2, n2, i2, c2);
      };
      if (this._viewer.useRgbm) {
        if (this._viewer.useRgbm) {
          if (o2 = false, !e2.info.autoReset)
            throw "renderer.info.autoReset must be true";
          {
            const t3 = e2.autoClearDepth;
            e2.autoClearDepth = !l2, W(e2, { shadowMapRender: true, backgroundRender: true, opaqueRender: true, transparentRender: false, transmissionRender: false }, u2), e2.autoClearDepth = t3;
          }
          if (!l2) {
            const t3 = e2.properties.get(r2);
            c2 = t3.__webglDepthRenderbuffer || t3.__webglDepthbuffer;
          }
          u2 = () => {
            super.render(e2, void 0, this.transparentTarget, n2, i2, c2);
          };
          {
            const t3 = this.clear, r3 = e2.autoClearDepth;
            e2.autoClearDepth = false, this.clear = true, W(e2, { shadowMapRender: false, backgroundRender: false, opaqueRender: false, transparentRender: true, transmissionRender: false }, u2), this.clear = t3, e2.autoClearDepth = r3;
          }
          e2.info.render.calls > 0 && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e2, t2, r2, n2, i2), o2 = true);
          {
            const n3 = this.clear;
            this.clear = false, a2.transmissionRenderTarget = o2 ? t2 : r2, a2.blurTransmissionTarget = this.blurTransmissionTarget, W(e2, { shadowMapRender: false, backgroundRender: false, opaqueRender: false, transparentRender: false, transmissionRender: true }, u2), a2.blurTransmissionTarget = void 0, a2.transmissionRenderTarget = void 0, this.clear = n3;
          }
          e2.info.render.calls > 0 && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e2, t2, r2, n2, i2), o2 = true);
        }
      } else {
        {
          const t3 = this.clear, r3 = e2.autoClearDepth;
          e2.autoClearDepth = !l2, this.clear = true, W(e2, { shadowMapRender: true, backgroundRender: true, opaqueRender: true, transparentRender: true, transmissionRender: false }, u2), this.clear = t3, e2.autoClearDepth = r3;
        }
        {
          this._viewer.renderer.blit(r2.texture, t2, { clear: true });
          const n3 = this.clear;
          this.clear = false, a2.transmissionRenderTarget = t2, a2.blurTransmissionTarget = this.blurTransmissionTarget, W(e2, { shadowMapRender: false, backgroundRender: false, opaqueRender: false, transparentRender: false, transmissionRender: true }, u2), a2.blurTransmissionTarget = void 0, a2.transmissionRenderTarget = void 0, this.clear = n3;
        }
        o2 = false;
      }
      this._releaseTransparentTarget(), this.needsSwap = o2, e2.userData.mainRenderPass = void 0;
    }
  }
  function uo(e2, t2) {
    return e2.multiplyScalar(e2.w * t2), e2.w = 1, e2;
  }
  function ho(e2, t2) {
    return uo(e2, t2), new Ae(e2.x, e2.y, e2.z);
  }
  function po(e2, t2) {
    const r2 = Math.max(e2.x, Math.max(e2.y, e2.z));
    let n2 = Math.max(Math.min(r2 / t2, 1), 0);
    return n2 = Math.ceil(255 * n2) / 255, e2.divideScalar(n2 * t2), e2.w = n2, e2;
  }
  function fo(e2, t2) {
    return po(new n.Ltg(e2.r, e2.g, e2.b, 1), t2);
  }
  var mo = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  function _o(e2) {
    return Object.getPrototypeOf(e2).constructor.PluginType;
  }
  n.Vj0.background.fragmentShader = n.Vj0.background.fragmentShader.replace("uniform sampler2D t2D;", "uniform sampler2D t2D;\nuniform float intensity;"), n.Vj0.background.fragmentShader = n.Vj0.background.fragmentShader.replace("texture2D( t2D, vUv )", "texture2D( t2D, vUv )*intensity");
  class go extends r {
    constructor({ isAntialiased: t2 = false, useRgbm: r2 = true, useGBufferDepth: i2 = false, screenShader: s2 = "", ...o2 }) {
      var a2;
      super(), this.console = console, this._state = e.None, this.plugins = {}, this._needsResize = false, this.resizeObserver = window.ResizeObserver ? new window.ResizeObserver((e2) => this.resize()) : void 0, this._lastSize = new n.FM8(), this._onContextRestore = (e2) => {
        this.enabled = true, this._canvas.width = this._lastSize.width, this._canvas.height = this._lastSize.height, this.resize(), this.scene.setDirty({ sceneUpdate: true, frameFade: false });
      }, this._onContextLost = (e2) => {
        this._lastSize.set(this._canvas.width, this._canvas.height), this._canvas.width = 2, this._canvas.height = 2, this.resize(), this.enabled = false;
      }, this.resize = () => {
        this._needsResize = true, this.setDirty();
      }, this._needsReset = true, this.enabled = true, this.renderEnabled = true, this._isRenderingFrame = false, this.maxFramePerLoop = 1, this._rawBackground = null, this.backgroundIntensity = 1, this._sceneEnvironmentChanged = () => {
        this._rawBackground === vo && this.scene.setBackground(this.scene.getEnvironment());
      }, this._addSceneObject = (e2) => {
        var t3;
        if (!e2 || !e2.object)
          return;
        const r3 = e2.object.__importedViewerConfig || (null === (t3 = e2.object.modelObject) || void 0 === t3 ? void 0 : t3.__importedViewerConfig);
        if (!r3)
          return;
        const n2 = this.getManager();
        n2 ? n2.applyViewerConfig(r3, r3.resources) : this.fromJSON(r3, r3.resources);
      }, this.alert = async (e2) => alert(e2), this.confirm = async (e2) => confirm(e2), this.prompt = async (e2, t3, r3 = true) => prompt(e2, t3), this._useRgbm = r2, this._useGBufferDepth = i2, this._screenShader = s2, this._canvas = o2.canvas || At();
      let l2 = o2.container;
      if (l2 && !o2.canvas && l2.appendChild(this._canvas), l2 || (l2 = null !== (a2 = this._canvas.parentElement) && void 0 !== a2 ? a2 : void 0), !l2)
        throw new Error("No container.");
      this._container = l2, this._animationLoop = this._animationLoop.bind(this), this.setDirty = this.setDirty.bind(this), this._setActiveCameraView = this._setActiveCameraView.bind(this), window.webGiViewers || (window.webGiViewers = []), window.webGiViewers.push(this), async function() {
        try {
          const e2 = window.location.href;
          if (e2.startsWith("http://localhost:8062") || e2.startsWith("https://localhost:8062"))
            return true;
          const t3 = "https://europe-west1-pixotronics-320918.cloudfunctions.net/viewer-hit-test";
          await fetch(t3 + "/?u=" + encodeURIComponent(e2), { mode: "no-cors", method: "POST", credentials: "omit", cache: "no-store", keepalive: false, referrer: "about:client", referrerPolicy: "unsafe-url" });
        } catch (e2) {
          return false;
        }
      }(), async function() {
        var e2;
        const t3 = window.location.href, r3 = "https://dev-sandbox.pixotronics.com/webgi/";
        if (!t3.startsWith(r3))
          return true;
        if (null !== Bt("noUpdate"))
          return true;
        const n2 = null === (e2 = t3.match(/\/webgi\/([0-9.a-zA-Z]+)/)) || void 0 === e2 ? void 0 : e2[1], i3 = (await (await fetch(r3 + "version.txt")).text()).split("\n")[0];
        if (n2 && n2 !== i3) {
          if (confirm(`New version ${i3} is available, do you want to open?`)) {
            const e3 = window.location.href.replace(n2, i3);
            return window.location.href = e3, false;
          }
          window.location.href.includes("noUpdate") || (window.location.href += (window.location.href.includes("?") ? "&" : "?") + "noUpdate");
        }
      }();
      const c2 = new _t(void 0, void 0, this._canvas);
      this.addEventListener("postFrame", () => {
        var e2, t3;
        const r3 = h2.scene.activeCamera;
        if (r3 && r3.interactionsEnabled) {
          if (0 === (null === (e2 = this.getPluginByType("Progressive")) || void 0 === e2 ? void 0 : e2.postFrameConvergedRecordingDelta()))
            return;
          null === (t3 = r3.controls) || void 0 === t3 || t3.update();
        }
      }), this.scene = new vt(c2), this.scene.addEventListener("environmentChanged", this._sceneEnvironmentChanged), this.scene.addEventListener("addSceneObject", this._addSceneObject), this.scene.addEventListener("setView", this._setActiveCameraView), this.scene.addEventListener("activateMain", this._setActiveCameraView), this._renderer = new K({ canvas: this._canvas, animationLoop: this._animationLoop, targetOptions: { samples: t2 ? 4 : 0, encoding: r2 ? R : n.rnI, type: r2 ? n.ywz : n.cLu, depthBuffer: !i2 } }), this._isAntialiased = t2 && this._renderer.isWebGL2;
      let u2 = true;
      this._renderer.rendererObject.userData || (u2 = false, this._renderer.rendererObject.userData = {}), this._renderer.rendererObject.userData.renderTransmissionPass = !u2;
      const h2 = this;
      this.renderFilter = { passId: "render", passObject: new co(this, u2), update() {
        const e2 = this.passObject;
        e2.scene = h2.scene.modelObject, e2.camera = h2.scene.activeCamera.cameraObject;
      } };
      const p2 = { passId: "screen", after: ["render"], required: ["render"], passObject: Ao(s2) };
      [this.renderFilter, p2].forEach((e2) => this._renderer.registerPass(e2)), this._renderer.pipeline = ["render", "screen"], this.scene.addEventListener("sceneMaterialUpdate", (e2) => this.setDirty(this.scene, e2)), this.scene.addEventListener("sceneUpdate", (e2) => {
        this.setDirty(this.scene, e2), false !== e2.geometryChanged && this.renderer.resetShadows();
      }), this.scene.addEventListener("update", (e2) => this.setDirty(this.scene, e2)), this._renderer.addEventListener("update", (e2) => this.setDirty(this._renderer, e2)), this.resizeObserver && this.resizeObserver.observe(this._canvas), window && window.addEventListener("resize", this.resize), this._canvas.addEventListener("webglcontextrestored", this._onContextRestore, false), this._canvas.addEventListener("webglcontextlost", this._onContextLost, false), this.renderer.addEventListener("resize", () => {
        this.scene.activeCamera.refreshAspect();
      }), this.setBackground("#ffffff"), this.console.log("WebGi Viewer instance initialized, version: ", go.VERSION);
    }
    get useRgbm() {
      return this._useRgbm;
    }
    get screenShader() {
      return this._screenShader;
    }
    get useGBufferDepth() {
      return this._useGBufferDepth;
    }
    get isAntialiased() {
      return this._isAntialiased;
    }
    setDirty(e2, t2) {
      this._needsReset = true, e2 = null != e2 ? e2 : this, this.dispatchEvent({ ...null != t2 ? t2 : {}, type: "update", source: e2 });
    }
    get renderer() {
      return this._renderer;
    }
    dispose() {
      var e2;
      this._canvas.removeEventListener("webglcontextrestored", this._onContextRestore, false), this._canvas.removeEventListener("webglcontextlost", this._onContextLost, false), null === (e2 = window.webGiViewers) || void 0 === e2 || e2.splice(window.webGiViewers.indexOf(this), 1), this.resizeObserver ? this.resizeObserver.unobserve(this._canvas) : window.removeEventListener("resize", this.resize), this.dispatchEvent({ type: "dispose" });
    }
    _animationLoop({ time: e2, deltaTime: t2, xrFrame: r2 }) {
      var n2, i2;
      if (this.enabled && this.renderEnabled)
        if (this._isRenderingFrame)
          this.console.warn("animation loop: frame skip");
        else {
          this._isRenderingFrame = true;
          for (let s2 = 0; s2 < this.maxFramePerLoop; s2++) {
            if (this._needsReset && (this._renderer.reset(), this._needsReset = false), this._needsResize) {
              const e3 = [this._canvas.clientWidth, this._canvas.clientHeight];
              if (r2) {
                const t3 = null === (i2 = null === (n2 = this._renderer.rendererObject.xr.getCamera()) || void 0 === n2 ? void 0 : n2.cameras[0]) || void 0 === i2 ? void 0 : i2.viewport;
                t3 ? (0 === t3.x && 0 === t3.y || this.console.warn("x and y must be 0?"), e3[0] = t3.width, e3[1] = t3.height, this.console.log("resize for xr", e3)) : this._needsResize = false;
              }
              this._needsResize && (this._renderer.setSize(...e3), this._needsResize = false);
            }
            this.dispatchEvent({ type: "preFrame", target: this, time: e2, deltaTime: t2, xrFrame: r2 });
            const s3 = Object.values(this.plugins).filter((e3) => e3.dirty);
            s3.length > 0 && this.setDirty(s3), this._needsReset && (this._renderer.reset(), this._needsReset = false), this._renderer.updateDirty();
            const o2 = this._renderer.dirty;
            if (o2) {
              this.dispatchEvent({ type: "preRender", target: this });
              try {
                this._renderer.render();
              } catch (e3) {
                this.console.error(e3), this.enabled = false;
              }
              this.dispatchEvent({ type: "postRender", target: this });
            }
            if (this.dispatchEvent({ type: "postFrame", target: this }), !o2)
              break;
          }
          this._isRenderingFrame = false;
        }
    }
    get state() {
      return this._state;
    }
    get container() {
      return this._container;
    }
    get canvas() {
      return this._canvas;
    }
    getPlugin(e2) {
      return this.plugins[e2.PluginType];
    }
    getPluginByType(e2) {
      return this.plugins[e2];
    }
    async addPlugin(e2, ...t2) {
      var r2;
      let n2;
      n2 = e2.prototype ? new e2(...t2) : e2;
      const i2 = _o(n2);
      return i2 ? (null === (r2 = n2.dependencies) || void 0 === r2 || r2.forEach((e3) => {
        this.getPlugin(e3) || (this.console.log("Adding plugin dependency", e3.name, "for", i2), this.addPlugin(e3));
      }), this.plugins[i2] && this.console.error(`Plugin of type ${i2} already exists`, this.plugins[i2], n2), this.plugins[i2] = n2, await n2.onAdded(this), this.dispatchEvent({ type: "addPlugin", target: this, plugin: n2 }), this.setDirty(n2), n2) : (this.console.error("PluginType is not defined for", n2), n2);
    }
    async removePlugin(e2, t2 = true) {
      const r2 = _o(e2);
      this.plugins[r2] && (await e2.onRemove(this), delete this.plugins[r2], t2 && await e2.onDispose(this), this.setDirty(e2));
    }
    createCamera(e2) {
      var t2;
      const r2 = null !== (t2 = e2.userData.iCamera) && void 0 !== t2 ? t2 : new _t(e2, { controlsMode: "", controlsEnabled: false }, this._canvas);
      return r2.autoLookAtTarget = false, r2;
    }
    setSize(e2) {
      this._canvas.style.width = (null == e2 ? void 0 : e2.width) ? e2.width + "px" : "100%", this._canvas.style.height = (null == e2 ? void 0 : e2.height) ? e2.height + "px" : "100%", this.resize();
    }
    _backgroundIntensityChanged() {
      var e2, t2, r2, i2;
      const s2 = null !== (i2 = null === (r2 = null === (t2 = null === (e2 = this._renderer) || void 0 === e2 ? void 0 : e2.rendererObject) || void 0 === t2 ? void 0 : t2.background.getPlaneMesh()) || void 0 === r2 ? void 0 : r2.material.uniforms) && void 0 !== i2 ? i2 : n.Vj0.background.uniforms;
      s2.intensity || (s2.intensity = { value: 1 }), s2.intensity.value = this.backgroundIntensity, this.setDirty();
    }
    setBackgroundColor(e2) {
      const t2 = new Ae().set(e2).convertSRGBToLinear();
      return this.setBackground(t2);
    }
    setBackground(e2) {
      if (this._rawBackground = e2, null != e2 && ("string" == typeof e2 || "number" == typeof e2 || e2.isVector4 || e2.isColor)) {
        if (e2 === vo)
          return this._sceneEnvironmentChanged();
        const t2 = e2.isVector4 ? H(e2) : Q(e2.isColor ? e2 : new Ae(e2));
        return t2.assetType = "texture", this.scene.setBackground(t2);
      }
      return !e2 && this.useRgbm && this.console.error("Transparent background not supported with HDR RGBM rendering mode"), this.scene.setBackground(e2);
    }
    getBackground(e2 = false) {
      var t2, r2, n2;
      if (e2)
        return this._rawBackground;
      let i2 = null !== (t2 = this._rawBackground) && void 0 !== t2 ? t2 : this.scene.getBackground();
      return i2 ? ((null === (r2 = i2) || void 0 === r2 ? void 0 : r2.isVector4) && (i2 = ho(i2, 7).getHexString()), (null === (n2 = i2) || void 0 === n2 ? void 0 : n2.isColor) ? i2.getHexString() : this._rawBackground === vo ? this.scene.getEnvironment() : i2) : null;
    }
    getManager() {
      return this.getPluginByType("AssetManager");
    }
    resetCamera({ rootObject: e2, centerOffset: t2 = new n.Pa4(1, 1, 1), targetOffset: r2 = new n.Pa4(0, 0, 0), ...i2 } = {}) {
      if (this.scene.activeCamera) {
        this.scene.matrixWorldNeedsUpdate = true, this.scene.updateMatrixWorld(true);
        const i3 = e2 ? new k().expandByObject(e2, true, true) : this.scene.getBounds(true), s2 = i3.getCenter(new n.Pa4()), o2 = 0.5 * i3.getSize(new n.Pa4()).length();
        s2.add(r2.clone().multiplyScalar(o2)), this.scene.activeCamera.position = new n.Pa4(s2.x + t2.x * o2, s2.y + t2.y * o2, s2.z + t2.z * o2), this.scene.activeCamera.target = s2, this.setDirty();
      }
    }
    async createObject3D(e2) {
      var t2;
      return null === (t2 = this.getManager()) || void 0 === t2 ? void 0 : t2.addImportedSingle(e2 || new n.Tme(), { autoScale: false, pseudoCenter: false });
    }
    createPhysicalMaterial(e2) {
      return this.createMaterial("standard", e2);
    }
    createMaterial(e2, t2) {
      var r2, n2, i2, s2, o2;
      if (null === (r2 = t2) || void 0 === r2 ? void 0 : r2.isMaterial) {
        const e3 = null === (i2 = null === (n2 = this.getManager()) || void 0 === n2 ? void 0 : n2.materials) || void 0 === i2 ? void 0 : i2.findMaterial(t2.uuid);
        if (e3)
          return e3;
      }
      return null === (o2 = null === (s2 = this.getManager()) || void 0 === s2 ? void 0 : s2.materials) || void 0 === o2 ? void 0 : o2.generateFromTemplate(e2, t2);
    }
    serializePlugins(e2, t2) {
      return Object.entries(this.plugins).map((r2) => {
        var n2, i2;
        if (!t2 || t2.includes(r2[1].constructor.PluginType))
          return false !== r2[1].serializeWithViewer ? null === (i2 = (n2 = r2[1]).toJSON) || void 0 === i2 ? void 0 : i2.call(n2, e2) : void 0;
      }).filter((e3) => !!e3);
    }
    deserializePlugins(e2, t2) {
      return e2.forEach((e3) => {
        var r2;
        if (!e3.type)
          return void this.console.warn("Invalid plugin to import ", e3);
        const n2 = this.getPluginByType(e3.type);
        n2 && (null === (r2 = n2.fromJSON) || void 0 === r2 || r2.call(n2, e3, t2));
      }), this;
    }
    traverseSceneObjects(e2) {
      this.scene.modelRoot.modelObject.traverse(e2);
    }
    toJSON(e2, t2) {
      return Object.assign({ version: go.VERSION, plugins: this.serializePlugins(e2, t2) }, ke(this, true, e2));
    }
    fromJSON(e2, t2) {
      return De(e2, this, true, t2), Array.isArray(e2.plugins) && this.deserializePlugins(e2.plugins, t2), this.setBackground(this._rawBackground), this;
    }
    _setActiveCameraView(e2 = {}) {
      if ("setView" === e2.type) {
        if (!e2.camera)
          return void console.warn("Cannot find camera", e2);
        this.scene.activeCamera.copyFromCamera(e2.camera);
      } else
        "activateMain" === e2.type && (this.scene.activeCamera = e2.camera ? this.createCamera(e2.camera) : void 0);
    }
  }
  go.VERSION = "0.5.5", mo([Ce()], go.prototype, "scene", void 0), mo([Ce("background")], go.prototype, "_rawBackground", void 0), mo([Ce(), M(go.prototype._backgroundIntensityChanged)], go.prototype, "backgroundIntensity", void 0);
  const vo = "envMapBackground";
  function Ao(e2) {
    var t2, r2, n2;
    return (null === (t2 = e2) || void 0 === t2 ? void 0 : t2.isShaderPass2) ? e2 : new zt({ ...i, fragmentShader: `
                       varying vec2 vUv;
                       
                       ${Array.isArray(e2) ? e2[0] : (null === (r2 = e2) || void 0 === r2 ? void 0 : r2.pars) || ""}
                       
                       void main() {

                            gl_FragColor = tDiffuseTexelToLinear (texture2D(tDiffuse, vUv));
                            
                            ${Array.isArray(e2) ? e2[1] : "string" == typeof e2 ? e2 : (null === (n2 = e2) || void 0 === n2 ? void 0 : n2.main) || ""}
                            
                        }`, uniforms: { tDiffuse: { value: null } } }, "tDiffuse");
  }
  var bo = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let yo = class extends ro {
    constructor() {
      super(), this.toJSON = void 0, this.enabled = true, this._lastSize = ["100%", "100%"], this._lastFsElement = null, this._fsChangeHandler = (e2) => {
        var t2;
        if (this.isFullScreen())
          this.dispatchEvent({ type: "enter" });
        else {
          const e3 = this._lastFsElement || (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.canvas);
          e3 && (e3.style.width = this._lastSize[0], e3.style.height = this._lastSize[1]), document.removeEventListener("webkitfullscreenchange", this._fsChangeHandler, false), document.removeEventListener("mozfullscreenchange", this._fsChangeHandler, false), document.removeEventListener("fullscreenchange", this._fsChangeHandler, false), document.removeEventListener("MSFullscreenChange", this._fsChangeHandler, false), this.dispatchEvent({ type: "exit" });
        }
      }, this.enter = this.enter.bind(this), this.exit = this.exit.bind(this);
    }
    async enter(e2) {
      var t2;
      if (this.isFullScreen())
        return;
      const r2 = e2 || (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.canvas);
      return r2 ? (this._lastFsElement = r2, document.addEventListener && (document.addEventListener("webkitfullscreenchange", this._fsChangeHandler, false), document.addEventListener("mozfullscreenchange", this._fsChangeHandler, false), document.addEventListener("fullscreenchange", this._fsChangeHandler, false), document.addEventListener("MSFullscreenChange", this._fsChangeHandler, false)), this._lastSize = [r2.style.width, r2.style.height], r2.style.width = "100%", r2.style.height = "100%", r2.requestFullscreen ? r2.requestFullscreen() : r2.mozRequestFullScreen ? r2.mozRequestFullScreen() : r2.webkitRequestFullscreen ? r2.webkitRequestFullscreen() : r2.msRequestFullscreen ? r2.msRequestFullscreen() : void 0) : void 0;
    }
    async exit() {
      return document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : void 0;
    }
    async toggle(e2) {
      return this.isFullScreen() ? this.exit() : this.enter(e2);
    }
    isFullScreen() {
      return document.webkitIsFullScreen || document.mozFullScreen || void 0 !== document.msFullscreenElement;
    }
  };
  yo.PluginType = "FullScreenPlugin", bo([rt("Enter FullScreen")], yo.prototype, "enter", null), bo([rt("Exit FullScreen")], yo.prototype, "exit", null), bo([rt("Toggle FullScreen")], yo.prototype, "toggle", null), yo = bo([lt("Full Screen")], yo);
  class xo {
    constructor(e2, t2, r2) {
      this._el = e2, this._inputEl = t2, this._listeners = { drop: [], dropstart: [], droperror: [] }, this._onDragover = this._onDragover.bind(this), this._onDrop = this._onDrop.bind(this), this._onSelect = this._onSelect.bind(this), null == e2 || e2.addEventListener("dragover", this._onDragover, false), null == e2 || e2.addEventListener("drop", this._onDrop, false), null == t2 || t2.addEventListener("change", this._onSelect), r2 && Object.entries(r2).forEach(([e3, t3]) => t3 && this.on(e3, t3));
    }
    get inputEl() {
      return this._inputEl;
    }
    get el() {
      return this._el;
    }
    on(e2, t2) {
      return this._listeners[e2].push(t2), this;
    }
    _emit(e2, t2) {
      return this._listeners[e2].forEach((e3) => e3(t2)), this;
    }
    destroy() {
      const e2 = this._el, t2 = this._inputEl;
      null == e2 || e2.removeEventListener("dragover", this._onDragover), null == e2 || e2.removeEventListener("drop", this._onDrop), null == t2 || t2.removeEventListener("change", this._onSelect);
    }
    _onDrop(e2) {
      var t2, r2;
      e2.stopPropagation(), e2.preventDefault(), this._emit("dropstart");
      const n2 = Array.from((null === (t2 = e2.dataTransfer) || void 0 === t2 ? void 0 : t2.files) || []), i2 = Array.from((null === (r2 = e2.dataTransfer) || void 0 === r2 ? void 0 : r2.items) || []);
      if (0 !== n2.length || 0 !== i2.length)
        if (i2.length > 0) {
          const e3 = i2.map((e4) => e4.webkitGetAsEntry());
          this._loadNextEntry(/* @__PURE__ */ new Map(), e3);
        } else
          this._emit("drop", { files: new Map(n2.map((e3) => (e3.filePath = e3.name, [e3.filePath, e3]))) });
      else
        this._fail("Required drag-and-drop APIs are not supported in this browser.");
    }
    _onDragover(e2) {
      e2.stopPropagation(), e2.preventDefault(), e2.dataTransfer && (e2.dataTransfer.dropEffect = "copy");
    }
    _onSelect(e2) {
      var t2;
      if (!this._inputEl)
        return void console.warn("Invalid Dropzone event ", e2);
      this._emit("dropstart");
      const r2 = [].slice.call(null !== (t2 = this._inputEl.files) && void 0 !== t2 ? t2 : new FileList()), n2 = /* @__PURE__ */ new Map();
      r2.forEach((e3) => {
        e3.filePath = e3.webkitRelativePath || e3.name, n2.set(e3.filePath, e3);
      }), this._emit("drop", { files: n2 });
    }
    _loadNextEntry(e2, t2) {
      const r2 = t2.pop();
      if (r2)
        if (r2.isFile)
          r2.file((n2) => {
            n2.filePath = r2.fullPath, e2.set(r2.fullPath, n2), this._loadNextEntry(e2, t2);
          }, () => console.error("Could not load file: %s", r2.fullPath));
        else if (r2.isDirectory) {
          const n2 = r2.createReader(), i2 = (r3) => {
            r3.length ? (t2 = t2.concat(r3), n2.readEntries(i2)) : this._loadNextEntry(e2, t2);
          };
          n2.readEntries(i2);
        } else
          console.warn("Unknown asset type: " + r2.fullPath), this._loadNextEntry(e2, t2);
      else
        this._emit("drop", { files: e2 });
    }
    _fail(e2) {
      this._emit("droperror", { message: e2 });
    }
  }
  class wo extends r {
    constructor(e2) {
      super(), this._domElement = e2, this._allowedExtensions = void 0, this.importerParams = { autoScale: true, autoScaleRadius: 2, pseudoCenter: true, autoCenter: false, autoImport: true, autoAdd: true, centerOffset: new n.Pa4(0.5, 0.5, 3) }, this.dependencies = [to], this.uiConfig = { type: "folder", label: "Drop Options", children: [{ label: "Auto Center", type: "checkbox", property: [this.importerParams, "pseudoCenter"], limitedUi: true }, { label: "Auto Scale", type: "checkbox", property: [this.importerParams, "autoScale"], limitedUi: true }, { label: "Auto scale radius", type: "slider", bounds: [0.5, 100], property: [this.importerParams, "autoScaleRadius"] }] };
    }
    async onAdded(e2) {
      this._inputEl = document.createElement("input"), this._viewer = e2, this._inputEl.type = "file", this._dropzone = new xo(this._domElement || e2.canvas, this._inputEl, { drop: this._onFileDrop.bind(this) });
    }
    async _onFileDrop({ files: e2 }) {
      var t2, r2, n2, i2, s2, o2;
      if (!e2)
        return;
      const a2 = this._viewer;
      if (!a2)
        return;
      if (void 0 !== this._allowedExtensions)
        for (const n3 of e2.keys())
          this._allowedExtensions.includes(null !== (r2 = null === (t2 = n3.split(".").pop()) || void 0 === t2 ? void 0 : t2.toLowerCase()) && void 0 !== r2 ? r2 : "") || e2.delete(n3);
      if (e2.size < 1)
        return;
      const l2 = a2.getPlugin(to), c2 = { type: "drop", files: e2 };
      if (this.importerParams.autoImport) {
        const t3 = { allowedExtensions: this.allowedExtensions, ...this.importerParams };
        if (c2.imported = await (null === (n2 = l2.importer) || void 0 === n2 ? void 0 : n2.importFiles(e2, t3)), this.importerParams.autoAdd) {
          const e3 = null !== (o2 = [...null !== (s2 = null === (i2 = c2.imported) || void 0 === i2 ? void 0 : i2.values()) && void 0 !== s2 ? s2 : []].flat(2).filter((e4) => !!e4)) && void 0 !== o2 ? o2 : [];
          if (c2.assets = l2.addProcessedAssets(e3, { ...this.importerParams }), !t3._rootSceneImported)
            for (const e4 of c2.assets)
              e4.modelObject && e4.modelObject.dispatchEvent({ type: "select", value: e4.modelObject });
        }
      }
      this.dispatchEvent(c2);
    }
    promptForFile() {
      var e2;
      null === (e2 = this._inputEl) || void 0 === e2 || e2.click();
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      var t2;
      null === (t2 = this._dropzone) || void 0 === t2 || t2.destroy(), this._dropzone = void 0, this._viewer = void 0;
    }
    get allowedExtensions() {
      return this._allowedExtensions;
    }
    set allowedExtensions(e2) {
      this._allowedExtensions = e2, this._inputEl && (this._inputEl.accept = e2 ? e2.map((e3) => "." + e3).join(", ") : "");
    }
  }
  wo.PluginType = "Dropzone";
  class Eo extends zt {
    constructor(e2) {
      super({ vertexShader: i.vertexShader, fragmentShader: w`
                uniform vec4 weight;
                uniform vec4 weight2;
                varying vec2 vUv;
                void main() {
                    vec4 texel = clamp(weight * tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ) + weight2 * tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), vec4(0), vec4(8));
                    gl_FragColor = texel;
                    #include <encodings_fragment>
                }
            `, uniforms: { tDiffuse: { value: null }, tDiffuse2: { value: e2 }, weight: { value: new n.Ltg(1, 1, 1, 1) }, weight2: { value: new n.Ltg(1, 1, 1, 1) } } }, "tDiffuse", "tDiffuse2"), this.clear = false, this.needsSwap = true;
    }
    set weights2(e2) {
      this.uniforms.weight2.value.copy(e2);
    }
    get weights2() {
      return this.uniforms.weight2.value;
    }
    set weights1(e2) {
      this.uniforms.weight.value.copy(e2);
    }
    get weights1() {
      return this.uniforms.weight.value;
    }
    set blendTexture(e2) {
      this.uniforms.tDiffuse2.value = e2;
    }
  }
  class So extends ro {
    constructor() {
      super(), this._pipeline = [];
    }
    get passes() {
      if (!this._passes)
        throw "Plugin not yet added to the viewer";
      return this._passes;
    }
    get pipeline() {
      return this._pipeline;
    }
    set pipeline(e2) {
      this._pipeline = e2;
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const t2 = this.createPasses(e2);
      this._passes = Object.fromEntries(t2.map((t3) => (t3.passId || (console.warn("no id found for pass", t3), t3.passId = Xe()), e2.renderer.registerPass(t3, true), [t3.passId, t3])));
    }
    async onRemove(e2) {
      var t2;
      if (this._passes) {
        for (const r2 of [...Object.values(this._passes)]) {
          const n2 = r2;
          e2.renderer.unregisterPass(n2), null === (t2 = null == n2 ? void 0 : n2.dispose) || void 0 === t2 || t2.call(n2);
        }
        this._passes = void 0;
      }
      await super.onRemove(e2);
    }
    toJSON(e2) {
      var t2, r2;
      const n2 = super.toJSON(e2);
      if (!n2.type)
        return n2;
      const i2 = Object.entries(this.passes);
      n2.passes = {};
      for (const [s2, o2] of i2)
        n2.passes[s2] = ke(null !== (r2 = null === (t2 = o2) || void 0 === t2 ? void 0 : t2.passObject) && void 0 !== r2 ? r2 : o2, false, e2);
      return n2;
    }
    fromJSON(e2, t2) {
      var r2, n2;
      if (!super.fromJSON(e2, t2))
        return null;
      if (e2.passes) {
        const i2 = Object.entries(this.passes);
        for (const [s2, o2] of i2)
          De(e2.passes[s2], null !== (n2 = null === (r2 = o2) || void 0 === r2 ? void 0 : r2.passObject) && void 0 !== n2 ? n2 : o2, false, t2);
      }
      return this;
    }
  }
  var Co = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  const Mo = [{ x: 0, y: 0 }, { x: -0.5, y: 0 }, { x: -0.375, y: -0.25 }, { x: -0.1875, y: -0.125 }, { x: -0.125, y: -0.375 }, { x: 0.0625, y: -0.0625 }, { x: 0.125, y: -0.3125 }, { x: 0.375, y: -0.4375 }, { x: 0.3125, y: -0.1875 }, { x: 0.25, y: 0.0625 }, { x: 0.4375, y: 0.25 }, { x: 0.1875, y: 0.3125 }, { x: 0, y: 0.4375 }, { x: -0.0625, y: 0.1875 }, { x: -0.25, y: 0.375 }, { x: -0.4375, y: 0.5 }, { x: -0.3125, y: 0.125 }];
  class To extends So {
    constructor(e2 = 2 * Mo.length) {
      super(), this.enabled = true, this.jitter = true, this._hasSetOffset = false, this.trackedJitterCameras = /* @__PURE__ */ new Set(), this._addSceneObject = (e3) => {
        const t2 = e3.object;
        (t2.modelObject || t2.lightObject) && (t2.modelObject || t2.lightObject).traverse((e4) => {
          var t3;
          (null === (t3 = null == e4 ? void 0 : e4.shadow) || void 0 === t3 ? void 0 : t3.camera) && e4.shadow.mapSize && this.trackedJitterCameras.add([e4.shadow.camera, e4.shadow.mapSize]);
        });
      }, this._jitterCamera = (e3) => {
        var t2;
        const r2 = e3.target;
        if (this.jitter && r2.renderer.frameCount > 2) {
          const e4 = (e5, t3) => {
            const n3 = { ...Mo[r2.renderer.frameCount % Mo.length] };
            e5.setViewOffset(t3.width, t3.height, n3.x, n3.y, t3.width, t3.height);
          }, n2 = r2.scene.activeCamera.cameraObject;
          e4(n2, { width: r2.canvas.clientWidth * r2.renderer.displayCanvasScaling, height: r2.canvas.clientHeight * r2.renderer.displayCanvasScaling }), this.trackedJitterCameras.forEach((t3) => e4(...t3)), this._hasSetOffset = true, null === (t2 = this._viewer) || void 0 === t2 || t2.renderer.resetShadows();
        }
      }, this._resetCameraJitter = (e3) => {
        const t2 = e3.target;
        this._hasSetOffset && (t2.scene.activeCamera.cameraObject.clearViewOffset(), this._hasSetOffset = false);
      }, this.uiConfig = at("Progressive", this), this.maxFrameCount = e2;
    }
    async onAdded(e2) {
      return this._lastFrame = e2.renderer.composerTarget.clone(true), await super.onAdded(e2);
    }
    async onRemove(e2) {
      e2.removeEventListener("preRender", this._jitterCamera), e2.removeEventListener("postRender", this._resetCameraJitter), e2.scene.removeEventListener("addSceneObject", this._addSceneObject), this._lastFrame && e2.renderer.disposeTarget(this._lastFrame), this._lastFrame = void 0, await super.onRemove(e2);
    }
    get lastFrame() {
      return this._lastFrame;
    }
    createPasses(e2) {
      e2.addEventListener("preRender", this._jitterCamera), e2.addEventListener("postRender", this._resetCameraJitter), e2.scene.addEventListener("addSceneObject", this._addSceneObject);
      const t2 = this, r2 = no(e2, { passId: "progressive", get dirty() {
        var e3;
        return t2.jitter && ((null === (e3 = t2._viewer) || void 0 === e3 ? void 0 : e3.renderer.frameCount) || 0) < t2.maxFrameCount;
      }, after: ["render"], before: ["combinedPost", "screen"], required: ["render"], passObject: new class extends Eo {
        render(r3, n2, i2, s2, o2) {
          if (e2.renderer.frameCount < 1)
            return this.needsSwap = false, void ((null == i2 ? void 0 : i2.texture) && e2.renderer.blit(i2.texture, t2.lastFrame, {}));
          this.needsSwap = true, super.render(r3, n2, i2, s2, o2), e2.renderer.blit(n2.texture, t2.lastFrame, {});
        }
      }(), update() {
        if (!t2.lastFrame)
          return void console.error("lastFrame render target undefined");
        let r3 = 1 / (Math.max(e2.renderer.frameCount, 0) + 1);
        this.passObject.weights1.set(r3, r3, r3, r3), r3 = 1 - r3, this.passObject.weights2.set(r3, r3, r3, r3), this.passObject.blendTexture = t2.lastFrame.texture, this.passObject.material.uniformsNeedUpdate = true;
      } });
      return [r2];
    }
    isConverged(e2 = false) {
      var t2;
      return ((null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.renderer.frameCount) || 0) >= this.maxFrameCount - 1 + (e2 ? 1 : 0);
    }
    updateShaderProperties(e2) {
      var t2, r2;
      return e2.uniforms.tLastFrame && (e2.uniforms.tLastFrame.value = null !== (r2 = null === (t2 = this.lastFrame) || void 0 === t2 ? void 0 : t2.texture) && void 0 !== r2 ? r2 : void 0), this;
    }
    postFrameConvergedRecordingDelta(e2 = "CanvasRecorder") {
      const t2 = this._viewer.getPluginByType(e2);
      return t2 && t2.isRecording() && t2.convergeMode ? this.isConverged(true) ? 1 / t2.videoFrameRate : 0 : -1;
    }
  }
  To.PluginType = "Progressive", Co([Ce(), nt("Frame count")], To.prototype, "maxFrameCount", void 0), Co([Ce(), Je("Jitter")], To.prototype, "jitter", void 0);
  var Io = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}", ko = "#ifndef BASIC_CAMERA_HELPERS\n#define BASIC_CAMERA_HELPERS \nuniform vec2 cameraNearFar;uniform vec3 cameraPositionWorld;uniform mat4 projection;\n#ifndef THREE_PACKING_INCLUDED\n#define THREE_PACKING_INCLUDED \n#include <packing>\n#endif\nfloat linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}float depthToViewZ(const in float depth){return(depth>0.999)?-cameraNearFar.y*1000.:-mix(cameraNearFar.x,cameraNearFar.y,depth);}float viewZToDepth(const in float viewZ){return linstep(-cameraNearFar.x,-cameraNearFar.y,viewZ);}vec4 viewToScreen3(const in vec3 pos){vec4 projected=projection*vec4(pos,1.);projected.z=pos.z;projected.w=1./projected.w;projected.xyz*=projected.w;projected.xy=0.5+0.5*projected.xy;return projected;}vec3 screenToView(const in vec2 uv,const in float viewZ){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewZ/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewZ/projection[1][1];return vec3(xe,ye,viewZ);}\n#endif\n", Do = "#ifndef BASIC_HELPERS\n#define BASIC_HELPERS \nfloat saturate2(float v,float mx){return max(0.,min(mx,v));}vec3 saturate2(vec3 v){return max(vec3(0.),min(vec3(1.),v));}\n#endif\n", Po = "#ifndef BASIC_RANDOM_HELPERS\n#define BASIC_RANDOM_HELPERS \nuniform float frameCount;float random(float n){return fract(sin(n)*43758.5453123);}float random2(vec2 n,float x){n+=x;return fract(sin(dot(n.xy,vec2(12.9898,78.233)))*43758.5453);}float random3(vec3 v){v=fract(v*443.8975);v+=dot(v,v.yzx+19.19);return fract((v.x+v.y)*v.z);}float interleavedGradientNoise(const in vec2 fragCoord,const in float seed){vec3 magic=vec3(0.06711056,0.00583715,52.9829189);return fract(magic.z*fract(dot(fragCoord.xy+seed*vec2(2.083,4.867),magic.xy)));}vec3 hash3(vec2 p){vec3 q=vec3(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)),dot(p,vec2(419.2,371.9)));return fract(sin(q)*43758.5453);}\n#endif\n", Bo = "#define PI  3.141592653589793\nmat3 GetTangentBasis(vec3 TangentZ){vec3 up=vec3(0.,0.,1.);vec3 TangentX=normalize(cross(dot(TangentZ,up)<0.8?up:vec3(1.,0.,0.),TangentZ));vec3 TangentY=cross(TangentZ,TangentX);return mat3(TangentX,TangentY,TangentZ);}vec4 CosineSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=sqrt(E.y);float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=CosTheta*(1./PI);return vec4(H,PDF);}vec4 UniformSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=E.y;float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=1./(2.*PI);return vec4(H,PDF);}vec2 UniformSampleDiskConcentric(vec2 E){vec2 p=2.*E-1.;float Radius;float Phi;if(abs(p.x)>abs(p.y)){Radius=p.x;Phi=(PI/4.)*(p.y/p.x);}else{Radius=p.y;Phi=(PI/2.)-(PI/4.)*(p.x/p.y);}return vec2(Radius*cos(Phi),Radius*sin(Phi));}vec2 UniformSampleDiskConcentricApprox(vec2 E){vec2 sf=E*sqrt(2.)-sqrt(0.5);vec2 sq=sf*sf;float root=sqrt(2.*max(sq.x,sq.y)-min(sq.x,sq.y));if(sq.x>sq.y){sf.x=sf.x>0.?root:-root;}else{sf.y=sf.y>0.?root:-root;}return sf;}", Ro = "#ifndef SSRT_PARS_SNIP\n#define SSRT_PARS_SNIP \n#define pow2(a)a*a\nfloat getDepth2(const in vec2 uv,const in float lod){float viewDepth=getDepth(uv);return depthToViewZ(viewDepth);}\n#define LOD_DEPTH  1.0\n#define LOD_COLOR  5.0\nvoid _traceRay(in vec4 ray_origin,in vec4 ray_dir,in float tolerance,inout vec3 state,in int loopMax,in float iStepCount){vec4 sample_uv;float d,hit;float dLod=0.;\n#pragma unroll_loop_start\nfor(int i=0;i<8;i++){if(UNROLLED_LOOP_INDEX<loopMax){sample_uv=ray_origin+ray_dir*state.y;d=getDepth2(sample_uv.xy,dLod);d=sample_uv.z/sample_uv.w-d;if(abs(d+tolerance)<tolerance){hit=clamp(state.x/(state.x-d),0.,1.)-1.;hit=(state.y+hit*iStepCount);state.z=min(state.z,hit);}state.x=d;state.y+=1.*iStepCount;}}\n#pragma unroll_loop_end\n}vec3 traceRay(in vec3 ray_origin_view,in vec3 ray_dir_view,in float tolerance,inout vec3 state,in int _STEP_COUNT){vec4 sample_uv;vec4 ray_origin=viewToScreen3(ray_origin_view);vec3 ray_end_view=ray_origin_view+ray_dir_view;vec4 ray_dir=viewToScreen3(ray_end_view);vec2 clamp_end=clamp(ray_dir.xy,vec2(0.),vec2(1.));vec2 correction=abs(ray_dir.xy-clamp_end);correction=(step(0.01,correction)*correction/(abs(clamp_end-ray_origin.xy)+0.01))+1.;correction.x=1./min(max(correction.y,correction.x),10.);ray_dir=ray_dir-ray_origin;ray_dir.xyw*=correction.x;float iStepCount=1./float(_STEP_COUNT);tolerance*=0.125;_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT,iStepCount);if(_STEP_COUNT>8&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-8,iStepCount);if(_STEP_COUNT>15&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);if(_STEP_COUNT>23&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);sample_uv=ray_origin+ray_dir*state.z;sample_uv.z/=sample_uv.w;state.z=state.z<0.999?state.z:9999999.;return sample_uv.xyz;}\n#endif\n", Lo = "uniform float objectRadius;uniform float radius;uniform float tolerance;uniform bool autoRadius;\n#ifndef D_sceneBoundingRadius\n#define D_sceneBoundingRadius \nuniform float sceneBoundingRadius;\n#endif\nvec3 ComputeReflectionL(vec3 N,vec2 E,vec3 V,float rough){float rough4=rough*rough*rough*rough;float phi=2.*PI*E.x;float cos_theta=pow(max(E.y,0.000001),rough4/(2.-rough4));float sin_theta=sqrt(max(0.,1.-cos_theta*cos_theta));vec3 half_vec=vec3(sin_theta*cos(phi),sin_theta*sin(phi),cos_theta);vec3 tangentX=normalize(cross(abs(N.z)<0.999?vec3(0.,0.,1.):vec3(1.,0.,0.),N));vec3 tangentY=cross(N,tangentX);half_vec=half_vec.x*tangentX+half_vec.y*tangentY+half_vec.z*N;vec3 ray_dir=(2.*dot(V,half_vec))*half_vec-V;return ray_dir;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=interleavedGradientNoise(gl_FragCoord.xy,frameCount*117.);rand_e.y=fract(rand_e.x*38.65435);rand_e.y=mix(rand_e.y,1.,0.7);return rand_e;}vec4 calculateSSR(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor,in float roughness){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeReflectionL(normal,E,-normalize(viewPos),roughness);L=normalize(L);float cameraDist=length(cameraPositionWorld);float rayLen=autoRadius?mix((cameraDist+objectRadius*sceneBoundingRadius)+viewPos.z,-viewPos.z-max(0.,cameraDist-objectRadius*sceneBoundingRadius),L.z*0.5+0.5):objectRadius*sceneBoundingRadius;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount+seed);rayLen=max(rayLen,0.001);int steps=SSR_STEP_COUNT/(frameCount<float(SSR_LOW_QUALITY_FRAMES)?2:1);vec3 state=vec3(0.,(r+0.5)/float(steps),2.);viewPos+=normal*max(-0.0001*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,steps);if(state.z<0.99){vec3 hitColor=(tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy))).rgb;float ssrWeight=1.;return vec4(hitColor*ssrWeight,1.);}return vec4(0.);}", Oo = "#ifndef SIMPLE_CAMERA_HELPERS\n#define SIMPLE_CAMERA_HELPERS \n#ifndef USE_TRANSMISSION\nuniform mat4 projectionMatrix;\n#endif\nvec3 viewToScreen(const in vec3 pos){vec4 projected=projectionMatrix*vec4(pos,1.);return vec3(0.5+0.5*projected.xy/projected.w,projected.w);}\n#endif\n", Fo = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let Uo = class extends zt {
    constructor(e2, t2, r2, i2 = true) {
      super({ vertexShader: Io, fragmentShader: `

varying vec2 vUv;

${Do}
${ko}
${Po}
${Bo}
${r2}

${Ro}

${Lo}

uniform sampler2D tLastThis;void main(){vec4 texel=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));vec4 lastAO=tLastThisTexelToLinear(texture2D(tLastThis,vUv));float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>=0.999){discard;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec3 viewPos=screenToView(screenPos.xy,screenPos.z);viewPos.z=viewZ/viewPos.z;vec4 ao=vec4(0.);ao+=calculateSSR(8.,screenPos,normal,1.,0.1);ao.rgb=min(vec3(3.),ao.rgb);ao.rgb=max(vec3(0.),ao.rgb);if(frameCount<1.){gl_FragColor=ao;return;}if(ao.a<0.01){gl_FragColor.rgb=lastAO.rgb;gl_FragColor.a=(((lastAO.a)*frameCount)/(frameCount+1.));}else{gl_FragColor=((ao+(lastAO)*frameCount)/(frameCount+1.));}
#include <encodings_fragment>
}


            `, uniforms: { tLastThis: { value: null }, tDiffuse: { value: null }, tNormalDepth: { value: null }, tLastFrame: { value: null }, opacity: { value: 1 }, intensity: { value: 0 }, boost: { value: new n.Pa4(0, 0, 0) }, objectRadius: { value: 0 }, autoRadius: { value: false }, power: { value: 0 }, maskFrontFactor: { value: -0.1 }, tolerance: { value: 0 }, frameCount: { value: 0 }, projection: { value: new n.yGw() }, cameraPositionWorld: { value: new n.Pa4() }, cameraNearFar: { value: new n.FM8(0.1, 1e3) }, sceneBoundingRadius: { value: 0 } }, defines: { PERSPECTIVE_CAMERA: 1, SSR_STEP_COUNT: 16, SSR_LOW_QUALITY_FRAMES: 2, SSR_MASK_FRONT_RAYS: true, SSR_INLINE: i2 ? "1" : "0", SSR_NON_PHYSICAL: "0" } }, "tDiffuse", "tLastThis", "tLastFrame"), this.uiConfig = void 0, this.materialExtension = { shaderExtender: (e3, t3, r3) => {
        if (!e3.defines.SSR_ENABLED)
          return;
        const n2 = "#glMarker beforeModulation";
        e3.fragmentShader = e3.fragmentShader.replace(n2, `

            
            #if defined(SSR_ENABLED) && SSR_ENABLED > 0
vec3 screenPos=viewToScreen(geometry.position);vec4 ssrColor=vec4(0,0,0,0);float alphaModifier=1.-clamp(material.roughness*.3,0.,1.);alphaModifier*=ssrIntensity;
#if defined(SSR_MASK_FRONT_RAYS) && SSR_MASK_FRONT_RAYS > 0
alphaModifier*=clamp(-4.*dot(geometry.viewDir,normal)+(4.+ssrMaskFrontFactor),0.,1.);
#endif
#ifdef USE_TRANSMISSION
alphaModifier*=1.-transmission;
#endif
float vignette=1.;if(true){float fadeStrength=0.1;float dist=min(min(1.-screenPos.x,1.-screenPos.y),min(screenPos.x,screenPos.y));float fade=dist*dist/(fadeStrength+0.001);fade=clamp(fade,0.,1.);fade=pow(fade,0.3);vignette=fade;}alphaModifier*=vignette;vec3 specularColor=EnvironmentBRDF(geometry.normal,geometry.viewDir,material.specularColor.rgb,material.specularF90,material.roughness);if(length(specularColor.rgb)*alphaModifier>0.01&&roughnessFactor<0.9){
#if defined(SSR_INLINE) && SSR_INLINE > 0
ssrColor=calculateSSR(8.,vec3(screenPos.xy,geometry.position.z),geometry.normal,1.,material.roughness);
#else
ssrColor=tSSRMapTexelToLinear(texture2D(tSSRMap,screenPos.xy));
#endif 
}ssrColor.rgb*=ssrBoost;ssrColor.a*=alphaModifier;ssrColor.a=min(ssrColor.a,1.);
#if defined(SSR_NON_PHYSICAL) && SSR_NON_PHYSICAL > 0
diffuseColor.a=max(ssrColor.a,diffuseColor.a*diffuseColor.a);reflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(diffuseColor.rgb*ssrColor.rgb),1.);reflectedLight.indirectDiffuse=diffuseColor.rgb*(1.-ssrColor.a);reflectedLight.directDiffuse=vec3(0.);reflectedLight.directSpecular=vec3(0.);
#else
reflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(specularColor.rgb*ssrColor.rgb),ssrColor.a);
#endif
#endif

            
            // reflectedLight.directDiffuse = vec3(0.);
            // reflectedLight.indirectDiffuse = vec3(0.);
            // reflectedLight.directSpecular = vec3(0.);
            // reflectedLight.indirectSpecular = vec3(0.);
            
            
${n2}`);
      }, onObjectRender: (e3, t3, r3) => {
        var n2, i3, s2, o2;
        let a2 = this.enabled && false !== r3.userData.screenSpaceRendering && !(null === (n2 = t3.materialObject.userData) || void 0 === n2 ? void 0 : n2.ssreflDisabled) ? 1 : 0;
        t3.materialObject.defines.SSR_ENABLED !== a2 && (t3.materialObject.defines.SSR_ENABLED = a2, t3.materialObject.needsUpdate = true), a2 = this.material.defines.SSR_STEP_COUNT, t3.materialObject.defines.SSR_STEP_COUNT !== a2 && (t3.materialObject.defines.SSR_STEP_COUNT = a2, t3.materialObject.needsUpdate = true), a2 = this.material.defines.SSR_LOW_QUALITY_FRAMES, t3.materialObject.defines.SSR_LOW_QUALITY_FRAMES !== a2 && (t3.materialObject.defines.SSR_LOW_QUALITY_FRAMES = a2, t3.materialObject.needsUpdate = true), a2 = this.material.defines.PERSPECTIVE_CAMERA, t3.materialObject.defines.PERSPECTIVE_CAMERA !== a2 && (t3.materialObject.defines.PERSPECTIVE_CAMERA = a2, t3.materialObject.needsUpdate = true), a2 = this.material.defines.SSR_INLINE, t3.materialObject.defines.SSR_INLINE !== a2 && (t3.materialObject.defines.SSR_INLINE = a2, t3.materialObject.needsUpdate = true), a2 = this.material.defines.SSR_MASK_FRONT_RAYS ? 1 : 0, t3.materialObject.defines.SSR_MASK_FRONT_RAYS !== a2 && (t3.materialObject.defines.SSR_MASK_FRONT_RAYS = a2, t3.materialObject.needsUpdate = true), a2 = (null === (i3 = t3.materialObject.userData) || void 0 === i3 ? void 0 : i3.ssreflNonPhysical) ? "1" : "0", t3.materialObject.defines.SSR_NON_PHYSICAL !== a2 && (t3.materialObject.defines.SSR_NON_PHYSICAL = a2, t3.materialObject.needsUpdate = true), a2 = null !== (o2 = null === (s2 = this._target) || void 0 === s2 ? void 0 : s2.texture) && void 0 !== o2 ? o2 : null, this.materialExtension.extraUniforms.tSSRMap.value !== a2 && (this.materialExtension.extraUniforms.tSSRMap.value = a2, t3.materialObject.needsUpdate = true);
      }, parsFragmentSnippet: (e3) => {
        var t3;
        return "\nuniform float ssrPower;\nuniform float ssrIntensity;\nuniform float ssrMaskFrontFactor;\nuniform vec3 ssrBoost;\nuniform sampler2D tSSRMap;\nuniform sampler2D tLastFrame;\n" + U("tSSRMap", null === (t3 = this._target) || void 0 === t3 ? void 0 : t3.texture, e3.capabilities.isWebGL2) + U("tLastFrame", this.materialExtension.extraUniforms.tLastFrame.value, e3.capabilities.isWebGL2) + (this._inline ? `
#if 1
// #if SSR_INLINE
    ${Do}
    
    #define THREE_PACKING_INCLUDED
    ${ko}
    
    ${Po}
    ${Bo}
    ${Ht}
    
    ${Ro}
    
    ${Lo}
// #endif // SSR_INLINE
#endif
` : "") + `

${Oo}

        `;
      }, extraUniforms: { tSSRMap: { value: null }, ssrPower: this.material.uniforms.power, ssrIntensity: this.material.uniforms.intensity, ssrMaskFrontFactor: this.material.uniforms.maskFrontFactor, ssrBoost: this.material.uniforms.boost, tNormalDepth: this.material.uniforms.tNormalDepth, tLastFrame: this.material.uniforms.tLastFrame, objectRadius: this.material.uniforms.objectRadius, autoRadius: this.material.uniforms.autoRadius, tolerance: this.material.uniforms.tolerance, frameCount: this.material.uniforms.frameCount, projection: this.material.uniforms.projection, cameraPositionWorld: this.material.uniforms.cameraPositionWorld, cameraNearFar: this.material.uniforms.cameraNearFar, sceneBoundingRadius: this.material.uniforms.sceneBoundingRadius }, computeCacheKey: (e3) => {
        var t3, r3;
        return this.enabled ? "1" : "0" + (null === (r3 = null === (t3 = this._target) || void 0 === t3 ? void 0 : t3.texture) || void 0 === r3 ? void 0 : r3.encoding);
      }, isCompatible: (e3) => {
        var t3;
        return !(null === (t3 = e3.materialObject.userData) || void 0 === t3 ? void 0 : t3.ssreflDisabled) && e3.isMeshStandardMaterial2;
      } }, this.intensity = 1, this.boost = new n.Pa4(1, 1, 1), this.objectRadius = 1, this.autoRadius = true, this.power = 1.1, this.tolerance = 0.5, this.stepCount = 16, this.lowQualityFrames = 0, this.maskFrontRays = true, this.maskFrontFactor = -0.2, this._renderer = e2, this._target = t2, this.needsSwap = false, this._inline = i2;
    }
    render(e2, t2, r2, n2, i2) {
      if (this._inline)
        this.needsSwap = false;
      else {
        if (!this._target)
          throw "Target must be set when inline = false";
        this._renderer.blit(this._target.texture, t2, {}), this.uniforms.tLastThis.value = t2.texture, super.render(e2, this._target, r2, n2, i2), this.needsSwap = false;
      }
    }
  };
  Fo([$e("Intensity", [0, 4]), Ce(), G()], Uo.prototype, "intensity", void 0), Fo([et("Boost"), Ce(), G()], Uo.prototype, "boost", void 0), Fo([$e("Object Radius", [0.01, 2]), Ce(), G()], Uo.prototype, "objectRadius", void 0), Fo([Je("Auto radius"), Ce(), G()], Uo.prototype, "autoRadius", void 0), Fo([$e("Power", [0, 3]), Ce(), G()], Uo.prototype, "power", void 0), Fo([$e("Tolerance", [0.1, 5]), Ce(), G()], Uo.prototype, "tolerance", void 0), Fo([$e("Step count", [1, 32], 1), Ce(), V("SSR_STEP_COUNT")], Uo.prototype, "stepCount", void 0), Fo([$e("Low Quality Frames", [0, 4], 1), Ce(), V("SSR_LOW_QUALITY_FRAMES")], Uo.prototype, "lowQualityFrames", void 0), Fo([Je("Ignore front rays"), Ce(), V("SSR_MASK_FRONT_RAYS")], Uo.prototype, "maskFrontRays", void 0), Fo([$e("Mask front rays factor", [-1, 1], 0.01, (e2) => ({ hidden: () => !e2.maskFrontRays })), Ce(), G()], Uo.prototype, "maskFrontFactor", void 0), Uo = Fo([lt("Screen Space Reflections")], Uo);
  class No extends So {
    constructor() {
      super(), this.dependencies = [to, lo, To], this.inlineSSR = true, this.setDirty = this.setDirty.bind(this);
    }
    get ssrTarget() {
      return this._ssrTarget;
    }
    get enabled() {
      var e2, t2;
      return (null === (t2 = null === (e2 = this.passes.ssr) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.enabled) || false;
    }
    set enabled(e2) {
      var t2;
      (null === (t2 = this.passes.ssr) || void 0 === t2 ? void 0 : t2.passObject) && (this.passes.ssr.passObject.enabled = e2);
    }
    async onAdded(e2) {
      var t2, r2;
      e2.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSRPlugin"), await super.onAdded(e2), null === (r2 = (t2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(t2, "postFrame", true);
    }
    createPasses(e2) {
      var t2, r2;
      return this._ssrTarget = this.inlineSSR ? void 0 : e2.renderer.createTarget({ sizeMultiplier: 1 }), [no(e2, { passId: "ssr", after: ["gbuffer"], before: ["render"], required: ["render", "gbuffer", "progressive"], passObject: new Uo(e2.renderer, this._ssrTarget, null !== (r2 = null === (t2 = e2.getPlugin(lo)) || void 0 === t2 ? void 0 : t2.getUnpackSnippet()) && void 0 !== r2 ? r2 : "", this.inlineSSR) }, () => [e2.getPlugin(lo), e2.getPlugin(To), e2.scene.activeCamera, e2.renderer, e2.scene])];
    }
    async onRemove(e2) {
      return this._ssrTarget && e2.renderer.disposeTarget(this._ssrTarget), super.onRemove(e2);
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    get uiConfig() {
      var e2, t2, r2, n2, i2;
      const s2 = null !== (r2 = null === (t2 = null === (e2 = this.passes.ssr) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.uiConfig) && void 0 !== r2 ? r2 : {};
      return null === (i2 = null === (n2 = s2.children) || void 0 === n2 ? void 0 : n2.map((e3) => A(e3))) || void 0 === i2 || i2.flat(2).forEach((e3) => e3 && (e3.onChange = this.setDirty)), s2;
    }
  }
  No.PluginType = "SSReflection";
  var jo = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class zo extends zt {
    constructor(e2, t2, r2 = "rgba") {
      super({ vertexShader: i.vertexShader, fragmentShader: t2 + "uniform vec2 tDiffuseSize;uniform vec2 bilDirection;varying vec2 vUv;uniform bool smoothEnabled;uniform float edgeSharpness;vec4 bilaterialAO(){vec4 color=clamp((texture2D(tDiffuse,vUv.xy)).B_SRC_ACCESSOR,0.,5.);if(!smoothEnabled)return color;float depth;vec3 normal;getDepthNormal(vUv.xy,depth,normal);float gaussianWeights[4];gaussianWeights[0]=0.153170;gaussianWeights[1]=0.144893;gaussianWeights[2]=0.122649;gaussianWeights[3]=0.092902;float Z=gaussianWeights[0]+0.03;vec4 final_colour=Z*color;vec2 nuv;vec4 cc;float dp;vec3 nor;vec2 direction=bilDirection/tDiffuseSize.xy;\n#pragma unroll_loop_start\nfor(int i=0;i<6;i++){direction*=-1.;nuv=vUv+2.*direction*float(UNROLLED_LOOP_INDEX/2+1);getDepthNormal(nuv,dp,nor);if(dp<0.999){float normalCloseness=dot(normal,nor);normalCloseness*=normalCloseness;float normalError=(1.-normalCloseness)*8.;float normalWeight=max((1.-normalError*edgeSharpness),0.00);float depthWeight=max(0.,1.-edgeSharpness*4000.*abs(depth-dp));float kernelWeight=gaussianWeights[UNROLLED_LOOP_INDEX/2]+0.03;float bilateralWeight=kernelWeight*depthWeight*normalWeight;Z+=bilateralWeight;cc=clamp((texture2D(tDiffuse,nuv)).B_SRC_ACCESSOR,0.,5.);final_colour+=bilateralWeight*cc;}}\n#pragma unroll_loop_end\nfinal_colour/=Z;return final_colour;}void main(){vec4 ao=clamp(bilaterialAO(),vec4(0.),vec4(1.));gl_FragColor=ao;}", uniforms: { bilDirection: { value: new n.FM8(1, 0) }, tNormalDepth: { value: null }, tDiffuse: { value: e2.texture }, tDiffuseSize: { value: new n.FM8() } }, defines: { B_SRC_ACCESSOR: r2 } }, "tDiffuse"), this.smoothEnabled = true, this.edgeSharpness = 0.1, this._target = e2, this.clear = false, this.needsSwap = false;
    }
    render(e2, t2, r2, n2, i2) {
      var s2, o2, a2, l2;
      this.enabled && (this.uniforms.bilDirection.value.set(1, 0), this.uniforms.tDiffuse.value = this._target.texture, this.uniforms.tDiffuseSize.value.set((null === (s2 = this.uniforms.tDiffuse.value) || void 0 === s2 ? void 0 : s2.image.width) || 0, (null === (o2 = this.uniforms.tDiffuse.value) || void 0 === o2 ? void 0 : o2.image.height) || 0), super.render(e2, t2, this._target, n2, i2), this.uniforms.bilDirection.value.set(0, 1), this.uniforms.tDiffuse.value = t2.texture, this.uniforms.tDiffuseSize.value.set((null === (a2 = this.uniforms.tDiffuse.value) || void 0 === a2 ? void 0 : a2.image.width) || 0, (null === (l2 = this.uniforms.tDiffuse.value) || void 0 === l2 ? void 0 : l2.image.height) || 0), super.render(e2, this._target, t2, n2, i2));
    }
  }
  jo([Ce(), G()], zo.prototype, "smoothEnabled", void 0), jo([Ce(), G()], zo.prototype, "edgeSharpness", void 0);
  var Go = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class Vo extends zt {
    constructor(e2, t2, r2) {
      super({ defines: { LINEAR_DEPTH: 1, NUM_SAMPLES: 11, NUM_SPIRAL_TURNS: 3, DEPTH_NORMAL_TEXTURE: 1, DEPTH_PACKING_MODE: 2, PERSPECTIVE_CAMERA: 1 }, uniforms: { tLastThis: { value: null }, tNormalDepth: { value: null }, screenSize: { value: new n.FM8(512, 512) }, saoData: { value: new n.Ltg() }, frameCount: { value: 0 }, cameraNearFar: { value: new n.FM8(0.1, 1e3) }, projection: { value: new n.yGw() }, saoBiasEpsilon: { value: new n.Pa4(1, 1, 1) } }, vertexShader: Io, fragmentShader: `

${Po}

${r2}

#include <common>
#include <packing>
varying vec2 vUv;uniform vec2 cameraNearFar;uniform mat4 projection;uniform sampler2D tLastThis;uniform vec4 saoData;uniform vec3 saoBiasEpsilon;uniform vec2 screenSize;const float INV_NUM_SAMPLES=1./float(NUM_SAMPLES);float getViewZFromNDCZ(const in float depth){
#if PERSPECTIVE_CAMERA == 1
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}vec3 packFloatToRGB(const in float x){const vec3 code=vec3(1.,255.,65025.);vec3 pack=vec3(code*x);pack.gb=fract(pack.gb);pack.rg-=pack.gb*(1./256.);return pack;}vec3 getViewPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return vec3(xe,ye,viewDepth);}float decodeDepth(const in vec2 uv){vec4 uncodedDepth;
#if DEPTH_PACKING_MODE == 2
uncodedDepth=texture2D(tNormalDepth,uv);
#else
uncodedDepth=texture2D(tDepth,uv);
#endif
#if DEPTH_PACKING_MODE == 0
return uncodedDepth.x;
#elif DEPTH_PACKING_MODE == 1
#if LINEAR_DEPTH == 1
return pow2(unpackRGBAToDepth(uncodedDepth));
#else
return unpackRGBAToDepth(uncodedDepth);
#endif
#else
return pow2(unpack16(uncodedDepth.xy));
#endif
}vec3 getPositionFromOffset(const in vec2 uv,const in vec2 offset,const in float screenSpaceRadius){vec2 uvOffset=uv+floor(screenSpaceRadius*offset)/screenSize;float d=decodeDepth(uvOffset);
#if LINEAR_DEPTH == 0
float centerViewZ=getViewZFromNDCZ(d);return getViewPositionFromViewZ(uvOffset,centerViewZ);
#else
d=mix(-cameraNearFar.x,-cameraNearFar.y,d);return getViewPositionFromViewZ(uvOffset,d);
#endif
}float getOcclusion(const in vec2 uv,const in int id,const in float randomAngle,const in float occlusionSphereRadius,const in vec3 centerPosition,const in vec3 centerNormal){float screenSpaceRadius=(float(id)+mod(randomAngle,1.)+0.5)*INV_NUM_SAMPLES;float angle=screenSpaceRadius*(float(NUM_SPIRAL_TURNS)*6.28)+randomAngle;screenSpaceRadius=(screenSpaceRadius*occlusionSphereRadius);vec2 offset=vec2(cos(angle),sin(angle));vec3 samplePosition=getPositionFromOffset(uv,offset,screenSpaceRadius);vec3 direction=samplePosition-centerPosition;float d2=dot(direction,direction);float ao=max((dot(centerNormal,direction)+centerPosition.z*saoBiasEpsilon.x)/(saoBiasEpsilon.z*d2+saoBiasEpsilon.y),0.);return ao;}void main(){float centerDepth;vec3 centerNormal;getDepthNormal(vUv,centerDepth,centerNormal);
#if LINEAR_DEPTH == 0
float centerViewZ=getViewZFromNDCZ(centerDepth);
#else
float centerViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,centerDepth);
#endif
vec3 centerPosition=getViewPositionFromViewZ(vUv,centerViewZ);float occlusionSphereScreenRadius=200.*saoData.z/(-centerPosition.z);float randomAngle=6.2*random3(vec3(vUv,frameCount*0.1));float sum=0.;sum+=getOcclusion(vUv,0,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#if NUM_SAMPLES > 1
sum+=getOcclusion(vUv,1,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 2
sum+=getOcclusion(vUv,2,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 3
sum+=getOcclusion(vUv,3,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 4
sum+=getOcclusion(vUv,4,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 5
sum+=getOcclusion(vUv,5,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 6
sum+=getOcclusion(vUv,6,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 7
sum+=getOcclusion(vUv,7,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 8
sum+=getOcclusion(vUv,8,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 9
sum+=getOcclusion(vUv,9,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 10
sum+=getOcclusion(vUv,10,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
float aoValue=sum*saoData.y*INV_NUM_SAMPLES;aoValue=clamp(1.-max(aoValue,0.),0.,1.);gl_FragColor.gba=packFloatToRGB(centerDepth);gl_FragColor.r=(vec4(aoValue)).r;}

            ` }, "tDiffuse"), this.parameters = { intensity: 0.25, occlusionWorldRadius: 1, bias: 1e-3, falloff: 1, edgeSharpness: 0.3, blurEnabled: true }, this._smoothEnabled = true, this.materialExtension = { shaderExtender: (e3, t3, r3) => {
        e3.defines.SSAO_ENABLED && (e3.fragmentShader = e3.fragmentShader.replace("#include <aomap_fragment>", "#ifndef USE_TRANSMISSION\n#if defined(SSAO_ENABLED) && SSAO_ENABLED > 0\nfloat ambientOcclusion=tSSAOMapTexelToLinear(texture2D(tSSAOMap,viewToScreen(vViewPosition.xyz).xy)).r;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined( USE_ENVMAP )\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);\n#endif\n#endif\n#endif\n"));
      }, onObjectRender: (e3, t3, r3) => {
        var n2, i2;
        this.materialExtension.extraUniforms.tSSAOMap.value = null === (n2 = this._target) || void 0 === n2 ? void 0 : n2.texture;
        const s2 = t3.materialObject, o2 = !s2.transparent && s2.transmission < 1e-3;
        let a2 = this.enabled && o2 && false !== r3.userData.screenSpaceRendering && !(null === (i2 = t3.materialObject.userData) || void 0 === i2 ? void 0 : i2.ssaoDisabled) ? 1 : 0;
        s2.defines.SSAO_ENABLED !== a2 && (s2.defines.SSAO_ENABLED = a2, s2.needsUpdate = true), a2 = this._target.texture, this.materialExtension.extraUniforms.tSSAOMap.value !== a2 && (this.materialExtension.extraUniforms.tSSAOMap.value = a2, s2.needsUpdate = true);
      }, parsFragmentSnippet: (e3) => {
        var t3;
        return w`
             uniform sampler2D tSSAOMap;
             ${U("tSSAOMap", null === (t3 = this._target) || void 0 === t3 ? void 0 : t3.texture, e3.capabilities.isWebGL2)}
            ${Oo}
        `;
      }, extraUniforms: { tSSAOMap: { value: null } }, computeCacheKey: (e3) => {
        var t3, r3;
        return this.enabled ? "1" : "0" + (null === (r3 = null === (t3 = this._target) || void 0 === t3 ? void 0 : t3.texture) || void 0 === r3 ? void 0 : r3.encoding);
      }, isCompatible: (e3) => {
        var t3;
        return !(null === (t3 = e3.materialObject.userData) || void 0 === t3 ? void 0 : t3.ssaoDisabled) && e3.isMeshStandardMaterial2;
      } }, this._renderer = e2, this._target = t2, this.needsSwap = false, this.clear = true, this.bilateralPass = new zo(this._target, r2, "rrrr");
    }
    get smoothEnabled() {
      return this._smoothEnabled;
    }
    set smoothEnabled(e2) {
      this._smoothEnabled = e2, this.bilateralPass.enabled = e2, this.bilateralPass.uniforms.smoothEnabled.value = e2;
    }
    render(e2, t2, r2, n2, i2) {
      this.enabled && (this._updateParameters(), this._renderer.blit(this._target.texture, t2, {}), this.uniforms.tLastThis.value = t2.texture, super.render(e2, this._target, r2, n2, i2), this._smoothEnabled && this.bilateralPass.render(e2, t2, r2, n2, i2));
    }
    _updateParameters() {
      const e2 = this.material.uniforms.saoData.value;
      e2.y = this.parameters.intensity, e2.z = this.parameters.occlusionWorldRadius;
      const t2 = this.material.uniforms.saoBiasEpsilon.value;
      t2.x = this.parameters.bias, t2.y = 1e-3, t2.z = this.parameters.falloff;
    }
  }
  Go([Ce()], Vo.prototype, "bilateralPass", void 0), Go([Ce()], Vo.prototype, "parameters", void 0);
  class Qo extends So {
    constructor() {
      super(), this.dependencies = [to, lo], this.setDirty = this.setDirty.bind(this);
    }
    get aoTarget() {
      return this._aoTarget;
    }
    async onAdded(e2) {
      return e2.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSAOPlugin"), super.onAdded(e2);
    }
    createPasses(e2) {
      var t2, r2;
      return this._aoTarget = e2.renderer.createTarget({ sizeMultiplier: 1 }), [no(e2, { passId: "ssao", after: ["gbuffer"], before: ["render"], required: ["render", "gbuffer"], passObject: new Vo(e2.renderer, this._aoTarget, null !== (r2 = null === (t2 = e2.getPlugin(lo)) || void 0 === t2 ? void 0 : t2.getUnpackSnippet()) && void 0 !== r2 ? r2 : ""), update() {
        this.passObject.bilateralPass.updateShaderProperties([e2.getPlugin(lo)]);
      } }, () => [e2.getPlugin(lo), e2.scene.activeCamera, e2.renderer])];
    }
    async onRemove(e2) {
      return e2.renderer.disposeTarget(this._aoTarget), super.onRemove(e2);
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    get enabled() {
      var e2, t2;
      return (null === (t2 = null === (e2 = this.passes.ssao) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.enabled) || false;
    }
    set enabled(e2) {
      var t2;
      (null === (t2 = this.passes.ssao) || void 0 === t2 ? void 0 : t2.passObject) && (this.passes.ssao.passObject.enabled = e2);
    }
    get uiConfig() {
      var e2;
      if (this._uiConfig)
        return this._uiConfig;
      const t2 = this, r2 = t2.passes.ssao.passObject;
      return this._uiConfig = { type: "folder", label: "SS Ambient Occlusion", children: [{ type: "checkbox", label: "Enabled", property: [r2, "enabled"], onChange: t2.setDirty }, { type: "slider", label: "Intensity", bounds: [0, 4], property: [r2.parameters, "intensity"], onChange: t2.setDirty }, { type: "slider", label: "Radius", bounds: [0.1, 8], property: [r2.parameters, "occlusionWorldRadius"], onChange: t2.setDirty }, { type: "slider", label: "Bias", bounds: [1e-5, 0.01], property: [r2.parameters, "bias"], onChange: t2.setDirty }, { type: "slider", label: "Falloff", bounds: [0.01, 3], property: [r2.parameters, "falloff"], onChange: t2.setDirty }, { type: "slider", label: "Num samples", stepSize: 1, bounds: [1, 11], property: [null === (e2 = r2.material) || void 0 === e2 ? void 0 : e2.defines, "NUM_SAMPLES"], onChange: [() => r2.material.needsUpdate = true, t2.setDirty] }, { type: "checkbox", property: [r2.bilateralPass, "smoothEnabled"], onChange: t2.setDirty }, { type: "vec4", property: [r2.bilateralPass, "edgeSharpness"], onChange: t2.setDirty }] };
    }
  }
  Qo.PluginType = "SSAO";
  class Ho {
    constructor(e2) {
      this._normalsCache = {}, this._renderer = e2, this._scene = new n.xsS(), this._mesh = new n.Kj0(), this._mesh.frustumCulled = false, this._scene.add(this._mesh), this._mesh.position.set(0, 0, 0), this._mesh.material = new Wo();
    }
    dispose() {
      this._mesh.material.dispose();
    }
    captureNormalMap(e2, t2, r2 = 512) {
      if (!e2)
        throw "No geometry";
      if (e2.userData._normalsCaptureMap)
        return false;
      const i2 = null == t2 ? void 0 : t2.split(";").find((e3) => this._normalsCache[e3]);
      if (i2) {
        const n2 = this._normalsCache[i2];
        return null == t2 || t2.split(";").forEach((e3) => e3 !== i2 && (this._normalsCache[e3] = n2)), n2.width !== r2 && console.warn("last cacheKey normalMapRes mismatch, check model", r2), e2.userData._normalsCaptureMap = n2, false;
      }
      const s2 = this._renderer.createTargetCustom({ width: r2, height: r2 }, { minFilter: n.TyD, magFilter: n.TyD, generateMipmaps: false, type: n.cLu }, n.oAp);
      if (!s2)
        throw "Unable to create render target";
      null == t2 || t2.split(";").forEach((e3) => this._normalsCache[e3] = s2), s2.addEventListener("dispose", () => delete this._normalsCache[t2]);
      const o2 = new n._am(1e-4, 100, s2);
      this._scene.add(o2);
      const a2 = e2.userData._normalsCaptureOffsets;
      return void 0 !== a2.center && this._mesh.material.uniforms.offsetCenter.value.copy(a2.center), void 0 !== a2.offsetMatrixInv && this._mesh.material.uniforms.offsetMatrixInv.value.copy(a2.offsetMatrixInv), void 0 !== a2.radius && (this._mesh.material.uniforms.radius.value = a2.radius), this._mesh.geometry = e2, o2.update(this._renderer.rendererObject, this._scene), this._scene.remove(o2), this._mesh.geometry = void 0, e2.userData._normalsCaptureMap = s2, true;
    }
  }
  class Wo extends n.jyz {
    constructor() {
      super({ vertexShader: "varying vec3 vNormal;varying vec3 vecPosition;uniform mat4 offsetMatrixInv;uniform vec3 offsetCenter;void main(){vNormal=normalize((offsetMatrixInv*vec4(normal,0.)).xyz);vecPosition=(modelMatrix*offsetMatrixInv*vec4(position-offsetCenter,1.)).xyz;gl_Position=projectionMatrix*modelViewMatrix*offsetMatrixInv*vec4(position-offsetCenter,1.);}", fragmentShader: "varying vec3 vNormal;varying vec3 vecPosition;uniform float radius;void main(){vec3 color=normalize(vNormal);color=color*0.5+0.5;gl_FragColor=vec4(color.x,color.y,color.z,length(vecPosition)/radius);}", side: n.ehD, clipping: false, uniforms: { radius: { value: 1 }, offsetMatrixInv: { value: new n.yGw().identity() }, offsetCenter: { value: new n.Pa4() } } });
    }
  }
  var qo = __webpackgi_require__2(654);
  function Xo(e2) {
    const t2 = new n.Pa4(0, 0, 0), r2 = new n.Pa4(0, 0, 0), i2 = new n.Pa4(0, 0, 0), s2 = new n.Pa4(0, 0, 0), o2 = e2.getAttribute("position"), a2 = e2.index;
    if (a2)
      for (let n2 = Math.max(0, e2.drawRange.start), l3 = Math.min(a2.count, e2.drawRange.start + e2.drawRange.count) - 1; n2 < l3 / 3; n2 += 3) {
        const e3 = a2.getX(n2), l4 = a2.getX(n2 + 1), c3 = a2.getX(n2 + 2);
        r2.set(o2.getX(e3), o2.getY(e3), o2.getZ(e3)), i2.set(o2.getX(l4), o2.getY(l4), o2.getZ(l4)), s2.set(o2.getX(c3), o2.getY(c3), o2.getZ(c3)), i2.sub(r2), s2.sub(r2), s2.cross(i2), s2.normalize(), t2.add(s2);
      }
    else
      for (let e3 = 0; e3 < o2.count; e3 += 3)
        r2.set(o2.getX(e3), o2.getY(e3), o2.getZ(e3)), i2.set(o2.getX(e3 + 1), o2.getY(e3 + 1), o2.getZ(e3 + 1)), s2.set(o2.getX(e3 + 2), o2.getY(e3 + 2), o2.getZ(e3 + 2)), i2.sub(r2), s2.sub(r2), s2.cross(i2), s2.normalize(), t2.add(s2);
    t2.normalize();
    let l2 = false, c2 = 0;
    for (; !l2; ) {
      const e3 = c2 / 3, n2 = a2 ? a2.getX(e3) : e3, s3 = a2 ? a2.getX(e3 + 1) : e3 + 1;
      r2.set(o2.getX(n2), o2.getY(n2), o2.getZ(n2)), i2.set(o2.getX(s3), o2.getY(s3), o2.getZ(s3)), r2.sub(i2), r2.normalize();
      const u3 = t2.dot(r2);
      Math.abs(u3 - 1) > 1e-3 && r2.length() > 0.5 && (l2 = true), c2 += 3;
    }
    i2.crossVectors(r2, t2), i2.normalize(), r2.crossVectors(t2, i2), r2.normalize();
    const u2 = new n.yGw();
    u2.elements[0] = r2.x, u2.elements[1] = r2.y, u2.elements[2] = r2.z, u2.elements[3] = 0, u2.elements[4] = t2.x, u2.elements[5] = t2.y, u2.elements[6] = t2.z, u2.elements[7] = 0, u2.elements[8] = i2.x, u2.elements[9] = i2.y, u2.elements[10] = i2.z, u2.elements[11] = 0, u2.elements[12] = 0, u2.elements[13] = 0, u2.elements[14] = 0, u2.elements[15] = 1, e2.computeBoundingSphere();
    const h2 = e2.boundingSphere.radius, p2 = new n.yGw().makeScale(h2, h2, h2);
    return u2.multiply(p2), u2;
  }
  function Yo(e2) {
    const t2 = e2.getAttribute("position");
    if (t2.count > 0)
      return Xo(e2);
    const r2 = new n.Pa4(0, 0, 0), i2 = new n.Pa4(0, 0, 0), s2 = new n.Pa4(0, 0, 0), o2 = e2.index, a2 = [];
    if (o2)
      for (let n2 = Math.max(0, e2.drawRange.start), l3 = Math.min(o2.count, e2.drawRange.start + e2.drawRange.count) - 1; n2 < l3 / 3; n2 += 3) {
        const e3 = o2.getX(n2), l4 = o2.getX(n2 + 1), c3 = o2.getX(n2 + 2);
        r2.set(t2.getX(e3), t2.getY(e3), t2.getZ(e3)), i2.set(t2.getX(l4), t2.getY(l4), t2.getZ(l4)), s2.set(t2.getX(c3), t2.getY(c3), t2.getZ(c3)), a2.push(r2.toArray(), i2.toArray(), s2.toArray());
      }
    else
      for (let e3 = 0; e3 < t2.count; e3++)
        r2.set(t2.getX(e3), t2.getY(e3), t2.getZ(e3)), a2.push(r2.toArray());
    const l2 = (0, qo.getEigenVectors)(a2), c2 = new n.yGw();
    c2.elements[0] = l2[0].vector[0], c2.elements[1] = l2[0].vector[1], c2.elements[2] = l2[0].vector[2], c2.elements[3] = 0, c2.elements[4] = l2[1].vector[0], c2.elements[5] = l2[1].vector[1], c2.elements[6] = l2[1].vector[2], c2.elements[7] = 0, c2.elements[8] = l2[2].vector[0], c2.elements[9] = l2[2].vector[1], c2.elements[10] = l2[2].vector[2], c2.elements[11] = 0, c2.elements[12] = 0, c2.elements[13] = 0, c2.elements[14] = 0, c2.elements[15] = 1, console.log(c2.determinant()), e2.computeBoundingSphere();
    const u2 = e2.boundingSphere.radius, h2 = new n.yGw().makeScale(u2, u2, u2);
    return c2.multiply(h2), c2;
  }
  const Ko = { ...Wt, color: new Ae(1, 1, 1), envMapIntensity: 1, envMapRotation: 0, dispersion: 0.012, squashFactor: 0.98, geometryFactor: 0.5, gammaFactor: 1, absorptionFactor: 1, reflectivity: 0.5, refractiveIndex: 2.4, boostFactors: new n.Pa4(0.892, 0.892, 0.98595025), envMap: null, wireframe: false, wireframeLinewidth: 0, skinning: false, transmission: 0, morphTargets: false, morphNormals: false, rayBounces: 1, diamondOrientedEnvMap: 0 };
  var Jo = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class Zo extends n.jyz {
    constructor(e2) {
      super({ side: n.ehD, defines: { DIA_ORIENT_ENVMAP: 0, RAY_BOUNCES: 5, ENV_MAP_TYPE: 0, PI: 3.1428 }, vertexShader: "#ifndef USE_ENVMAP\n#define USE_ENVMAP  \n#endif\nvarying vec3 vWorldPosition;varying vec3 vWorldNormal;void main(){vWorldNormal=(modelMatrix*vec4(normal,0.)).xyz;\n#include <begin_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\nvWorldPosition=worldPosition.xyz;}", fragmentShader: "varying vec3 vWorldNormal;varying vec3 vWorldPosition;uniform samplerCube tCubeMapNormals;\n#if ENV_MAP_TYPE == 0\nuniform samplerCube envMap;\n#elif ENV_MAP_TYPE == 1\nuniform sampler2D envMap;\n#endif\nuniform float envMapIntensity;uniform mat4 modelMatrix;uniform mat4 inverseModelMatrix;uniform mat4 offsetMatrixInv;uniform mat4 offsetMatrix;uniform float transmission;uniform vec2 transmissionSamplerSize;uniform sampler2D transmissionSamplerMap;uniform float refractiveIndex;uniform float radius;uniform float rIndexDelta;uniform float squashFactor;uniform float geometryFactor;uniform vec3 color;uniform vec3 colorCorrection;uniform vec3 boostFactors;uniform vec3 centerOffset;uniform float gammaFactor;uniform float absorptionFactor;uniform float envMapRotation;uniform float reflectivity;vec3 BRDF_Specular_GGX_Environment(const in vec3 viewDir,const in vec3 normal,const in vec3 specularColor,const in float roughness){float dotNV=abs(dot(normal,viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec2 cartesianToPolar(vec3 n){vec2 uv;uv.x=atan(n.z,n.x)/(PI*2.)+0.5;uv.y=asin(n.y)/PI+0.5;return uv;}vec4 sampleEnvMap(vec3 direction){\n#if !defined(USE_ENVMAP)\nreturn vec4(direction,1);\n#else\nfloat cs=cos(envMapRotation);float sn=sin(envMapRotation);float temp=cs*direction.x+sn*direction.z;direction.z=-sn*direction.x+cs*direction.z;direction.x=temp;direction.x*=-1.;direction.z*=-1.;\n#if ENV_MAP_TYPE == 0\nreturn(textureCube(envMap,direction));\n#elif ENV_MAP_TYPE == 1\nreturn(texture2D(envMap,cartesianToPolar(direction)));\n#endif\nreturn vec4(1,0,1,1);\n#endif\n}vec4 SampleSpecularReflection(vec3 direction){return envMapIntensity*(sampleEnvMap(direction));}uniform mat4 projectionMatrix;vec4 SampleSpecularContribution(vec3 direction){direction=normalize(direction);direction.x*=-1.;direction.z*=-1.;return envMapIntensity*(sampleEnvMap(direction));}vec4 SampleSpecularContributionRef(vec3 origin,int i){vec4 ndcPos=projectionMatrix*viewMatrix*vec4(origin,1.);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.;refractionCoords/=2.;return transmissionSamplerMapTexelToLinear(texture2D(transmissionSamplerMap,refractionCoords));}vec3 intersectSphere(vec3 origin,vec3 direction){origin-=centerOffset;direction.y/=squashFactor;float A=dot(direction,direction);float B=2.*dot(origin,direction);float C=dot(origin,origin)-radius*radius;float disc=B*B-4.*A*C;if(disc>0.){disc=sqrt(disc);float t1=(-B+disc)*geometryFactor/A;float t2=(-B-disc)*geometryFactor/A;float t=(t1>t2)?t1:t2;direction.y*=squashFactor;return vec3(origin+centerOffset+direction*t);}return vec3(0.);}vec3 linePlaneIntersect(in vec3 pointOnLine,in vec3 lineDirection,in vec3 pointOnPlane,in vec3 planeNormal){return lineDirection*(dot(planeNormal,pointOnPlane-pointOnLine)/dot(planeNormal,lineDirection))+pointOnLine;}vec4 getNormalDistance(vec3 d){return textureCube(tCubeMapNormals,d);}vec3 getSurfaceNormal(vec4 surfaceInfos){vec3 surfaceNormal=surfaceInfos.rgb;surfaceNormal=surfaceNormal*2.-1.;return-normalize(surfaceNormal);}vec3 intersect(vec3 rayOrigin,vec3 rayDirection){vec3 sphereHitPoint=intersectSphere(rayOrigin,rayDirection);vec3 direction1=normalize(sphereHitPoint-centerOffset);vec4 normalDistanceData1=getNormalDistance(direction1);float distance1=normalDistanceData1.a*radius;vec3 pointOnPlane1=centerOffset+direction1*distance1;vec3 planeNormal1=getSurfaceNormal(normalDistanceData1);vec3 hitPoint1=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane1,planeNormal1);vec3 direction2=normalize(hitPoint1-centerOffset);vec4 normalDistanceData2=getNormalDistance(direction2);float distance2=normalDistanceData2.a*radius;vec3 pointOnPlane2=centerOffset+direction2*distance2;vec3 hitPoint=hitPoint1;vec3 planeNormal2=getSurfaceNormal(normalDistanceData2);hitPoint=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane2,planeNormal2);return hitPoint;}vec3 debugBounces(int count){vec3 color=vec3(1.,1.,1.);if(count==1)color=vec3(0.,1.,0.);else if(count==2)color=vec3(0.,0.,1.);else if(count==3)color=vec3(1.,1.,0.);else if(count==4)color=vec3(0.,1.,1.);else color=vec3(0.,1.,0.);if(count==0)color=vec3(1.,0.,0.);return color;}vec3 traceRay(vec3 origin,vec3 direction,vec3 normal){vec3 outColor=vec3(0.);const float n1=1.;const float epsilon=1e-4;float f0=(2.4-n1)/(2.4+n1);f0*=f0;vec3 attenuationFactor=vec3(1.);vec3 newDirection=refract(direction,normal,n1/refractiveIndex);vec3 reflectedDirection=reflect(direction,normal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(reflectedDirection,normal,vec3(f0),0.);vec3 brdfRefracted=BRDF_Specular_GGX_Environment(newDirection,-normal,vec3(f0),0.);attenuationFactor*=(vec3(1.)-brdfRefracted);outColor+=SampleSpecularReflection(reflectedDirection).rgb*brdfReflected*reflectivity*2.;int count=0;newDirection=(offsetMatrixInv*inverseModelMatrix*vec4(newDirection,0.)).xyz;newDirection=normalize(newDirection);origin=(offsetMatrixInv*inverseModelMatrix*vec4(origin,1.)).xyz;vec3 origin2=origin;origin2=(modelMatrix*offsetMatrix*vec4(origin2,1.)).xyz;for(int i=0;i<RAY_BOUNCES;i++){vec3 intersectedPos=intersect(origin,newDirection);vec3 dist=intersectedPos-origin;vec3 d=normalize(intersectedPos-centerOffset);vec3 mappedNormal=getNormalDistance(d).rgb;mappedNormal=2.*mappedNormal-1.;mappedNormal=-normalize(mappedNormal);float r=length(dist)/radius*absorptionFactor;attenuationFactor*=exp(-r*(1.-color));origin=intersectedPos;origin2=(modelMatrix*offsetMatrix*vec4(intersectedPos,1.)).xyz;vec3 oldDir=newDirection;newDirection=refract(newDirection,mappedNormal,refractiveIndex/n1);if(dot(newDirection,newDirection)<epsilon){newDirection=reflect(oldDir,mappedNormal);if(i==RAY_BOUNCES-1){vec3 brdfReflected=BRDF_Specular_GGX_Environment(-oldDir,mappedNormal,vec3(f0),0.);vec3 d1=(modelMatrix*offsetMatrix*vec4(oldDir,0.)).xyz;d1=normalize(d1);float cosT=1.-dot(direction,d1);outColor+=((transmission>0.&&cosT<transmission)?SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb:SampleSpecularContribution(DIA_ORIENT_ENVMAP<1?d1:newDirection).rgb)*attenuationFactor*colorCorrection*boostFactors*(vec3(1.)-brdfReflected);}}else{vec3 brdfRefracted=vec3(1.)-BRDF_Specular_GGX_Environment(newDirection,-mappedNormal,vec3(f0),0.);vec3 d1=(modelMatrix*offsetMatrix*vec4(newDirection,0.)).xyz;d1=normalize(d1);float cosT=1.-dot(direction,d1);if(transmission>0.&&cosT<transmission){outColor+=SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}else{vec3 dir0=newDirection;vec3 dir1=refract(oldDir,mappedNormal,(refractiveIndex+rIndexDelta)/n1);vec3 dir2=refract(oldDir,mappedNormal,(refractiveIndex-rIndexDelta)/n1);\n#if DIA_ORIENT_ENVMAP < 1\ndir0=d1;dir1=(modelMatrix*offsetMatrix*vec4(dir1,0.)).xyz;dir2=(modelMatrix*offsetMatrix*vec4(dir2,0.)).xyz;\n#endif\noutColor+=vec3(SampleSpecularContribution(dir1).r,SampleSpecularContribution(dir0).g,SampleSpecularContribution(dir2).b)*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}newDirection=reflect(oldDir,mappedNormal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(newDirection,mappedNormal,vec3(f0),0.);attenuationFactor*=brdfReflected*boostFactors;count++;}}return outColor;}void main(){vec3 normalizedNormal=normalize(vWorldNormal);vec3 viewVector=normalize(vWorldPosition-cameraPosition);vec3 color=traceRay(vWorldPosition,viewVector,normalizedNormal);gl_FragColor=vec4(color.rgb,1.);\n#include <encodings_fragment>\n}", uniforms: { envMap: { value: e2.envMap || null }, envMapRotation: { value: 0 }, transmission: { value: 0 }, transmissionSamplerMap: { value: null }, transmissionSamplerSize: { value: new n.FM8() }, normalOffset: { value: 0 }, distanceOffset: { value: 0 }, colorCorrection: { value: new n.Pa4(1, 1, 1) } } }), this.typeSlug = Zo.TypeSlug, this.assetType = "material", this.__envMap = null, this.isDiamondMaterial = true, this.color = new Ae(1, 1, 1), this.envMapIntensity = 1, this.dispersion = 0.012, this.absorptionFactor = 1, this.refractiveIndex = 2.4, this.squashFactor = 0.98, this.geometryFactor = 0.5, this.gammaFactor = 1, this.boostFactors = new n.Pa4(0.892, 0.892, 0.98595025), this.transmission = 0, this.reflectivity = 0.5, this.rayBounces = 5, this.diamondOrientedEnvMap = 0, this.normalsCaptureMap = null, this.extraUniformsToUpload = { inverseModelMatrix: { value: new n.yGw().identity() }, radius: { value: 1 }, centerOffset: { value: new n.Pa4(0, 0, 0) }, offsetMatrix: { value: new n.yGw().identity() }, offsetMatrixInv: { value: new n.yGw().identity() } }, this.setDirty = this.setDirty.bind(this), this.userData.setDirty = (e3) => {
        console.warn("userData.setDirty is deprecated. Use setDirty instead."), this.setDirty(e3);
      }, this.userData.separateEnvMapIntensity = true, this.userData.enableLUT = true, this.setValues(e2);
    }
    get mmMaterial() {
      return this;
    }
    get materialObject() {
      return this;
    }
    onBeforeRender(e2, t2, r2, n2, i2) {
      var s2, o2;
      super.onBeforeRender(e2, t2, r2, n2, i2), this.uniforms.envMapRotation.value = (null === (s2 = this.envMap) || void 0 === s2 ? void 0 : s2.rotation) || 0, this.extraUniformsToUpload.inverseModelMatrix.value.copy(i2.matrixWorld).invert();
      const a2 = n2.userData._normalsCaptureOffsets;
      a2 && (this.extraUniformsToUpload.centerOffset.value.copy(a2.centerOffset), this.extraUniformsToUpload.offsetMatrix.value.copy(a2.offsetMatrix), this.extraUniformsToUpload.offsetMatrixInv.value.copy(a2.offsetMatrixInv), this.extraUniformsToUpload.radius.value = a2.radius);
      const l2 = null === (o2 = n2.userData._normalsCaptureMap) || void 0 === o2 ? void 0 : o2.texture;
      this.normalsCaptureMap !== l2 && (this.normalsCaptureMap = l2);
    }
    setDirty(e2) {
      var t2, r2;
      this.needsUpdate = true, this.dispatchEvent({ ...e2, type: "materialUpdate" }), null === (r2 = null === (t2 = this._uiConfig) || void 0 === t2 ? void 0 : t2.uiRefresh) || void 0 === r2 || r2.call(t2, "postFrame", true, 1);
    }
    set envMap(e2) {
      var t2;
      this.__envMap = e2, this.uniforms.envMap.value = this.__envMap, (null === (t2 = this.__envMap) || void 0 === t2 ? void 0 : t2.isCubeTexture) ? (this.defines.ENV_MAP_TYPE = 0, this.needsUpdate = true) : (this.defines.ENV_MAP_TYPE = 1, this.needsUpdate = true);
    }
    get envMap() {
      return this.__envMap;
    }
    clone() {
      return super.clone();
    }
    toJSON(e2) {
      const t2 = {};
      return t2.name = this.name, t2.uuid = this.uuid, t2.color = this.color.getHex(), t2.envMapIntensity = this.envMapIntensity, t2.dispersion = this.dispersion, t2.squashFactor = this.squashFactor, t2.geometryFactor = this.geometryFactor, t2.gammaFactor = this.gammaFactor, t2.absorptionFactor = this.absorptionFactor, t2.reflectivity = this.reflectivity, t2.refractiveIndex = this.refractiveIndex, t2.rayBounces = this.rayBounces, t2.diamondOrientedEnvMap = this.diamondOrientedEnvMap, t2.boostFactors = { x: this.boostFactors.x, y: this.boostFactors.y, z: this.boostFactors.z, isVector3: true }, t2.transmission = this.transmission, t2.isDiamondMaterialParameters = true, t2.type = Zo.TYPE, t2.userData = {}, xe(t2.userData, this.userData), t2.userData.uuid = this.userData.uuid, t2;
    }
    get uiConfig() {
      const e2 = this;
      return this._uiConfigChildren || (this._uiConfigChildren = [{ type: "input", property: [this, "name"] }, { type: "checkbox", property: [this, "wireframe"] }, ...ot(this), { type: "input", label: "Mesh count", get value() {
        var t2, r2, n2;
        return null !== (n2 = null === (r2 = null === (t2 = e2.userData) || void 0 === t2 ? void 0 : t2.__appliedMeshes) || void 0 === r2 ? void 0 : r2.size) && void 0 !== n2 ? n2 : 0;
      }, set value(e3) {
      }, disabled: true }, { type: "checkbox", label: "Enable LUT", getValue: () => true === this.userData.enableLUT, setValue: (e3) => {
        this.userData.enableLUT = e3 || void 0, this.setDirty();
      } }, { type: "input", label: "uuid", get value() {
        return e2.uuid;
      }, set value(e3) {
      }, disabled: true }, { type: "checkbox", label: "Render to Depth", hidden: () => 0 === this.transmission, get value() {
        return true === e2.userData.renderToDepth;
      }, set value(t2) {
        e2.userData.renderToDepth = t2 || void 0;
      } }, { type: "button", label: "Download .dmat", value: () => {
        yt(new Blob([JSON.stringify(e2.toJSON(), null, 2)], { type: "application/json" }), "diamond-material.dmat");
      } }]), this._uiConfig || (this._uiConfig = { type: "folder", label: "Diamond Material", expanded: true, children: this._uiConfigChildren, limitedUi: true }), this._uiConfig;
    }
    copyProps(e2) {
      if (!e2.isDiamondMaterialParameters && !e2.isDiamondMaterial && !e2.isDiamond && e2.type !== Zo.TYPE)
        return console.warn("Material type is not supported", e2), this;
      const t2 = {};
      b(e2, t2, Array.from(Object.keys(Ko)));
      const r2 = t2.userData;
      return delete t2.userData, this.setValues(t2), xe(this.userData, r2), this.setDirty(), this;
    }
    fromJSON(e2, t2) {
      return this.copyProps(e2);
    }
  }
  Zo.TypeSlug = "dmat", Zo.TYPE = "DiamondMaterial", Jo([it("Color", { limitedUi: true }), G()], Zo.prototype, "color", void 0), Jo([$e("Env Intensity", [0, 5], 0.01, { limitedUi: true }), G()], Zo.prototype, "envMapIntensity", void 0), Jo([$e("Dispersion", [0, 0.1], 1e-4, { limitedUi: true }), G({ propKey: "rIndexDelta" })], Zo.prototype, "dispersion", void 0), Jo([$e("Absorption", [0, 15], 0.01, { limitedUi: true }), G()], Zo.prototype, "absorptionFactor", void 0), Jo([$e("Refractive Index", [0, 4], 0.01, { limitedUi: true }), G()], Zo.prototype, "refractiveIndex", void 0), Jo([G()], Zo.prototype, "squashFactor", void 0), Jo([G()], Zo.prototype, "geometryFactor", void 0), Jo([G()], Zo.prototype, "gammaFactor", void 0), Jo([et("RGB Boost", void 0, void 0, { limitedUi: true }), G()], Zo.prototype, "boostFactors", void 0), Jo([$e("Transmission", [0, 1], 0.01, { limitedUi: true }), G()], Zo.prototype, "transmission", void 0), Jo([$e("Reflectivity", [0, 2], 0.01, { limitedUi: true }), G()], Zo.prototype, "reflectivity", void 0), Jo([V("RAY_BOUNCES", void 0, true), $e("Ray Bounces", [1, 16], 1)], Zo.prototype, "rayBounces", void 0), Jo([V("DIA_ORIENT_ENVMAP", void 0, true), $e("Diamond Oriented Lighting", [0, 1], 1)], Zo.prototype, "diamondOrientedEnvMap", void 0), Jo([G({ propKey: "tCubeMapNormals" })], Zo.prototype, "normalsCaptureMap", void 0);
  class $o extends r {
    constructor(e2, t2, r2, i2) {
      super(), this._scene = e2, this._camera = null != r2 ? r2 : this._scene.activeCamera, this.domElement = t2, this._time = this.time, this._mouseDownTime = 0, this._mouseUpTime = 1, this.selectionCondition = null != i2 ? i2 : (e3) => false !== e3.userData.userSelectable && false !== e3.userData.bboxVisible && null != e3.material && "ShadowMaterial" !== e3.material.type, this.raycaster = new n.iMs(), this.mouse = new n.FM8(), this._selected = [], this._hovering = [], this.cursorStyles = { default: "grab", down: "grabbing" }, this._activeCameraChange = this._activeCameraChange.bind(this), this._scene.addEventListener("activeCameraChange", this._activeCameraChange), this.domElement.style.touchAction = "none", this.domElement.style.cursor = this.cursorStyles.default, this.domElement.addEventListener("pointermove", (e3) => this.onPointerMove(e3)), this.domElement.addEventListener("pointerleave", (e3) => this.onPointerLeave(e3)), this.domElement.addEventListener("pointerout", (e3) => this.onPointerLeave(e3)), this.domElement.addEventListener("pointercancel", (e3) => this.onPointerCancel(e3)), this.domElement.addEventListener("pointerenter", (e3) => this.onPointerEnter(e3)), this.domElement.addEventListener("pointerdown", (e3) => this.onPointerDown(e3)), this.domElement.addEventListener("pointerup", (e3) => this.onPointerUp(e3));
    }
    get scene() {
      return this._scene;
    }
    set scene(e2) {
      var t2;
      null === (t2 = this._scene) || void 0 === t2 || t2.removeEventListener("activeCameraChange", this._activeCameraChange), this._scene = e2, this._scene.addEventListener("activeCameraChange", this._activeCameraChange);
    }
    _activeCameraChange() {
      this.camera = this._scene.activeCamera;
    }
    get camera() {
      return this._camera;
    }
    set camera(e2) {
      this._camera = e2;
    }
    get selectedObject() {
      return this._selected.length > 0 ? this._selected[0] : null;
    }
    set selectedObject(e2) {
      1 === this._selected.length && this._selected[0] === e2 || (this._selected = e2 ? Array.isArray(e2) ? [...e2] : [e2] : [], this.refreshOutlinePass(), this.dispatchEvent({ type: "selectedObjectChanged", object: this.selectedObject }));
    }
    get hoverObject() {
      return this._hovering.length > 0 ? this._hovering[0] : null;
    }
    set hoverObject(e2) {
      this._hovering = e2 ? Array.isArray(e2) ? [...e2] : [e2] : [], this.refreshOutlinePass(), this.dispatchEvent({ type: "hoverObjectChanged", object: this.hoverObject });
    }
    get time() {
      return this._time = Dt(), this._time;
    }
    get isMouseDown() {
      return this.mouseDownDeltaTime < 0;
    }
    get mouseDownDeltaTime() {
      return this._mouseUpTime - this._mouseDownTime;
    }
    onPointerMove(e2) {
      false !== e2.isPrimary && this.updateMouseFromEvent(e2);
    }
    onPointerLeave(e2) {
      false !== e2.isPrimary && (this.domElement.style.cursor = this.cursorStyles.default, this.hoverObject = null);
    }
    onPointerEnter(e2) {
    }
    onPointerCancel(e2) {
    }
    updateMouseFromEvent(e2) {
      const t2 = this.domElement.getBoundingClientRect();
      this.mouse.x = (e2.clientX - t2.x) / t2.width * 2 - 1, this.mouse.y = -(e2.clientY - t2.y) / t2.height * 2 + 1;
    }
    onPointerDown(e2) {
      false !== e2.isPrimary && (this.domElement.style.cursor = this.cursorStyles.down, this._mouseDownTime = this.time);
    }
    onPointerUp(e2) {
      false !== e2.isPrimary && (this.domElement.style.cursor = this.cursorStyles.default, this._mouseUpTime = this.time, this.mouseDownDeltaTime < 200 && this.onPointerClick(e2));
    }
    onPointerClick(e2) {
      if (false === e2.isPrimary)
        return;
      this.updateMouseFromEvent(e2);
      const t2 = this.checkIntersection();
      t2 && this.dispatchEvent({ type: "hitObject", time: this._mouseUpTime, intersects: t2 }), this.selectedObject = (null == t2 ? void 0 : t2.selectedObject) || null;
    }
    addPasses() {
    }
    checkIntersection() {
      var e2;
      const t2 = null === (e2 = this._camera) || void 0 === e2 ? void 0 : e2.cameraObject;
      if (!t2)
        return null;
      this.raycaster.setFromCamera(this.mouse, t2);
      const r2 = this.raycaster.intersectObject(this._scene.modelRoot.modelObject, true), n2 = this.selectedObject;
      if (n2) {
        const e3 = r2.length - 1 - [...r2].reverse().findIndex((e4) => {
          let t3 = e4.object;
          for (; t3; ) {
            if (e4.object === n2)
              return true;
            t3 = t3.parent;
          }
          return false;
        });
        e3 >= 0 && r2.splice(0, e3 + 1);
      }
      if (r2.length > 0) {
        for (const e3 of r2) {
          let t3 = e3.object;
          for (; !(null == t3 || t3.visible && this.selectionCondition(t3)); )
            t3 = t3.parent;
          if (t3)
            return { selectedObject: t3, intersect: e3, intersects: r2, mouse: this.mouse.toArray() };
        }
        return null;
      }
      return null;
    }
    refreshOutlinePass() {
      var e2;
      null !== (e2 = this.hoverObject) && void 0 !== e2 || this.selectedObject;
    }
    isHovering() {
      return null != this.hoverObject;
    }
    isSelected() {
      return null != this.selectedObject;
    }
  }
  const ea = new n.iMs(), ta = new n.Pa4(), ra = new n.Pa4(), na = new n._fP(), ia = { X: new n.Pa4(1, 0, 0), Y: new n.Pa4(0, 1, 0), Z: new n.Pa4(0, 0, 1) }, sa = { type: "change" }, oa = { type: "mouseDown" }, aa = { type: "mouseUp", mode: null }, la = { type: "objectChange" };
  class ca extends n.Tme {
    constructor(e2, t2) {
      super(), void 0 === t2 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t2 = document), this.isTransformControls = true, this.visible = false, this.domElement = t2, this.domElement.style.touchAction = "none";
      const r2 = new ka();
      this._gizmo = r2, this.add(r2);
      const i2 = new Da();
      this._plane = i2, this.add(i2);
      const s2 = this;
      function o2(e3, t3) {
        let n2 = t3;
        Object.defineProperty(s2, e3, { get: function() {
          return void 0 !== n2 ? n2 : t3;
        }, set: function(t4) {
          n2 !== t4 && (n2 = t4, i2[e3] = t4, r2[e3] = t4, s2.dispatchEvent({ type: e3 + "-changed", value: t4 }), s2.dispatchEvent(sa));
        } }), s2[e3] = t3, i2[e3] = t3, r2[e3] = t3;
      }
      o2("camera", e2), o2("object", void 0), o2("enabled", true), o2("axis", null), o2("mode", "translate"), o2("translationSnap", null), o2("rotationSnap", null), o2("scaleSnap", null), o2("space", "world"), o2("size", 1), o2("dragging", false), o2("showX", true), o2("showY", true), o2("showZ", true);
      const a2 = new n.Pa4(), l2 = new n.Pa4(), c2 = new n._fP(), u2 = new n._fP(), h2 = new n.Pa4(), p2 = new n._fP(), d2 = new n.Pa4(), f2 = new n.Pa4(), m2 = new n.Pa4(), _2 = new n.Pa4();
      o2("worldPosition", a2), o2("worldPositionStart", l2), o2("worldQuaternion", c2), o2("worldQuaternionStart", u2), o2("cameraPosition", h2), o2("cameraQuaternion", p2), o2("pointStart", d2), o2("pointEnd", f2), o2("rotationAxis", m2), o2("rotationAngle", 0), o2("eye", _2), this._offset = new n.Pa4(), this._startNorm = new n.Pa4(), this._endNorm = new n.Pa4(), this._cameraScale = new n.Pa4(), this._parentPosition = new n.Pa4(), this._parentQuaternion = new n._fP(), this._parentQuaternionInv = new n._fP(), this._parentScale = new n.Pa4(), this._worldScaleStart = new n.Pa4(), this._worldQuaternionInv = new n._fP(), this._worldScale = new n.Pa4(), this._positionStart = new n.Pa4(), this._quaternionStart = new n._fP(), this._scaleStart = new n.Pa4(), this._getPointer = ua.bind(this), this._onPointerDown = pa.bind(this), this._onPointerHover = ha.bind(this), this._onPointerMove = da.bind(this), this._onPointerUp = fa.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
    }
    updateMatrixWorld() {
      void 0 !== this.object && (this.object.updateMatrixWorld(), null === this.object.parent ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye) : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
    }
    pointerHover(e2) {
      if (void 0 === this.object || true === this.dragging)
        return;
      ea.setFromCamera(e2, this.camera);
      const t2 = ma(this._gizmo.picker[this.mode], ea);
      this.axis = t2 ? t2.object.name : null;
    }
    pointerDown(e2) {
      if (void 0 !== this.object && true !== this.dragging && 0 === e2.button && null !== this.axis) {
        ea.setFromCamera(e2, this.camera);
        const t2 = ma(this._plane, ea, true);
        t2 && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t2.point).sub(this.worldPositionStart)), this.dragging = true, oa.mode = this.mode, this.dispatchEvent(oa);
      }
    }
    pointerMove(e2) {
      const t2 = this.axis, r2 = this.mode, n2 = this.object;
      let i2 = this.space;
      if ("scale" === r2 ? i2 = "local" : "E" !== t2 && "XYZE" !== t2 && "XYZ" !== t2 || (i2 = "world"), void 0 === n2 || null === t2 || false === this.dragging || -1 !== e2.button)
        return;
      ea.setFromCamera(e2, this.camera);
      const s2 = ma(this._plane, ea, true);
      if (s2) {
        if (this.pointEnd.copy(s2.point).sub(this.worldPositionStart), "translate" === r2)
          this._offset.copy(this.pointEnd).sub(this.pointStart), "local" === i2 && "XYZ" !== t2 && this._offset.applyQuaternion(this._worldQuaternionInv), -1 === t2.indexOf("X") && (this._offset.x = 0), -1 === t2.indexOf("Y") && (this._offset.y = 0), -1 === t2.indexOf("Z") && (this._offset.z = 0), "local" === i2 && "XYZ" !== t2 ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), n2.position.copy(this._offset).add(this._positionStart), this.translationSnap && ("local" === i2 && (n2.position.applyQuaternion(na.copy(this._quaternionStart).invert()), -1 !== t2.search("X") && (n2.position.x = Math.round(n2.position.x / this.translationSnap) * this.translationSnap), -1 !== t2.search("Y") && (n2.position.y = Math.round(n2.position.y / this.translationSnap) * this.translationSnap), -1 !== t2.search("Z") && (n2.position.z = Math.round(n2.position.z / this.translationSnap) * this.translationSnap), n2.position.applyQuaternion(this._quaternionStart)), "world" === i2 && (n2.parent && n2.position.add(ta.setFromMatrixPosition(n2.parent.matrixWorld)), -1 !== t2.search("X") && (n2.position.x = Math.round(n2.position.x / this.translationSnap) * this.translationSnap), -1 !== t2.search("Y") && (n2.position.y = Math.round(n2.position.y / this.translationSnap) * this.translationSnap), -1 !== t2.search("Z") && (n2.position.z = Math.round(n2.position.z / this.translationSnap) * this.translationSnap), n2.parent && n2.position.sub(ta.setFromMatrixPosition(n2.parent.matrixWorld))));
        else if ("scale" === r2) {
          if (-1 !== t2.search("XYZ")) {
            let e3 = this.pointEnd.length() / this.pointStart.length();
            this.pointEnd.dot(this.pointStart) < 0 && (e3 *= -1), ra.set(e3, e3, e3);
          } else
            ta.copy(this.pointStart), ra.copy(this.pointEnd), ta.applyQuaternion(this._worldQuaternionInv), ra.applyQuaternion(this._worldQuaternionInv), ra.divide(ta), -1 === t2.search("X") && (ra.x = 1), -1 === t2.search("Y") && (ra.y = 1), -1 === t2.search("Z") && (ra.z = 1);
          n2.scale.copy(this._scaleStart).multiply(ra), this.scaleSnap && (-1 !== t2.search("X") && (n2.scale.x = Math.round(n2.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t2.search("Y") && (n2.scale.y = Math.round(n2.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t2.search("Z") && (n2.scale.z = Math.round(n2.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
        } else if ("rotate" === r2) {
          this._offset.copy(this.pointEnd).sub(this.pointStart);
          const e3 = 20 / this.worldPosition.distanceTo(ta.setFromMatrixPosition(this.camera.matrixWorld));
          "E" === t2 ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : "XYZE" === t2 ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(ta.copy(this.rotationAxis).cross(this.eye)) * e3) : "X" !== t2 && "Y" !== t2 && "Z" !== t2 || (this.rotationAxis.copy(ia[t2]), ta.copy(ia[t2]), "local" === i2 && ta.applyQuaternion(this.worldQuaternion), this.rotationAngle = this._offset.dot(ta.cross(this.eye).normalize()) * e3), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), "local" === i2 && "E" !== t2 && "XYZE" !== t2 ? (n2.quaternion.copy(this._quaternionStart), n2.quaternion.multiply(na.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), n2.quaternion.copy(na.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), n2.quaternion.multiply(this._quaternionStart).normalize());
        }
        this.dispatchEvent(sa), this.dispatchEvent(la);
      }
    }
    pointerUp(e2) {
      0 === e2.button && (this.dragging && null !== this.axis && (aa.mode = this.mode, this.dispatchEvent(aa)), this.dragging = false, this.axis = null);
    }
    dispose() {
      this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(e2) {
        e2.geometry && e2.geometry.dispose(), e2.material && e2.material.dispose();
      });
    }
    attach(e2) {
      return this.object = e2, this.visible = true, this;
    }
    detach() {
      return this.object = void 0, this.visible = false, this.axis = null, this;
    }
    reset() {
      this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(sa), this.dispatchEvent(la), this.pointStart.copy(this.pointEnd));
    }
    getRaycaster() {
      return ea;
    }
    getMode() {
      return this.mode;
    }
    setMode(e2) {
      this.mode = e2;
    }
    setTranslationSnap(e2) {
      this.translationSnap = e2;
    }
    setRotationSnap(e2) {
      this.rotationSnap = e2;
    }
    setScaleSnap(e2) {
      this.scaleSnap = e2;
    }
    setSize(e2) {
      this.size = e2;
    }
    setSpace(e2) {
      this.space = e2;
    }
  }
  function ua(e2) {
    if (this.domElement.ownerDocument.pointerLockElement)
      return { x: 0, y: 0, button: e2.button };
    {
      const t2 = this.domElement.getBoundingClientRect();
      return { x: (e2.clientX - t2.left) / t2.width * 2 - 1, y: -(e2.clientY - t2.top) / t2.height * 2 + 1, button: e2.button };
    }
  }
  function ha(e2) {
    if (this.enabled)
      switch (e2.pointerType) {
        case "mouse":
        case "pen":
          this.pointerHover(this._getPointer(e2));
      }
  }
  function pa(e2) {
    this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(e2.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(e2)), this.pointerDown(this._getPointer(e2)));
  }
  function da(e2) {
    this.enabled && this.pointerMove(this._getPointer(e2));
  }
  function fa(e2) {
    this.enabled && (this.domElement.releasePointerCapture(e2.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(e2)));
  }
  function ma(e2, t2, r2) {
    const n2 = t2.intersectObject(e2, true);
    for (let e3 = 0; e3 < n2.length; e3++)
      if (n2[e3].object.visible || r2)
        return n2[e3];
    return false;
  }
  const _a2 = new n.USm(), ga = new n.Pa4(0, 1, 0), va = new n.Pa4(0, 0, 0), Aa = new n.yGw(), ba = new n._fP(), ya = new n._fP(), xa = new n.Pa4(), wa = new n.yGw(), Ea = new n.Pa4(1, 0, 0), Sa = new n.Pa4(0, 1, 0), Ca = new n.Pa4(0, 0, 1), Ma = new n.Pa4(), Ta = new n.Pa4(), Ia = new n.Pa4();
  class ka extends n.Tme {
    constructor() {
      super(), this.isTransformControlsGizmo = true, this.type = "TransformControlsGizmo";
      const e2 = new n.vBJ({ depthTest: false, depthWrite: false, fog: false, toneMapped: false, transparent: true }), t2 = new n.nls({ depthTest: false, depthWrite: false, fog: false, toneMapped: false, transparent: true }), r2 = e2.clone();
      r2.opacity = 0.15;
      const i2 = t2.clone();
      i2.opacity = 0.5;
      const s2 = e2.clone();
      s2.color.setHex(16711680);
      const o2 = e2.clone();
      o2.color.setHex(65280);
      const a2 = e2.clone();
      a2.color.setHex(255);
      const l2 = e2.clone();
      l2.color.setHex(16711680), l2.opacity = 0.5;
      const c2 = e2.clone();
      c2.color.setHex(65280), c2.opacity = 0.5;
      const u2 = e2.clone();
      u2.color.setHex(255), u2.opacity = 0.5;
      const h2 = e2.clone();
      h2.opacity = 0.25;
      const p2 = e2.clone();
      p2.color.setHex(16776960), p2.opacity = 0.25, e2.clone().color.setHex(16776960);
      const d2 = e2.clone();
      d2.color.setHex(7895160);
      const f2 = new n.fHI(0, 0.04, 0.1, 12);
      f2.translate(0, 0.05, 0);
      const m2 = new n.DvJ(0.08, 0.08, 0.08);
      m2.translate(0, 0.04, 0);
      const _2 = new n.u9r();
      _2.setAttribute("position", new n.a$l([0, 0, 0, 1, 0, 0], 3));
      const g2 = new n.fHI(75e-4, 75e-4, 0.5, 3);
      function v2(e3, t3) {
        const r3 = new n.XvJ(e3, 75e-4, 3, 64, t3 * Math.PI * 2);
        return r3.rotateY(Math.PI / 2), r3.rotateX(Math.PI / 2), r3;
      }
      g2.translate(0, 0.25, 0);
      const A2 = { X: [[new n.Kj0(f2, s2), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(f2, s2), [-0.5, 0, 0], [0, 0, Math.PI / 2]], [new n.Kj0(g2, s2), [0, 0, 0], [0, 0, -Math.PI / 2]]], Y: [[new n.Kj0(f2, o2), [0, 0.5, 0]], [new n.Kj0(f2, o2), [0, -0.5, 0], [Math.PI, 0, 0]], [new n.Kj0(g2, o2)]], Z: [[new n.Kj0(f2, a2), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new n.Kj0(f2, a2), [0, 0, -0.5], [-Math.PI / 2, 0, 0]], [new n.Kj0(g2, a2), null, [Math.PI / 2, 0, 0]]], XYZ: [[new n.Kj0(new n.pQR(0.1, 0), h2.clone()), [0, 0, 0]]], XY: [[new n.Kj0(new n.DvJ(0.15, 0.15, 0.01), u2.clone()), [0.15, 0.15, 0]]], YZ: [[new n.Kj0(new n.DvJ(0.15, 0.15, 0.01), l2.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new n.Kj0(new n.DvJ(0.15, 0.15, 0.01), c2.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] }, b2 = { X: [[new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [-0.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, 0.3, 0]], [new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, -0.3, 0], [0, 0, Math.PI]]], Z: [[new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]], XYZ: [[new n.Kj0(new n.pQR(0.2, 0), r2)]], XY: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.01), r2), [0.15, 0.15, 0]]], YZ: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.01), r2), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.01), r2), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] }, y2 = { START: [[new n.Kj0(new n.pQR(0.01, 2), i2), null, null, null, "helper"]], END: [[new n.Kj0(new n.pQR(0.01, 2), i2), null, null, null, "helper"]], DELTA: [[new n.x12(function() {
        const e3 = new n.u9r();
        return e3.setAttribute("position", new n.a$l([0, 0, 0, 1, 1, 1], 3)), e3;
      }(), i2), null, null, null, "helper"]], X: [[new n.x12(_2, i2.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new n.x12(_2, i2.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new n.x12(_2, i2.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] }, x2 = { XYZE: [[new n.Kj0(v2(0.5, 1), d2), null, [0, Math.PI / 2, 0]]], X: [[new n.Kj0(v2(0.5, 0.5), s2)]], Y: [[new n.Kj0(v2(0.5, 0.5), o2), null, [0, 0, -Math.PI / 2]]], Z: [[new n.Kj0(v2(0.5, 0.5), a2), null, [0, Math.PI / 2, 0]]], E: [[new n.Kj0(v2(0.75, 1), p2), null, [0, Math.PI / 2, 0]]] }, w2 = { AXIS: [[new n.x12(_2, i2.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]] }, E2 = { XYZE: [[new n.Kj0(new n.xo$(0.25, 10, 8), r2)]], X: [[new n.Kj0(new n.XvJ(0.5, 0.1, 4, 24), r2), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]], Y: [[new n.Kj0(new n.XvJ(0.5, 0.1, 4, 24), r2), [0, 0, 0], [Math.PI / 2, 0, 0]]], Z: [[new n.Kj0(new n.XvJ(0.5, 0.1, 4, 24), r2), [0, 0, 0], [0, 0, -Math.PI / 2]]], E: [[new n.Kj0(new n.XvJ(0.75, 0.1, 2, 24), r2)]] }, S2 = { X: [[new n.Kj0(m2, s2), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(g2, s2), [0, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(m2, s2), [-0.5, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new n.Kj0(m2, o2), [0, 0.5, 0]], [new n.Kj0(g2, o2)], [new n.Kj0(m2, o2), [0, -0.5, 0], [0, 0, Math.PI]]], Z: [[new n.Kj0(m2, a2), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new n.Kj0(g2, a2), [0, 0, 0], [Math.PI / 2, 0, 0]], [new n.Kj0(m2, a2), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]], XY: [[new n.Kj0(new n.DvJ(0.15, 0.15, 0.01), u2), [0.15, 0.15, 0]]], YZ: [[new n.Kj0(new n.DvJ(0.15, 0.15, 0.01), l2), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new n.Kj0(new n.DvJ(0.15, 0.15, 0.01), c2), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]], XYZ: [[new n.Kj0(new n.DvJ(0.1, 0.1, 0.1), h2.clone())]] }, C2 = { X: [[new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [-0.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, 0.3, 0]], [new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, -0.3, 0], [0, 0, Math.PI]]], Z: [[new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new n.Kj0(new n.fHI(0.2, 0, 0.6, 4), r2), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]], XY: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.01), r2), [0.15, 0.15, 0]]], YZ: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.01), r2), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.01), r2), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]], XYZ: [[new n.Kj0(new n.DvJ(0.2, 0.2, 0.2), r2), [0, 0, 0]]] }, M2 = { X: [[new n.x12(_2, i2.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new n.x12(_2, i2.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new n.x12(_2, i2.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] };
      function T2(e3) {
        const t3 = new n.Tme();
        for (const r3 in e3)
          for (let n2 = e3[r3].length; n2--; ) {
            const i3 = e3[r3][n2][0].clone(), s3 = e3[r3][n2][1], o3 = e3[r3][n2][2], a3 = e3[r3][n2][3], l3 = e3[r3][n2][4];
            i3.name = r3, i3.tag = l3, s3 && i3.position.set(s3[0], s3[1], s3[2]), o3 && i3.rotation.set(o3[0], o3[1], o3[2]), a3 && i3.scale.set(a3[0], a3[1], a3[2]), i3.updateMatrix();
            const c3 = i3.geometry.clone();
            c3.applyMatrix4(i3.matrix), i3.geometry = c3, i3.renderOrder = 1 / 0, i3.position.set(0, 0, 0), i3.rotation.set(0, 0, 0), i3.scale.set(1, 1, 1), t3.add(i3);
          }
        return t3;
      }
      this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = T2(A2)), this.add(this.gizmo.rotate = T2(x2)), this.add(this.gizmo.scale = T2(S2)), this.add(this.picker.translate = T2(b2)), this.add(this.picker.rotate = T2(E2)), this.add(this.picker.scale = T2(C2)), this.add(this.helper.translate = T2(y2)), this.add(this.helper.rotate = T2(w2)), this.add(this.helper.scale = T2(M2)), this.picker.translate.visible = false, this.picker.rotate.visible = false, this.picker.scale.visible = false;
    }
    updateMatrixWorld(e2) {
      const t2 = "local" === ("scale" === this.mode ? "local" : this.space) ? this.worldQuaternion : ya;
      this.gizmo.translate.visible = "translate" === this.mode, this.gizmo.rotate.visible = "rotate" === this.mode, this.gizmo.scale.visible = "scale" === this.mode, this.helper.translate.visible = "translate" === this.mode, this.helper.rotate.visible = "rotate" === this.mode, this.helper.scale.visible = "scale" === this.mode;
      let r2 = [];
      r2 = r2.concat(this.picker[this.mode].children), r2 = r2.concat(this.gizmo[this.mode].children), r2 = r2.concat(this.helper[this.mode].children);
      for (let e3 = 0; e3 < r2.length; e3++) {
        const n2 = r2[e3];
        let i2;
        if (n2.visible = true, n2.rotation.set(0, 0, 0), n2.position.copy(this.worldPosition), i2 = this.camera.isOrthographicCamera ? (this.camera.top - this.camera.bottom) / this.camera.zoom : this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), n2.scale.set(1, 1, 1).multiplyScalar(i2 * this.size / 4), "helper" !== n2.tag) {
          if (n2.quaternion.copy(t2), "translate" === this.mode || "scale" === this.mode) {
            const e4 = 0.99, r3 = 0.2;
            "X" === n2.name && Math.abs(ga.copy(Ea).applyQuaternion(t2).dot(this.eye)) > e4 && (n2.scale.set(1e-10, 1e-10, 1e-10), n2.visible = false), "Y" === n2.name && Math.abs(ga.copy(Sa).applyQuaternion(t2).dot(this.eye)) > e4 && (n2.scale.set(1e-10, 1e-10, 1e-10), n2.visible = false), "Z" === n2.name && Math.abs(ga.copy(Ca).applyQuaternion(t2).dot(this.eye)) > e4 && (n2.scale.set(1e-10, 1e-10, 1e-10), n2.visible = false), "XY" === n2.name && Math.abs(ga.copy(Ca).applyQuaternion(t2).dot(this.eye)) < r3 && (n2.scale.set(1e-10, 1e-10, 1e-10), n2.visible = false), "YZ" === n2.name && Math.abs(ga.copy(Ea).applyQuaternion(t2).dot(this.eye)) < r3 && (n2.scale.set(1e-10, 1e-10, 1e-10), n2.visible = false), "XZ" === n2.name && Math.abs(ga.copy(Sa).applyQuaternion(t2).dot(this.eye)) < r3 && (n2.scale.set(1e-10, 1e-10, 1e-10), n2.visible = false);
          } else
            "rotate" === this.mode && (ba.copy(t2), ga.copy(this.eye).applyQuaternion(na.copy(t2).invert()), -1 !== n2.name.search("E") && n2.quaternion.setFromRotationMatrix(Aa.lookAt(this.eye, va, Sa)), "X" === n2.name && (na.setFromAxisAngle(Ea, Math.atan2(-ga.y, ga.z)), na.multiplyQuaternions(ba, na), n2.quaternion.copy(na)), "Y" === n2.name && (na.setFromAxisAngle(Sa, Math.atan2(ga.x, ga.z)), na.multiplyQuaternions(ba, na), n2.quaternion.copy(na)), "Z" === n2.name && (na.setFromAxisAngle(Ca, Math.atan2(ga.y, ga.x)), na.multiplyQuaternions(ba, na), n2.quaternion.copy(na)));
          n2.visible = n2.visible && (-1 === n2.name.indexOf("X") || this.showX), n2.visible = n2.visible && (-1 === n2.name.indexOf("Y") || this.showY), n2.visible = n2.visible && (-1 === n2.name.indexOf("Z") || this.showZ), n2.visible = n2.visible && (-1 === n2.name.indexOf("E") || this.showX && this.showY && this.showZ), n2.material._color = n2.material._color || n2.material.color.clone(), n2.material._opacity = n2.material._opacity || n2.material.opacity, n2.material.color.copy(n2.material._color), n2.material.opacity = n2.material._opacity, this.enabled && this.axis && (n2.name === this.axis || this.axis.split("").some(function(e4) {
            return n2.name === e4;
          })) && (n2.material.color.setHex(16776960), n2.material.opacity = 1);
        } else
          n2.visible = false, "AXIS" === n2.name ? (n2.position.copy(this.worldPositionStart), n2.visible = !!this.axis, "X" === this.axis && (na.setFromEuler(_a2.set(0, 0, 0)), n2.quaternion.copy(t2).multiply(na), Math.abs(ga.copy(Ea).applyQuaternion(t2).dot(this.eye)) > 0.9 && (n2.visible = false)), "Y" === this.axis && (na.setFromEuler(_a2.set(0, 0, Math.PI / 2)), n2.quaternion.copy(t2).multiply(na), Math.abs(ga.copy(Sa).applyQuaternion(t2).dot(this.eye)) > 0.9 && (n2.visible = false)), "Z" === this.axis && (na.setFromEuler(_a2.set(0, Math.PI / 2, 0)), n2.quaternion.copy(t2).multiply(na), Math.abs(ga.copy(Ca).applyQuaternion(t2).dot(this.eye)) > 0.9 && (n2.visible = false)), "XYZE" === this.axis && (na.setFromEuler(_a2.set(0, Math.PI / 2, 0)), ga.copy(this.rotationAxis), n2.quaternion.setFromRotationMatrix(Aa.lookAt(va, ga, Sa)), n2.quaternion.multiply(na), n2.visible = this.dragging), "E" === this.axis && (n2.visible = false)) : "START" === n2.name ? (n2.position.copy(this.worldPositionStart), n2.visible = this.dragging) : "END" === n2.name ? (n2.position.copy(this.worldPosition), n2.visible = this.dragging) : "DELTA" === n2.name ? (n2.position.copy(this.worldPositionStart), n2.quaternion.copy(this.worldQuaternionStart), ta.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), ta.applyQuaternion(this.worldQuaternionStart.clone().invert()), n2.scale.copy(ta), n2.visible = this.dragging) : (n2.quaternion.copy(t2), this.dragging ? n2.position.copy(this.worldPositionStart) : n2.position.copy(this.worldPosition), this.axis && (n2.visible = -1 !== this.axis.search(n2.name)));
      }
      super.updateMatrixWorld(e2);
    }
  }
  class Da extends n.Kj0 {
    constructor() {
      super(new n._12(1e5, 1e5, 2, 2), new n.vBJ({ visible: false, wireframe: true, side: n.ehD, transparent: true, opacity: 0.1, toneMapped: false })), this.isTransformControlsPlane = true, this.type = "TransformControlsPlane";
    }
    updateMatrixWorld(e2) {
      let t2 = this.space;
      switch (this.position.copy(this.worldPosition), "scale" === this.mode && (t2 = "local"), Ma.copy(Ea).applyQuaternion("local" === t2 ? this.worldQuaternion : ya), Ta.copy(Sa).applyQuaternion("local" === t2 ? this.worldQuaternion : ya), Ia.copy(Ca).applyQuaternion("local" === t2 ? this.worldQuaternion : ya), ga.copy(Ta), this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              ga.copy(this.eye).cross(Ma), xa.copy(Ma).cross(ga);
              break;
            case "Y":
              ga.copy(this.eye).cross(Ta), xa.copy(Ta).cross(ga);
              break;
            case "Z":
              ga.copy(this.eye).cross(Ia), xa.copy(Ia).cross(ga);
              break;
            case "XY":
              xa.copy(Ia);
              break;
            case "YZ":
              xa.copy(Ma);
              break;
            case "XZ":
              ga.copy(Ia), xa.copy(Ta);
              break;
            case "XYZ":
            case "E":
              xa.set(0, 0, 0);
          }
          break;
        default:
          xa.set(0, 0, 0);
      }
      0 === xa.length() ? this.quaternion.copy(this.cameraQuaternion) : (wa.lookAt(ta.set(0, 0, 0), xa, ga), this.quaternion.setFromRotationMatrix(wa)), super.updateMatrixWorld(e2);
    }
  }
  const Pa = new n.ZzF(), Ba = new n.Pa4();
  class Ra extends n.L5s {
    constructor() {
      super(), this.isLineSegmentsGeometry = true, this.type = "LineSegmentsGeometry", this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new n.a$l([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new n.a$l([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2));
    }
    applyMatrix4(e2) {
      const t2 = this.attributes.instanceStart, r2 = this.attributes.instanceEnd;
      return void 0 !== t2 && (t2.applyMatrix4(e2), r2.applyMatrix4(e2), t2.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
    }
    setPositions(e2) {
      let t2;
      e2 instanceof Float32Array ? t2 = e2 : Array.isArray(e2) && (t2 = new Float32Array(e2));
      const r2 = new n.$TI(t2, 6, 1);
      return this.setAttribute("instanceStart", new n.kB5(r2, 3, 0)), this.setAttribute("instanceEnd", new n.kB5(r2, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
    }
    setColors(e2) {
      let t2;
      e2 instanceof Float32Array ? t2 = e2 : Array.isArray(e2) && (t2 = new Float32Array(e2));
      const r2 = new n.$TI(t2, 6, 1);
      return this.setAttribute("instanceColorStart", new n.kB5(r2, 3, 0)), this.setAttribute("instanceColorEnd", new n.kB5(r2, 3, 3)), this;
    }
    fromWireframeGeometry(e2) {
      return this.setPositions(e2.attributes.position.array), this;
    }
    fromEdgesGeometry(e2) {
      return this.setPositions(e2.attributes.position.array), this;
    }
    fromMesh(e2) {
      return this.fromWireframeGeometry(new n.Uk6(e2.geometry)), this;
    }
    fromLineSegments(e2) {
      const t2 = e2.geometry;
      return this.setPositions(t2.attributes.position.array), this;
    }
    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new n.ZzF());
      const e2 = this.attributes.instanceStart, t2 = this.attributes.instanceEnd;
      void 0 !== e2 && void 0 !== t2 && (this.boundingBox.setFromBufferAttribute(e2), Pa.setFromBufferAttribute(t2), this.boundingBox.union(Pa));
    }
    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new n.aLr()), null === this.boundingBox && this.computeBoundingBox();
      const e2 = this.attributes.instanceStart, t2 = this.attributes.instanceEnd;
      if (void 0 !== e2 && void 0 !== t2) {
        const r2 = this.boundingSphere.center;
        this.boundingBox.getCenter(r2);
        let n2 = 0;
        for (let i2 = 0, s2 = e2.count; i2 < s2; i2++)
          Ba.fromBufferAttribute(e2, i2), n2 = Math.max(n2, r2.distanceToSquared(Ba)), Ba.fromBufferAttribute(t2, i2), n2 = Math.max(n2, r2.distanceToSquared(Ba));
        this.boundingSphere.radius = Math.sqrt(n2), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    }
    toJSON() {
    }
    applyMatrix(e2) {
      return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e2);
    }
  }
  class La extends Ra {
    constructor(e2) {
      super(), this.isWireframeGeometry2 = true, this.type = "WireframeGeometry2", this.fromWireframeGeometry(new n.Uk6(e2));
    }
  }
  n.rBU.line = { worldUnits: { value: 1 }, linewidth: { value: 1 }, resolution: { value: new n.FM8(1, 1) }, dashOffset: { value: 0 }, dashScale: { value: 1 }, dashSize: { value: 1 }, gapSize: { value: 1 } }, n.Vj0.line = { uniforms: n.rDY.merge([n.rBU.common, n.rBU.fog, n.rBU.line]), vertexShader: "\n		#include <common>\n		#include <color_pars_vertex>\n		#include <fog_pars_vertex>\n		#include <logdepthbuf_pars_vertex>\n		#include <clipping_planes_pars_vertex>\n\n		uniform float linewidth;\n		uniform vec2 resolution;\n\n		attribute vec3 instanceStart;\n		attribute vec3 instanceEnd;\n\n		attribute vec3 instanceColorStart;\n		attribute vec3 instanceColorEnd;\n\n		#ifdef WORLD_UNITS\n\n			varying vec4 worldPos;\n			varying vec3 worldStart;\n			varying vec3 worldEnd;\n\n			#ifdef USE_DASH\n\n				varying vec2 vUv;\n\n			#endif\n\n		#else\n\n			varying vec2 vUv;\n\n		#endif\n\n		#ifdef USE_DASH\n\n			uniform float dashScale;\n			attribute float instanceDistanceStart;\n			attribute float instanceDistanceEnd;\n			varying float vLineDistance;\n\n		#endif\n\n		void trimSegment( const in vec4 start, inout vec4 end ) {\n\n			// trim end segment so it terminates between the camera plane and the near plane\n\n			// conservative estimate of the near plane\n			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n			float nearEstimate = - 0.5 * b / a;\n\n			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n			end.xyz = mix( start.xyz, end.xyz, alpha );\n\n		}\n\n		void main() {\n\n			#ifdef USE_COLOR\n\n				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n			#endif\n\n			#ifdef USE_DASH\n\n				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n				vUv = uv;\n\n			#endif\n\n			float aspect = resolution.x / resolution.y;\n\n			// camera space\n			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n			#ifdef WORLD_UNITS\n\n				worldStart = start.xyz;\n				worldEnd = end.xyz;\n\n			#else\n\n				vUv = uv;\n\n			#endif\n\n			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n			// perhaps there is a more elegant solution -- WestLangley\n\n			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n			if ( perspective ) {\n\n				if ( start.z < 0.0 && end.z >= 0.0 ) {\n\n					trimSegment( start, end );\n\n				} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n					trimSegment( end, start );\n\n				}\n\n			}\n\n			// clip space\n			vec4 clipStart = projectionMatrix * start;\n			vec4 clipEnd = projectionMatrix * end;\n\n			// ndc space\n			vec3 ndcStart = clipStart.xyz / clipStart.w;\n			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n			// direction\n			vec2 dir = ndcEnd.xy - ndcStart.xy;\n\n			// account for clip-space aspect ratio\n			dir.x *= aspect;\n			dir = normalize( dir );\n\n			#ifdef WORLD_UNITS\n\n				// get the offset direction as perpendicular to the view vector\n				vec3 worldDir = normalize( end.xyz - start.xyz );\n				vec3 offset;\n				if ( position.y < 0.5 ) {\n\n					offset = normalize( cross( start.xyz, worldDir ) );\n\n				} else {\n\n					offset = normalize( cross( end.xyz, worldDir ) );\n\n				}\n\n				// sign flip\n				if ( position.x < 0.0 ) offset *= - 1.0;\n\n				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n				// don't extend the line if we're rendering dashes because we\n				// won't be rendering the endcaps\n				#ifndef USE_DASH\n\n					// extend the line bounds to encompass  endcaps\n					start.xyz += - worldDir * linewidth * 0.5;\n					end.xyz += worldDir * linewidth * 0.5;\n\n					// shift the position of the quad so it hugs the forward edge of the line\n					offset.xy -= dir * forwardOffset;\n					offset.z += 0.5;\n\n				#endif\n\n				// endcaps\n				if ( position.y > 1.0 || position.y < 0.0 ) {\n\n					offset.xy += dir * 2.0 * forwardOffset;\n\n				}\n\n				// adjust for linewidth\n				offset *= linewidth * 0.5;\n\n				// set the world position\n				worldPos = ( position.y < 0.5 ) ? start : end;\n				worldPos.xyz += offset;\n\n				// project the worldpos\n				vec4 clip = projectionMatrix * worldPos;\n\n				// shift the depth of the projected points so the line\n				// segments overlap neatly\n				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n				clip.z = clipPose.z * clip.w;\n\n			#else\n\n				vec2 offset = vec2( dir.y, - dir.x );\n				// undo aspect ratio adjustment\n				dir.x /= aspect;\n				offset.x /= aspect;\n\n				// sign flip\n				if ( position.x < 0.0 ) offset *= - 1.0;\n\n				// endcaps\n				if ( position.y < 0.0 ) {\n\n					offset += - dir;\n\n				} else if ( position.y > 1.0 ) {\n\n					offset += dir;\n\n				}\n\n				// adjust for linewidth\n				offset *= linewidth;\n\n				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n				offset /= resolution.y;\n\n				// select end\n				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n				// back to clip space\n				offset *= clip.w;\n\n				clip.xy += offset;\n\n			#endif\n\n			gl_Position = clip;\n\n			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n			#include <logdepthbuf_vertex>\n			#include <clipping_planes_vertex>\n			#include <fog_vertex>\n\n		}\n		", fragmentShader: "\n		uniform vec3 diffuse;\n		uniform float opacity;\n		uniform float linewidth;\n\n		#ifdef USE_DASH\n\n			uniform float dashOffset;\n			uniform float dashSize;\n			uniform float gapSize;\n\n		#endif\n\n		varying float vLineDistance;\n\n		#ifdef WORLD_UNITS\n\n			varying vec4 worldPos;\n			varying vec3 worldStart;\n			varying vec3 worldEnd;\n\n			#ifdef USE_DASH\n\n				varying vec2 vUv;\n\n			#endif\n\n		#else\n\n			varying vec2 vUv;\n\n		#endif\n\n		#include <common>\n		#include <color_pars_fragment>\n		#include <fog_pars_fragment>\n		#include <logdepthbuf_pars_fragment>\n		#include <clipping_planes_pars_fragment>\n\n		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n			float mua;\n			float mub;\n\n			vec3 p13 = p1 - p3;\n			vec3 p43 = p4 - p3;\n\n			vec3 p21 = p2 - p1;\n\n			float d1343 = dot( p13, p43 );\n			float d4321 = dot( p43, p21 );\n			float d1321 = dot( p13, p21 );\n			float d4343 = dot( p43, p43 );\n			float d2121 = dot( p21, p21 );\n\n			float denom = d2121 * d4343 - d4321 * d4321;\n\n			float numer = d1343 * d4321 - d1321 * d4343;\n\n			mua = numer / denom;\n			mua = clamp( mua, 0.0, 1.0 );\n			mub = ( d1343 + d4321 * ( mua ) ) / d4343;\n			mub = clamp( mub, 0.0, 1.0 );\n\n			return vec2( mua, mub );\n\n		}\n\n		void main() {\n\n			#include <clipping_planes_fragment>\n\n			#ifdef USE_DASH\n\n				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n			#endif\n\n			float alpha = opacity;\n\n			#ifdef WORLD_UNITS\n\n				// Find the closest points on the view ray and the line segment\n				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n				vec3 lineDir = worldEnd - worldStart;\n				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n				vec3 p1 = worldStart + lineDir * params.x;\n				vec3 p2 = rayEnd * params.y;\n				vec3 delta = p1 - p2;\n				float len = length( delta );\n				float norm = len / linewidth;\n\n				#ifndef USE_DASH\n\n					#ifdef USE_ALPHA_TO_COVERAGE\n\n						float dnorm = fwidth( norm );\n						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n					#else\n\n						if ( norm > 0.5 ) {\n\n							discard;\n\n						}\n\n					#endif\n\n				#endif\n\n			#else\n\n				#ifdef USE_ALPHA_TO_COVERAGE\n\n					// artifacts appear on some hardware if a derivative is taken within a conditional\n					float a = vUv.x;\n					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n					float len2 = a * a + b * b;\n					float dlen = fwidth( len2 );\n\n					if ( abs( vUv.y ) > 1.0 ) {\n\n						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n					}\n\n				#else\n\n					if ( abs( vUv.y ) > 1.0 ) {\n\n						float a = vUv.x;\n						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n						float len2 = a * a + b * b;\n\n						if ( len2 > 1.0 ) discard;\n\n					}\n\n				#endif\n\n			#endif\n\n			vec4 diffuseColor = vec4( diffuse, alpha );\n\n			#include <logdepthbuf_fragment>\n			#include <color_fragment>\n\n			gl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n			#include <tonemapping_fragment>\n			#include <encodings_fragment>\n			#include <fog_fragment>\n			#include <premultiplied_alpha_fragment>\n\n		}\n		" };
  class Oa extends n.jyz {
    constructor(e2) {
      super({ type: "LineMaterial", uniforms: n.rDY.clone(n.Vj0.line.uniforms), vertexShader: n.Vj0.line.vertexShader, fragmentShader: n.Vj0.line.fragmentShader, clipping: true }), this.isLineMaterial = true, Object.defineProperties(this, { color: { enumerable: true, get: function() {
        return this.uniforms.diffuse.value;
      }, set: function(e3) {
        this.uniforms.diffuse.value = e3;
      } }, worldUnits: { enumerable: true, get: function() {
        return "WORLD_UNITS" in this.defines;
      }, set: function(e3) {
        true === e3 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
      } }, linewidth: { enumerable: true, get: function() {
        return this.uniforms.linewidth.value;
      }, set: function(e3) {
        this.uniforms.linewidth.value = e3;
      } }, dashed: { enumerable: true, get: function() {
        return Boolean("USE_DASH" in this.defines);
      }, set(e3) {
        Boolean(e3) !== Boolean("USE_DASH" in this.defines) && (this.needsUpdate = true), true === e3 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
      } }, dashScale: { enumerable: true, get: function() {
        return this.uniforms.dashScale.value;
      }, set: function(e3) {
        this.uniforms.dashScale.value = e3;
      } }, dashSize: { enumerable: true, get: function() {
        return this.uniforms.dashSize.value;
      }, set: function(e3) {
        this.uniforms.dashSize.value = e3;
      } }, dashOffset: { enumerable: true, get: function() {
        return this.uniforms.dashOffset.value;
      }, set: function(e3) {
        this.uniforms.dashOffset.value = e3;
      } }, gapSize: { enumerable: true, get: function() {
        return this.uniforms.gapSize.value;
      }, set: function(e3) {
        this.uniforms.gapSize.value = e3;
      } }, opacity: { enumerable: true, get: function() {
        return this.uniforms.opacity.value;
      }, set: function(e3) {
        this.uniforms.opacity.value = e3;
      } }, resolution: { enumerable: true, get: function() {
        return this.uniforms.resolution.value;
      }, set: function(e3) {
        this.uniforms.resolution.value.copy(e3);
      } }, alphaToCoverage: { enumerable: true, get: function() {
        return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
      }, set: function(e3) {
        Boolean(e3) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines) && (this.needsUpdate = true), true === e3 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = true) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = false);
      } } }), this.setValues(e2);
    }
  }
  const Fa = new n.Pa4(), Ua = new n.Pa4();
  class Na extends n.Kj0 {
    constructor(e2 = new Ra(), t2 = new Oa({ color: 16777215 * Math.random() })) {
      super(e2, t2), this.isWireframe = true, this.type = "Wireframe";
    }
    computeLineDistances() {
      const e2 = this.geometry, t2 = e2.attributes.instanceStart, r2 = e2.attributes.instanceEnd, i2 = new Float32Array(2 * t2.count);
      for (let e3 = 0, n2 = 0, s3 = t2.count; e3 < s3; e3++, n2 += 2)
        Fa.fromBufferAttribute(t2, e3), Ua.fromBufferAttribute(r2, e3), i2[n2] = 0 === n2 ? 0 : i2[n2 - 1], i2[n2 + 1] = i2[n2] + Fa.distanceTo(Ua);
      const s2 = new n.$TI(i2, 2, 1);
      return e2.setAttribute("instanceDistanceStart", new n.kB5(s2, 1, 0)), e2.setAttribute("instanceDistanceEnd", new n.kB5(s2, 1, 1)), this;
    }
  }
  class ja extends n.ZAu {
    constructor() {
      super(), this.assetType = "widget", this.modelObject = this, this._object = null, this.boundingScaleMultiplier = 1, this.position.set(0, 0, 0), this.visible = false, this.renderOrder = 1, this.userData.bboxVisible = false, this._updater = this._updater.bind(this);
    }
    _updater() {
      const e2 = this._object;
      if (e2) {
        const t2 = new k().expandByObject(e2, false);
        t2.getCenter(this.position);
        const r2 = t2.getBoundingSphere(new n.aLr()).radius;
        this.scale.setScalar(r2 * this.boundingScaleMultiplier), this.setVisible(true);
      } else
        this.setVisible(false);
    }
    _initGeometry(e2) {
      if (this._geometry)
        return;
      const t2 = new La(e2);
      this._geometry = t2;
      const r2 = new Oa({ color: "#ff2222", transparent: true, opacity: 0.9, linewidth: 5, resolution: new n.FM8(1024, 1024), dashed: false, toneMapped: false }), i2 = new Na(t2, r2);
      i2.computeLineDistances(), i2.scale.set(1, 1, 1), i2.visible = true, this.add(i2);
    }
    setVisible(e2) {
      var t2;
      e2 !== this.visible && (this.visible = e2, null === (t2 = this.setDirty) || void 0 === t2 || t2.call(this, { sceneUpdate: false }));
    }
    attach(e2) {
      return this.detach(), e2 ? (this._object = e2, this._object.addEventListener("objectUpdate", this._updater), this._updater(), this) : this;
    }
    detach() {
      var e2;
      return this._object ? (null === (e2 = this._object) || void 0 === e2 || e2.removeEventListener("objectUpdate", this._updater), this._object = null, this._updater(), this) : this;
    }
    get object() {
      return this._object;
    }
  }
  class za extends ja {
    constructor() {
      super(), this.boundingScaleMultiplier = 1 / 1.7, this._initGeometry(new n.DvJ(2, 2, 2, 1, 1, 1));
    }
    _updater() {
      super._updater();
      const e2 = this.object;
      e2 && (new k().expandByObject(e2, false).getSize(this.scale).multiplyScalar(this.boundingScaleMultiplier).clampScalar(0.1, 100), this.setVisible(true));
    }
  }
  var Ga = function(e2) {
    return function(t2) {
      return 1 - e2(1 - t2);
    };
  }, Va = function(e2) {
    return function(t2) {
      return t2 <= 0.5 ? e2(2 * t2) / 2 : (2 - e2(2 * (1 - t2))) / 2;
    };
  }, Qa = function(e2) {
    return function(t2) {
      return Math.pow(t2, e2);
    };
  }, Ha = function(e2) {
    return function(t2) {
      return t2 * t2 * ((e2 + 1) * t2 - e2);
    };
  }, Wa = function(e2) {
    var t2 = Ha(e2);
    return function(e3) {
      return (e3 *= 2) < 1 ? 0.5 * t2(e3) : 0.5 * (2 - Math.pow(2, -10 * (e3 - 1)));
    };
  }, qa = function(e2) {
    return e2;
  }, Xa = Qa(2), Ya = Ga(Xa), Ka = Va(Xa), Ja = function(e2) {
    return 1 - Math.sin(Math.acos(e2));
  }, Za = Ga(Ja), $a = Va(Za), el = Ha(1.525), tl = Ga(el), rl = Va(el), nl = Wa(1.525), il = function(e2) {
    if (1 === e2 || 0 === e2)
      return e2;
    var t2 = e2 * e2;
    return e2 < 0.36363636363636365 ? 7.5625 * t2 : e2 < 0.7272727272727273 ? 9.075 * t2 - 9.9 * e2 + 3.4 : e2 < 0.9 ? 12.066481994459833 * t2 - 19.63545706371191 * e2 + 8.898060941828255 : 10.8 * e2 * e2 - 20.52 * e2 + 10.72;
  }, sl = Ga(il), ol = function(e2) {
    return e2 < 0.5 ? 0.5 * (1 - il(1 - 2 * e2)) : 0.5 * il(2 * e2 - 1) + 0.5;
  }, al = function() {
    return al = Object.assign || function(e2) {
      for (var t2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
        for (var i2 in t2 = arguments[r2])
          Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);
      return e2;
    }, al.apply(this, arguments);
  };
  function ll(e2, t2) {
    var r2 = {};
    for (var n2 in e2)
      Object.prototype.hasOwnProperty.call(e2, n2) && t2.indexOf(n2) < 0 && (r2[n2] = e2[n2]);
    if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
      var i2 = 0;
      for (n2 = Object.getOwnPropertySymbols(e2); i2 < n2.length; i2++)
        t2.indexOf(n2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, n2[i2]) && (r2[n2[i2]] = e2[n2[i2]]);
    }
    return r2;
  }
  Object.create, Object.create;
  var cl = function(e2, t2, r2) {
    return Math.min(Math.max(r2, e2), t2);
  };
  function ul(e2, t2) {
    return e2 * Math.sqrt(1 - t2 * t2);
  }
  var hl = ["duration", "bounce"], pl = ["stiffness", "damping", "mass"];
  function dl(e2, t2) {
    return t2.some(function(t3) {
      return void 0 !== e2[t3];
    });
  }
  function fl(e2) {
    var t2 = e2.from, r2 = void 0 === t2 ? 0 : t2, n2 = e2.to, i2 = void 0 === n2 ? 1 : n2, s2 = e2.restSpeed, o2 = void 0 === s2 ? 2 : s2, a2 = e2.restDelta, l2 = ll(e2, ["from", "to", "restSpeed", "restDelta"]), c2 = { done: false, value: r2 }, u2 = function(e3) {
      var t3 = al({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, e3);
      if (!dl(e3, pl) && dl(e3, hl)) {
        var r3 = function(e4) {
          var t4, r4, n3 = e4.duration, i3 = void 0 === n3 ? 800 : n3, s3 = e4.bounce, o3 = void 0 === s3 ? 0.25 : s3, a3 = e4.velocity, l3 = void 0 === a3 ? 0 : a3, c3 = e4.mass, u3 = void 0 === c3 ? 1 : c3, h3 = 1 - o3;
          h3 = cl(0.05, 1, h3), i3 = cl(0.01, 10, i3 / 1e3), h3 < 1 ? (t4 = function(e5) {
            var t5 = e5 * h3, r5 = t5 * i3;
            return 1e-3 - (t5 - l3) / ul(e5, h3) * Math.exp(-r5);
          }, r4 = function(e5) {
            var r5 = e5 * h3 * i3, n4 = r5 * l3 + l3, s4 = Math.pow(h3, 2) * Math.pow(e5, 2) * i3, o4 = Math.exp(-r5), a4 = ul(Math.pow(e5, 2), h3);
            return (1e-3 - t4(e5) > 0 ? -1 : 1) * ((n4 - s4) * o4) / a4;
          }) : (t4 = function(e5) {
            return Math.exp(-e5 * i3) * ((e5 - l3) * i3 + 1) - 1e-3;
          }, r4 = function(e5) {
            return Math.exp(-e5 * i3) * (i3 * i3 * (l3 - e5));
          });
          var p3 = function(e5, t5, r5) {
            for (var n4 = r5, i4 = 1; i4 < 12; i4++)
              n4 -= e5(n4) / t5(n4);
            return n4;
          }(t4, r4, 5 / i3);
          if (i3 *= 1e3, isNaN(p3))
            return { stiffness: 100, damping: 10, duration: i3 };
          var d3 = Math.pow(p3, 2) * u3;
          return { stiffness: d3, damping: 2 * h3 * Math.sqrt(u3 * d3), duration: i3 };
        }(e3);
        (t3 = al(al(al({}, t3), r3), { velocity: 0, mass: 1 })).isResolvedFromDuration = true;
      }
      return t3;
    }(l2), h2 = u2.stiffness, p2 = u2.damping, d2 = u2.mass, f2 = u2.velocity, m2 = u2.duration, _2 = u2.isResolvedFromDuration, g2 = ml, v2 = ml;
    function A2() {
      var e3 = f2 ? -f2 / 1e3 : 0, t3 = i2 - r2, n3 = p2 / (2 * Math.sqrt(h2 * d2)), s3 = Math.sqrt(h2 / d2) / 1e3;
      if (null != a2 || (a2 = Math.abs(i2 - r2) <= 1 ? 0.01 : 0.4), n3 < 1) {
        var o3 = ul(s3, n3);
        g2 = function(r3) {
          var a3 = Math.exp(-n3 * s3 * r3);
          return i2 - a3 * ((e3 + n3 * s3 * t3) / o3 * Math.sin(o3 * r3) + t3 * Math.cos(o3 * r3));
        }, v2 = function(r3) {
          var i3 = Math.exp(-n3 * s3 * r3);
          return n3 * s3 * i3 * (Math.sin(o3 * r3) * (e3 + n3 * s3 * t3) / o3 + t3 * Math.cos(o3 * r3)) - i3 * (Math.cos(o3 * r3) * (e3 + n3 * s3 * t3) - o3 * t3 * Math.sin(o3 * r3));
        };
      } else if (1 === n3)
        g2 = function(r3) {
          return i2 - Math.exp(-s3 * r3) * (t3 + (e3 + s3 * t3) * r3);
        };
      else {
        var l3 = s3 * Math.sqrt(n3 * n3 - 1);
        g2 = function(r3) {
          var o4 = Math.exp(-n3 * s3 * r3), a3 = Math.min(l3 * r3, 300);
          return i2 - o4 * ((e3 + n3 * s3 * t3) * Math.sinh(a3) + l3 * t3 * Math.cosh(a3)) / l3;
        };
      }
    }
    return A2(), { next: function(e3) {
      var t3 = g2(e3);
      if (_2)
        c2.done = e3 >= m2;
      else {
        var r3 = 1e3 * v2(e3), n3 = Math.abs(r3) <= o2, s3 = Math.abs(i2 - t3) <= a2;
        c2.done = n3 && s3;
      }
      return c2.value = c2.done ? i2 : t3, c2;
    }, flipTarget: function() {
      var e3;
      f2 = -f2, r2 = (e3 = [i2, r2])[0], i2 = e3[1], A2();
    } };
  }
  fl.needsInterpolation = function(e2, t2) {
    return "string" == typeof e2 || "string" == typeof t2;
  };
  var ml = function(e2) {
    return 0;
  }, _l = function(e2, t2, r2) {
    var n2 = t2 - e2;
    return 0 === n2 ? 1 : (r2 - e2) / n2;
  }, gl = function(e2, t2, r2) {
    return -r2 * e2 + r2 * t2 + e2;
  }, vl = function(e2, t2) {
    return function(r2) {
      return Math.max(Math.min(r2, t2), e2);
    };
  }, Al = function(e2) {
    return e2 % 1 ? Number(e2.toFixed(5)) : e2;
  }, bl = /(-)?([\d]*\.?[\d])+/g, yl = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi, xl = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
  function wl(e2) {
    return "string" == typeof e2;
  }
  var El = { test: function(e2) {
    return "number" == typeof e2;
  }, parse: parseFloat, transform: function(e2) {
    return e2;
  } }, Sl = al(al({}, El), { transform: vl(0, 1) }), Cl = (al(al({}, El), { default: 1 }), function(e2, t2) {
    return function(r2) {
      return Boolean(wl(r2) && xl.test(r2) && r2.startsWith(e2) || t2 && Object.prototype.hasOwnProperty.call(r2, t2));
    };
  }), Ml = function(e2, t2, r2) {
    return function(n2) {
      var i2;
      if (!wl(n2))
        return n2;
      var s2 = n2.match(bl), o2 = s2[0], a2 = s2[1], l2 = s2[2], c2 = s2[3];
      return (i2 = {})[e2] = parseFloat(o2), i2[t2] = parseFloat(a2), i2[r2] = parseFloat(l2), i2.alpha = void 0 !== c2 ? parseFloat(c2) : 1, i2;
    };
  }, Tl = vl(0, 255), Il = al(al({}, El), { transform: function(e2) {
    return Math.round(Tl(e2));
  } }), kl = { test: Cl("rgb", "red"), parse: Ml("red", "green", "blue"), transform: function(e2) {
    var t2 = e2.red, r2 = e2.green, n2 = e2.blue, i2 = e2.alpha, s2 = void 0 === i2 ? 1 : i2;
    return "rgba(" + Il.transform(t2) + ", " + Il.transform(r2) + ", " + Il.transform(n2) + ", " + Al(Sl.transform(s2)) + ")";
  } }, Dl = { test: Cl("#"), parse: function(e2) {
    var t2 = "", r2 = "", n2 = "", i2 = "";
    return e2.length > 5 ? (t2 = e2.substr(1, 2), r2 = e2.substr(3, 2), n2 = e2.substr(5, 2), i2 = e2.substr(7, 2)) : (t2 = e2.substr(1, 1), r2 = e2.substr(2, 1), n2 = e2.substr(3, 1), i2 = e2.substr(4, 1), t2 += t2, r2 += r2, n2 += n2, i2 += i2), { red: parseInt(t2, 16), green: parseInt(r2, 16), blue: parseInt(n2, 16), alpha: i2 ? parseInt(i2, 16) / 255 : 1 };
  }, transform: kl.transform }, Pl = function(e2) {
    return { test: function(t2) {
      return wl(t2) && t2.endsWith(e2) && 1 === t2.split(" ").length;
    }, parse: parseFloat, transform: function(t2) {
      return "" + t2 + e2;
    } };
  }, Bl = (Pl("deg"), Pl("%")), Rl = (Pl("px"), Pl("vh"), Pl("vw"), al(al({}, Bl), { parse: function(e2) {
    return Bl.parse(e2) / 100;
  }, transform: function(e2) {
    return Bl.transform(100 * e2);
  } }), { test: Cl("hsl", "hue"), parse: Ml("hue", "saturation", "lightness"), transform: function(e2) {
    var t2 = e2.hue, r2 = e2.saturation, n2 = e2.lightness, i2 = e2.alpha, s2 = void 0 === i2 ? 1 : i2;
    return "hsla(" + Math.round(t2) + ", " + Bl.transform(Al(r2)) + ", " + Bl.transform(Al(n2)) + ", " + Al(Sl.transform(s2)) + ")";
  } }), Ll = function(e2, t2, r2) {
    var n2 = e2 * e2, i2 = t2 * t2;
    return Math.sqrt(Math.max(0, r2 * (i2 - n2) + n2));
  }, Ol = [Dl, kl, Rl], Fl = function(e2) {
    return Ol.find(function(t2) {
      return t2.test(e2);
    });
  }, Ul = function(e2) {
    return "'" + e2 + "' is not an animatable color. Use the equivalent color code instead.";
  }, Nl = function(e2, t2) {
    var r2 = Fl(e2), n2 = Fl(t2);
    Ul(e2), Ul(t2), r2.transform, n2.transform;
    var i2 = r2.parse(e2), s2 = n2.parse(t2), o2 = al({}, i2), a2 = r2 === Rl ? gl : Ll;
    return function(e3) {
      for (var t3 in o2)
        "alpha" !== t3 && (o2[t3] = a2(i2[t3], s2[t3], e3));
      return o2.alpha = gl(i2.alpha, s2.alpha, e3), r2.transform(o2);
    };
  }, jl = function(e2) {
    return kl.test(e2) || Dl.test(e2) || Rl.test(e2);
  }, zl = function(e2) {
    return kl.test(e2) ? kl.parse(e2) : Rl.test(e2) ? Rl.parse(e2) : Dl.parse(e2);
  }, Gl = function(e2) {
    return wl(e2) ? e2 : e2.hasOwnProperty("red") ? kl.transform(e2) : Rl.transform(e2);
  }, Vl = "${c}", Ql = "${n}";
  function Hl(e2) {
    var t2 = [], r2 = 0, n2 = e2.match(yl);
    n2 && (r2 = n2.length, e2 = e2.replace(yl, Vl), t2.push.apply(t2, n2.map(zl)));
    var i2 = e2.match(bl);
    return i2 && (e2 = e2.replace(bl, Ql), t2.push.apply(t2, i2.map(El.parse))), { values: t2, numColors: r2, tokenised: e2 };
  }
  function Wl(e2) {
    return Hl(e2).values;
  }
  function ql(e2) {
    var t2 = Hl(e2), r2 = t2.values, n2 = t2.numColors, i2 = t2.tokenised, s2 = r2.length;
    return function(e3) {
      for (var t3 = i2, r3 = 0; r3 < s2; r3++)
        t3 = t3.replace(r3 < n2 ? Vl : Ql, r3 < n2 ? Gl(e3[r3]) : Al(e3[r3]));
      return t3;
    };
  }
  var Xl = function(e2) {
    return "number" == typeof e2 ? 0 : e2;
  }, Yl = { test: function(e2) {
    var t2, r2, n2, i2;
    return isNaN(e2) && wl(e2) && (null !== (r2 = null === (t2 = e2.match(bl)) || void 0 === t2 ? void 0 : t2.length) && void 0 !== r2 ? r2 : 0) + (null !== (i2 = null === (n2 = e2.match(yl)) || void 0 === n2 ? void 0 : n2.length) && void 0 !== i2 ? i2 : 0) > 0;
  }, parse: Wl, createTransformer: ql, getAnimatableNone: function(e2) {
    var t2 = Wl(e2);
    return ql(e2)(t2.map(Xl));
  } }, Kl = { x: 0, y: 0, z: 0 }, Jl = function(e2) {
    return "number" == typeof e2;
  }, Zl = function(e2, t2) {
    return function(r2) {
      return t2(e2(r2));
    };
  }, $l = function() {
    for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
      e2[t2] = arguments[t2];
    return e2.reduce(Zl);
  };
  function ec(e2, t2) {
    return Jl(e2) ? function(r2) {
      return gl(e2, t2, r2);
    } : jl(e2) ? Nl(e2, t2) : ic(e2, t2);
  }
  var tc = function(e2, t2) {
    var r2 = function(e3, t3) {
      for (var r3 = 0, n3 = t3.length, i3 = e3.length; r3 < n3; r3++, i3++)
        e3[i3] = t3[r3];
      return e3;
    }([], e2), n2 = r2.length, i2 = e2.map(function(e3, r3) {
      return ec(e3, t2[r3]);
    });
    return function(e3) {
      for (var t3 = 0; t3 < n2; t3++)
        r2[t3] = i2[t3](e3);
      return r2;
    };
  }, rc = function(e2, t2) {
    var r2 = al(al({}, e2), t2), n2 = {};
    for (var i2 in r2)
      void 0 !== e2[i2] && void 0 !== t2[i2] && (n2[i2] = ec(e2[i2], t2[i2]));
    return function(e3) {
      for (var t3 in n2)
        r2[t3] = n2[t3](e3);
      return r2;
    };
  };
  function nc(e2) {
    for (var t2 = Yl.parse(e2), r2 = t2.length, n2 = 0, i2 = 0, s2 = 0, o2 = 0; o2 < r2; o2++)
      n2 || "number" == typeof t2[o2] ? n2++ : void 0 !== t2[o2].hue ? s2++ : i2++;
    return { parsed: t2, numNumbers: n2, numRGB: i2, numHSL: s2 };
  }
  var ic = function(e2, t2) {
    var r2 = Yl.createTransformer(t2), n2 = nc(e2), i2 = nc(t2);
    return n2.numHSL === i2.numHSL && n2.numRGB === i2.numRGB && (n2.numNumbers, i2.numNumbers), $l(tc(n2.parsed, i2.parsed), r2);
  }, sc = function(e2, t2) {
    return function(r2) {
      return gl(e2, t2, r2);
    };
  };
  function oc(e2, t2, r2) {
    var n2 = void 0 === r2 ? {} : r2, i2 = n2.clamp, s2 = void 0 === i2 || i2, o2 = n2.ease, a2 = n2.mixer, l2 = e2.length;
    t2.length, !o2 || !Array.isArray(o2) || o2.length, e2[0] > e2[l2 - 1] && (e2 = [].concat(e2), t2 = [].concat(t2), e2.reverse(), t2.reverse());
    var c2 = function(e3, t3, r3) {
      for (var n3 = [], i3 = r3 || ("number" == typeof (c3 = e3[0]) ? sc : "string" == typeof c3 ? jl(c3) ? Nl : ic : Array.isArray(c3) ? tc : "object" == typeof c3 ? rc : void 0), s3 = e3.length - 1, o3 = 0; o3 < s3; o3++) {
        var a3 = i3(e3[o3], e3[o3 + 1]);
        if (t3) {
          var l3 = Array.isArray(t3) ? t3[o3] : t3;
          a3 = $l(l3, a3);
        }
        n3.push(a3);
      }
      var c3;
      return n3;
    }(t2, o2, a2), u2 = 2 === l2 ? function(e3, t3) {
      var r3 = e3[0], n3 = e3[1], i3 = t3[0];
      return function(e4) {
        return i3(_l(r3, n3, e4));
      };
    }(e2, c2) : function(e3, t3) {
      var r3 = e3.length, n3 = r3 - 1;
      return function(i3) {
        var s3 = 0, o3 = false;
        if (i3 <= e3[0] ? o3 = true : i3 >= e3[n3] && (s3 = n3 - 1, o3 = true), !o3) {
          for (var a3 = 1; a3 < r3 && !(e3[a3] > i3 || a3 === n3); a3++)
            ;
          s3 = a3 - 1;
        }
        var l3 = _l(e3[s3], e3[s3 + 1], i3);
        return t3[s3](l3);
      };
    }(e2, c2);
    return s2 ? function(t3) {
      return u2(cl(e2[0], e2[l2 - 1], t3));
    } : u2;
  }
  function ac(e2, t2) {
    return e2.map(function() {
      return t2 || Ka;
    }).splice(0, e2.length - 1);
  }
  function lc(e2) {
    var t2 = e2.from, r2 = void 0 === t2 ? 0 : t2, n2 = e2.to, i2 = void 0 === n2 ? 1 : n2, s2 = e2.ease, o2 = e2.offset, a2 = e2.duration, l2 = void 0 === a2 ? 300 : a2, c2 = { done: false, value: r2 }, u2 = Array.isArray(i2) ? i2 : [r2, i2], h2 = function(e3, t3) {
      return e3.map(function(e4) {
        return e4 * t3;
      });
    }(o2 && o2.length === u2.length ? o2 : function(e3) {
      var t3 = e3.length;
      return e3.map(function(e4, r3) {
        return 0 !== r3 ? r3 / (t3 - 1) : 0;
      });
    }(u2), l2);
    function p2() {
      return oc(h2, u2, { ease: Array.isArray(s2) ? s2 : ac(u2, s2) });
    }
    var d2 = p2();
    return { next: function(e3) {
      return c2.value = d2(e3), c2.done = e3 >= l2, c2;
    }, flipTarget: function() {
      u2.reverse(), d2 = p2();
    } };
  }
  function cc(e2) {
    var t2 = e2.velocity, r2 = void 0 === t2 ? 0 : t2, n2 = e2.from, i2 = void 0 === n2 ? 0 : n2, s2 = e2.power, o2 = void 0 === s2 ? 0.8 : s2, a2 = e2.timeConstant, l2 = void 0 === a2 ? 350 : a2, c2 = e2.restDelta, u2 = void 0 === c2 ? 0.5 : c2, h2 = e2.modifyTarget, p2 = { done: false, value: i2 }, d2 = o2 * r2, f2 = i2 + d2, m2 = void 0 === h2 ? f2 : h2(f2);
    return m2 !== f2 && (d2 = m2 - i2), { next: function(e3) {
      var t3 = -d2 * Math.exp(-e3 / l2);
      return p2.done = !(t3 > u2 || t3 < -u2), p2.value = p2.done ? m2 : m2 + t3, p2;
    }, flipTarget: function() {
    } };
  }
  var uc = { keyframes: lc, spring: fl, decay: cc }, hc = 1 / 60 * 1e3, pc = "undefined" != typeof performance ? function() {
    return performance.now();
  } : function() {
    return Date.now();
  }, dc = "undefined" != typeof window ? function(e2) {
    return window.requestAnimationFrame(e2);
  } : function(e2) {
    return setTimeout(function() {
      return e2(pc());
    }, hc);
  }, fc = true, mc = false, _c = false, gc = { delta: 0, timestamp: 0 }, vc = ["read", "update", "preRender", "render", "postRender"], Ac = vc.reduce(function(e2, t2) {
    return e2[t2] = function(e3) {
      var t3 = [], r2 = [], n2 = 0, i2 = false, s2 = /* @__PURE__ */ new WeakSet(), o2 = { schedule: function(e4, o3, a2) {
        void 0 === o3 && (o3 = false), void 0 === a2 && (a2 = false);
        var l2 = a2 && i2, c2 = l2 ? t3 : r2;
        return o3 && s2.add(e4), -1 === c2.indexOf(e4) && (c2.push(e4), l2 && i2 && (n2 = t3.length)), e4;
      }, cancel: function(e4) {
        var t4 = r2.indexOf(e4);
        -1 !== t4 && r2.splice(t4, 1), s2.delete(e4);
      }, process: function(a2) {
        var l2;
        if (i2 = true, t3 = (l2 = [r2, t3])[0], (r2 = l2[1]).length = 0, n2 = t3.length)
          for (var c2 = 0; c2 < n2; c2++) {
            var u2 = t3[c2];
            u2(a2), s2.has(u2) && (o2.schedule(u2), e3());
          }
        i2 = false;
      } };
      return o2;
    }(function() {
      return mc = true;
    }), e2;
  }, {}), bc = vc.reduce(function(e2, t2) {
    var r2 = Ac[t2];
    return e2[t2] = function(e3, t3, n2) {
      return void 0 === t3 && (t3 = false), void 0 === n2 && (n2 = false), mc || Ec(), r2.schedule(e3, t3, n2);
    }, e2;
  }, {}), yc = vc.reduce(function(e2, t2) {
    return e2[t2] = Ac[t2].cancel, e2;
  }, {}), xc = function(e2) {
    return Ac[e2].process(gc);
  }, wc = function(e2) {
    mc = false, gc.delta = fc ? hc : Math.max(Math.min(e2 - gc.timestamp, 40), 1), gc.timestamp = e2, _c = true, vc.forEach(xc), _c = false, mc && (fc = false, dc(wc));
  }, Ec = function() {
    mc = true, fc = true, _c || dc(wc);
  }, Sc = function() {
    return gc;
  }, Cc = bc;
  function Mc(e2, t2, r2) {
    return void 0 === r2 && (r2 = 0), e2 - t2 - r2;
  }
  var Tc = function(e2) {
    var t2 = function(t3) {
      var r2 = t3.delta;
      return e2(r2);
    };
    return { start: function() {
      return Cc.update(t2, true);
    }, stop: function() {
      return yc.update(t2);
    } };
  };
  function Ic(e2) {
    var t2, r2, n2, i2, s2, o2 = e2.from, a2 = e2.autoplay, l2 = void 0 === a2 || a2, c2 = e2.driver, u2 = void 0 === c2 ? Tc : c2, h2 = e2.elapsed, p2 = void 0 === h2 ? 0 : h2, d2 = e2.repeat, f2 = void 0 === d2 ? 0 : d2, m2 = e2.repeatType, _2 = void 0 === m2 ? "loop" : m2, g2 = e2.repeatDelay, v2 = void 0 === g2 ? 0 : g2, A2 = e2.onPlay, b2 = e2.onStop, y2 = e2.onComplete, x2 = e2.onRepeat, w2 = e2.onUpdate, E2 = ll(e2, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]), S2 = E2.to, C2 = 0, M2 = E2.duration, T2 = false, I2 = true, k2 = function(e3) {
      if (Array.isArray(e3.to))
        return lc;
      if (uc[e3.type])
        return uc[e3.type];
      var t3 = new Set(Object.keys(e3));
      return t3.has("ease") || t3.has("duration") && !t3.has("dampingRatio") ? lc : t3.has("dampingRatio") || t3.has("stiffness") || t3.has("mass") || t3.has("damping") || t3.has("restSpeed") || t3.has("restDelta") ? fl : lc;
    }(E2);
    (null === (r2 = (t2 = k2).needsInterpolation) || void 0 === r2 ? void 0 : r2.call(t2, o2, S2)) && (s2 = oc([0, 100], [o2, S2], { clamp: false }), o2 = 0, S2 = 100);
    var D2 = k2(al(al({}, E2), { from: o2, to: S2 }));
    return l2 && (null == A2 || A2(), (n2 = u2(function(e3) {
      if (I2 || (e3 = -e3), p2 += e3, !T2) {
        var t3 = D2.next(Math.max(0, p2));
        i2 = t3.value, s2 && (i2 = s2(i2)), T2 = I2 ? t3.done : p2 <= 0;
      }
      null == w2 || w2(i2), T2 && (0 === C2 && (null != M2 || (M2 = p2)), C2 < f2 ? function(e4, t4, r3, n3) {
        return n3 ? e4 >= t4 + r3 : e4 <= -r3;
      }(p2, M2, v2, I2) && (C2++, "reverse" === _2 ? p2 = function(e4, t4, r3, n3) {
        return void 0 === r3 && (r3 = 0), void 0 === n3 && (n3 = true), n3 ? Mc(t4 + -e4, t4, r3) : t4 - (e4 - t4) + r3;
      }(p2, M2, v2, I2 = C2 % 2 == 0) : (p2 = Mc(p2, M2, v2), "mirror" === _2 && D2.flipTarget()), T2 = false, x2 && x2()) : (n2.stop(), y2 && y2()));
    })).start()), { stop: function() {
      null == b2 || b2(), n2.stop();
    } };
  }
  const kc = { linear: qa, easeIn: Xa, easeOut: Ya, easeInOut: Ka, circIn: Ja, circOut: Za, circInOut: $a, backIn: el, backOut: tl, backInOut: rl, anticipate: nl, bounceOut: il, bounceIn: sl, bounceInOut: ol, easeInOutSine: function(e2) {
    return -(Math.cos(Math.PI * e2) - 1) / 2;
  } };
  async function Dc(e2) {
    return new Promise((t2) => setTimeout(t2, Math.max(0, e2)));
  }
  function Pc(e2, t2, r2) {
    const n2 = e2[t2], i2 = () => {
      "function" == typeof (null == e2 ? void 0 : e2.setDirty) && e2.setDirty(), null == r2 || r2();
    };
    return n2.isVector3 || n2.isVector2 || n2.isVector4 ? (e3) => {
      n2.copy(e3), i2();
    } : (r3) => {
      e2[t2] = r3, i2();
    };
  }
  function Bc(e2) {
    return "boolean" != typeof e2;
  }
  async function Rc(e2, t2, r2) {
    t2 in e2 || console.error("invalid key", t2, e2);
    const n2 = Pc(e2, t2), i2 = e2[t2], s2 = (e3) => {
      var t3;
      n2(e3), null === (t3 = r2.onUpdate) || void 0 === t3 || t3.call(r2, e3);
    };
    if (Bc(i2))
      return "function" == typeof r2.to && (r2 = { ...r2, to: r2.to(i2, e2) }), Lc({ ...r2, from: i2, onUpdate: s2 });
    {
      const { duration: e3 } = r2;
      return Dc(null != e3 ? e3 : 0).then(() => s2(r2.to));
    }
  }
  async function Lc(e2) {
    return new Promise((t2, r2) => {
      Ic({ onComplete: () => {
        var r3;
        null === (r3 = e2.onComplete) || void 0 === r3 || r3.call(e2), t2();
      }, onStop: () => {
        var r3;
        null === (r3 = e2.onStop) || void 0 === r3 || r3.call(e2), t2();
      }, ...e2 });
    });
  }
  class Oc extends io {
    constructor() {
      super(), this.passId = "frameFade", this._fadeTime = 0, this._fadeTimeState = 0, this._toSaveFrame = false, this._beforeFilters = ["progressive", "taa"], this._afterFilters = ["render"], this._requiredFilters = ["render", "progressive"], this.dependencies = [To], this.fadeOnActiveCameraChange = true, this.fadeOnMaterialUpdate = true, this.fadeOnSceneUpdate = true, this.pointerEnabled = true, this._fadeCam = (e2) => false !== e2.frameFade && this.fadeOnActiveCameraChange && this.startTransition(1e3), this._fadeMat = (e2) => {
        false !== e2.frameFade && this.fadeOnMaterialUpdate && this.startTransition(200);
      }, this._fadeScene = (e2) => {
        false !== e2.frameFade && this.fadeOnSceneUpdate && this.startTransition(500);
      }, this._onPointerMove = (e2) => {
        var t2;
        const r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.canvas;
        if (!r2)
          return void (this.pointerEnabled = false);
        if (!e2.buttons || e2.target !== r2)
          return void (this.pointerEnabled = true);
        const n2 = r2.getBoundingClientRect(), i2 = (e2.clientX - n2.left) / n2.width, s2 = (e2.clientY - n2.top) / n2.height;
        this.pointerEnabled = i2 < 0 || i2 > 1 || s2 < 0 || s2 > 1;
      }, this._disabledBy = [], this.startTransition = this.startTransition.bind(this), this.stopTransition = this.stopTransition.bind(this), this._fadeCam = this._fadeCam.bind(this), this._fadeMat = this._fadeMat.bind(this);
    }
    async startTransition(e2) {
      this._viewer && this._pass && !this.isDisabled() && (this._target || (this._target = this._viewer.renderer.getTempTarget({ sizeMultiplier: 1, minFilter: n.wem, magFilter: n.wem, encoding: this._viewer.renderer.composerTarget.texture.encoding })), this._fadeTimeState = Math.max(e2, this._fadeTimeState), this._fadeTime = this._fadeTimeState, this._toSaveFrame = true, this.setDirty(), await Dc(e2));
    }
    stopTransition() {
      this._fadeTimeState = 0;
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("activeCameraChange", this._fadeCam), e2.scene.addEventListener("activeCameraUpdate", this.stopTransition), e2.scene.addEventListener("sceneMaterialUpdate", this._fadeMat), e2.scene.addEventListener("sceneUpdate", this._fadeScene), window.addEventListener("pointermove", this._onPointerMove);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("activeCameraChange", this._fadeCam), e2.scene.removeEventListener("activeCameraUpdate", this.stopTransition), e2.scene.removeEventListener("sceneMaterialUpdate", this._fadeMat), e2.scene.removeEventListener("sceneUpdate", this._fadeScene), window.removeEventListener("pointermove", this._onPointerMove), super.onRemove(e2);
    }
    passCtor(e2) {
      const t2 = this, r2 = e2.getPlugin(To), n2 = new class extends Eo {
        constructor() {
          super(...arguments), this._lastTime = 0, this.uiConfig = at("Frame Fade", this);
        }
        render(n3, i2, s2, o2, a2) {
          this.needsSwap = false;
          const l2 = t2._target;
          if (!l2 || !t2.pointerEnabled || !this.enabled || !t2.dirty || t2._fadeTimeState < 1e-3)
            return;
          t2._toSaveFrame && r2.lastFrame && (e2.renderer.blit(r2.lastFrame.texture, l2), this._lastTime = 0, t2._toSaveFrame = false), this.blendTexture = null == l2 ? void 0 : l2.texture;
          const c2 = t2._fadeTimeState / t2._fadeTime;
          this.weights2.setScalar(c2), this.weights2.w = 1, this.weights1.setScalar(1 - c2), this.weights1.w = 1, super.render(n3, i2, s2, o2, a2), this.needsSwap = true;
          const u2 = Dt();
          this._lastTime < 10 && (this._lastTime = u2 - 10);
          const h2 = u2 - this._lastTime;
          this._lastTime = u2, t2._fadeTimeState -= h2;
        }
      }();
      return n2.enabled = true, n2;
    }
    setDirty() {
      var e2;
      this.enabled && (null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty());
    }
    get dirty() {
      return this.enabled && this._fadeTimeState > 0;
    }
    set dirty(e2) {
      console.warn("FrameFadePlugin.dirty is readonly");
    }
    _update(e2) {
      return !!super._update(e2) && (this.isDisabled() && this.stopTransition(), this._fadeTimeState < 1e-3 && (this._toSaveFrame = false, this._target && this._viewer && (this._viewer.renderer.releaseTempTarget(this._target), this._target = void 0)), true);
    }
    get uiConfig() {
      var e2, t2;
      return null === (t2 = null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.uiConfig;
    }
    disable(e2) {
      this._disabledBy.includes(e2) || this._disabledBy.push(e2);
    }
    enable(e2) {
      const t2 = this._disabledBy.indexOf(e2);
      t2 >= 0 && this._disabledBy.splice(t2, 1);
    }
    isDisabled() {
      return !this.pointerEnabled || this._disabledBy.length > 0 || !this.enabled;
    }
  }
  Oc.PluginType = "FrameFade";
  var Fc = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  }, Uc = n.M8C.degToRad;
  class Nc extends ro {
    constructor(e2 = za, t2 = false, r2 = true, n2 = false) {
      super(), this.enabled = true, this.autoFocus = false, this._onObjectHit = (e3) => {
        this._viewer && (this.enabled ? this.dispatchEvent(e3) : e3.intersects.selectedObject = null);
      }, this._uiConfigChildren = [{ label: "AutoFocus", type: "checkbox", property: [this, "autoFocus"], onChange: () => {
        const e3 = this.getSelectedObject();
        this.autoFocus && e3 && this.setSelectedObject(e3, true);
      } }], e2 && (this._widget = new e2()), this._controls = t2, this._pickUi = r2, this.autoFocus = n2;
    }
    get picker() {
      return this._picker;
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    getSelectedObject() {
      var e2;
      if (this.enabled)
        return (null === (e2 = this._picker) || void 0 === e2 ? void 0 : e2.selectedObject) || void 0;
    }
    setSelectedObject(e2, t2 = false) {
      if (!this.enabled)
        return;
      if (!this._picker)
        return;
      const r2 = this.autoFocus;
      this.autoFocus = false, this._picker.selectedObject = e2 || null, this.autoFocus = r2, (r2 || t2) && this.focusObject(e2);
    }
    async onAdded(e2) {
      await super.onAdded(e2), this._picker = new $o(e2.scene, e2.canvas, void 0, (e3) => {
        var t2, r2;
        if (!e3.material)
          return false;
        let n2 = e3, i2 = false;
        for (; n2; ) {
          if (!n2.visible)
            return false;
          if ("model" === (null !== (t2 = n2.userData.iModel) && void 0 !== t2 ? t2 : n2).assetType && (i2 = true), "widget" === (null !== (r2 = n2.userData.iModel) && void 0 !== r2 ? r2 : n2).assetType)
            return false;
          if (false === n2.userData.userSelectable)
            return false;
          if (false === n2.userData.bboxVisible)
            return false;
          n2 = n2.parent;
        }
        return i2;
      }), this._widget && e2.scene.addWidget(this._widget), this._transformControls = new jc(e2), this._transformControls.enabled = this._controls, this._picker.addEventListener("selectedObjectChanged", (t2) => {
        var r2, n2, i2, s2;
        this.dispatchEvent(t2);
        const o2 = (null === (r2 = this._picker) || void 0 === r2 ? void 0 : r2.selectedObject) || void 0;
        if (this._pickUi) {
          const e3 = null === (n2 = o2) || void 0 === n2 ? void 0 : n2.uiConfig, t3 = this.uiConfig;
          t3.children = [...this._uiConfigChildren], e3 && t3.children.push(e3), null === (i2 = t3.uiRefresh) || void 0 === i2 || i2.call(t3);
        }
        const a2 = this._widget;
        a2 && (o2 ? a2.attach(o2) : a2.detach());
        const l2 = this._transformControls;
        l2 && (null === (s2 = this._viewer) || void 0 === s2 ? void 0 : s2.scene.activeCamera.controls) && (o2 && l2.enabled ? l2.attach(o2) : l2.detach()), e2.setDirty(), this.autoFocus && this.focusObject(o2);
      }), this._picker.addEventListener("hoverObjectChanged", this.dispatchEvent), this._picker.addEventListener("hitObject", this._onObjectHit), e2.scene.addEventListener("select", (e3) => {
        e3.value ? this.setSelectedObject(e3.value, this.autoFocus || e3.focusCamera) : console.warn("e.value must be set for picking");
      }), e2.scene.addEventListener("addSceneObject", async (t2) => {
        var r2, n2, i2;
        const s2 = t2.object, o2 = this.getSelectedObject();
        if (o2 && "material" === (null == s2 ? void 0 : s2.assetType) && "function" == typeof (null == o2 ? void 0 : o2.setMaterial) && (null === (r2 = null == o2 ? void 0 : o2.modelObject) || void 0 === r2 ? void 0 : r2.isMesh) && await e2.confirm("Applying material: Apply material to the selected object?")) {
          const t3 = o2.material;
          if (Array.isArray(t3))
            console.warn("Dropping on material array not yet fully supported."), o2.setMaterial(s2);
          else {
            let r3 = Array.from(null !== (n2 = null == t3 ? void 0 : t3.userData.__appliedMeshes) && void 0 !== n2 ? n2 : []);
            (r3.length > 1 ? !await e2.confirm("Applying material: Apply to all objects using this material?") : r3.length < 1) && (r3 = [o2]);
            for (const e3 of r3)
              e3 && (null === (i2 = e3.setMaterial) || void 0 === i2 || i2.call(e3, s2));
          }
        }
      }), e2.scene.addEventListener("sceneUpdate", (t2) => {
        if (!t2.hierarchyChanged)
          return;
        const r2 = this.getSelectedObject();
        let n2 = false;
        null == r2 || r2.traverseAncestors((t3) => {
          t3 === e2.scene.modelObject && (n2 = true);
        }), n2 || this.setSelectedObject(void 0);
      });
    }
    async focusObject(e2) {
      var t2, r2, n2, i2;
      const s2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("CameraViews");
      await (null == s2 ? void 0 : s2.animateToObject(e2, 4, 1e3, "easeOut", { min: (null !== (i2 = null === (n2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.scene.activeCamera.getControls()) || void 0 === n2 ? void 0 : n2.minDistance) && void 0 !== i2 ? i2 : 0.5) + 0.5, max: 5 }));
    }
    get uiConfig() {
      return this._pickUi ? this._uiConfig ? this._uiConfig : this._uiConfig = { type: "folder", label: "Picker", expanded: true, children: [...this._uiConfigChildren] } : {};
    }
    get transformControls() {
      return this._transformControls;
    }
    get widget() {
      return this._widget;
    }
  }
  Nc.PluginType = "Picking", Fc([Ce(), Je()], Nc.prototype, "enabled", void 0), Fc([Ce()], Nc.prototype, "autoFocus", void 0);
  class jc extends ca {
    constructor(e2) {
      super(e2.scene.activeCamera.cameraObject, e2.canvas), this.modelObject = this, this.assetType = "widget", this._activeCameraChange = this._activeCameraChange.bind(this), this._scene = e2.scene, this._scene.addEventListener("activeCameraChange", this._activeCameraChange), this.visible = false, this.userData.bboxVisible = false, this.addEventListener("objectChange", () => {
        var e3;
        null === (e3 = null == this ? void 0 : this.object) || void 0 === e3 || e3.dispatchEvent({ type: "objectUpdate", fadeFrame: false });
      }), this.addEventListener("dragging-changed", (t2) => {
        const r2 = null == e2 ? void 0 : e2.getPlugin(Oc);
        r2 && (r2.enabled = !t2.value), this._scene.activeCamera.interactionsEnabled = !t2.value;
      }), this._keyDownListener = this._keyDownListener.bind(this), window.addEventListener("keydown", this._keyDownListener), window.addEventListener("keyup", this._keyUpListener), this._scene.addWidget(this);
    }
    _keyDownListener(e2) {
      if (this.enabled && this.object) {
        switch (e2.keyCode) {
          case 81:
            this.setSpace("local" === this.space ? "world" : "local");
            break;
          case 16:
            this.setTranslationSnap(100), this.setRotationSnap(Uc(15)), this.setScaleSnap(0.25);
            break;
          case 87:
            this.setMode("translate");
            break;
          case 69:
            this.setMode("rotate");
            break;
          case 82:
            this.setMode("scale");
            break;
          case 187:
          case 107:
            this.setSize(this.size + 0.1);
            break;
          case 189:
          case 109:
            this.setSize(Math.max(this.size - 0.1, 0.1));
            break;
          case 88:
            this.showX = !this.showX;
            break;
          case 89:
            this.showY = !this.showY;
            break;
          case 90:
            this.showZ = !this.showZ;
            break;
          case 32:
            this.enabled = !this.enabled;
            break;
          default:
            return;
        }
        this._scene.setDirty({ sceneUpdate: true, frameFade: true });
      }
    }
    _keyUpListener(e2) {
      this.enabled && (16 === e2.keyCode && (this.setTranslationSnap(null), this.setRotationSnap(null), this.setScaleSnap(null)), this.object && e2.keyCode);
    }
    _activeCameraChange() {
      this.camera = this._scene.activeCamera.cameraObject;
    }
    dispose() {
      window.removeEventListener("keydown", this._keyDownListener), window.removeEventListener("keyup", this._keyUpListener), this._scene.removeEventListener("activeCameraChange", this._activeCameraChange), this._scene.modelObject.remove(this), super.dispose();
    }
  }
  var zc = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class Gc extends ro {
    constructor() {
      super(), this.offsetCache = {}, this.enabled = true, this.envMap = null, this.forceSceneEnvMap = false, this.getEnvMap = () => {
        var e2;
        return !this.forceSceneEnvMap && this.envMap ? this.envMap : (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.getEnvironment()) || null;
      }, this._modelProcessor = { forAssetType: "model", processAsync: async (e2, t2) => {
        const r2 = [];
        return e2.modelObject.traverse((e3) => {
          var t3, n2, i2, s2;
          const o2 = null === (n2 = null === (t3 = e3.userData) || void 0 === t3 ? void 0 : t3.gltfExtensions) || void 0 === n2 ? void 0 : n2[Gc.DIAMOND_GLTF_EXTENSION];
          o2 && e3.geometry && (this.prepareDiamondMesh(e3, o2), delete e3.userData.gltfExtensions[Gc.DIAMOND_GLTF_EXTENSION]), e3.material && !r2.includes(e3.material) && (null === (s2 = null === (i2 = e3.material.userData) || void 0 === i2 ? void 0 : i2.gltfExtensions) || void 0 === s2 ? void 0 : s2[Gc.DIAMOND_GLTF_EXTENSION]) && (e3.material.materialObject || console.warn("material not processed", e3.material), r2.push(e3.material));
        }), r2.forEach((e3) => {
          const t3 = e3.userData.gltfExtensions[Gc.DIAMOND_GLTF_EXTENSION];
          t3 && this._convertToDiamondMaterial(e3, t3);
        }), e2;
      } }, this.uiConfig = { type: "folder", label: "Diamonds", children: [{ type: "toggle", label: "Use Scene Environment", property: [this, "forceSceneEnvironment"], limitedUi: true }, { type: "image", label: "Environment", hidden: () => this.forceSceneEnvMap, property: [this, "envMap"], limitedUi: true }, { type: "slider", bounds: [0, 2 * Math.PI], hidden: () => this.forceSceneEnvMap, label: "Env Rotation", property: [this, "envMapRotation"], limitedUi: true }, { type: "button", label: "Make Diamond", hidden: () => {
        var e2, t2, r2;
        const n2 = null === (r2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Nc)) || void 0 === t2 ? void 0 : t2.getSelectedObject()) || void 0 === r2 ? void 0 : r2.material;
        return !!Array.isArray(n2) || (null == n2 ? void 0 : n2.typeSlug) !== Kt.TypeSlug;
      }, value: async () => {
        var e2, t2, r2, n2, i2, s2;
        const o2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Nc)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
        if (!(null == o2 ? void 0 : o2.material))
          return;
        const a2 = await (null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.prompt("Cache key: Enter optional cache key unique to the diamond shape.", "", false));
        let l2 = parseInt(await (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.prompt("Cache size: Enter size of the cache [64-1024]", "512", false)) || "512");
        isFinite(l2) || (l2 = 512), l2 < 64 && (l2 = 64), (null === (i2 = o2.material.userData) || void 0 === i2 ? void 0 : i2.__appliedMeshes.size) > 1 && await (null === (s2 = this._viewer) || void 0 === s2 ? void 0 : s2.confirm("Convert all: Apply diamond material to all the meshes with the same material?")) ? this.makeDiamond(o2.material, { cacheKey: a2 || void 0, normalMapRes: l2 }, {}) : this.makeDiamondMesh(o2, { cacheKey: a2 || void 0, normalMapRes: l2 }, {}), this.refreshUi();
      }, limitedUi: true }, { type: "button", label: "Make Standard", hidden: () => {
        var e2, t2, r2;
        const n2 = null === (r2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Nc)) || void 0 === t2 ? void 0 : t2.getSelectedObject()) || void 0 === r2 ? void 0 : r2.material;
        return !!Array.isArray(n2) || (null == n2 ? void 0 : n2.typeSlug) !== Zo.TypeSlug;
      }, value: async () => {
        var e2, t2, r2, n2, i2, s2, o2, a2;
        const l2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Nc)) || void 0 === t2 ? void 0 : t2.getSelectedObject(), c2 = null == l2 ? void 0 : l2.material;
        if (!c2)
          return;
        const u2 = c2.userData._baseMaterial;
        let h2 = null === (i2 = null === (n2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.getManager()) || void 0 === n2 ? void 0 : n2.materials) || void 0 === i2 ? void 0 : i2.findMaterial(u2);
        if (h2 && !h2.isDiamondMaterial || (h2 = null === (s2 = this._viewer) || void 0 === s2 ? void 0 : s2.createPhysicalMaterial({ color: c2.color })), h2) {
          const e3 = c2.userData.__appliedMeshes.size > 1 && await (null === (o2 = this._viewer) || void 0 === o2 ? void 0 : o2.confirm("Convert all with this material?")) ? Array.from(c2.userData.__appliedMeshes) : [l2];
          for (const t3 of e3)
            null === (a2 = null == t3 ? void 0 : t3.setMaterial) || void 0 === a2 || a2.call(t3, h2);
        }
        this.refreshUi();
      }, limitedUi: true }] }, this.refreshEnvMaps = this.refreshEnvMaps.bind(this), this.refreshUi = this.refreshUi.bind(this);
    }
    get envMapRotation() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this.envMap) || void 0 === e2 ? void 0 : e2.rotation) && void 0 !== t2 ? t2 : 0;
    }
    set envMapRotation(e2) {
      var t2;
      const r2 = this.envMap;
      r2 && (r2.rotation = e2, null === (t2 = this._viewer) || void 0 === t2 || t2.scene.setDirty());
    }
    refreshEnvMaps() {
      var e2, t2, r2;
      if (!this._viewer)
        return;
      const n2 = this.getEnvMap(), i2 = (null === (t2 = null === (e2 = this._viewer.getPlugin(to)) || void 0 === e2 ? void 0 : e2.materials) || void 0 === t2 ? void 0 : t2.getMaterialsOfType(Zo.TypeSlug)) || [];
      for (const e3 of i2)
        e3 && e3.envMap !== n2 && (e3.envMap = n2, e3.needsUpdate = true);
      null === (r2 = this._viewer) || void 0 === r2 || r2.scene.setDirty();
    }
    refreshUi() {
      var e2, t2, r2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty(), null === (r2 = null === (t2 = this.uiConfig) || void 0 === t2 ? void 0 : t2.uiRefresh) || void 0 === r2 || r2.call(t2, "postFrame", true);
    }
    async onAdded(e2) {
      var t2, r2, n2, i2, s2, o2;
      this._normalCapture = new Ho(e2.renderer), this.offsetCache = {}, e2.scene.addEventListener("environmentChanged", this.refreshEnvMaps);
      const a2 = e2.getPlugin(to);
      null === (t2 = null == a2 ? void 0 : a2.importer) || void 0 === t2 || t2.processors.add("model", this._modelProcessor), null === (r2 = e2.getPlugin(Nc)) || void 0 === r2 || r2.addEventListener("selectedObjectChanged", this.refreshUi);
      const l2 = this.getEnvMap, c2 = new ir(class extends ur {
        async loadAsync(e3, t3) {
          var r3;
          const n3 = await super.loadAsync(e3, t3);
          return n3.type === Zo.TYPE || n3.isDiamondMaterialParameters ? (n3.envMap = l2(), null === (r3 = null == a2 ? void 0 : a2.materials) || void 0 === r3 ? void 0 : r3.generateFromTemplate("diamond", n3)) : (console.error("Invalid material type for Diamond Material.", n3), null);
        }
      }, [Zo.TypeSlug], false);
      return Js.Importers.push(c2), null === (s2 = null === (i2 = null === (n2 = null == a2 ? void 0 : a2.exporter) || void 0 === n2 ? void 0 : n2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(Vc), null === (o2 = null == a2 ? void 0 : a2.materials) || void 0 === o2 || o2.registerMaterialTemplate({ name: "diamond", materialType: Zo.TYPE, isDiamondMaterialParameters: true, generator: (e3, t3) => {
        const r3 = new Zo(e3);
        return r3.envMap = l2(), t3 && t3 !== {} && r3.copyProps(t3), r3;
      } }), super.onAdded(e2);
    }
    async onRemove(e2) {
      var t2, r2, n2, i2;
      return null === (t2 = this._normalCapture) || void 0 === t2 || t2.dispose(), this._normalCapture = void 0, this.offsetCache = {}, null === (n2 = null === (r2 = e2.getPlugin(to)) || void 0 === r2 ? void 0 : r2.importer) || void 0 === n2 || n2.processors.remove("model", this._modelProcessor), null === (i2 = e2.getPlugin(Nc)) || void 0 === i2 || i2.removeEventListener("selectedObjectChanged", this.refreshUi), super.onRemove(e2);
    }
    prepareDiamondMesh(e2, { cacheKey: t2, normalMapRes: r2 }) {
      var n2, i2, s2;
      e2.userData._diamondCacheKey = null != t2 ? t2 : e2.userData._diamondCacheKey, e2.userData._diamondNormalMapRes = null != r2 ? r2 : e2.userData._diamondNormalMapRes, t2 = t2 && t2.length > 0 ? t2.includes(";" + e2.geometry.uuid) ? t2 : t2 + ";" + e2.geometry.uuid : e2.geometry.uuid, this._computeOffsets(e2.geometry, e2.geometry.uuid);
      const o2 = null !== (i2 = null === (n2 = this._normalCapture) || void 0 === n2 ? void 0 : n2.captureNormalMap(e2.geometry, t2, r2)) && void 0 !== i2 ? i2 : [void 0, false], a2 = null === (s2 = this._viewer) || void 0 === s2 ? void 0 : s2.getPluginByType("debug");
      a2 && o2 && (a2.counters.normalsCapture || (a2.counters.normalsCapture = 0), a2.counters.normalsCapture++, console.log("DEBUG: new normal map captured", a2.counters.normalsCapture, t2), a2.addTexture("normal" + a2.counters.normalsCapture, () => {
        var t3;
        return null === (t3 = e2.geometry.userData._normalsCaptureMap) || void 0 === t3 ? void 0 : t3.texture;
      }, [40, 110 * a2.counters.normalsCapture - 100, 200, 100], void 0, void 0, "postRender", true));
    }
    makeDiamond(e2, t2, r2) {
      var n2, i2;
      Array.from(null !== (n2 = null == e2 ? void 0 : e2.userData.__appliedMeshes) && void 0 !== n2 ? n2 : []).forEach((e3) => {
        (null == e3 ? void 0 : e3.isMesh) && e3.geometry && this.prepareDiamondMesh(e3, t2);
      }), this._convertToDiamondMaterial(e2, r2), null === (i2 = this._viewer) || void 0 === i2 || i2.setDirty();
    }
    makeDiamondMesh(e2, t2, r2) {
      if (!e2.modelObject.isMesh || !e2.geometry || !e2.setMaterial)
        return;
      this.prepareDiamondMesh(e2.modelObject, t2);
      const n2 = Array.isArray(e2.material) ? e2.material[0] : e2.material, i2 = this._convertToDiamondMaterial(n2, r2, false);
      e2.setMaterial(i2);
    }
    _convertToDiamondMaterial(e2, t2 = { isDiamond: true }, r2 = true) {
      var i2, s2, o2, a2, l2, c2, u2;
      let h2 = { ...null != t2 ? t2 : {} };
      h2.isDiamond || h2.isDiamondMaterialParameters ? Array.isArray(h2.boostFactors) && (h2.boostFactors = new n.Pa4().fromArray(h2.boostFactors)) : h2 = { isDiamondMaterialParameters: true }, h2.color = null !== (o2 = null !== (i2 = h2.color) && void 0 !== i2 ? i2 : null === (s2 = null == e2 ? void 0 : e2.materialObject) || void 0 === s2 ? void 0 : s2.color) && void 0 !== o2 ? o2 : new Ae(1, 1, 1);
      const p2 = null === (c2 = null === (l2 = null === (a2 = this._viewer) || void 0 === a2 ? void 0 : a2.getManager()) || void 0 === l2 ? void 0 : l2.materials) || void 0 === c2 ? void 0 : c2.generateFromTemplate("diamond", h2);
      if (p2 && e2 && !e2.isDiamondMaterial && (p2.userData._baseMaterial = e2.uuid), r2) {
        const r3 = (e3) => {
          var t3;
          return null !== (t3 = e3.setMaterial) && void 0 !== t3 ? t3 : (t4) => {
            e3.material = t4.materialObject;
          };
        };
        Array.from(null !== (u2 = null == e2 ? void 0 : e2.userData.__appliedMeshes) && void 0 !== u2 ? u2 : []).forEach((e3) => {
          r3(e3)(p2), this.prepareDiamondMesh(e3, t2);
        });
      }
      return p2;
    }
    _computeOffsets(e2, t2, r2 = false) {
      const i2 = t2.split(";").find((e3) => this.offsetCache[e3]);
      if (i2 && !r2) {
        const r3 = this.offsetCache[i2];
        return t2.split(";").forEach((e3) => e3 !== i2 && (this.offsetCache[e3] = r3)), e2.userData._normalsCaptureOffsets = r3, r3;
      }
      e2.computeBoundingBox();
      const s2 = e2.boundingBox.getCenter(new n.Pa4()), o2 = Yo(e2), a2 = o2.clone().invert(), l2 = { center: s2, offsetMatrix: o2, offsetMatrixInv: a2, radius: 1, centerOffset: new n.Pa4().copy(s2).applyMatrix4(a2) };
      return t2.split(";").forEach((e3) => this.offsetCache[e3] = l2), e2.userData._normalsCaptureOffsets = l2, l2;
    }
  }
  Gc.PluginType = "Diamond", Gc.DIAMOND_GLTF_EXTENSION = "WEBGI_materials_diamond", zc([M(Gc.prototype.refreshEnvMaps), Ce()], Gc.prototype, "envMap", void 0), zc([M(Gc.prototype.refreshEnvMaps), Ce()], Gc.prototype, "forceSceneEnvMap", void 0);
  const Vc = (e2) => ({ writeMaterial: (t2, r2) => {
    t2.isDiamondMaterial && (r2.extensions = r2.extensions || {}, r2.extensions[Gc.DIAMOND_GLTF_EXTENSION] = t2.toJSON(), e2.extensionsUsed[Gc.DIAMOND_GLTF_EXTENSION] = true);
  }, writeMesh: (t2, r2) => {
    var n2, i2;
    if (!(null == t2 ? void 0 : t2.material.isDiamondMaterial))
      return;
    r2.extensions = r2.extensions || {};
    const s2 = {};
    null === (i2 = null === (n2 = t2.userData) || void 0 === n2 ? void 0 : n2.gltfExtensions) || void 0 === i2 || delete i2[Gc.DIAMOND_GLTF_EXTENSION], t2.userData._diamondNormalMapRes && (s2.normalMapRes = t2.userData._diamondNormalMapRes), t2.userData._diamondCacheKey && (s2.cacheKey = t2.userData._diamondCacheKey), r2.extensions[Gc.DIAMOND_GLTF_EXTENSION] = s2, e2.extensionsUsed[Gc.DIAMOND_GLTF_EXTENSION] = true;
  } });
  var Qc, Hc = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let Wc = Qc = class extends ro {
    constructor() {
      super(), this.enabled = true, this.animations = [], this.loopAnimations = true, this.loopRepetitions = 1 / 0, this.timeScale = 0, this.animateOnScroll = false, this.animationSpeed = 1, this._scrollAnimationState = 0, this.scrollAnimationDamping = 0.1, this.dependencies = [to], this._lastFrameTime = 0, this._fadeDisabled = false, this._objectAdded = (e2) => {
        const t2 = e2.object;
        "model" === t2.assetType && t2.modelObject && this._viewer && t2.modelObject.traverse((e3) => {
          const t3 = e3.animations;
          if (t3.length < 1)
            return;
          const r2 = Math.max(...t3.map((e4) => e4.duration));
          t3.forEach((e4) => e4.duration = r2);
          const i2 = new n.Xcj(this._viewer.scene.modelRoot.modelObject), s2 = t3.map((e4) => i2.clipAction(e4).setLoop(this.loopAnimations ? n.YKA : n.jAl, this.loopRepetitions));
          this.animations.push({ mixer: i2, clips: t3, actions: s2, duration: r2 }), this.onPropertyChange();
        });
      }, this._animationTime = 0, this._animationDuration = 0, this._animationState = "none", this.uiConfig = void 0, this._lastAnimId = "", this.timelineMarkers = [], this._postFrame = this._postFrame.bind(this), this._wheel = this._wheel.bind(this), this.playClips = this.playClips.bind(this), this.playClip = this.playClip.bind(this), this.playAnimation = this.playAnimation.bind(this), this.playPauseAnimation = this.playPauseAnimation.bind(this), this.pauseAnimation = this.pauseAnimation.bind(this), this.stopAnimation = this.stopAnimation.bind(this), this.resetAnimation = this.resetAnimation.bind(this), this.onPropertyChange = this.onPropertyChange.bind(this), this._loaderCreate = this._loaderCreate.bind(this);
    }
    get animationState() {
      return this._animationState;
    }
    get animationTime() {
      return this._animationTime;
    }
    get animationDuration() {
      return this._animationDuration;
    }
    _wheel({ deltaY: e2 }) {
      this.enabled && Math.abs(e2) > 1e-3 && (this._scrollAnimationState = -1 * Math.sign(e2));
    }
    _postFrame() {
      var e2, t2;
      if (!this._viewer)
        return;
      const r2 = this._viewer, n2 = this.animateOnScroll;
      if (!this.enabled || this.animations.length < 1 || "playing" !== this._animationState && !n2)
        return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e2 = this._viewer.getPluginByType("FrameFade")) || void 0 === e2 || e2.enable(Qc.PluginType), this._fadeDisabled = false));
      const i2 = Dt() / 1e3;
      this._lastFrameTime < 1 && (this._lastFrameTime = i2 - 1 / 30);
      let s2 = i2 - this._lastFrameTime;
      if (s2 *= this.animationSpeed, this._lastFrameTime = i2, n2 && (s2 *= this._scrollAnimationState), Math.abs(s2) < 1e-4)
        return;
      const o2 = null === (t2 = this._viewer.getPluginByType("Progressive")) || void 0 === t2 ? void 0 : t2.postFrameConvergedRecordingDelta();
      if (o2 && o2 > 0 && (s2 = o2), 0 !== o2 && (this.animations.map((e3) => e3.mixer.update(s2)), this._animationTime += s2, this._animationTime > this._animationDuration && (this._animationTime -= this._animationDuration), this._animationTime < 0 && (this._animationTime += this._animationDuration), this._scrollAnimationState < 1e-3 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping, r2.scene.activeCamera.cameraObject.userData.__animatingCamera && r2.scene.activeCamera.setDirty(), r2.renderer.resetShadows(), r2.setDirty(), !this._fadeDisabled)) {
        const e3 = this._viewer.getPluginByType("FrameFade");
        e3 && (e3.disable(Qc.PluginType), this._fadeDisabled = true);
      }
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new qc(e3, this));
    }
    async onAdded(e2) {
      var t2, r2, n2, i2, s2, o2;
      null === (r2 = null === (t2 = e2.getPlugin(to)) || void 0 === t2 ? void 0 : t2.importer) || void 0 === r2 || r2.addEventListener("loaderCreate", this._loaderCreate), e2.scene.addEventListener("addSceneObject", this._objectAdded), null === (o2 = null === (s2 = null === (i2 = null === (n2 = e2.getPlugin(to)) || void 0 === n2 ? void 0 : n2.exporter) || void 0 === i2 ? void 0 : i2.getExporter("gltf", "glb")) || void 0 === s2 ? void 0 : s2.extensions) || void 0 === o2 || o2.push(Xc), e2.addEventListener("postFrame", this._postFrame), window.addEventListener("wheel", this._wheel);
      let a2 = -1;
      return Object.defineProperty(e2.scene.modelRoot, "currentTimelineMarker", { get: () => a2, set: (t3) => e2.scene.modelRoot.dispatchEvent({ type: "animationTimelineMarker", marker: this.timelineMarkers[a2 = t3] }) }), e2.scene.modelRoot.addEventListener("animationTimelineMarker", ({ marker: e3 }) => {
        var t3;
        if (!this._viewer)
          return;
        if (!e3)
          return this._viewer.scene.activeCamera = null === (t3 = this._viewer) || void 0 === t3 ? void 0 : t3.scene.defaultCamera, void this._viewer.setDirty();
        const r3 = e3.camera;
        r3 && (r3.userData.__animatingCamera = true, this._viewer.scene.activeCamera = this._viewer.createCamera(r3));
      }), super.onAdded(e2);
    }
    async onRemove(e2) {
      var t2, r2;
      return e2.scene.removeEventListener("addSceneObject", this._objectAdded), null === (r2 = null === (t2 = e2.getPlugin(to)) || void 0 === t2 ? void 0 : t2.importer) || void 0 === r2 || r2.addEventListener("loaderCreate", this._loaderCreate), e2.removeEventListener("postFrame", this._postFrame), window.removeEventListener("wheel", this._wheel), super.onRemove(e2);
    }
    onPropertyChange() {
      "playing" === this._animationState && this.playAnimation(), this._animationDuration = Math.max(...this.animations.map(({ duration: e2 }) => e2));
    }
    onStateChange() {
      var e2, t2;
      null === (t2 = null === (e2 = this.uiConfig) || void 0 === e2 ? void 0 : e2.children) || void 0 === t2 || t2.map((e3) => e3 && A(e3)).flat(2).forEach((e3) => {
        var t3;
        return null === (t3 = null == e3 ? void 0 : e3.uiRefresh) || void 0 === t3 ? void 0 : t3.call(e3);
      });
    }
    playPauseAnimation() {
      "playing" === this._animationState ? this.pauseAnimation() : this.playAnimation();
    }
    async playClip(e2, t2 = false) {
      return this.playClips([e2], t2);
    }
    async playClips(e2, t2 = false) {
      const r2 = [];
      return this.animations.forEach(({ actions: t3 }) => {
        t3.forEach((t4) => {
          e2.includes(t4.getClip().name) && r2.push(t4);
        });
      }), this.playAnimation(t2, r2);
    }
    async playAnimation(e2 = false, t2) {
      var r2, i2, s2;
      if (!this.enabled)
        return;
      "playing" === this._animationState && this.stopAnimation(false), _(null === (i2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.getPluginByType("Picking")) || void 0 === i2 ? void 0 : i2.transformControls, "enabled", false);
      let o2 = 0;
      t2 || (t2 = [], this.animations.forEach(({ mixer: e3, actions: r3, clips: n2 }) => {
        t2.push(...r3);
      }));
      const a2 = Xe();
      this._lastAnimId = a2, "paused" !== this._animationState && this.resetAnimation();
      for (const e3 of t2)
        this.timeScale > 0 && (e3.timeScale = this.timeScale), e3.setLoop(this.loopAnimations ? n.YKA : n.jAl, this.loopRepetitions), e3.play(), o2 = Math.max(o2, e3.getClip().duration / e3.timeScale);
      if (this._animationState = "playing", null === (s2 = this._viewer) || void 0 === s2 || s2.setDirty(), o2 *= this.loopAnimations ? this.loopRepetitions : 1, o2 /= this.animationSpeed, !isFinite(o2))
        return;
      const l2 = 1e3 * o2 - this._animationTime / this.animationSpeed + 0.01;
      l2 > 0 && await Dc(l2), a2 === this._lastAnimId && this.stopAnimation(e2);
    }
    pauseAnimation() {
      var e2, t2, r2;
      this._animationState = "paused", _(null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("Picking")) || void 0 === t2 ? void 0 : t2.transformControls, "enabled", true), null === (r2 = this._viewer) || void 0 === r2 || r2.setDirty(), this._lastAnimId = "";
    }
    stopAnimation(e2 = false) {
      var t2, r2, n2;
      this._animationState = "stopped", _(null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Picking"), "enabled", true), e2 ? this.resetAnimation() : null === (r2 = this._viewer) || void 0 === r2 || r2.setDirty(), this._lastAnimId = "", this._viewer && this._fadeDisabled && (null === (n2 = this._viewer.getPluginByType("FrameFade")) || void 0 === n2 || n2.enable(Qc.PluginType), this._fadeDisabled = false);
    }
    resetAnimation() {
      var e2;
      "stopped" === this._animationState ? (this.animations.forEach(({ mixer: e3, actions: t2, clips: r2 }) => {
        e3.stopAllAction(), e3.setTime(0);
      }), this._animationTime = 0, null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty()) : this.stopAnimation(true);
    }
  };
  Wc.PluginType = "GLTFAnimation", Wc.AnimationMarkersExtension = "WEBGI_animation_markers", Hc([Ze()], Wc.prototype, "animationState", null), Hc([Ze()], Wc.prototype, "animationTime", null), Hc([Ze()], Wc.prototype, "animationDuration", null), Hc([M(Qc.prototype.onPropertyChange), Je("Loop", { limitedUi: true })], Wc.prototype, "loopAnimations", void 0), Hc([M(Qc.prototype.onPropertyChange)], Wc.prototype, "loopRepetitions", void 0), Hc([M(Qc.prototype.onPropertyChange)], Wc.prototype, "timeScale", void 0), Hc([Je(), Ce()], Wc.prototype, "animateOnScroll", void 0), Hc([$e("Speed", [0.1, 4], 0.1, { limitedUi: true }), Ce()], Wc.prototype, "animationSpeed", void 0), Hc([M(Qc.prototype.onStateChange)], Wc.prototype, "_animationState", void 0), Hc([rt("Play/Pause", (e2) => ({ label: () => "playing" === e2.animationState ? "Pause" : "Play", limitedUi: true }))], Wc.prototype, "playPauseAnimation", null), Hc([rt("Stop", { limitedUi: true })], Wc.prototype, "stopAnimation", null), Hc([rt("Reset", { limitedUi: true })], Wc.prototype, "resetAnimation", null), Wc = Qc = Hc([lt("GLTF Animations")], Wc);
  class qc {
    constructor(e2, t2) {
      this.parser = e2, this.name = Wc.AnimationMarkersExtension, this.plugin = t2;
    }
    async afterRoot(e2) {
      var t2;
      let r2 = [];
      for (const e3 of this.parser.json.scenes) {
        if (!e3.extensions)
          continue;
        const t3 = e3.extensions[this.name];
        for (const e4 of (null == t3 ? void 0 : t3.markers) || []) {
          const t4 = void 0 !== e4.camera ? await this.parser.getDependency("camera", e4.camera) : void 0;
          if (void 0 === e4.time) {
            const t5 = 30;
            e4.time = e4.frame / t5, console.error("Update timeline markers plugin for correct times.");
          }
          r2.push({ name: e4.name, frame: e4.frame, time: e4.time, camera: t4 });
        }
      }
      if (r2.length < 1)
        return;
      r2 = r2.sort((e3, t3) => e3.frame - t3.frame);
      const i2 = null !== (t2 = e2.scene) && void 0 !== t2 ? t2 : e2.scenes[0];
      if (!i2)
        return;
      i2.userData.__markers = r2;
      const s2 = this.plugin.timelineMarkers, o2 = r2.map((e3) => e3.time);
      let a2 = s2.length;
      const l2 = r2.map((e3) => a2++), c2 = Math.max(...o2) + 0.01;
      s2.push(...r2);
      const u2 = new n.dUE(".currentTimelineMarker", o2, l2, 2300), h2 = new n.m7l("animationTimelineMarker", c2, [u2]);
      h2.__gltfExport = false, e2.animations.push(h2);
    }
  }
  const Xc = (e2) => ({ afterParse(t2) {
    const r2 = e2.json.scenes[e2.json.scene || 0];
    r2.extensions = r2.extensions || {};
    const n2 = { markers: [] }, i2 = [];
    if ((Array.isArray(t2) ? t2 : [t2]).forEach((e3) => e3.traverse((e4) => {
      e4.userData.__markers && i2.push(...e4.userData.__markers);
    })), i2.sort((e3, t3) => e3.frame - t3.frame), !(i2.length < 1)) {
      for (const t3 of i2) {
        const r3 = t3.camera;
        if (r3) {
          const i3 = e2.nodeMap.get(r3);
          if (void 0 === i3) {
            console.warn("Camera not found in gltf export", r3, e2.nodeMap);
            continue;
          }
          const s2 = e2.json.nodes[i3].camera;
          t3.camera = s2, n2.markers.push(t3);
        }
      }
      r2.extensions[Wc.AnimationMarkersExtension] = n2, e2.extensionsUsed[Wc.AnimationMarkersExtension] = true;
    }
  } });
  class Yc extends r {
    constructor() {
      super(...arguments), this.dirty = false, this.counters = {}, this._generators = /* @__PURE__ */ new Map(), this._preRender = () => this._showDebug("preRender"), this._postRender = () => this._showDebug("postRender");
    }
    async onAdded(e2) {
      this._viewer = e2, e2.addEventListener("preRender", this._preRender), e2.addEventListener("postRender", this._postRender);
    }
    addTexture(e2, t2, r2, s2, o2, a2 = "postRender", l2 = false) {
      var c2;
      this._generators.has(a2) || this._generators.set(a2, []), null === (c2 = this._generators.get(a2)) || void 0 === c2 || c2.push({ key: e2, fn: t2, rect: r2 ? [...r2] : void 0, frag: o2 || s2 || l2 ? new n.jyz({ vertexShader: i.vertexShader, uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, fragmentShader: null != o2 ? o2 : `
        #include <common>
        #include <packing>
        uniform float opacity;
		uniform ${l2 ? "samplerCube" : "sampler2D"} tDiffuse;
		varying vec2 vUv;
		void main() {
			vec4 texel = ${l2 ? "textureCube( tDiffuse, vec3(cos(vUv.y * PI2) * cos(vUv.x * PI2), sin(vUv.y * PI2), cos(vUv.y * PI2) * sin(vUv.x * PI2)) )" : "texture2D( tDiffuse, vUv )"};
			${null != s2 ? s2 : ""}
			gl_FragColor = opacity * texel;
		}
            ` }) : void 0 });
    }
    removeTexture(e2, t2 = "postRender") {
      var r2, n2;
      this._generators.set(t2, null !== (n2 = null === (r2 = this._generators.get(t2)) || void 0 === r2 ? void 0 : r2.filter((t3) => t3.key !== e2)) && void 0 !== n2 ? n2 : []);
    }
    async onDispose(e2) {
      return Promise.resolve(void 0);
    }
    async onRemove(e2) {
      return e2.removeEventListener("preRender", this._preRender), e2.removeEventListener("postRender", this._postRender), this._viewer = void 0, Promise.resolve(void 0);
    }
    _showDebug(e2) {
      var t2;
      const r2 = this._viewer, n2 = null == r2 ? void 0 : r2.renderer;
      n2 && r2 && (null === (t2 = this._generators.get(e2)) || void 0 === t2 || t2.forEach(({ key: e3, fn: t3, rect: i2, frag: s2 }) => {
        const o2 = t3(r2);
        if (o2) {
          if (o2.image && i2) {
            const e4 = o2.image.width / o2.image.height;
            i2[2] < 1 && i2[3] < 1 && (i2[2] = 200), i2[2] < 1 && (i2[2] = i2[3] * e4), i2[3] < 1 && (i2[3] = i2[2] / e4);
          }
          n2.blit(o2, void 0, { viewport: i2, clear: false, material: s2 });
        }
      }));
    }
  }
  Yc.PluginType = "debug";
  var Kc = function(e2, t2) {
    return Kc = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
      e3.__proto__ = t3;
    } || function(e3, t3) {
      for (var r2 in t3)
        Object.prototype.hasOwnProperty.call(t3, r2) && (e3[r2] = t3[r2]);
    }, Kc(e2, t2);
  };
  function Jc(e2, t2) {
    if ("function" != typeof t2 && null !== t2)
      throw new TypeError("Class extends value " + String(t2) + " is not a constructor or null");
    function r2() {
      this.constructor = e2;
    }
    Kc(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
  }
  var Zc, $c = function() {
    function e2() {
    }
    return e2._xfnv1a = function(e3) {
      for (var t2 = 2166136261, r2 = 0; r2 < e3.length; r2++)
        t2 = Math.imul(t2 ^ e3.charCodeAt(r2), 16777619);
      return function() {
        return t2 += t2 << 13, t2 ^= t2 >>> 7, t2 += t2 << 3, t2 ^= t2 >>> 17, (t2 += t2 << 5) >>> 0;
      };
    }, e2;
  }(), eu = function(e2) {
    function t2(r2) {
      var n2 = e2.call(this) || this;
      return n2.a = t2._xfnv1a(r2)(), n2;
    }
    return Jc(t2, e2), t2.prototype.next = function() {
      var e3 = this.a += 1831565813;
      return e3 = Math.imul(e3 ^ e3 >>> 15, 1 | e3), (((e3 ^= e3 + Math.imul(e3 ^ e3 >>> 7, 61 | e3)) ^ e3 >>> 14) >>> 0) / 4294967296;
    }, t2;
  }($c), tu = function(e2) {
    function t2(r2) {
      var n2 = e2.call(this) || this, i2 = t2._xfnv1a(r2);
      return n2.a = i2(), n2.b = i2(), n2.c = i2(), n2.d = i2(), n2;
    }
    return Jc(t2, e2), t2.prototype.next = function() {
      this.a >>>= 0, this.b >>>= 0, this.c >>>= 0, this.d >>>= 0;
      var e3 = this.a + this.b | 0;
      return this.a = this.b ^ this.b >>> 9, this.b = this.c + (this.c << 3) | 0, this.c = this.c << 21 | this.c >>> 11, this.d = this.d + 1 | 0, e3 = e3 + this.d | 0, this.c = this.c + e3 | 0, (e3 >>> 0) / 4294967296;
    }, t2;
  }($c), ru = function(e2) {
    function t2(r2) {
      var n2 = e2.call(this) || this, i2 = t2._xfnv1a(r2);
      return n2.a = i2(), n2.b = i2(), n2.c = i2(), n2.d = i2(), n2;
    }
    return Jc(t2, e2), t2.prototype.next = function() {
      var e3 = this.b << 9, t3 = 5 * this.a;
      return t3 = t3 << 7 | 9 * (t3 >>> 25), this.c ^= this.a, this.d ^= this.b, this.b ^= this.c, this.a ^= this.d, this.c ^= e3, this.d = this.d << 11 | this.d >>> 21, (t3 >>> 0) / 4294967296;
    }, t2;
  }($c);
  !function(e2) {
    e2.sfc32 = "sfc32", e2.mulberry32 = "mulberry32", e2.xoshiro128ss = "xoshiro128ss";
  }(Zc || (Zc = {}));
  var nu = function() {
    function e2(e3, t2) {
      void 0 === t2 && (t2 = Zc.sfc32), this.str = e3, this.prng = t2, this.generator = this._initializeGenerator();
    }
    return e2.prototype.next = function() {
      return this.generator.next();
    }, e2.prototype._initializeGenerator = function() {
      if (function(e4) {
        return null === e4;
      }(e3 = this.str) || function(e4) {
        return void 0 === e4;
      }(e3))
        return this.wrap();
      var e3;
      switch (this.prng) {
        case "sfc32":
          return new tu(this.str);
        case "mulberry32":
          return new eu(this.str);
        case "xoshiro128ss":
          return new ru(this.str);
        default:
          return this.wrap();
      }
    }, e2.prototype.wrap = function() {
      return { next: function() {
        return Math.random();
      } };
    }, e2;
  }(), iu = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class su extends Ws {
    constructor(e2, t2, r2, i2) {
      super(e2, t2), this._shadowParams = { enabled: true, radius: 2, width: 1024, height: 1024, bias: -1e-3, normalBias: 0, near: 1.5, far: 4, frustumSize: 4 }, this._randomParams = { focus: 1, spread: 0.01, distanceScale: 50, minDistanceScale: new n.Pa4(10, 10, 10), normalDirection: new n.Pa4(0.01, 0.98, 0.01).normalize(), direction: new n.Pa4(-0.9, 0.5, -1) }, this.isRandomizedDirectionalLight = true, this.shadowParams = null != r2 ? r2 : {}, this.randomParams = null != i2 ? i2 : {}, this.updateShadowParams = this.updateShadowParams.bind(this);
    }
    get shadowParams() {
      return this._shadowParams;
    }
    set shadowParams(e2) {
      Object.keys(e2).forEach((t2) => void 0 === e2[t2] && delete e2[t2]), this._shadowParams = { ...this._shadowParams, ...e2 }, this.updateShadowParams();
    }
    get randomParams() {
      return this._randomParams;
    }
    set randomParams(e2) {
      Object.keys(e2).forEach((t2) => void 0 === e2[t2] && delete e2[t2]), Object.assign(this._randomParams, e2);
    }
    updateShadowParams() {
      this.castShadow = this._shadowParams.enabled, this.shadow.mapSize.x = this._shadowParams.width, this.shadow.mapSize.y = this._shadowParams.height, this.shadow.bias = this._shadowParams.bias, this.shadow.normalBias = this._shadowParams.normalBias, this.refreshShadowCamNearFar(), this.shadow.radius = this._shadowParams.radius, this.shadow.camera.right = this._shadowParams.frustumSize / 2, this.shadow.camera.left = -this._shadowParams.frustumSize / 2, this.shadow.camera.top = this._shadowParams.frustumSize / 2, this.shadow.camera.bottom = -this._shadowParams.frustumSize / 2, this.shadow.camera.updateProjectionMatrix(), this.matrixWorldNeedsUpdate = true;
    }
    randomizePosition(e2, t2 = null, r2 = null) {
      const i2 = new nu(e2.toString()), s2 = new n.FM8(i2.next() * Math.PI * 2, Math.asin(2 * i2.next() - 1));
      let o2 = new n.Pa4(Math.cos(s2.x) * Math.cos(s2.y), Math.sin(s2.y), Math.sin(s2.x) * Math.cos(s2.y));
      const a2 = new n.FM8();
      for (let e3 = 0; e3 < 5; e3++) {
        a2.set(i2.next(), i2.next()), o2 = ou(a2, this._randomParams.normalDirection, 0.4), i2.next() < Math.sqrt(null != t2 ? t2 : this._randomParams.focus) && (a2.set(i2.next(), i2.next()), o2 = ou(a2, this._randomParams.direction, Math.pow((null != r2 ? r2 : this._randomParams.spread) / 2, 2)));
        const e4 = o2.dot(this._randomParams.normalDirection);
        if (e4 > 0 && e4 < 0.4)
          break;
      }
      o2.normalize(), o2.multiplyScalar(this._randomParams.distanceScale), this.position.set(0, 0, 0), this.target.position.copy(o2.normalize().negate()), this.target.updateMatrixWorld(), this.refreshShadowCamNearFar(), this.updateMatrixWorld();
    }
    refreshShadowCamNearFar() {
      const e2 = new n.Pa4().subVectors(this.target.position, this.shadow.camera.position).length();
      this.shadow.camera.near = e2 - this._shadowParams.near * this._shadowParams.frustumSize / 2, this.shadow.camera.far = e2 + this._shadowParams.far * this._shadowParams.frustumSize / 2;
    }
    dispose() {
    }
    get uiConfig() {
      if (this._uiConfig)
        return this._uiConfig;
    }
    fromJSON(e2, t2) {
      return super.fromJSON(e2, t2) ? (this.updateShadowParams(), this) : null;
    }
  }
  function ou(e2, t2, r2) {
    t2 = t2.clone().normalize();
    const i2 = new n.Pa4(0, -t2.z, t2.y).normalize(), s2 = new n.Pa4().crossVectors(t2, i2).normalize(), o2 = e2;
    o2.x = 2 * o2.x * Math.PI, o2.y = 1 - o2.y * r2;
    const a2 = Math.sqrt(1 - o2.y * o2.y);
    return i2.multiplyScalar(Math.cos(o2.x) * a2).add(s2.multiplyScalar(Math.sin(o2.x) * a2)).add(t2.multiplyScalar(o2.y));
  }
  iu([Ce("shadowParams")], su.prototype, "_shadowParams", void 0), iu([Ce("randomParams")], su.prototype, "_randomParams", void 0);
  class au extends n.Tn7 {
    constructor() {
      super(...arguments), this.typeSlug = "fsShadow", this.assetType = "material", this._uniforms = {}, this.lastFrameTexture = null;
    }
    get materialObject() {
      return this;
    }
    onBeforeCompile(e2, t2) {
      e2.vertexShader = e2.vertexShader.replace("#include <project_vertex>", "\n#include <project_vertex>\ngl_Position = vec4(uv*2.-1., 0, 1.); \n        "), e2.vertexShader = e2.vertexShader.replace("void main() {", "\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n        "), e2.fragmentShader = e2.fragmentShader.replace("void main() {", "\nvarying vec2 vUv;\nuniform sampler2D tLastThis;\nvoid main() {\n        "), e2.fragmentShader = e2.fragmentShader.replace("gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );", w`
float shadow = getShadowMask();

//shift the color by dither_shift
shadow = clamp(shadow + mix(-1./512., 1./512., rand( gl_FragCoord.xy )), 0., 1.);

float last = unpackRGBAToDepth(texture2D(tLastThis, vUv));
gl_FragColor = packDepthToRGBA(mix(last, shadow, opacity));
//if not useMovingAverage:
//gl_FragColor = packDepthToRGBA(shadow * opacity + last);
        `), Object.assign(e2.uniforms, this._uniforms), super.onBeforeCompile(e2, t2);
    }
    customProgramCacheKey() {
      return super.customProgramCacheKey();
    }
    toJSON(e2) {
      throw new Error("Method not supported for this material.");
    }
    fromJSON(e2, t2) {
      throw new Error("Method not supported for this material.");
    }
    copyProps(e2) {
      throw new Error("Method not supported for this material.");
    }
    setDirty(e2) {
      this.needsUpdate = true, this.dispatchEvent({ ...e2, type: "materialUpdate" });
    }
  }
  !function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, r2, o2);
  }([G({ propKey: "tLastThis" })], au.prototype, "lastFrameTexture", void 0);
  var lu = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class cu {
    constructor(e2) {
      this.enabled = true, this._lightLayer = 5, this._frameNumber = 0, this.maxFrameNumber = 400, this.groundMapMode = "aoMap", this.alphaVignette = true, this.alphaVignetteAxis = "xy", this.shadowAutoUpdate = true, this.materialExtension = { shaderExtender: (e3, t3, r2) => {
        "aoMap" === this.groundMapMode ? e3.fragmentShader = qt(e3.fragmentShader, "#include <aomap_fragment>", qt(n.WdD.aomap_fragment, "float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;", "float ambientOcclusion = ( unpackRGBAToDepth(texture2D( aoMap, vUv2 ) ) - 1.0) * aoMapIntensity + 1.0;")) : "map" === this.groundMapMode ? e3.fragmentShader = qt(e3.fragmentShader, "#include <map_fragment>", qt(n.WdD.map_fragment, "diffuseColor *= sampledDiffuseColor;", "float groundShadow = unpackRGBAToDepth(sampledDiffuseColor); diffuseColor.rgb *= groundShadow; diffuseColor.a *= max(0., 1.-groundShadow);")) : "alphaMap" === this.groundMapMode && (e3.fragmentShader = qt(e3.fragmentShader, "#include <alphamap_fragment>", qt(n.WdD.alphamap_fragment, "texture2D( alphaMap, vUv ).g", "1. - unpackRGBAToDepth( texture2D( alphaMap, vUv ) )", { replaceAll: true }))), this.alphaVignette && r2.capabilities.isWebGL2 && (e3.fragmentShader = qt(e3.fragmentShader, "#include <output_fragment>", w`#include <output_fragment>
                    #ifndef OPAQUE
                    float weight = 0.;
                    #ifdef USE_UV
                    weight = 2.*abs(length(0.5 - vUv.${this.alphaVignetteAxis}));
                    #endif
                    #if defined(USE_LIGHTMAP) || defined(USE_AOMAP)
                    weight = 2.*abs(length(0.5 - vUv2.${this.alphaVignetteAxis}));
                    #endif
                    weight = min(1., max(0., weight))-0.5;
                    weight = min(1., max(0., 1.0-2.*weight));
                    weight = pow(weight, 1.5);
                    gl_FragColor.a *= weight;
                    //gl_FragColor.rgb /= max(0.01, weight);
                    gl_FragColor = saturate(gl_FragColor);
                    //gl_FragColor.a = 0.5;
                    #endif
                    `));
      }, computeCacheKey: () => this.groundMapMode + "." + this.alphaVignette + "." + this.alphaVignetteAxis, onObjectRender: (e3, t3) => {
        t3.materialObject.userData.gMapMode !== this.groundMapMode && (t3.materialObject.userData.gMapMode = this.groundMapMode, t3.materialObject.needsUpdate = true);
      }, isCompatible: (e3) => e3.isMeshStandardMaterial2 }, this._viewer = e2;
      const t2 = new su(16777215, 10, { near: 1.5, far: 20, bias: 0, frustumSize: 4, width: 1024, height: 1024, enabled: true, radius: 10, normalBias: 0 }, { direction: new n.Pa4(0.2, 1, 0.2).normalize(), spread: 0.9, focus: 1, distanceScale: 20, minDistanceScale: new n.Pa4(10, 10, 10), normalDirection: new n.Pa4(0, 1, 0) });
      t2.shadow.camera.updateProjectionMatrix(), t2.layers.disableAll(), t2.layers.set(this._lightLayer), this._light = t2, e2.scene.addLight(this._light, { addToRoot: true }), this._shadowMat = new au({ color: "#ffffff", toneMapped: false, depthWrite: false, depthTest: false, premultipliedAlpha: false, opacity: 1, transparent: false, blending: n.jFi });
    }
    get attachedMesh() {
      return this._attachedMesh;
    }
    set attachedMesh(e2) {
      this._attachedMesh !== e2 && (this._attachedMesh && this.cleanupMaterial(), this._attachedMesh = e2, this._attachedMesh && this._updateMaterial());
    }
    get target() {
      return this._target;
    }
    get light() {
      return this._light;
    }
    dispose() {
      this._shadowMat.dispose(), this._target = void 0, this.reset();
    }
    cleanupMaterial() {
      this._updateMaterial(true);
    }
    _groundMapModeChanged() {
      this._attachedMesh && (this.cleanupMaterial(), this._updateMaterial(), "alphaMap" === this.groundMapMode ? this._attachedMesh.material.transparent = true : this._attachedMesh.material.transparent = false), this.reset();
    }
    _alphaVignetteChanged() {
      var e2, t2, r2;
      null === (t2 = null === (e2 = this.materialExtension) || void 0 === e2 ? void 0 : e2.setDirty) || void 0 === t2 || t2.call(e2), null === (r2 = this._viewer) || void 0 === r2 || r2.setDirty();
    }
    fromJSON(e2, t2) {
      return De(e2, this, true, t2), this.reset(), this;
    }
    reset() {
      this._frameNumber = 0;
    }
    autoUpdateShadow() {
      this.shadowAutoUpdate && this.updateShadow();
    }
    updateShadow() {
      if (!this.enabled)
        return false;
      const e2 = this._attachedMesh;
      if (++this._frameNumber > this.maxFrameNumber || !e2)
        return false;
      const t2 = 1024;
      this._target || (this._target = this._viewer.renderer.createTarget({ type: n.ywz, depthBuffer: false, size: new n.FM8(t2, t2), sizeMultiplier: void 0, encoding: n.rnI, format: n.wk1 })), this._frameNumber < 3 ? this._light.randomizePosition(0, 1, 0) : this._light.randomizePosition(this._frameNumber), e2.castShadow = false;
      const r2 = this._viewer.renderer.rendererObject, i2 = r2.shadowMap, s2 = i2.type, o2 = i2.needsUpdate, a2 = i2.autoUpdate;
      i2.type = n._MY, i2.needsUpdate = true, i2.autoUpdate = false;
      const l2 = this._viewer.scene, c2 = new n.S9g();
      c2.disableAll(), l2.modelObject.traverse((e3) => {
        e3.isLight && e3 !== this._light.lightObject && (e3.userData.__gp_layers = e3.layers, e3.layers = c2);
      });
      const u2 = l2.activeCamera.cameraObject;
      if (0 != (u2.layers.mask & 1 << this._lightLayer))
        throw "Camera can render pseudo directional light, check layers";
      u2.layers.enable(this._lightLayer), e2.layers.disable(this._lightLayer), W(r2, { shadowMapRender: true, backgroundRender: false, sceneRender: false }, () => this._viewer.renderer.renderScene(l2)), u2.layers.disable(this._lightLayer);
      const h2 = u2.layers.mask;
      u2.layers.set(this._lightLayer), e2.layers.enable(this._lightLayer);
      const p2 = this._viewer.renderer.getTempTarget({ type: n.ywz, depthBuffer: false, size: new n.FM8(t2, t2), encoding: n.rnI, format: n.wk1 }), d2 = p2.texture.encoding;
      p2.texture.encoding = n.rnI, this._viewer.renderer.blit(this._target.texture, p2, { clear: true });
      {
        const t3 = l2.modelObject.environment, n2 = l2.modelObject.background, i3 = e2.material, s3 = e2.frustumCulled, o3 = r2.getRenderTarget(), a3 = r2.getActiveCubeFace(), c3 = r2.getActiveMipmapLevel();
        l2.modelObject.background = null, l2.modelObject.environment = null, e2.material = this._shadowMat, e2.frustumCulled = false, r2.setRenderTarget(this._target);
        const u3 = false;
        this._shadowMat.opacity = u3 ? 1 / this.maxFrameNumber : Math.max(1 / this.maxFrameNumber, 1 / this._frameNumber), this._shadowMat.lastFrameTexture = p2.texture, this._shadowMat.needsUpdate = true, W(r2, { shadowMapRender: false, backgroundRender: false, opaqueRender: true, transparentRender: false, transmissionRender: false }, () => this._viewer.renderer.renderScene(l2)), r2.setRenderTarget(o3, a3, c3), e2.frustumCulled = s3, e2.material = i3, l2.modelObject.environment = t3, l2.modelObject.background = n2;
      }
      return p2.texture.encoding = d2, this._viewer.renderer.releaseTempTarget(p2), e2.layers.disable(this._lightLayer), u2.layers.mask = h2, l2.modelObject.traverse((e3) => {
        e3.isLight && e3 !== this._light.lightObject && (e3.layers = e3.userData.__gp_layers, delete e3.userData.__gp_layers);
      }), i2.type = s2, i2.needsUpdate = o2, i2.autoUpdate = a2, e2.castShadow = true, (this._frameNumber < 2 || this._frameNumber > Math.min(30, this.maxFrameNumber) && this._frameNumber % 150 == 0) && (this._updateMaterial(), this._viewer.setDirty(), e2.dispatchEvent({ type: "materialUpdate" })), true;
    }
    _updateMaterial(e2 = false) {
      var t2, r2, n2;
      this._attachedMesh && (e2 ? (this._attachedMesh.material.alphaMap === (null === (t2 = this._target) || void 0 === t2 ? void 0 : t2.texture) && (this._attachedMesh.material.alphaMap = null), this._attachedMesh.material.aoMap === (null === (r2 = this._target) || void 0 === r2 ? void 0 : r2.texture) && (this._attachedMesh.material.aoMap = null), this._attachedMesh.material.map === (null === (n2 = this._target) || void 0 === n2 ? void 0 : n2.texture) && (this._attachedMesh.material.map = null)) : this._target && ("alphaMap" === this.groundMapMode && (this._attachedMesh.material.alphaMap = this._target.texture), "aoMap" === this.groundMapMode && (this._attachedMesh.material.aoMap = this._target.texture), "map" === this.groundMapMode && (this._attachedMesh.material.map = this._target.texture)), this._attachedMesh.material && (this._attachedMesh.material.userData.ALPHA_I_RGBA_PACKING = !e2 && "alphaMap" === this.groundMapMode, this._attachedMesh.material.alphaTest = e2 || "alphaMap" !== this.groundMapMode ? 0 : 1e-3, this._attachedMesh.material.needsUpdate = true));
    }
  }
  lu([Ce("randomizedLight")], cu.prototype, "_light", void 0), lu([M(cu.prototype.reset), Ce()], cu.prototype, "maxFrameNumber", void 0), lu([M(cu.prototype._groundMapModeChanged), Ce()], cu.prototype, "groundMapMode", void 0), lu([Ce(), M(cu.prototype._alphaVignetteChanged)], cu.prototype, "alphaVignette", void 0), lu([Ce(), M(cu.prototype._alphaVignetteChanged)], cu.prototype, "alphaVignetteAxis", void 0);
  var uu = "vec2 poisson_disk_samples[16];void setPds(){poisson_disk_samples[0]=vec2(-0.399691779231,0.728591545584);poisson_disk_samples[1]=vec2(-0.48622557676,-0.84016533712);poisson_disk_samples[2]=vec2(0.770309468987,-0.24906070432);poisson_disk_samples[3]=vec2(0.556596796154,0.820359876432);poisson_disk_samples[4]=vec2(-0.933902004071,0.0600539051593);poisson_disk_samples[5]=vec2(0.330144964342,0.207477293384);poisson_disk_samples[6]=vec2(0.289013230975,-0.686749271417);poisson_disk_samples[7]=vec2(-0.0832470893559,-0.187351643125);poisson_disk_samples[8]=vec2(-0.296314525615,0.254474834305);poisson_disk_samples[9]=vec2(-0.850977666059,0.484642744689);poisson_disk_samples[10]=vec2(0.829287915319,0.2345063545);poisson_disk_samples[11]=vec2(-0.773042143899,-0.543741521254);poisson_disk_samples[12]=vec2(0.0561133030864,0.928419742597);poisson_disk_samples[13]=vec2(-0.205799249508,-0.562072714492);poisson_disk_samples[14]=vec2(-0.526991665882,-0.193690188118);poisson_disk_samples[15]=vec2(-0.051789270667,-0.935374050821);}", hu = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class pu extends n.Kj0 {
    constructor(e2, t2, r2 = 0) {
      super(e2), this.type = "Reflector", this.isReflector2 = true, this.enabled = true, this.reflectorModePhysical = true, this.reflectionTargetNeedsUpdate = true, this.transparentReflectionBackground = true, this.materialExtension = { extraUniforms: { tRefDiffuse: { value: null }, tRefDiffuseSize: { value: new n.FM8() }, refTextureMatrix: { value: null }, frameCount: { value: 0 }, sceneBoundingRadius: { value: 0 } }, updaters: [], shaderExtender: (e3, t3, r3) => {
        if (this.enabled) {
          e3.vertexShader = e3.vertexShader.replace("void main() {", "void main() {\nvRefUv = refTextureMatrix * vec4( position, 1.0 );");
          const t4 = "#glMarker beforeModulation";
          e3.fragmentShader = e3.fragmentShader.replace(t4, "\n                    if(roughnessFactor < 0.95) {\n                        float d = 0.;//textureProj(tRefDepth, vRefUv).r;\n                        // d = min(2., max(0., (d-0.06) * ((7./3.-ior)) * sceneBoundingRadius));\n                        vec4 refBaseColor = getReflectionColor(material.roughness, material.roughness * d);\n                        // refBaseColor.rgb = vec3(refBaseColor.a);\n                        // refBaseColor.a *= 1.0 - clamp(material.roughness * .3, 0., 1.);\n                        " + (this.reflectorModePhysical ? "\n                        #if !defined(SSR_ENABLED) || SSR_ENABLED < 1 \n                        vec3 specularColor = EnvironmentBRDF(geometry.normal, geometry.viewDir, material.specularColor.rgb, material.specularF90, material.roughness);\n                        #endif\n                        reflectedLight.indirectSpecular = mix(vec3(reflectedLight.indirectSpecular), saturate(specularColor.rgb * refBaseColor.rgb), refBaseColor.a);\n                        " : "\n                        reflectedLight.indirectSpecular = saturate(diffuseColor.rgb * refBaseColor.rgb);\n                        diffuseColor.a *= refBaseColor.a;\n                        ") + "}\n" + t4), e3.vertexUvs = true;
        }
      }, parsVertexSnippet: () => this.enabled ? "\n		uniform mat4 refTextureMatrix;\n		varying vec4 vRefUv;\n" : "", parsFragmentSnippet: () => this.enabled ? uu + "\n" + Po + "\n#ifndef D_sceneBoundingRadius\n#define D_sceneBoundingRadius \nuniform float sceneBoundingRadius;\n#endif\nvarying vec4 vRefUv;uniform sampler2D tRefDiffuse;uniform vec2 tRefDiffuseSize;float getSpecularMIPLevel(const in float roughness,const in float maxMIPLevel){float sigma=PI*roughness*roughness/(1.+roughness);float desiredMIPLevel=maxMIPLevel+log2(sigma);return clamp(desiredMIPLevel,0.,maxMIPLevel);}vec4 getReflectionColor(const in float roughness,const in float depthModifier){float mip=getSpecularMIPLevel(roughness+depthModifier,5.);vec4 color=texture2D(tRefDiffuse,vRefUv.xy/vRefUv.w,mip);float blurDist=saturate(2./(1.+pow(abs(vViewPosition.z),0.25)))*mip*32.*color.a;float rnd=PI2*interleavedGradientNoise(vUv.xy,frameCount);vec4 rotationMatrix=vec4(cos(rnd),-sin(rnd),0.,0.);rotationMatrix.z=-rotationMatrix.y;rotationMatrix.w=rotationMatrix.x;vec3 colorSum=color.rgb*color.a;float weightSum=0.001+color.a;vec2 ofs;setPds();\n#pragma unroll_loop_start\nfor(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));ofs=vRefUv.xy+vRefUv.w*blurDist*ofs/tRefDiffuseSize.xy;color=texture2D(tRefDiffuse,ofs/vRefUv.w,mip);colorSum+=color.rgb*color.a;weightSum+=color.a;}\n#pragma unroll_loop_end\nreturn vec4(colorSum/weightSum,1.);}" : "", computeCacheKey: (e3) => this.enabled + " " + e3.materialObject.transparent + " " + this.reflectorModePhysical + " ", onObjectRender: (e3, { materialObject: t3 }) => {
        t3.userData.__lastTransparent !== t3.transparent && (t3.needsUpdate = true, t3.userData.__lastTransparent = t3.transparent);
      }, isCompatible: (e3) => e3.isMeshStandardMaterial2 }, this.material = void 0, this._renderTarget = t2;
      const i2 = new n.JOQ(), s2 = new n.Pa4(), o2 = new n.Pa4(), a2 = new n.Pa4(), l2 = new n.yGw(), c2 = new n.Pa4(0, 0, -1), u2 = new n.Ltg(), h2 = new n.Pa4(), p2 = new n.Pa4(), d2 = new n.Ltg(), f2 = new n.yGw(), m2 = new n.cPb();
      n.M8C.isPowerOfTwo(t2.texture.image.width) && n.M8C.isPowerOfTwo(t2.texture.image.height) || (this._renderTarget.texture.generateMipmaps = false), this.onBeforeRender = (e3, t3, n2) => {
        if (!this.enabled || !e3.userData.mainRenderPass)
          return;
        if (!this.reflectionTargetNeedsUpdate)
          return;
        const _2 = n2.view ? Object.assign({}, n2.view) : null;
        if (_2 && n2.clearViewOffset && n2.clearViewOffset(), o2.setFromMatrixPosition(this.matrixWorld), a2.setFromMatrixPosition(n2.matrixWorld), l2.extractRotation(this.matrixWorld), s2.set(0, 0, 1), s2.applyMatrix4(l2), h2.subVectors(o2, a2), h2.dot(s2) > 0)
          return;
        h2.reflect(s2).negate(), h2.add(o2), l2.extractRotation(n2.matrixWorld), c2.set(0, 0, -1), c2.applyMatrix4(l2), c2.add(a2), p2.subVectors(o2, c2), p2.reflect(s2).negate(), p2.add(o2), m2.position.copy(h2), m2.up.set(0, 1, 0), m2.up.applyMatrix4(l2), m2.up.reflect(s2), m2.lookAt(p2), m2.far = 2, m2.near = 0, m2.updateMatrixWorld(), m2.projectionMatrix.copy(n2.projectionMatrix), f2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), f2.multiply(m2.projectionMatrix), f2.multiply(m2.matrixWorldInverse), f2.multiply(this.matrixWorld), i2.setFromNormalAndCoplanarPoint(s2, o2), i2.applyMatrix4(m2.matrixWorldInverse), u2.set(i2.normal.x, i2.normal.y, i2.normal.z, i2.constant);
        const g2 = m2.projectionMatrix;
        d2.x = (Math.sign(u2.x) + g2.elements[8]) / g2.elements[0], d2.y = (Math.sign(u2.y) + g2.elements[9]) / g2.elements[5], d2.z = -1, d2.w = (1 + g2.elements[10]) / g2.elements[14], u2.multiplyScalar(2 / u2.dot(d2)), g2.elements[2] = u2.x, g2.elements[6] = u2.y, g2.elements[10] = u2.z + 1 - r2, g2.elements[14] = u2.w, this.visible = false;
        const v2 = e3.getRenderTarget(), A2 = e3.xr.enabled, b2 = e3.shadowMap.autoUpdate;
        e3.xr.enabled = false, e3.shadowMap.autoUpdate = false, e3.setRenderTarget(this._renderTarget), e3.state.buffers.depth.setMask(true), false === e3.autoClear && e3.clear();
        const y2 = t3.background;
        this.transparentReflectionBackground && (t3.background = null);
        const x2 = !this.transparentReflectionBackground;
        y2 && x2 && (y2.userData.flipX = !y2.userData.flipX), W(e3, { shadowMapRender: false, backgroundRender: x2, opaqueRender: true, transparentRender: true, transmissionRender: false, screenSpaceRendering: false }, () => e3.render(t3, m2)), y2 && x2 && (y2.userData.flipX = !y2.userData.flipX || void 0), this.transparentReflectionBackground && (t3.background = y2), e3.xr.enabled = A2, e3.shadowMap.autoUpdate = b2, e3.setRenderTarget(v2), (null == _2 ? void 0 : _2.enabled) && n2.setViewOffset && n2.setViewOffset(_2.fullWidth, _2.fullHeight, _2.offsetX, _2.offsetY, _2.width, _2.height);
        const w2 = n2.viewport;
        void 0 !== w2 && e3.state.viewport(w2), this.visible = true, this.reflectionTargetNeedsUpdate = false;
      }, this.textureMatrix = f2, this.materialExtension.extraUniforms.tRefDiffuse.value = this._renderTarget.texture, this.materialExtension.extraUniforms.tRefDiffuseSize.value = new n.FM8(this._renderTarget.width, this._renderTarget.height), this.materialExtension.extraUniforms.refTextureMatrix.value = f2;
    }
    _updateExtension() {
      var e2, t2;
      this.transparentReflectionBackground = this.reflectorModePhysical, null === (t2 = null === (e2 = this.materialExtension) || void 0 === e2 ? void 0 : e2.setDirty) || void 0 === t2 || t2.call(e2);
    }
    getRenderTarget() {
      return this._renderTarget;
    }
  }
  hu([M(pu.prototype._updateExtension)], pu.prototype, "enabled", void 0), hu([M(pu.prototype._updateExtension)], pu.prototype, "reflectorModePhysical", void 0), pu.prototype.isReflector = true;
  var du = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class fu extends ro {
    constructor(e2 = {}) {
      super(), this._transformNeedRefresh = true, this.dependencies = [to], this.visible = true, this.size = 8, this.yOffset = 0, this.renderToDepth = true, this.tonemapGround = true, this.limitCameraAboveGround = false, this._cameraLimitsSet = false, this._cameraLastMaxPolarAngle = Math.PI, this._refreshMaterial = this._refreshMaterial.bind(this), this._refreshTransform = this._refreshTransform.bind(this), this._refreshCameraLimits = this._refreshCameraLimits.bind(this), this.refreshOptions = this.refreshOptions.bind(this), this._refreshOptions2 = this._refreshOptions2.bind(this), this._onSceneUpdate = this._onSceneUpdate.bind(this), this._preRender = this._preRender.bind(this), this._postFrame = this._postFrame.bind(this), this._geometry = new n._12(1, 1, 1, 1), this._geometry.attributes.uv2 = this._geometry.attributes.uv.clone(), this._geometry.attributes.uv2.needsUpdate = true, this._options = { shape: "", up: [0, 100, 0], autoAdjustTransform: true }, this.setOptions(e2);
    }
    get enabled() {
      return this.visible;
    }
    set enabled(e2) {
      this.visible = e2;
    }
    get material() {
      return this._material;
    }
    get mesh() {
      return this._iMesh;
    }
    _createMesh() {
      return new n.Kj0(this._geometry);
    }
    async onAdded(e2) {
      var t2, r2;
      await super.onAdded(e2), e2.getPluginByType("TweakpaneUi") && console.error("TweakpaneUiPlugin must be added after Ground Plugin"), this._manager = e2.getPlugin(to);
      const n2 = this._createMesh();
      n2.userData.physicsMass = 0, this._iMesh = await (null === (t2 = this._manager) || void 0 === t2 ? void 0 : t2.addImportedSingle(n2, { pseudoCenter: false, autoScale: false, addToRoot: true })), this._mesh = null === (r2 = this._iMesh) || void 0 === r2 ? void 0 : r2.modelObject, this._mesh && (this._mesh.userData.userSelectable = false, this._mesh.castShadow = true, this._mesh.receiveShadow = true, this._mesh.name = "Ground Plane"), e2.scene.addEventListener("sceneUpdate", this._onSceneUpdate), e2.scene.addEventListener("addSceneObject", this._onSceneUpdate), e2.addEventListener("preRender", this._preRender), e2.addEventListener("postFrame", this._postFrame), this.refreshOptions();
    }
    _postFrame() {
      this._transformNeedRefresh && this._refreshTransform(), this._viewer;
    }
    _preRender() {
      this._viewer;
    }
    async onDispose(e2) {
      var t2, r2;
      return this._geometry.dispose(), null === (r2 = null === (t2 = this._iMesh) || void 0 === t2 ? void 0 : t2.dispose) || void 0 === r2 || r2.call(t2), super.onDispose(e2);
    }
    async onRemove(e2) {
      return this._removeMaterial(), e2.scene.removeEventListener("sceneUpdate", this._onSceneUpdate), e2.scene.removeEventListener("addSceneObject", this._onSceneUpdate), e2.removeEventListener("postFrame", this._postFrame), e2.removeEventListener("preRender", this._preRender), this._manager = void 0, super.onRemove(e2);
    }
    _removeMaterial() {
      var e2, t2;
      this._material && (null === (t2 = null === (e2 = this._manager) || void 0 === e2 ? void 0 : e2.materials) || void 0 === t2 || t2.unregisterMaterial(this._material), this._material.userData.renderToDepth = this._material.userData.__renderToDepth, this._material.userData.__renderToDepth = void 0, this._material = void 0);
    }
    _onSceneUpdate(e2) {
      false !== e2.geometryChanged && false !== e2.updateGround && this.refreshTransform();
    }
    refreshTransform() {
      this._transformNeedRefresh = true;
    }
    _refreshOptions2() {
      this.refreshOptions();
    }
    refreshOptions() {
      this._viewer && (this._refreshMaterial(), this.refreshTransform(), this._refreshCameraLimits());
    }
    _refreshCameraLimits() {
      var e2;
      const t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.activeCamera.controls;
      t2 && (void 0 !== t2.maxPolarAngle ? this.limitCameraAboveGround ? (this._cameraLimitsSet || (this._cameraLastMaxPolarAngle = t2.maxPolarAngle), t2.maxPolarAngle = Math.PI / 2, this._cameraLimitsSet = true) : this._cameraLimitsSet && (t2.maxPolarAngle = this._cameraLastMaxPolarAngle, this._cameraLimitsSet = false) : console.warn("refreshCameraLimits only available with orbit controls."));
    }
    _refreshTransform() {
      var e2, t2, r2;
      if (!this._mesh)
        return;
      if (!this._viewer)
        return;
      let i2 = false;
      if (this.visible !== this._mesh.visible && (this._mesh.visible = this.visible, i2 = true), this.enabled) {
        if (this._options.autoAdjustTransform) {
          this._mesh.userData.bboxVisible = false;
          const e3 = this._viewer.scene.getBounds(true);
          this._mesh.userData.bboxVisible = true;
          const t3 = e3.getCenter(new n.Pa4()).sub(new n.Pa4(0, e3.getSize(new n.Pa4()).y / 2 + this.yOffset, 0));
          i2 = i2 || t3.clone().sub(this._mesh.position).length() > 1e-4, i2 && this._mesh.position.copy(t3);
        }
        i2 = i2 || Math.abs(this._mesh.scale.x - this.size) > 1e-4, i2 && (this._mesh.scale.setScalar(this.size), this._mesh.setRotationFromEuler(new n.USm(-Math.PI / 2, 0, 0)), this._mesh.matrixWorldNeedsUpdate = true, null === (r2 = (t2 = this._mesh).setDirty) || void 0 === r2 || r2.call(t2)), this._transformNeedRefresh = false;
      } else
        i2 && (null === (e2 = this._viewer) || void 0 === e2 || e2.scene.setDirty());
    }
    _refreshMaterial() {
      var e2, t2, r2, n2, i2, s2, o2, a2;
      if (!this._viewer)
        return false;
      if (!this.enabled)
        return false;
      this._manager || console.error("GroundPlugin requires asset manager");
      const l2 = null === (t2 = null === (e2 = this._manager) || void 0 === e2 ? void 0 : e2.materials) || void 0 === t2 ? void 0 : t2.findOrCreate(null !== (n2 = null === (r2 = this._material) || void 0 === r2 ? void 0 : r2.uuid) && void 0 !== n2 ? n2 : "standard", { name: "BaseGroundMaterial", runtimeMaterial: true, color: 16777215 });
      let c2 = false;
      if ((null == l2 ? void 0 : l2.uuid) !== (null === (i2 = this._material) || void 0 === i2 ? void 0 : i2.uuid)) {
        if (this._removeMaterial(), l2 && (this._material = l2), (null === (s2 = this._material) || void 0 === s2 ? void 0 : s2.uuid) || console.warn("No material found for ground"), this._viewer.scene.setDirty(), this._mesh && this._material) {
          this._material.roughness = 0.2, this._material.metalness = 0.5;
          (null !== (a2 = null === (o2 = this._mesh) || void 0 === o2 ? void 0 : o2.setMaterial) && void 0 !== a2 ? a2 : (e3) => {
            this._mesh && (this._mesh.material = e3.materialObject);
          })(this._material);
        }
        c2 = true;
      }
      return this._material && (void 0 === this._material.userData.__renderToDepth && (this._material.userData.__renderToDepth = this._material.userData.renderToDepth), this._material.userData.renderToDepth !== this.renderToDepth && (this._material.userData.renderToDepth = this.renderToDepth), void 0 === this._material.userData.__postTonemap && (this._material.userData.__postTonemap = this._material.userData.postTonemap), this._material.userData.postTonemap !== this.tonemapGround && (this._material.userData.postTonemap = this.tonemapGround), this._material.materialObject.userData.ssaoDisabled = true, this._material.materialObject.userData.sscsDisabled = true), this._viewer.setDirty(this), c2;
    }
    setOptions(e2) {
      Object.assign(this._options, e2), this.refreshOptions();
    }
    fromJSON(e2, t2) {
      return super.fromJSON(e2, t2) ? (this.refreshOptions(), this) : null;
    }
    _extraUiConfig() {
      return [() => {
        var e2;
        return null === (e2 = this._material) || void 0 === e2 ? void 0 : e2.uiConfig;
      }];
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = { type: "folder", label: "Ground", children: [{ label: "Visible", type: "checkbox", property: [this, "visible"], limitedUi: true }, { label: "Size", type: "input", property: [this, "size"], limitedUi: true }, { label: "Render to Depth", type: "checkbox", property: [this, "renderToDepth"] }, { label: "Limit Camera", type: "checkbox", property: [this, "limitCameraAboveGround"] }, { label: "Tonemap", type: "checkbox", property: [this, "tonemapGround"] }, { label: "Height", type: "slider", bounds: [-2, 2], property: [this, "yOffset"] }, ...this._extraUiConfig()] };
    }
  }
  du([Ce("material")], fu.prototype, "_material", void 0), du([M(fu.prototype.refreshTransform), Ce()], fu.prototype, "visible", void 0), du([M(fu.prototype._onSceneUpdate), Ce()], fu.prototype, "size", void 0), du([M(fu.prototype._onSceneUpdate), Ce()], fu.prototype, "yOffset", void 0), du([M(fu.prototype._refreshOptions2), Ce()], fu.prototype, "renderToDepth", void 0), du([M(fu.prototype._refreshOptions2), Ce()], fu.prototype, "tonemapGround", void 0), du([M(fu.prototype._refreshCameraLimits), Ce()], fu.prototype, "limitCameraAboveGround", void 0);
  var mu = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class _u extends fu {
    constructor(e2 = {}, t2 = false) {
      super(e2), this.bakedShadows = true, this.groundReflection = false, this.physicalReflections = false, this._showDebug = t2, t2 && this.dependencies.push(Yc), this._onSceneUpdate = this._onSceneUpdate.bind(this);
    }
    get shadowBaker() {
      return this._shadowBaker;
    }
    _createMesh() {
      const e2 = new pu(this._geometry, this._viewer.renderer.createTarget({ type: n.ywz, format: n.wk1, encoding: n.rnI, size: { width: 1024, height: 1024 }, generateMipmaps: true, depthBuffer: true, minFilter: n.D1R, magFilter: n.wem })), t2 = e2.onBeforeRender;
      return e2.onBeforeRender = (...e3) => {
        var r2, n2, i2, s2, o2;
        let a2 = null === (n2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.getPluginByType("SSReflection")) || void 0 === n2 ? void 0 : n2.passes.ssr.passObject;
        a2 && !a2.enabled && (a2 = void 0), a2 && (a2.enabled = false);
        let l2 = null === (o2 = null === (s2 = null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.getPluginByType("SSBevelPlugin")) || void 0 === s2 ? void 0 : s2.pass) || void 0 === o2 ? void 0 : o2.passObject;
        l2 && !l2.enabled && (l2 = void 0), l2 && (l2.enabled = false), t2(...e3), a2 && (a2.enabled = true), l2 && (l2.enabled = true);
      }, e2;
    }
    async onAdded(e2) {
      var t2, r2;
      await super.onAdded(e2), this._showDebug && (null === (t2 = e2.getPlugin(Yc)) || void 0 === t2 || t2.addTexture("bake_ground_1", () => {
        var e3, t3;
        return null === (t3 = null === (e3 = this._shadowBaker) || void 0 === e3 ? void 0 : e3.light.shadow.map) || void 0 === t3 ? void 0 : t3.texture;
      }, [100, 100, 200, 200]), null === (r2 = e2.getPlugin(Yc)) || void 0 === r2 || r2.addTexture("bake_ground_2", () => {
        var e3, t3;
        return null === (t3 = null === (e3 = this._shadowBaker) || void 0 === e3 ? void 0 : e3.target) || void 0 === t3 ? void 0 : t3.texture;
      }, [100, 400, 400, 400], "texel = vec4(vec3(unpackRGBAToDepth(texel)), 1.0);"));
    }
    _postFrame() {
      var e2;
      super._postFrame(), this._viewer && this.enabled && this.bakedShadows && (null === (e2 = this._shadowBaker) || void 0 === e2 || e2.autoUpdateShadow());
    }
    _preRender() {
      super._preRender(), this._viewer && (this._mesh.reflectionTargetNeedsUpdate = this._viewer.renderer.frameCount < 1);
    }
    async onDispose(e2) {
      return super.onDispose(e2);
    }
    async onRemove(e2) {
      return super.onRemove(e2);
    }
    _removeMaterial() {
      var e2, t2, r2, n2;
      if (this._material) {
        if (this._shadowBaker && this._material.groundMatExtension && (null === (t2 = (e2 = this._material).unregisterMaterialExtensions) || void 0 === t2 || t2.call(e2, [this._shadowBaker.materialExtension]), delete this._material.groundMatExtension), this._material.reflectorMatExtension) {
          const e3 = this._mesh.materialExtension;
          e3 || console.warn("unable to find the extension to unregister"), null === (n2 = (r2 = this._material).unregisterMaterialExtensions) || void 0 === n2 || n2.call(r2, [e3]), delete this._material.reflectorMatExtension;
        }
        super._removeMaterial();
      }
    }
    _onSceneUpdate(e2) {
      var t2;
      super._onSceneUpdate(e2), false !== e2.geometryChanged && (null === (t2 = this._shadowBaker) || void 0 === t2 || t2.reset());
    }
    refreshOptions() {
      if (!this._viewer)
        return;
      this.bakedShadows && !this._shadowBaker ? (this._shadowBaker = new cu(this._viewer), this._shadowBaker.attachedMesh = this._mesh) : !this.bakedShadows && this._shadowBaker && (this._shadowBaker.reset(), this._shadowBaker.cleanupMaterial());
      const e2 = this._mesh;
      e2.isReflector2 && (e2.enabled = this.groundReflection, e2.reflectorModePhysical = this.physicalReflections), super.refreshOptions(), this._viewer.setDirty(this);
    }
    _refreshMaterial() {
      var e2, t2, r2, n2;
      if (!this._viewer)
        return false;
      const i2 = super._refreshMaterial();
      if (!this._material)
        return i2;
      if (this.groundReflection && this._mesh.isReflector2 && !this._material.reflectorMatExtension) {
        const r3 = this._mesh.materialExtension;
        r3.updaters = [this._viewer.scene, this._viewer.renderer], null === (t2 = (e2 = this._material).registerMaterialExtensions) || void 0 === t2 || t2.call(e2, [r3]), this._material.reflectorMatExtension = true;
      }
      return this.bakedShadows && this._shadowBaker && !this._material.groundMatExtension && (null === (n2 = (r2 = this._material).registerMaterialExtensions) || void 0 === n2 || n2.call(r2, [this._shadowBaker.materialExtension]), this._material.groundMatExtension = true), this._material.materialObject.userData.ssreflDisabled = this.groundReflection, this._material.materialObject.userData.ssreflNonPhysical = !this.physicalReflections, this._viewer.setDirty(this), i2;
    }
    _extraUiConfig() {
      var e2, t2, r2, n2, i2, s2, o2, a2, l2, c2, u2, h2, p2, d2, f2, m2, _2, g2, v2, A2, b2, y2, x2, w2, E2, S2, C2, M2, T2, I2;
      return [{ label: "Baked Shadows", type: "checkbox", property: [this, "bakedShadows"] }, { label: "Shadow Frames", type: "input", hidden: () => !this._shadowBaker, stepSize: 1, bounds: [1, 1e3], property: [this._shadowBaker, "maxFrameNumber"] }, { label: "Alpha Vignette", type: "checkbox", hidden: () => !this._material || this._material.transmission < 1e-4 && !this._material.transparent, property: [this._shadowBaker, "alphaVignette"], limitedUi: true, onChange: () => {
        var e3, t3;
        return null === (t3 = null === (e3 = this._uiConfig) || void 0 === e3 ? void 0 : e3.uiRefresh) || void 0 === t3 ? void 0 : t3.call(e3, "postFrame", true);
      } }, { label: "Alpha Vignette Axis", type: "dropdown", hidden: () => {
        var e3;
        return !(null === (e3 = this._shadowBaker) || void 0 === e3 ? void 0 : e3.alphaVignette) || !this._material || this._material.transmission < 1e-4 && !this._material.transparent;
      }, property: [this._shadowBaker, "alphaVignetteAxis"], children: ["x", "y", "xy"].map((e3) => ({ label: e3, value: e3 })), limitedUi: true }, { label: "Planar Reflections", type: "checkbox", property: [this, "groundReflection"], limitedUi: true }, { label: "Physical Reflections", type: "checkbox", property: [this, "physicalReflections"], limitedUi: true }, { label: "Shadow type", type: "dropdown", hidden: () => !this._shadowBaker, property: [this._shadowBaker, "groundMapMode"], children: [{ label: "aoMap" }, { label: "map" }, { label: "alphaMap" }], limitedUi: true }, { type: "folder", label: "Randomized Light", hidden: () => !this._shadowBaker, limitedUi: true, children: [{ type: "color", label: "Color", property: [null === (e2 = this._shadowBaker) || void 0 === e2 ? void 0 : e2.light, "color"] }, { type: "slider", label: "Intensity", bounds: [0, 100], property: [null === (t2 = this._shadowBaker) || void 0 === t2 ? void 0 : t2.light, "intensity"] }, { type: "checkbox", label: "Shadow Enabled", property: [null === (n2 = null === (r2 = this._shadowBaker) || void 0 === r2 ? void 0 : r2.light) || void 0 === n2 ? void 0 : n2.shadowParams, "enabled"], onChange: [null === (s2 = null === (i2 = this._shadowBaker) || void 0 === i2 ? void 0 : i2.light) || void 0 === s2 ? void 0 : s2.updateShadowParams, this._onSceneUpdate] }, { type: "slider", bounds: [0, 1], property: [null === (a2 = null === (o2 = this._shadowBaker) || void 0 === o2 ? void 0 : o2.light) || void 0 === a2 ? void 0 : a2.randomParams, "focus"], onChange: [this._onSceneUpdate] }, { type: "slider", bounds: [0, 1], property: [null === (c2 = null === (l2 = this._shadowBaker) || void 0 === l2 ? void 0 : l2.light) || void 0 === c2 ? void 0 : c2.randomParams, "spread"], onChange: [this._onSceneUpdate], limitedUi: true }, { type: "slider", bounds: [0.01, 60], property: [null === (h2 = null === (u2 = this._shadowBaker) || void 0 === u2 ? void 0 : u2.light) || void 0 === h2 ? void 0 : h2.randomParams, "distanceScale"], onChange: [null === (d2 = null === (p2 = this._shadowBaker) || void 0 === p2 ? void 0 : p2.light) || void 0 === d2 ? void 0 : d2.updateShadowParams, this._onSceneUpdate] }, { type: "vec3", bounds: [-1, 1], property: [null === (m2 = null === (f2 = this._shadowBaker) || void 0 === f2 ? void 0 : f2.light) || void 0 === m2 ? void 0 : m2.randomParams, "direction"], onChange: [this._onSceneUpdate], limitedUi: true }, { type: "vec3", bounds: [-1, 1], property: [null === (g2 = null === (_2 = this._shadowBaker) || void 0 === _2 ? void 0 : _2.light) || void 0 === g2 ? void 0 : g2.randomParams, "normalDirection"], onChange: [this._onSceneUpdate], limitedUi: true }, { type: "slider", bounds: [0.01, 10], property: [null === (A2 = null === (v2 = this._shadowBaker) || void 0 === v2 ? void 0 : v2.light) || void 0 === A2 ? void 0 : A2.shadowParams, "radius"], onChange: [null === (y2 = null === (b2 = this._shadowBaker) || void 0 === b2 ? void 0 : b2.light) || void 0 === y2 ? void 0 : y2.updateShadowParams, this._onSceneUpdate] }, { type: "input", property: [null === (w2 = null === (x2 = this._shadowBaker) || void 0 === x2 ? void 0 : x2.light) || void 0 === w2 ? void 0 : w2.shadowParams, "frustumSize"], onChange: [null === (S2 = null === (E2 = this._shadowBaker) || void 0 === E2 ? void 0 : E2.light) || void 0 === S2 ? void 0 : S2.updateShadowParams, this._onSceneUpdate] }, { type: "slider", bounds: [-0.1, 0.1], property: [null === (M2 = null === (C2 = this._shadowBaker) || void 0 === C2 ? void 0 : C2.light) || void 0 === M2 ? void 0 : M2.shadowParams, "bias"], onChange: [null === (I2 = null === (T2 = this._shadowBaker) || void 0 === T2 ? void 0 : T2.light) || void 0 === I2 ? void 0 : I2.updateShadowParams, this._onSceneUpdate] }] }, ...super._extraUiConfig()];
    }
  }
  _u.PluginType = "Ground", mu([M(_u.prototype.refreshOptions), Ce()], _u.prototype, "bakedShadows", void 0), mu([M(_u.prototype.refreshOptions), Ce()], _u.prototype, "groundReflection", void 0), mu([M(_u.prototype.refreshOptions), Ce()], _u.prototype, "physicalReflections", void 0), mu([Ce("shadowBaker")], _u.prototype, "_shadowBaker", void 0);
  var gu, vu = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let Au = gu = class extends zt {
    constructor() {
      super({ vertexShader: i.vertexShader, defines: { PASS_STEP: 1 }, uniforms: { tSource: { value: null }, tDiffuse: { value: null }, opacity: { value: 1 }, tDiffuseSize: { value: new n.FM8() }, weight: { value: 1 }, tNormalDepth: { value: null } }, fragmentShader: Ht + "\nuniform float intensity;uniform float opacity;uniform vec2 tDiffuseSize;varying vec2 vUv;uniform float weight;\n#if PASS_STEP == 0\nuniform vec4 prefilter;vec4 Prefilter(vec4 c){if(getDepth(vUv)>0.999){return vec4(0.);}float brightness=max(c.r,max(c.g,c.b));float soft=brightness+prefilter.x*(prefilter.y-1.);soft=clamp(soft,0.,prefilter.z);soft=soft*soft*prefilter.w;float contribution=max(soft,brightness-prefilter.x);contribution/=max(brightness,0.001);return vec4(c.rgb*contribution,c.a);}\n#endif\nvec4 Sample(vec2 uv){return tDiffuseTexelToLinear(texture2D(tDiffuse,uv));}vec4 SampleBox(vec2 uv,float delta){vec4 o=vec2(-delta,delta).xxyy/tDiffuseSize.xyxy;vec4 s=Sample(uv+o.xy)+Sample(uv+o.zy)+Sample(uv+o.xw)+Sample(uv+o.zw);return s*0.25;}void main(){\n#if PASS_STEP == 0 \ngl_FragColor=weight*Prefilter(SampleBox(vUv,1.));gl_FragColor.a=1.;\n#elif PASS_STEP == 1 \ngl_FragColor=weight*(SampleBox(vUv,1.));gl_FragColor.a=1.;\n#elif PASS_STEP == 2 \ngl_FragColor=(SampleBox(vUv,0.5));gl_FragColor.a=1.;\n#elif PASS_STEP == 3 \nvec4 texel=tSourceTexelToLinear(texture2D(tSource,vUv));vec4 bloom=intensity*SampleBox(vUv,0.5).rgba;float brightness=max(bloom.r,max(bloom.g,bloom.b));texel.rgb+=bloom.rgb;texel.a=min(1.,texel.a+brightness);gl_FragColor=texel;\n#elif PASS_STEP == 4 \nvec4 texel=vec4(0.);texel.rgb+=intensity*SampleBox(vUv,0.5).rgb;texel.a=1.;gl_FragColor=texel;\n#endif\n#include <encodings_fragment>\n}" }, "tDiffuse", "tSource"), this.uiConfig = void 0, this.prefilter = new n.Ltg(2, 0.5, 0, 0), this.threshold = 2, this.softThreshold = 0.5, this.intensity = 0.5, this.bloomIterations = 4, this.radius = 0.6, this.power = 1, this.bloomDebug = false, this._weights = [], this._updateWeights = this._updateWeights.bind(this), this._thresholdsUpdated = this._thresholdsUpdated.bind(this), this._updateWeights(), this._thresholdsUpdated(), this.clear = true, this.userData = { setDirty: () => {
        this.setDirty();
      } };
    }
    _thresholdsUpdated() {
      this.prefilter.x = this.threshold, this.prefilter.y = this.softThreshold, this.prefilter.z = 2 * this.prefilter.x * this.prefilter.y, this.prefilter.w = 0.125 / (this.uniforms.prefilter.value.z + 1e-5);
    }
    render(e2, t2, r2, i2, s2) {
      const o2 = e2.baseRenderer;
      this.material.defines.PASS_STEP = 0, this.clear = true;
      const a2 = r2;
      let l2 = 0.5, c2 = a2.width * l2, u2 = a2.height * l2;
      const h2 = [];
      let p2 = o2.getTempTarget({ sizeMultiplier: 0.5, type: n.cLu });
      h2.push(p2);
      let d2 = a2;
      this.material.needsUpdate = true, this.material.uniforms.weight.value = this._weights[0], super.render(e2, p2, d2, i2, s2), d2 = p2;
      let f2 = 1;
      for (; f2 < this.bloomIterations && (c2 /= 2, u2 /= 2, l2 /= 2, !(u2 < 2 || c2 < 2)); f2++) {
        p2 = o2.getTempTarget({ sizeMultiplier: l2, type: n.cLu }), h2.push(p2), this.material.defines.PASS_STEP = 1;
        let t3 = this._weights[f2];
        t3 = 0 !== this._weights[f2 - 1] ? this._weights[f2] / this._weights[f2 - 1] : this._weights[f2], this.material.uniforms.weight.value = t3, this.material.needsUpdate = true, super.render(e2, p2, d2, i2, s2), d2 = p2;
      }
      this.clear = false;
      const m2 = e2.autoClear;
      for (e2.autoClear = false, f2 -= 2; f2 >= 0; f2--)
        p2 = h2[f2], h2[f2] = void 0, this.material.defines.PASS_STEP = 2, this.material.transparent = true, this.material.blending = n.WMw, this.material.needsUpdate = true, e2.autoClear = false, super.render(e2, p2, d2, i2, s2), this.material.blending = n.jFi, o2.releaseTempTarget(d2), d2 = p2;
      this.clear = true, e2.autoClear = m2, e2.autoClear = true, this.bloomDebug ? (this.material.defines.PASS_STEP = 4, this.material.needsUpdate = true, super.render(e2, t2, d2, i2, s2)) : (this.uniforms.tSource.value = a2.texture, this.material.defines.PASS_STEP = 3, this.material.needsUpdate = true, super.render(e2, t2, d2, i2, s2), this.uniforms.tSource.value = null), o2.releaseTempTarget(d2);
    }
    _updateWeights() {
      if (!this._weights)
        return;
      const e2 = Math.max(Math.min(this.radius, 1), 0), t2 = 1 / (this.bloomIterations - 1);
      for (let r2 = 0; r2 < this.bloomIterations; r2++) {
        let n2 = r2 * t2 + 0.1, i2 = 1.2 - n2;
        n2 = Math.pow(n2, this.power), i2 = Math.pow(i2, this.power), this._weights[r2] = i2 * (1 - e2) + n2 * e2;
      }
      this.setDirty();
    }
  };
  vu([G()], Au.prototype, "prefilter", void 0), vu([$e("Threshold", [0, 2]), M(gu.prototype._thresholdsUpdated), Ce()], Au.prototype, "threshold", void 0), vu([$e("Soft Threshold", [0, 1]), M(gu.prototype._thresholdsUpdated), Ce()], Au.prototype, "softThreshold", void 0), vu([$e("Intensity", [0, 3]), Ce(), G()], Au.prototype, "intensity", void 0), vu([$e("Iterations", [0, 7], 1), M(gu.prototype._updateWeights), Ce()], Au.prototype, "bloomIterations", void 0), vu([$e("Radius", [0, 1], 0.01), M(gu.prototype._updateWeights), Ce()], Au.prototype, "radius", void 0), vu([$e("Power", [0.2, 10], 0.01), M(gu.prototype._updateWeights), Ce()], Au.prototype, "power", void 0), vu([Je("Debug")], Au.prototype, "bloomDebug", void 0), Au = gu = vu([lt("Bloom")], Au);
  class bu extends io {
    constructor() {
      super(...arguments), this.passId = "bloom", this._beforeFilters = ["combinedPost", "screen"], this._afterFilters = ["render", "progressive"], this._requiredFilters = ["render"];
    }
    passCtor(e2) {
      return new Au();
    }
    _update(e2) {
      var t2, r2;
      return null === (t2 = e2.getPlugin(lo)) || void 0 === t2 || t2.updateShaderProperties(null === (r2 = this.pass) || void 0 === r2 ? void 0 : r2.passObject.material), super._update(e2);
    }
    get uiConfig() {
      var e2;
      return null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.uiConfig;
    }
  }
  bu.PluginType = "Bloom";
  var yu = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let xu = class extends ro {
    constructor() {
      super(), this.enabled = true, this.dependencies = [to], this._defines = { ANISOTROPY_DEBUG: false }, this._uniforms = { anisotropyFactor: { value: 1 }, anisotropyNoise: { value: 1 }, anisotropyDirection: { value: 1 }, anisotropyDirectionMap: { value: null }, frameCount: { value: 0 } }, this.materialExtension = { shaderExtender: (e2, t2, r2) => {
        var i2;
        if (!this.enabled || !t2.materialObject.userData._isAnisotropic)
          return;
        const s2 = null === (i2 = t2.materialObject.userData) || void 0 === i2 ? void 0 : i2._anisotropyDirectionMap, o2 = w`
                #include <bsdfs>
                //#if ANISOTROPY_ENABLED
                ${Po}
                ${"uniform float anisotropyFactor;uniform float anisotropyNoise;\n#if ANISOTROPY_TEX_MODE == 0\nuniform float anisotropyDirection;\n#else\nuniform sampler2D anisotropyDirectionMap;\n#endif\nconst float MIN_ROUGHNESS=0.05;float D_GGX_Anisotropy(float at,float ab,float ToH,float BoH,float NoH){float a2=at*ab;highp vec3 d=vec3(ab*ToH,at*BoH,a2*NoH);highp float d2=dot(d,d);float b2=a2/d2;return a2*b2*b2*(1./PI);}float V_GGX_SmithCorrelated_Anisotropy(float at,float ab,float ToV,float BoV,float ToL,float BoL,float NoV,float NoL){float lambdaV=NoL*length(vec3(at*ToV,ab*BoV,NoV));float lambdaL=NoV*length(vec3(at*ToL,ab*BoL,NoL));float v=0.5/(lambdaV+lambdaL);return saturate(v);}vec3 indirectAnisotropyBentNormal(const in vec3 normal,const in vec3 viewDir,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){vec3 aDirection=anisotropyFactor>=0.?anisotropicB:anisotropicT;vec3 aTangent=cross(aDirection,viewDir);vec3 aNormal=cross(aTangent,aDirection);float bendFactor=abs(anisotropyFactor)*saturate(5.*max(roughness,MIN_ROUGHNESS));return normalize(mix(normal,aNormal,bendFactor));}vec3 BRDF_GGX_Anisotropy(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 f0,const in float f90,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){float alpha=pow2(roughness);vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));float dotTV=dot(anisotropicT,viewDir);float dotBV=dot(anisotropicB,viewDir);float dotTL=dot(anisotropicT,lightDir);float dotBL=dot(anisotropicB,lightDir);float dotTH=dot(anisotropicT,halfDir);float dotBH=dot(anisotropicB,halfDir);float aspect=sqrt(1.-min(1.-MIN_ROUGHNESS,abs(anisotropyFactor)*0.9));if(anisotropyFactor>0.)aspect=1./aspect;float at=roughness*aspect;float ab=roughness/aspect;vec3 F=F_Schlick(f0,f90,dotVH);float V=V_GGX_SmithCorrelated_Anisotropy(at,ab,dotTV,dotBV,dotTL,dotBL,dotNV,dotNL);float D=D_GGX_Anisotropy(at,ab,dotTH,dotBH,dotNH);return F*(V*D);}"}
            ` + (s2 ? U("anisotropyDirectionMap", s2, r2.capabilities.isWebGL2) : "");
        e2.fragmentShader = e2.fragmentShader.replace("#include <bsdfs>", o2), e2.fragmentShader = e2.fragmentShader.replace("#include <lights_fragment_begin>", n.WdD.lights_fragment_begin), e2.fragmentShader = e2.fragmentShader.replace("IncidentLight directLight;", "float rnd=(random2(vUv.xy,frameCount)-0.5)*anisotropyNoise*material.roughness;\n#if ANISOTROPY_TEX_MODE < 2\n#if ANISOTROPY_TEX_MODE == 0 \nfloat rot=saturate(anisotropyDirection);\n#else \nfloat rot=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vUv)).r);\n#endif\nrot=rot*2.*PI+rnd;vec2 rot2=vec2(sin(rot),cos(rot));\n#else \nvec2 rot2=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vUv)).rg*2.-1.)+vec2(rnd,rnd);rot2=normalize(rot2);const float anisoSpecMultiplier=0.25;float matSpecAniso=(length(material.specularColor.rgb))*2.*PI;rot2=mix(rot2,vec2(sin(matSpecAniso),cos(matSpecAniso)),anisoSpecMultiplier);rot2=normalize(rot2);\n#endif\nvec3 anisotropicT=(tangent*rot2.x+bitangent*rot2.y);anisotropicT=normalize(anisotropicT-normal*dot(anisotropicT,normal));vec3 anisotropicB=normalize(cross(normal,anisotropicT));IncidentLight directLight;").replaceAll("RE_Direct( directLight, geometry, material, reflectedLight )", "RE_Direct( directLight, geometry, material, reflectedLight, anisotropicT, anisotropicB )");
        const a2 = n.WdD.lights_physical_pars_fragment.replace("void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {", "void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight, const in vec3 anisotropicT, const in vec3 anisotropicB ) {").replace("BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness )", "BRDF_GGX_Anisotropy( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness, anisotropicT, anisotropicB )");
        e2.fragmentShader = e2.fragmentShader.replace("#include <lights_physical_pars_fragment>", a2);
        const l2 = w`
                #if defined( USE_ENVMAP )
                vec3 anisotropyBentNormal = indirectAnisotropyBentNormal(geometry.normal, geometry.viewDir, material.roughness, anisotropicT, anisotropicB);
                #endif
            ` + n.WdD.lights_fragment_maps.replace("getIBLIrradiance( geometry.normal )", "getIBLIrradiance( anisotropyBentNormal )").replace("getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness )", "getIBLRadiance( geometry.viewDir, anisotropyBentNormal, material.roughness )");
        e2.fragmentShader = e2.fragmentShader.replace("#include <lights_fragment_maps>", l2), e2.vertexUvs = true, e2.vertexTangents = true;
      }, onObjectRender: (e2, t2) => {
        var r2;
        const n2 = t2.materialObject.userData;
        if (!(null == n2 ? void 0 : n2._isAnisotropic))
          return;
        const i2 = e2;
        if (!i2.isMesh || !i2.geometry)
          return;
        if (!i2.geometry.attributes.tangent)
          throw new Error("No tangents on the geometry");
        this._uniforms.anisotropyFactor.value = n2._anisotropyFactor, this._uniforms.anisotropyNoise.value = n2._anisotropyNoise, this._uniforms.anisotropyDirectionMap.value = (null === (r2 = n2._anisotropyDirectionMap) || void 0 === r2 ? void 0 : r2.isTexture) ? n2._anisotropyDirectionMap : null, this._uniforms.anisotropyDirection.value = n2._anisotropyDirection;
        let s2 = this.enabled ? 1 : 0;
        t2.materialObject.defines.ANISOTROPY_ENABLED !== s2 && (t2.materialObject.defines.ANISOTROPY_ENABLED = s2, t2.materialObject.needsUpdate = true), s2 = +this._defines.ANISOTROPY_DEBUG, t2.materialObject.defines.ANISOTROPY_DEBUG !== s2 && (t2.materialObject.defines.ANISOTROPY_DEBUG = s2, t2.materialObject.needsUpdate = true), s2 = n2._anisotropyDirectionMode, this._uniforms.anisotropyDirectionMap.value || (s2 = "CONSTANT"), s2 = "DIRECTION" === s2 ? 2 : "ROTATION" === s2 ? 1 : 0, t2.materialObject.defines.ANISOTROPY_TEX_MODE !== s2 && (t2.materialObject.defines.ANISOTROPY_TEX_MODE = s2, t2.materialObject.needsUpdate = true);
      }, extraUniforms: { ...this._uniforms }, computeCacheKey: (e2) => {
        var t2, r2, n2;
        return (this.enabled ? "1" : "0") + ((null === (t2 = e2.materialObject.userData) || void 0 === t2 ? void 0 : t2._isAnisotropic) ? "1" : "0") + (null === (n2 = null === (r2 = e2.materialObject.userData) || void 0 === r2 ? void 0 : r2._anisotropyDirectionMap) || void 0 === n2 ? void 0 : n2.uuid);
      }, isCompatible: (e2) => e2.isMeshStandardMaterial2, updaters: () => {
        var e2;
        return [null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.renderer];
      }, getUiConfig: (e2) => {
        const t2 = this._viewer, r2 = this.makeAnisotropic, n2 = { type: "folder", label: "Anisotropy", children: [{ type: "checkbox", label: "Enabled", get value() {
          return e2.materialObject.userData._isAnisotropic || false;
        }, set value(i2) {
          var s2;
          i2 !== e2.materialObject.userData._isAnisotropic && (i2 ? r2(e2) || t2.alert("One or more geometries cannot be made anisotropic.") : (e2.materialObject.userData._isAnisotropic = false, e2.materialObject.needsUpdate = true), null === (s2 = n2.uiRefresh) || void 0 === s2 || s2.call(n2, "postFrame", true));
        }, onChange: this.setDirty }, { type: "slider", label: "Factor", bounds: [-2, 2], hidden: () => !e2.materialObject.userData._isAnisotropic, property: [e2.materialObject.userData, "_anisotropyFactor"], onChange: this.setDirty }, { type: "slider", label: "Noise", bounds: [0, 2], hidden: () => !e2.materialObject.userData._isAnisotropic, property: [e2.materialObject.userData, "_anisotropyNoise"], onChange: this.setDirty }, { type: "image", label: "Texture", hidden: () => !e2.materialObject.userData._isAnisotropic, property: [e2.materialObject.userData, "_anisotropyDirectionMap"], onChange: () => {
          e2.materialObject.needsUpdate = true, this.setDirty();
        } }, { type: "dropdown", label: "Mode", hidden: () => !e2.materialObject.userData._isAnisotropic, property: [e2.materialObject.userData, "_anisotropyDirectionMode"], children: ["CONSTANT", "ROTATION", "DIRECTION"].map((e3) => ({ label: e3 })), onChange: () => {
          e2.materialObject.needsUpdate = true, this.setDirty();
        } }] };
        return n2;
      } }, this.setDirty = () => {
        var e2;
        null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
      }, this.makeSelectedAnisotropic = () => {
        var e2, t2, r2;
        const n2 = null === (r2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Nc)) || void 0 === t2 ? void 0 : t2.getSelectedObject()) || void 0 === r2 ? void 0 : r2.material;
        return "material" === (null == n2 ? void 0 : n2.assetType) && this.makeAnisotropic(n2);
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    makeAnisotropic(e2) {
      var t2;
      const r2 = null === (t2 = e2.materialObject) || void 0 === t2 ? void 0 : t2.userData;
      if (!r2)
        return false;
      if (void 0 === r2._isAnisotropic) {
        const e3 = r2.__appliedMeshes;
        let t3 = true;
        if (e3)
          for (const { geometry: r3 } of e3)
            !r3 || r3.index && r3.attributes.position && r3.attributes.normal && r3.attributes.uv || (t3 = false), t3 && !r3.attributes.tangent && r3.computeTangents();
        if (!t3)
          return false;
      }
      return r2._isAnisotropic = true, void 0 === r2._anisotropyFactor && (r2._anisotropyFactor = 1), void 0 === r2._anisotropyNoise && (r2._anisotropyNoise = 0), void 0 === r2._anisotropyDirectionMode && (r2._anisotropyDirectionMode = "DIRECTION"), e2.materialObject.needsUpdate = true, true;
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new wu(e3));
    }
    async onAdded(e2) {
      var t2, r2, n2, i2, s2;
      await super.onAdded(e2);
      const o2 = e2.getPlugin(to);
      null === (t2 = null == o2 ? void 0 : o2.materials) || void 0 === t2 || t2.registerMaterialExtension(this.materialExtension), null === (r2 = null == o2 ? void 0 : o2.importer) || void 0 === r2 || r2.addEventListener("loaderCreate", this._loaderCreate), null === (s2 = null === (i2 = null === (n2 = null == o2 ? void 0 : o2.exporter) || void 0 === n2 ? void 0 : n2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(Eu);
    }
    async onRemove(e2) {
      var t2, r2, n2, i2;
      return null === (r2 = null === (t2 = e2.getPlugin(to)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === r2 || r2.unregisterMaterialExtension(this.materialExtension), null === (i2 = null === (n2 = e2.getPlugin(to)) || void 0 === n2 ? void 0 : n2.importer) || void 0 === i2 || i2.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e2);
    }
  };
  xu.PluginType = "AnisotropyPlugin", xu.ANISOTROPY_GLTF_EXTENSION = "WEBGI_materials_anisotropy", yu([Je("Enabled", (e2) => ({ onChange: e2.setDirty })), Ce()], xu.prototype, "enabled", void 0), yu([rt("Make Anisotropy", (e2) => ({ hidden: () => {
    var t2;
    return !(null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Nc));
  } }))], xu.prototype, "makeSelectedAnisotropic", void 0), xu = yu([lt("Anisotropy Materials")], xu);
  class wu {
    constructor(e2) {
      this.parser = e2, this.name = xu.ANISOTROPY_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      var r2, i2, s2;
      const o2 = this.parser, a2 = o2.json.materials[e2];
      if (!a2.extensions || !a2.extensions[this.name])
        return Promise.resolve();
      const l2 = [], c2 = a2.extensions[this.name];
      t2.userData || (t2.userData = {}), t2.userData._isAnisotropic = true, t2.userData._anisotropyFactor = null !== (r2 = c2.anisotropyFactor) && void 0 !== r2 ? r2 : 0, t2.userData._anisotropyNoise = null !== (s2 = null !== (i2 = c2.anisotropyNoiseFactor) && void 0 !== i2 ? i2 : c2.anisotropyNoise) && void 0 !== s2 ? s2 : 0;
      let { anisotropyDirectionMode: u2, anisotropyDirection: h2 } = c2;
      return u2 || (u2 = c2.anisotropyTextureMode), h2 || (h2 = c2.anisotropyRotation), t2.userData._anisotropyDirectionMode = u2 && "number" == typeof (null == h2 ? void 0 : h2.index) ? u2 : "CONSTANT", "ROTATION" === u2 || "DIRECTION" === u2 ? l2.push(o2.assignTexture(t2.userData, "_anisotropyDirectionMap", h2).then((e3) => {
        e3.encoding = n.knz;
      })) : t2.userData._anisotropyDirection = null != h2 ? h2 : 0, Promise.all(l2);
    }
    afterRoot(e2) {
      return e2.scene.traverse((e3) => {
        var t2, r2;
        if (!(null === (r2 = null === (t2 = e3.material) || void 0 === t2 ? void 0 : t2.userData) || void 0 === r2 ? void 0 : r2._isAnisotropic))
          return;
        const n2 = e3.geometry;
        n2.attributes.tangent || (n2.computeTangents(), n2.attributes.tangent.needsUpdate = true);
      }), null;
    }
  }
  const Eu = (e2) => ({ writeMaterial: (t2, r2) => {
    if (!t2.isMeshStandardMaterial || !t2.userData._isAnisotropic)
      return;
    if ((t2.userData._anisotropyFactor || 0) < 1e-3)
      return;
    r2.extensions = r2.extensions || {};
    const n2 = {};
    if (n2.anisotropyFactor = t2.userData._anisotropyFactor || 1, n2.anisotropyNoiseFactor = t2.userData._anisotropyNoise || 0, n2.anisotropyDirectionMode = t2.userData._anisotropyDirectionMode || "CONSTANT", t2.userData._anisotropyDirectionMap && "CONSTANT" !== n2.anisotropyDirectionMode) {
      const r3 = { index: e2.processTexture(t2.userData._anisotropyDirectionMap) };
      e2.applyTextureTransform(r3, t2.userData._anisotropyDirectionMap), n2.anisotropyDirection = r3;
    } else
      n2.anisotropyDirectionMode = "CONSTANT", n2.anisotropyDirection = t2.userData._anisotropyDirection || 0;
    r2.extensions[xu.ANISOTROPY_GLTF_EXTENSION] = n2, e2.extensionsUsed[xu.ANISOTROPY_GLTF_EXTENSION] = true;
  } });
  var Su = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let Cu = class extends ro {
    constructor() {
      super(), this.enabled = true, this.dependencies = [to], this._defines = {}, this._uniforms = { thinBaseLayerFactors: { value: new n.Ltg() }, thinNoiseLayerFactors: { value: new n.Ltg() }, thinColorNoiseParams: { value: new n.Ltg() }, thinFilmFactor: { value: 0.8 } }, this.materialExtension = { parsFragmentSnippet: (e2, t2) => {
        var r2;
        return this.enabled && (null === (r2 = null == t2 ? void 0 : t2.materialObject.userData._thinFilmLayer) || void 0 === r2 ? void 0 : r2.hasThinFilm) ? Po + "\n#ifndef VORONOISE_HELPER\n#define VORONOISE_HELPER \nfloat voronoise(in vec2 p,float u,float v){float k=1.+63.*pow(1.-v,6.);vec2 i=floor(p);vec2 f=fract(p);vec2 a=vec2(0.,0.);for(int y=-2;y<=2;y++)for(int x=-2;x<=2;x++){vec2 g=vec2(x,y);vec3 o=hash3(i+g)*vec3(u,u,1.);vec2 d=g-f+o.xy;float w=pow(1.-smoothstep(0.,1.414,length(d)),k);a+=vec2(o.z*w,w);}return a.x/a.y;}vec3 voronoise3(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),voronoise(p-vec2(0.83,0.45),u,v));}vec3 voronoiseNormal(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),1.);}\n#endif\n\n#ifndef HSV_HELPERS\n#define HSV_HELPERS \nvec3 hsv2rgb(vec3 c){vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}vec3 rgb2hsv(vec3 c){vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=c.g<c.b?vec4(c.bg,K.wz):vec4(c.gb,K.xy);vec4 q=c.r<p.x?vec4(p.xyw,c.r):vec4(c.r,p.yzx);float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);}\n#endif \n\nuniform vec4 thinBaseLayerFactors;\nuniform vec4 thinNoiseLayerFactors;\nuniform vec4 thinColorNoiseParams;\nuniform float thinFilmFactor;\n        " : "";
      }, shaderExtender: (e2, t2, r2) => {
        var n2;
        if (!this.enabled || !(null === (n2 = t2.materialObject.userData._thinFilmLayer) || void 0 === n2 ? void 0 : n2.hasThinFilm))
          return;
        const i2 = "#glMarker beforeAccumulation";
        e2.fragmentShader = e2.fragmentShader.replace(i2, "vec3 incident=normalize(vViewPosition.xyz);float hWeight=1.-dot(normal,incident);vec3 noiseV=voronoise3(vUv.xy*thinColorNoiseParams.xy*60.,thinColorNoiseParams.z,thinColorNoiseParams.w);float hWeight2=1.-dot(normalize(noiseV),incident);vec3 film=hsv2rgb(vec3(fract(hWeight+thinBaseLayerFactors.x),thinBaseLayerFactors.y,thinBaseLayerFactors.z))*thinBaseLayerFactors.a;vec3 film2=hsv2rgb(vec3(fract(hWeight2+thinNoiseLayerFactors.x),thinNoiseLayerFactors.y,thinNoiseLayerFactors.z))*thinNoiseLayerFactors.a;film=(film+film2)/(thinBaseLayerFactors.a+thinNoiseLayerFactors.a);diffuseColor.rgb=mix(diffuseColor.rgb,film,thinFilmFactor);" + i2), e2.vertexUvs = true;
      }, onObjectRender: (e2, t2) => {
        var r2;
        const n2 = null === (r2 = t2.materialObject.userData) || void 0 === r2 ? void 0 : r2._thinFilmLayer;
        if (!(null == n2 ? void 0 : n2.hasThinFilm))
          return;
        this._uniforms.thinBaseLayerFactors.value.fromArray(n2.baseLayerFactors), this._uniforms.thinNoiseLayerFactors.value.fromArray(n2.noiseLayerFactors), this._uniforms.thinColorNoiseParams.value.fromArray(n2.colorNoiseParams), this._uniforms.thinFilmFactor.value = n2.filmFactor;
        const i2 = this.enabled ? 1 : 0;
        t2.materialObject.defines.THIN_FILM_LAYER_ENABLED !== i2 && (t2.materialObject.defines.THIN_FILM_LAYER_ENABLED = i2, t2.materialObject.needsUpdate = true);
      }, extraUniforms: { ...this._uniforms }, computeCacheKey: (e2) => {
        var t2, r2;
        return (this.enabled ? "1" : "0") + ((null === (r2 = null === (t2 = e2.materialObject.userData) || void 0 === t2 ? void 0 : t2._thinFilmLayer) || void 0 === r2 ? void 0 : r2.hasThinFilm) ? "1" : "0");
      }, isCompatible: (e2) => e2.isMeshStandardMaterial2, updaters: () => [], getUiConfig: (e2) => {
        const t2 = this._viewer, r2 = { type: "folder", label: "ThinFilmLayer", children: [{ type: "checkbox", label: "Enabled", get value() {
          var t3;
          return (null === (t3 = e2.materialObject.userData._thinFilmLayer) || void 0 === t3 ? void 0 : t3.hasThinFilm) || false;
        }, set value(n2) {
          var i2, s2;
          n2 !== (null === (i2 = e2.materialObject.userData._thinFilmLayer) || void 0 === i2 ? void 0 : i2.hasThinFilm) && (n2 ? Mu(e2.materialObject) || t2.alert("Cannot add thin film.") : (e2.materialObject.userData._thinFilmLayer.hasThinFilm = false, e2.materialObject.needsUpdate = true), null === (s2 = r2.uiRefresh) || void 0 === s2 || s2.call(r2, "postFrame", true));
        }, onChange: this.setDirty }, () => ({ type: "slider", bounds: [0, 1], label: "Intensity", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._thinFilmLayer) || void 0 === t3 ? void 0 : t3.hasThinFilm);
        }, property: [e2.materialObject.userData._thinFilmLayer, "filmFactor"], onChange: this.setDirty }), () => ({ type: "vec4", label: "Base Layer", bounds: [0, 1], hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._thinFilmLayer) || void 0 === t3 ? void 0 : t3.hasThinFilm);
        }, property: [e2.materialObject.userData._thinFilmLayer, "baseLayerFactors"], onChange: this.setDirty }), () => ({ type: "vec4", label: "Noise Layer", bounds: [0, 1], hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._thinFilmLayer) || void 0 === t3 ? void 0 : t3.hasThinFilm);
        }, property: [e2.materialObject.userData._thinFilmLayer, "noiseLayerFactors"], onChange: this.setDirty }), () => ({ type: "vec4", label: "Noise Params", bounds: [0, 1], hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._thinFilmLayer) || void 0 === t3 ? void 0 : t3.hasThinFilm);
        }, property: [e2.materialObject.userData._thinFilmLayer, "colorNoiseParams"], onChange: this.setDirty })] };
        return r2;
      } }, this.setDirty = () => {
        var e2;
        null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    addThinFilmLayer(e2) {
      return Mu(e2.materialObject);
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Tu(e3));
    }
    async onAdded(e2) {
      var t2, r2, n2, i2, s2;
      await super.onAdded(e2);
      const o2 = e2.getPlugin(to);
      null === (t2 = null == o2 ? void 0 : o2.materials) || void 0 === t2 || t2.registerMaterialExtension(this.materialExtension), null === (r2 = null == o2 ? void 0 : o2.importer) || void 0 === r2 || r2.addEventListener("loaderCreate", this._loaderCreate), null === (s2 = null === (i2 = null === (n2 = null == o2 ? void 0 : o2.exporter) || void 0 === n2 ? void 0 : n2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(Iu);
    }
    async onRemove(e2) {
      var t2, r2, n2, i2;
      return null === (r2 = null === (t2 = e2.getPlugin(to)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === r2 || r2.unregisterMaterialExtension(this.materialExtension), null === (i2 = null === (n2 = e2.getPlugin(to)) || void 0 === n2 ? void 0 : n2.importer) || void 0 === i2 || i2.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e2);
    }
  };
  function Mu(e2) {
    const t2 = null == e2 ? void 0 : e2.userData;
    if (!t2)
      return false;
    t2._thinFilmLayer || (t2._thinFilmLayer = {});
    const r2 = t2._thinFilmLayer;
    return r2.hasThinFilm = true, void 0 === r2.baseLayerFactors && (r2.baseLayerFactors = [0.3, 0.6, 1, 0.9]), void 0 === r2.noiseLayerFactors && (r2.noiseLayerFactors = [0.7, 0.5, 0.9, 0.7]), void 0 === r2.colorNoiseParams && (r2.colorNoiseParams = [0.5, 0.5, 0.5, 0.7]), void 0 === r2.filmFactor && (r2.filmFactor = 0.3), e2.isMaterial && (e2.needsUpdate = true), true;
  }
  Cu.PluginType = "ThinFilmLayerPlugin", Cu.THIN_FILM_LAYER_GLTF_EXTENSION = "WEBGI_materials_thin_film_layer", Su([Je("Enabled", (e2) => ({ onChange: e2.setDirty })), Ce()], Cu.prototype, "enabled", void 0), Cu = Su([lt("ThinFilmLayer Materials")], Cu);
  class Tu {
    constructor(e2) {
      this.parser = e2, this.name = Cu.THIN_FILM_LAYER_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      const r2 = this.parser.json.materials[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return Promise.resolve();
      const n2 = r2.extensions[this.name];
      return t2.userData || (t2.userData = {}), Mu(t2), t2.userData._thinFilmLayer = De(n2, t2.userData._thinFilmLayer, false, {}), Promise.resolve();
    }
  }
  const Iu = (e2) => ({ writeMaterial: (t2, r2) => {
    if (!t2.isMeshStandardMaterial || !t2.userData._thinFilmLayer)
      return;
    if (!t2.userData._thinFilmLayer.hasThinFilm)
      return;
    r2.extensions = r2.extensions || {};
    const n2 = ke(t2.userData._thinFilmLayer, false);
    r2.extensions[Cu.THIN_FILM_LAYER_GLTF_EXTENSION] = n2, e2.extensionsUsed[Cu.THIN_FILM_LAYER_GLTF_EXTENSION] = true;
  } });
  var ku = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let Du = class extends ro {
    constructor() {
      super(), this.enabled = true, this.dependencies = [to], this._defines = {}, this._uniforms = { noiseBumpParams: { value: new n.FM8() }, noiseBumpScale: { value: 0.05 }, noiseBumpFlakeScale: { value: 1e3 }, noiseFlakeClamp: { value: 1 }, noiseFlakeRadius: { value: 0.5 }, noiseFlakeRoughnessMod: { value: 1 } }, this.materialExtension = { parsFragmentSnippet: (e2, t2) => {
        var r2;
        return this.enabled && (null === (r2 = null == t2 ? void 0 : t2.materialObject.userData._noiseBumpMat) || void 0 === r2 ? void 0 : r2.hasBump) ? Po + "\n#ifndef VORONOI_HELPER\n#define VORONOI_HELPER \nfloat voronoi_distance(vec2 a,vec2 b,float metric){return distance(a,b);}float voronoi_f1_2d(in vec2 coord,in float randomness,in float flakeClamp,in float flakeRadius,inout vec3 outColor){vec2 cellPosition=floor(coord);vec2 localPosition=coord-cellPosition;float minDistance=8.;vec2 targetOffset,targetPosition;for(int j=-1;j<=1;j++){for(int i=-1;i<=1;i++){vec2 cellOffset=vec2(i,j);vec2 pointPosition=cellOffset+hash3(cellPosition+cellOffset).xy*randomness;float distanceToPoint=voronoi_distance(pointPosition,localPosition,1.);if(distanceToPoint<minDistance){targetOffset=cellOffset;minDistance=distanceToPoint;targetPosition=pointPosition;}}}float outDistance=minDistance;float dist=step(flakeRadius,outDistance);outColor=hash3(cellPosition+hash3(cellPosition+targetOffset).xy*randomness+targetOffset);vec3 outColor1=minDistance<flakeRadius?outColor:vec3(0.5,0.5,1.);outDistance=mix(dist,minDistance,flakeClamp);outColor=mix(outColor1,outColor,flakeClamp);return outDistance;}\n#endif\n\nuniform vec2 noiseBumpParams;uniform float noiseBumpScale;uniform float noiseBumpFlakeScale;uniform float noiseFlakeClamp;uniform float noiseFlakeRadius;uniform float noiseFlakeRoughnessMod;vec3 perturbNormalArb_nb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=dFdx(surf_pos.xyz);vec3 vSigmaY=dFdy(surf_pos.xyz);vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n" : "";
      }, shaderExtender: (e2, t2, r2) => {
        var n2;
        if (!this.enabled || !(null === (n2 = t2.materialObject.userData._noiseBumpMat) || void 0 === n2 ? void 0 : n2.hasBump))
          return;
        const i2 = "#glMarker beforeAccumulation";
        e2.fragmentShader = e2.fragmentShader.replace(i2, "\n            vec3 outColor; \n            float voronoiDist = clamp(voronoi_f1_2d( noiseBumpFlakeScale * noiseBumpParams.xy * vUv, 1., noiseFlakeClamp, noiseFlakeRadius, outColor ), 0.0, 1.0);\n            normal = perturbNormalArb_nb( - vViewPosition, normal, (2. * outColor.xy - 1.) * noiseBumpScale, faceDirection ); \n            float avg = (outColor.r + outColor.g)*0.5; \n            diffuseColor *= (clamp(avg+0.5, 0.3, 1.));\n            float roughnessModifier = mix(1. - avg, 1., noiseFlakeRoughnessMod);\n            roughnessFactor *= roughnessModifier;\n            \n" + i2), e2.vertexUvs = true, e2.extensionDerivatives = true;
      }, onObjectRender: (e2, t2) => {
        var r2;
        const n2 = null === (r2 = t2.materialObject.userData) || void 0 === r2 ? void 0 : r2._noiseBumpMat;
        if (!(null == n2 ? void 0 : n2.hasBump))
          return;
        this._uniforms.noiseBumpParams.value.fromArray(n2.bumpNoiseParams), this._uniforms.noiseBumpScale.value = n2.bumpScale, this._uniforms.noiseBumpFlakeScale.value = n2.flakeScale, this._uniforms.noiseFlakeClamp.value = n2.flakeClamp, this._uniforms.noiseFlakeRadius.value = n2.flakeRadius, this._uniforms.noiseFlakeRoughnessMod.value = n2.flakeRoughnessMod;
        const i2 = this.enabled ? 1 : 0;
        t2.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED !== i2 && (t2.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED = i2, t2.materialObject.needsUpdate = true);
      }, extraUniforms: { ...this._uniforms }, computeCacheKey: (e2) => {
        var t2, r2;
        return (this.enabled ? "1" : "0") + ((null === (r2 = null === (t2 = e2.materialObject.userData) || void 0 === t2 ? void 0 : t2._noiseBumpMat) || void 0 === r2 ? void 0 : r2.hasBump) ? "1" : "0");
      }, isCompatible: (e2) => e2.isMeshStandardMaterial2, updaters: () => [], getUiConfig: (e2) => {
        const t2 = this._viewer, r2 = { type: "folder", label: "NoiseBumpMaterial", children: [{ type: "checkbox", label: "Enabled", get value() {
          var t3;
          return (null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump) || false;
        }, set value(n2) {
          var i2, s2;
          n2 !== (null === (i2 = e2.materialObject.userData._noiseBumpMat) || void 0 === i2 ? void 0 : i2.hasBump) && (n2 ? Pu(e2.materialObject) || t2.alert("Cannot add noise bump.") : (e2.materialObject.userData._noiseBumpMat.hasBump = false, e2.materialObject.needsUpdate = true), null === (s2 = r2.uiRefresh) || void 0 === s2 || s2.call(r2, "postFrame", true));
        }, onChange: this.setDirty }, () => ({ type: "vec4", label: "Bump Noise Params", bounds: [0, 1], hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump);
        }, property: [e2.materialObject.userData._noiseBumpMat, "bumpNoiseParams"], onChange: this.setDirty }), () => ({ type: "slider", label: "Bump Scale", bounds: [0, 0.01], stepSize: 1e-5, hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump);
        }, property: [e2.materialObject.userData._noiseBumpMat, "bumpScale"], onChange: this.setDirty }), () => ({ type: "slider", label: "Flake Scale", bounds: [100, 1e4], stepSize: 1e-4, hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump);
        }, property: [e2.materialObject.userData._noiseBumpMat, "flakeScale"], onChange: this.setDirty }), () => ({ type: "slider", label: "Flake Clamp", bounds: [0, 1], stepSize: 1, hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump);
        }, property: [e2.materialObject.userData._noiseBumpMat, "flakeClamp"], onChange: this.setDirty }), () => ({ type: "slider", label: "Flake Radius", bounds: [0.1, 1], stepSize: 0.01, hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump);
        }, property: [e2.materialObject.userData._noiseBumpMat, "flakeRadius"], onChange: this.setDirty }), () => ({ type: "slider", label: "Flake Roughness Modifier", bounds: [0, 1], stepSize: 1, hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._noiseBumpMat) || void 0 === t3 ? void 0 : t3.hasBump);
        }, property: [e2.materialObject.userData._noiseBumpMat, "flakeRoughnessMod"], onChange: this.setDirty })] };
        return r2;
      } }, this.setDirty = () => {
        var e2;
        null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    addNoiseBumpMaterial(e2) {
      return Pu(e2.materialObject);
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Bu(e3));
    }
    async onAdded(e2) {
      var t2, r2, n2, i2, s2;
      await super.onAdded(e2);
      const o2 = e2.getPlugin(to);
      null === (t2 = null == o2 ? void 0 : o2.materials) || void 0 === t2 || t2.registerMaterialExtension(this.materialExtension), null === (r2 = null == o2 ? void 0 : o2.importer) || void 0 === r2 || r2.addEventListener("loaderCreate", this._loaderCreate), null === (s2 = null === (i2 = null === (n2 = null == o2 ? void 0 : o2.exporter) || void 0 === n2 ? void 0 : n2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(Ru);
    }
    async onRemove(e2) {
      var t2, r2, n2, i2;
      return null === (r2 = null === (t2 = e2.getPlugin(to)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === r2 || r2.unregisterMaterialExtension(this.materialExtension), null === (i2 = null === (n2 = e2.getPlugin(to)) || void 0 === n2 ? void 0 : n2.importer) || void 0 === i2 || i2.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e2);
    }
  };
  function Pu(e2) {
    const t2 = null == e2 ? void 0 : e2.userData;
    if (!t2)
      return false;
    t2._noiseBumpMat || (t2._noiseBumpMat = {});
    const r2 = t2._noiseBumpMat;
    return r2.hasBump = true, void 0 === r2.bumpNoiseParams && (r2.bumpNoiseParams = [0.5, 0.5]), void 0 === r2.bumpScale && (r2.bumpScale = 0.05), void 0 === r2.flakeScale && (r2.flakeScale = 0.05), void 0 === r2.flakeClamp && (r2.flakeClamp = 1), void 0 === r2.flakeRadius && (r2.flakeRadius = 0.3), void 0 === r2.flakeRoughnessMod && (r2.flakeRoughnessMod = 1), e2.isMaterial && (e2.needsUpdate = true), true;
  }
  Du.PluginType = "NoiseBumpMaterialPlugin", Du.NOISE_BUMP_MATERIAL_GLTF_EXTENSION = "WEBGI_materials_noise_bump", ku([Je("Enabled", (e2) => ({ onChange: e2.setDirty })), Ce()], Du.prototype, "enabled", void 0), Du = ku([lt("NoiseBumpMaterial Materials")], Du);
  class Bu {
    constructor(e2) {
      this.parser = e2, this.name = Du.NOISE_BUMP_MATERIAL_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      const r2 = this.parser.json.materials[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return Promise.resolve();
      const n2 = r2.extensions[this.name];
      return t2.userData || (t2.userData = {}), Pu(t2), t2.userData._noiseBumpMat = De(n2, t2.userData._noiseBumpMat, false, {}), Promise.resolve();
    }
  }
  const Ru = (e2) => ({ writeMaterial: (t2, r2) => {
    if (!t2.isMeshStandardMaterial || !t2.userData._noiseBumpMat)
      return;
    if (!t2.userData._noiseBumpMat.hasBump)
      return;
    r2.extensions = r2.extensions || {};
    const n2 = ke(t2.userData._noiseBumpMat, false);
    r2.extensions[Du.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = n2, e2.extensionsUsed[Du.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = true;
  } });
  var Lu, Ou = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let Fu = Lu = class extends ro {
    constructor() {
      super(), this.enabled = true, this.dependencies = [to], this.bicubicFiltering = true, this._defines = { CUSTOM_BUMP_MAP_DEBUG: false, CUSTOM_BUMP_MAP_BICUBIC: true }, this._uniforms = { customBumpUvTransform: { value: new n.Vkp() }, customBumpScale: { value: 1e-3 }, customBumpMap: { value: null } }, this.materialExtension = { parsFragmentSnippet: (e2, t2) => this.enabled && (null == t2 ? void 0 : t2.materialObject.userData._hasCustomBump) ? "#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n#if CUSTOM_BUMP_MAP_BICUBIC > 0  \nvec4 cubic(float v){vec4 n=vec4(1.,2.,3.,4.)-v;vec4 s=n*n*n;float x=s.x;float y=s.y-4.*s.x;float z=s.z-4.*s.y+6.*s.x;float w=6.-x-y-z;return vec4(x,y,z,w)*(1./6.);}vec4 textureBicubic(sampler2D sampler,vec2 texCoords){vec2 texSize=vec2(textureSize(sampler,0));vec2 invTexSize=1./texSize;texCoords=texCoords*texSize-0.5;vec2 fxy=fract(texCoords);texCoords-=fxy;vec4 xcubic=cubic(fxy.x);vec4 ycubic=cubic(fxy.y);vec4 c=texCoords.xxyy+vec2(-0.5,+1.5).xyxy;vec4 s=vec4(xcubic.xz+xcubic.yw,ycubic.xz+ycubic.yw);vec4 offset=c+vec4(xcubic.yw,ycubic.yw)/s;offset*=invTexSize.xxyy;vec4 sample0=texture(sampler,offset.xz);vec4 sample1=texture(sampler,offset.yz);vec4 sample2=texture(sampler,offset.xw);vec4 sample3=texture(sampler,offset.yw);float sx=s.x/(s.x+s.y);float sy=s.z/(s.z+s.w);return mix(mix(sample3,sample2,sx),mix(sample1,sample0,sx),sy);}\n#endif\nvarying vec2 vCustomBumpUv;uniform sampler2D customBumpMap;uniform float customBumpScale;vec2 dHdxy_fwd_cb(){vec2 dSTdx=dFdx(vCustomBumpUv);vec2 dSTdy=dFdy(vCustomBumpUv);\n#if CUSTOM_BUMP_MAP_BICUBIC > 0\nfloat Hll=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;\n#else\nfloat Hll=customBumpScale*texture2D(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;\n#endif\nreturn vec2(dBx,dBy);}\n#ifndef USE_BUMPMAP\nvec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=dFdx(surf_pos.xyz);vec3 vSigmaY=dFdy(surf_pos.xyz);vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n#endif\n#endif\n" : "", shaderExtender: (e2, t2, r2) => {
        var n2;
        this.enabled && t2.materialObject.userData._hasCustomBump && (null === (n2 = t2.materialObject.userData) || void 0 === n2 ? void 0 : n2._customBumpMap) && (e2.fragmentShader = qt(e2.fragmentShader, "#glMarker beforeAccumulation", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n    normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd_cb(), faceDirection );\n#endif\n                ", { prepend: true }), e2.vertexShader = qt(e2.vertexShader, "#include <uv_pars_vertex>", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n                varying vec2 vCustomBumpUv;\n                uniform mat3 customBumpUvTransform;\n#endif\n                ", { prepend: true }), e2.vertexShader = qt(e2.vertexShader, "#include <uv_vertex>", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n                vCustomBumpUv = ( customBumpUvTransform * vec3( uv, 1 ) ).xy;\n#endif\n                ", { prepend: true }), e2.vertexUvs = true);
      }, onObjectRender: (e2, t2) => {
        var r2;
        const n2 = t2.materialObject.userData;
        if (!(null == n2 ? void 0 : n2._hasCustomBump))
          return;
        const i2 = e2;
        if (!i2.isMesh || !i2.geometry)
          return;
        const s2 = (null === (r2 = n2._customBumpMap) || void 0 === r2 ? void 0 : r2.isTexture) ? n2._customBumpMap : null;
        this._uniforms.customBumpMap.value = s2, this._uniforms.customBumpScale.value = s2 ? n2._customBumpScale : 0, s2 && (s2.updateMatrix(), this._uniforms.customBumpUvTransform.value.copy(s2.matrix));
        let o2 = this.enabled && s2 ? 1 : 0;
        t2.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED !== o2 && (t2.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED = o2, t2.materialObject.needsUpdate = true), o2 = +this._defines.CUSTOM_BUMP_MAP_DEBUG, t2.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG !== o2 && (t2.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG = o2, t2.materialObject.needsUpdate = true), o2 = +this._defines.CUSTOM_BUMP_MAP_BICUBIC, t2.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC !== o2 && (t2.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC = o2, t2.materialObject.needsUpdate = true);
      }, extraUniforms: { ...this._uniforms }, computeCacheKey: (e2) => {
        var t2, r2, n2;
        return (this.enabled ? "1" : "0") + ((null === (t2 = e2.materialObject.userData) || void 0 === t2 ? void 0 : t2._hasCustomBump) ? "1" : "0") + (null === (n2 = null === (r2 = e2.materialObject.userData) || void 0 === r2 ? void 0 : r2._customBumpMap) || void 0 === n2 ? void 0 : n2.uuid);
      }, isCompatible: (e2) => e2.isMeshStandardMaterial2, updaters: () => [], getUiConfig: (e2) => {
        const t2 = this._viewer, r2 = this.enableCustomBump, n2 = { type: "folder", label: "CustomBumpMap", children: [{ type: "checkbox", label: "Enabled", get value() {
          return e2.materialObject.userData._hasCustomBump || false;
        }, set value(i2) {
          var s2;
          i2 !== e2.materialObject.userData._hasCustomBump && (i2 ? r2(e2) || t2.alert("One or more geometries cannot be made anisotropic.") : (e2.materialObject.userData._hasCustomBump = false, e2.materialObject.needsUpdate = true), null === (s2 = n2.uiRefresh) || void 0 === s2 || s2.call(n2, "postFrame", true));
        }, onChange: this.setDirty }, { type: "slider", label: "Bump Scale", hidden: () => !e2.materialObject.userData._hasCustomBump, property: [e2.materialObject.userData, "_customBumpScale"], onChange: this.setDirty }, { type: "image", label: "Bump Map", hidden: () => !e2.materialObject.userData._hasCustomBump, property: [e2.materialObject.userData, "_customBumpMap"], onChange: () => {
          e2.materialObject.needsUpdate = true, this.setDirty();
        } }, be(e2.materialObject.userData, "_customBumpMap")] };
        return n2;
      } }, this.setDirty = () => {
        var e2, t2, r2;
        null === (t2 = (e2 = this.materialExtension).setDirty) || void 0 === t2 || t2.call(e2), null === (r2 = this._viewer) || void 0 === r2 || r2.setDirty();
      }, this.enableCustomBumpSelected = () => {
        var e2, t2, r2;
        const n2 = null === (r2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Nc)) || void 0 === t2 ? void 0 : t2.getSelectedObject()) || void 0 === r2 ? void 0 : r2.material;
        return "material" === (null == n2 ? void 0 : n2.assetType) && this.enableCustomBump(n2);
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    enableCustomBump(e2, t2, r2) {
      var n2, i2;
      const s2 = null === (n2 = e2.materialObject) || void 0 === n2 ? void 0 : n2.userData;
      if (!s2)
        return false;
      if (void 0 === s2._hasCustomBump) {
        const e3 = s2.__appliedMeshes;
        let t3 = true;
        if (e3)
          for (const { geometry: r3 } of e3)
            !r3 || r3.attributes.position && r3.attributes.normal && r3.attributes.uv || (t3 = false);
        if (!t3)
          return false;
      }
      return s2._hasCustomBump = true, s2._customBumpScale = null !== (i2 = null != r2 ? r2 : s2._customBumpScale) && void 0 !== i2 ? i2 : 1e-3, s2._customBumpMap = null != t2 ? t2 : s2._customBumpMap, e2.materialObject.needsUpdate = true, true;
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Uu(e3));
    }
    async onAdded(e2) {
      var t2, r2, n2, i2, s2;
      await super.onAdded(e2);
      const o2 = e2.getPlugin(to);
      null === (t2 = null == o2 ? void 0 : o2.materials) || void 0 === t2 || t2.registerMaterialExtension(this.materialExtension), null === (r2 = null == o2 ? void 0 : o2.importer) || void 0 === r2 || r2.addEventListener("loaderCreate", this._loaderCreate), null === (s2 = null === (i2 = null === (n2 = null == o2 ? void 0 : o2.exporter) || void 0 === n2 ? void 0 : n2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(Nu);
    }
    async onRemove(e2) {
      var t2, r2, n2, i2;
      return null === (r2 = null === (t2 = e2.getPlugin(to)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === r2 || r2.unregisterMaterialExtension(this.materialExtension), null === (i2 = null === (n2 = e2.getPlugin(to)) || void 0 === n2 ? void 0 : n2.importer) || void 0 === i2 || i2.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e2);
    }
  };
  Fu.PluginType = "CustomBumpMapPlugin", Fu.CUSTOM_BUMP_MAP_GLTF_EXTENSION = "WEBGI_materials_custom_bump_map", Ou([Je("Enabled", (e2) => ({ onChange: e2.setDirty })), Ce()], Fu.prototype, "enabled", void 0), Ou([Je("Bicubic", (e2) => ({ onChange: e2.setDirty })), V("CUSTOM_BUMP_MAP_BICUBIC", void 0, true, Lu.prototype.setDirty), Ce()], Fu.prototype, "bicubicFiltering", void 0), Ou([rt("Enable CustomBumpMap", (e2) => ({ hidden: () => {
    var t2;
    return !(null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Nc));
  } }))], Fu.prototype, "enableCustomBumpSelected", void 0), Fu = Lu = Ou([lt("CustomBumpMap Materials")], Fu);
  class Uu {
    constructor(e2) {
      this.parser = e2, this.name = Fu.CUSTOM_BUMP_MAP_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      var r2;
      const i2 = this.parser, s2 = i2.json.materials[e2];
      if (!s2.extensions || !s2.extensions[this.name])
        return Promise.resolve();
      const o2 = [], a2 = s2.extensions[this.name];
      t2.userData || (t2.userData = {}), t2.userData._hasCustomBump = true, t2.userData._customBumpScale = null !== (r2 = a2.customBumpScale) && void 0 !== r2 ? r2 : 0;
      const l2 = a2.customBumpMap;
      return l2 && o2.push(i2.assignTexture(t2.userData, "_customBumpMap", l2).then((e3) => {
        e3.encoding = n.knz;
      })), Promise.all(o2);
    }
  }
  const Nu = (e2) => ({ writeMaterial: (t2, r2) => {
    if (!t2.isMeshStandardMaterial || !t2.userData._hasCustomBump)
      return;
    if ((t2.userData._customBumpScale || 0) < 1e-3)
      return;
    r2.extensions = r2.extensions || {};
    const n2 = {};
    if (n2.customBumpScale = t2.userData._customBumpScale || 1, t2.userData._customBumpMap) {
      const r3 = { index: e2.processTexture(t2.userData._customBumpMap) };
      e2.applyTextureTransform(r3, t2.userData._customBumpMap), n2.customBumpMap = r3;
    }
    r2.extensions[Fu.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = n2, e2.extensionsUsed[Fu.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = true;
  } });
  var ju = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let zu = class extends ro {
    constructor() {
      super(), this.enabled = true, this.dependencies = [to], this._defines = {}, this._uniforms = { ccTintColor: { value: new Ae() }, ccThickness: { value: 0 }, ccIor: { value: 0 } }, this.materialExtension = { parsFragmentSnippet: (e2, t2) => {
        var r2;
        return this.enabled && (null === (r2 = null == t2 ? void 0 : t2.materialObject.userData._clearcoatTint) || void 0 === r2 ? void 0 : r2.enableTint) && t2.materialObject.clearcoat > 0 ? "\nuniform vec3 ccTintColor;\nuniform float ccThickness;\nuniform float ccIor;\nvec3 clearcoatTint(const in float dotNV, const in float dotNL, const in float clearcoat) {\n    vec3 tint = ( ccThickness > 0. ? 1. - ccTintColor : ccTintColor); // Set thickness < 0 for glow.\n    tint = exp(tint * -(ccThickness * ((dotNL + dotNV) / max(dotNL * dotNV, 1e-3)))); // beer's law\n    return mix(vec3(1.0), tint, clearcoat);\n}\n        " : "";
      }, shaderExtender: (e2, t2, r2) => {
        var n2;
        if (!(this.enabled && (null === (n2 = null == t2 ? void 0 : t2.materialObject.userData._clearcoatTint) || void 0 === n2 ? void 0 : n2.enableTint) && t2.materialObject.clearcoat > 0))
          return;
        const i2 = "outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;", s2 = "float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );";
        e2.fragmentShader.includes(s2) && e2.fragmentShader.includes(i2) || console.error("ClearcoatTintPlugin: shaderExtender cannot patch shader, version changed?"), e2.fragmentShader = e2.fragmentShader.replace(s2, "\n            float dotNVcc = saturate( dot( geometry.clearcoatNormal, -refract(geometry.viewDir, geometry.clearcoatNormal, 1./ccIor) ) );\n            "), e2.fragmentShader = e2.fragmentShader.replace(i2, "\n            outgoingLight *= clearcoatTint(dotNVcc, dotNVcc, material.clearcoat);\n            " + i2), e2.vertexUvs = true;
      }, onObjectRender: (e2, t2) => {
        var r2;
        const n2 = null === (r2 = t2.materialObject.userData) || void 0 === r2 ? void 0 : r2._clearcoatTint;
        if (!(null == n2 ? void 0 : n2.enableTint))
          return;
        this._uniforms.ccTintColor.value.set(n2.tintColor), this._uniforms.ccThickness.value = n2.thickness, this._uniforms.ccIor.value = n2.ior;
        const i2 = this.enabled ? 1 : 0;
        t2.materialObject.defines.CLEARCOAT_TINT_ENABLED !== i2 && (t2.materialObject.defines.CLEARCOAT_TINT_ENABLED = i2, t2.materialObject.needsUpdate = true);
      }, extraUniforms: { ...this._uniforms }, computeCacheKey: (e2) => {
        var t2, r2;
        return (this.enabled ? "1" : "0") + ((null === (r2 = null === (t2 = e2.materialObject.userData) || void 0 === t2 ? void 0 : t2._clearcoatTint) || void 0 === r2 ? void 0 : r2.enableTint) ? "1" : "0") + (e2.materialObject.clearcoat > 0 ? "1" : "0");
      }, isCompatible: (e2) => e2.isMeshStandardMaterial2, updaters: () => [], getUiConfig: (e2) => {
        const t2 = this._viewer, r2 = { type: "folder", label: "ClearcoatTint", children: [{ type: "checkbox", label: "Enabled", get value() {
          var t3;
          return (null === (t3 = e2.materialObject.userData._clearcoatTint) || void 0 === t3 ? void 0 : t3.enableTint) || false;
        }, set value(n2) {
          var i2, s2;
          n2 !== (null === (i2 = e2.materialObject.userData._clearcoatTint) || void 0 === i2 ? void 0 : i2.enableTint) && (n2 ? Gu(e2.materialObject) || t2.alert("Cannot add clearcoat tint.") : (e2.materialObject.userData._clearcoatTint.enableTint = false, e2.materialObject.needsUpdate = true), null === (s2 = r2.uiRefresh) || void 0 === s2 || s2.call(r2, "postFrame", true));
        }, onChange: this.setDirty }, () => ({ type: "color", label: "Tint color", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._clearcoatTint) || void 0 === t3 ? void 0 : t3.enableTint);
        }, property: [e2.materialObject.userData._clearcoatTint, "tintColor"], onChange: this.setDirty }), () => ({ type: "input", label: "Thickness", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._clearcoatTint) || void 0 === t3 ? void 0 : t3.enableTint);
        }, property: [e2.materialObject.userData._clearcoatTint, "thickness"], onChange: this.setDirty }), () => ({ type: "slider", bounds: [0.8, 2.5], label: "IOR", hidden: () => {
          var t3;
          return !(null === (t3 = e2.materialObject.userData._clearcoatTint) || void 0 === t3 ? void 0 : t3.enableTint);
        }, property: [e2.materialObject.userData._clearcoatTint, "ior"], onChange: this.setDirty })] };
        return r2;
      } }, this.setDirty = () => {
        var e2;
        null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }
    addClearcoatTint(e2) {
      return Gu(e2.materialObject);
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new Vu(e3));
    }
    async onAdded(e2) {
      var t2, r2, n2, i2, s2;
      await super.onAdded(e2);
      const o2 = e2.getPlugin(to);
      null === (t2 = null == o2 ? void 0 : o2.materials) || void 0 === t2 || t2.registerMaterialExtension(this.materialExtension), null === (r2 = null == o2 ? void 0 : o2.importer) || void 0 === r2 || r2.addEventListener("loaderCreate", this._loaderCreate), null === (s2 = null === (i2 = null === (n2 = null == o2 ? void 0 : o2.exporter) || void 0 === n2 ? void 0 : n2.getExporter("gltf", "glb")) || void 0 === i2 ? void 0 : i2.extensions) || void 0 === s2 || s2.push(Qu);
    }
    async onRemove(e2) {
      var t2, r2, n2, i2;
      return null === (r2 = null === (t2 = e2.getPlugin(to)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === r2 || r2.unregisterMaterialExtension(this.materialExtension), null === (i2 = null === (n2 = e2.getPlugin(to)) || void 0 === n2 ? void 0 : n2.importer) || void 0 === i2 || i2.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e2);
    }
  };
  function Gu(e2) {
    const t2 = null == e2 ? void 0 : e2.userData;
    if (!t2)
      return false;
    t2._clearcoatTint || (t2._clearcoatTint = {});
    const r2 = t2._clearcoatTint;
    return r2.enableTint = true, void 0 === r2.tintColor && (r2.tintColor = 16777215), void 0 === r2.thickness && (r2.thickness = 0.1), void 0 === r2.ior && (r2.ior = 1.5), e2.isMaterial && (e2.needsUpdate = true), true;
  }
  zu.PluginType = "ClearcoatTintPlugin", zu.CLEARCOAT_TINT_GLTF_EXTENSION = "WEBGI_materials_clearcoat_tint", ju([Je("Enabled", (e2) => ({ onChange: e2.setDirty })), Ce()], zu.prototype, "enabled", void 0), zu = ju([lt("ClearcoatTint Materials")], zu);
  class Vu {
    constructor(e2) {
      this.parser = e2, this.name = zu.CLEARCOAT_TINT_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      const r2 = this.parser.json.materials[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return Promise.resolve();
      const n2 = r2.extensions[this.name];
      return t2.userData || (t2.userData = {}), Gu(t2), t2.userData._clearcoatTint = De(n2, t2.userData._clearcoatTint, false, {}), Promise.resolve();
    }
  }
  const Qu = (e2) => ({ writeMaterial: (t2, r2) => {
    if (!t2.isMeshStandardMaterial || !t2.userData._clearcoatTint)
      return;
    if (!t2.userData._clearcoatTint.enableTint)
      return;
    r2.extensions = r2.extensions || {};
    const n2 = ke(t2.userData._clearcoatTint, false);
    r2.extensions[zu.CLEARCOAT_TINT_GLTF_EXTENSION] = n2, e2.extensionsUsed[zu.CLEARCOAT_TINT_GLTF_EXTENSION] = true;
  } });
  var Hu = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let Wu = class extends Gt {
    constructor(e2, t2, r2) {
      super(e2, t2, null != r2 ? r2 : new qu(), new Ae(0, 0, 0), 1), this.enabled = true, this._firstCall = true;
    }
    render(e2, t2, r2, n2, i2) {
      if (!this.enabled)
        return;
      const s2 = this.overrideMaterial;
      s2.uniforms.currentProjectionViewMatrix.value.copy(this.camera.projectionMatrix).multiply(this.camera.matrixWorldInverse), this._firstCall && (s2.uniforms.lastProjectionViewMatrix.value.copy(s2.uniforms.currentProjectionViewMatrix.value), this._firstCall = false), super.render(e2, t2, r2, n2, i2), s2.uniforms.lastProjectionViewMatrix.value.copy(s2.uniforms.currentProjectionViewMatrix.value);
    }
  };
  Hu([Je("Enabled")], Wu.prototype, "enabled", void 0), Wu = Hu([lt("Velocity Buffer (TAA)")], Wu);
  class qu extends n.jyz {
    constructor() {
      super({ vertexShader: "#ifdef USE_ALPHAMAP\n#define USE_UV \n#endif\n#include <uv_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 modelMatrixPrevious;void main(){\n#include <uv_vertex>\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\nvec4 mvPosition=vec4(transformed,1.);\n#ifdef USE_INSTANCING\nmvPosition=instanceMatrix*mvPosition;\n#endif\nvWorldPosition=(modelMatrix*mvPosition).xyz;vWorldPositionPrevious=(modelMatrixPrevious*mvPosition).xyz;mvPosition=modelViewMatrix*mvPosition;gl_Position=projectionMatrix*mvPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n}", fragmentShader: "varying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 currentProjectionViewMatrix;uniform mat4 lastProjectionViewMatrix;vec2 computeScreenSpaceVelocity2(){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(vWorldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(vWorldPositionPrevious,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}void main(){vec2 velocity=clamp(computeScreenSpaceVelocity2(),-1.,1.);velocity=sign(velocity)*pow(abs(velocity),vec2(1./4.));velocity=velocity*0.5+0.5;gl_FragColor=vec4(velocity.x,velocity.y,1.,1.);}", uniforms: { cameraNearFar: { value: new n.FM8(0.1, 1e3) }, alphaMap: { value: null }, alphaTest: { value: null }, currentProjectionViewMatrix: { value: new n.yGw() }, lastProjectionViewMatrix: { value: new n.yGw() } } }), this.extraUniformsToUpload = { modelMatrixPrevious: { value: new n.yGw().identity() } }, this._previousWorldMatrices = {};
    }
    onBeforeRender(e2, t2, r2, i2, s2) {
      var o2, a2;
      const l2 = this._previousWorldMatrices[s2.uuid];
      this.extraUniformsToUpload.modelMatrixPrevious.value.copy(null != l2 ? l2 : s2.matrixWorld), l2 ? l2.copy(s2.matrixWorld) : this._previousWorldMatrices[s2.uuid] = s2.matrixWorld.clone();
      let c2 = s2.material;
      Array.isArray(c2) && (c2 = c2[0]), this.uniforms.alphaMap.value = null !== (o2 = null == c2 ? void 0 : c2.alphaMap) && void 0 !== o2 ? o2 : null, this.uniforms.alphaTest.value = !c2 || !c2.alphaTest || c2.alphaTest < 1e-7 ? 1e-3 : c2.alphaTest;
      let u2 = this.uniforms.alphaMap.value ? 1 : void 0;
      u2 !== this.defines.USE_ALPHAMAP && (void 0 === u2 ? delete this.defines.USE_ALPHAMAP : this.defines.USE_ALPHAMAP = u2, this.needsUpdate = true), u2 = c2.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0, u2 !== this.defines.ALPHA_I_RGBA_PACKING && (void 0 === u2 ? delete this.defines.ALPHA_I_RGBA_PACKING : this.defines.ALPHA_I_RGBA_PACKING = u2, this.needsUpdate = true), this.side = null !== (a2 = c2.side) && void 0 !== a2 ? a2 : n.ehD;
    }
  }
  class Xu extends io {
    constructor(e2 = true) {
      super(), this.passId = "velocityBuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this._velocityBuffers = [], this.enabled = e2;
    }
    passCtor(e2) {
      const t2 = e2.renderer.createTarget({ depthBuffer: true, type: n.ywz });
      t2.texture.name = "velocityBuffer", this._velocityBuffers.push(t2), e2.getPluginByType("debug");
      const r2 = /* @__PURE__ */ new Set(), i2 = /* @__PURE__ */ new Set();
      return new class extends Wu {
        render(n2, s2, o2, a2, l2) {
          if (e2.renderer.frameCount > 0)
            return;
          const c2 = n2.getRenderTarget(), u2 = n2.getActiveCubeFace(), h2 = n2.getActiveMipmapLevel();
          this.scene.traverse(({ material: e3 }) => {
            e3 && ((e3.transparent && e3.userData.renderToDepth || !e3.transparent && 0 === e3.transmission && false === e3.userData.renderToDepth) && (r2.add(e3), e3.transparent = !e3.transparent), Math.abs(e3.transmission || 0) > 0 && e3.userData.renderToDepth && (i2.add([e3, e3.transmission]), e3.transmission = 0));
          }), W(n2, { shadowMapRender: false, backgroundRender: false, opaqueRender: true, transparentRender: false, transmissionRender: false, mainRenderPass: false }, () => super.render(n2, s2, t2, a2, l2)), r2.forEach((e3) => e3.transparent = !e3.transparent), r2.clear(), i2.forEach(([e3, t3]) => e3.transmission = t3), i2.clear(), n2.setRenderTarget(c2, u2, h2);
        }
      }();
    }
    _update(e2) {
      if (!super._update(e2))
        return false;
      if (e2.renderer.frameCount > 0)
        return false;
      const t2 = this.pass.passObject;
      return t2.scene = e2.scene.modelObject, e2.scene.activeCamera.updateShaderProperties(t2.overrideMaterial), t2.camera = e2.scene.activeCamera.cameraObject, true;
    }
    getVelocityBuffer() {
      return this._velocityBuffers.length > 0 ? this._velocityBuffers[0] : void 0;
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      return this._velocityBuffers.forEach((t2) => {
        var r2;
        return e2.renderer.disposeTarget(null === (r2 = null == t2 ? void 0 : t2.dispose) || void 0 === r2 ? void 0 : r2.call(t2));
      }), super.onRemove(e2);
    }
    updateShaderProperties(e2) {
      var t2, r2;
      return e2.uniforms.tVelocity ? e2.uniforms.tVelocity.value = this.enabled && null !== (r2 = null === (t2 = this.getVelocityBuffer()) || void 0 === t2 ? void 0 : t2.texture) && void 0 !== r2 ? r2 : null : console.warn("BaseRenderer: no uniform: tVelocity"), this;
    }
    get uiConfig() {
      var e2;
      return null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.uiConfig;
    }
  }
  Xu.PluginType = "VelocityBuffer";
  class Yu extends zt {
    constructor(e2, t2) {
      super({ vertexShader: i.vertexShader, fragmentShader: t2 + "\n" + ko + "\n#include <common>\nvarying vec2 vUv;uniform vec2 previousRTSize;uniform mat4 lastProjectionViewMatrix;uniform mat4 currentProjectionViewMatrix;uniform mat4 inverseViewMatrix;uniform vec2 jitterSample;uniform vec2 feedBack;uniform bool firstFrame;\n#if HAS_VELOCITY_BUFFER == 1\nuniform sampler2D tVelocity;\n#endif\nvec3 find_closest_fragment_3x3(const in vec2 uv){const vec3 offset=vec3(-1.,1.,0.);vec2 texelSize=1./previousRTSize;vec3 dtr=vec3(-1,1,getDepth(uv+offset.yx*texelSize));vec3 dtc=vec3(0,1,getDepth(uv+offset.zx*texelSize));vec3 dtl=vec3(1,1,getDepth(uv+offset.xx*texelSize));vec3 dml=vec3(-1,0,getDepth(uv+offset.yz*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dmr=vec3(1,0,getDepth(uv+offset.xz*texelSize));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.yy*texelSize));vec3 dbc=vec3(0,-1,getDepth(uv+offset.zy*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.xy*texelSize));vec3 dmin=dtl;if(dmin.z>dtc.z)dmin=dtc;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dml.z)dmin=dml;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dmr.z)dmin=dmr;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbc.z)dmin=dbc;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+texelSize.xy*dmin.xy,dmin.z);}vec3 find_closest_fragment_5tap(const in vec2 uv){vec2 texelSize=1./previousRTSize;vec2 offset=vec2(1.,-1.);vec3 dtl=vec3(-1,1,getDepth(uv+offset.yx*texelSize));vec3 dtr=vec3(1,1,getDepth(uv+offset.xx*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.yy*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.xy*texelSize));vec3 dmin=dtl;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+dmin.xy*texelSize,dmin.z);}vec4 clip_aabb(const in vec4 aabb_min,const in vec4 aabb_max,vec4 p){const float FLT_EPS=1e-8;vec4 p_clip=0.5*(aabb_max+aabb_min);vec4 e_clip=0.5*(aabb_max-aabb_min)+FLT_EPS;vec4 v_clip=p-p_clip;vec4 v_unit=abs(v_clip/e_clip);float ma_unit=max(v_unit.x,max(v_unit.y,v_unit.z));if(ma_unit>1.)return p_clip+v_clip/ma_unit;else return p;}\n#if HAS_VELOCITY_BUFFER == 0\nvec2 computeScreenSpaceVelocity(const in vec3 worldPosition){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(worldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(worldPosition,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}\n#endif\nvec4 computeTAA(const in vec2 uv,const in vec2 screenSpaceVelocity){vec2 jitterOffset=jitterSample/previousRTSize;vec2 uvUnJitter=uv;vec4 currentColor=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter));vec4 previousColor=previousRTTexelToLinear(texture2D(previousRT,uv-screenSpaceVelocity));const vec3 offset=vec3(1.,-1.,0.);vec2 texelSize=1./previousRTSize;float texelSpeed=length(screenSpaceVelocity);vec4 tl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yx*texelSize));vec4 tc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zx*texelSize));vec4 tr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xx*texelSize));vec4 ml=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yz*texelSize));vec4 mc=currentColor;vec4 mr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xz*texelSize));vec4 bl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yy*texelSize));vec4 bc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zy*texelSize));vec4 br=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xy*texelSize));vec4 corners=2.*(tr+bl+br+tl)-2.*mc;mc+=(mc-(corners*0.166667))*2.718282*0.3;mc=max(vec4(0.),mc);vec4 min5=min(tc,min(ml,min(mc,min(mr,bc))));vec4 max5=max(tc,max(ml,max(mc,max(mr,bc))));vec4 cmin=min(min5,min(tl,min(tr,min(bl,br))));vec4 cmax=max(min5,max(tl,max(tr,max(bl,br))));;cmin=0.5*(cmin+min5);cmax=0.5*(cmax+max5);previousColor=clip_aabb(cmin,cmax,previousColor);float lum0=luminance(currentColor.rgb);float lum1=luminance(previousColor.rgb);float unbiased_diff=abs(lum0-lum1)/max(lum0,max(lum1,0.2));float unbiased_weight=1.-unbiased_diff;float unbiased_weight_sqr=unbiased_weight*unbiased_weight;float k_feedback=mix(feedBack.x,feedBack.y,unbiased_weight_sqr);return mix(currentColor,previousColor,k_feedback);}vec3 getWorldPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return(inverseViewMatrix*vec4(xe,ye,viewDepth,1.)).xyz;}void main(){vec2 jitterOffset=jitterSample/previousRTSize;\n#if QUALITY == 1\nvec3 c_frag=find_closest_fragment_3x3(vUv);\n#else\nvec3 c_frag=find_closest_fragment_5tap(vUv);\n#endif\nif(c_frag.z>=0.999){gl_FragColor=currentRTTexelToLinear(texture2D(currentRT,vUv-jitterOffset));}else{float sampleViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,c_frag.z);vec3 worldPosition=getWorldPositionFromViewZ(c_frag.xy,sampleViewZ);\n#if HAS_VELOCITY_BUFFER == 0\nvec2 screenSpaceVelocity=computeScreenSpaceVelocity(worldPosition);\n#else\nvec2 screenSpaceVelocity=(texture2D(tVelocity,vUv).xy*2.-1.);screenSpaceVelocity=sign(screenSpaceVelocity)*pow(abs(screenSpaceVelocity),vec2(4.));\n#endif\ngl_FragColor=firstFrame?currentRTTexelToLinear(texture2D(currentRT,vUv)):computeTAA(vUv,screenSpaceVelocity);}\n#include <encodings_fragment>\n}", uniforms: { currentRT: { value: null }, previousRT: { value: null }, previousRTSize: { value: new n.FM8() }, cameraNearFar: { value: new n.FM8() }, lastProjectionViewMatrix: { value: new n.yGw() }, currentProjectionViewMatrix: { value: new n.yGw() }, projection: { value: new n.yGw() }, inverseViewMatrix: { value: new n.yGw() }, jitterSample: { value: new n.FM8() }, firstFrame: { value: true }, tNormalDepth: { value: null }, tVelocity: { value: null } }, defines: { HAS_VELOCITY_BUFFER: 0, QUALITY: 1, UNJITTER: 0 } }, "currentRT", "previousRT"), this.taaEnabled = true, this.feedBack = new n.FM8(0.88, 0.97), this.uiConfig = { type: "folder", label: "Temporal AA", children: [{ type: "checkbox", label: "Enabled", property: [this, "enabled"], onChange: () => this.onSizeUpdate() }, { type: "input", label: "Feedback", property: [this, "feedBack"], onChange: this.setDirty }] }, this.onSizeUpdate = this.onSizeUpdate.bind(this), this.target = e2, this.clear = false, this.needsSwap = true;
    }
    render(e2, t2, r2, n2, i2) {
      if (!this.taaEnabled || !this.enabled)
        return void (this.needsSwap = false);
      this.needsSwap = true;
      const s2 = this.uniforms.tVelocity.value ? 1 : 0;
      s2 !== this.material.defines.HAS_VELOCITY_BUFFER && (this.material.defines.HAS_VELOCITY_BUFFER = s2, this.material.needsUpdate = true), this.uniforms.previousRT.value = this.target.texture, super.render(e2, t2, r2, n2, i2), this.uniforms.lastProjectionViewMatrix.value.copy(this.uniforms.currentProjectionViewMatrix.value), this.uniforms.firstFrame.value = false;
    }
    updateCameraProperties(e2) {
      e2 && (this.uniforms.currentProjectionViewMatrix.value.multiplyMatrices(e2.projectionMatrix, e2.matrixWorldInverse), this.uniforms.inverseViewMatrix.value.copy(e2.matrixWorld));
    }
    onSizeUpdate() {
      this.uniforms.firstFrame.value = true, this.setDirty();
    }
    setSize(e2, t2) {
      super.setSize(e2, t2), this.onSizeUpdate();
    }
  }
  !function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, r2, o2);
  }([Ce(), G()], Yu.prototype, "feedBack", void 0);
  class Ku extends io {
    constructor() {
      super(...arguments), this.passId = "taa", this._beforeFilters = ["progressive"], this._afterFilters = [], this._requiredFilters = ["render", "progressive"], this.dependencies = [lo];
    }
    passCtor(e2) {
      if (!e2.getPlugin(To))
        throw "Add ProgressivePlugin before TAA";
      const t2 = new Yu(e2.getPlugin(To).lastFrame, e2.getPlugin(lo).getUnpackSnippet());
      return e2.renderer.addEventListener("resize", t2.onSizeUpdate), t2;
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    async onDispose(e2) {
      return this.pass && e2.renderer.removeEventListener("resize", this.pass.passObject.onSizeUpdate), super.onDispose(e2);
    }
    _update(e2) {
      if (!super._update(e2))
        return false;
      const t2 = e2.renderer.frameCount, r2 = this._pass.passObject;
      if (r2.taaEnabled = t2 < 1, !r2.taaEnabled)
        return false;
      const n2 = e2.scene.activeCamera;
      return r2.updateShaderProperties([e2.getPlugin(lo), n2, e2.getPluginByType("VelocityBuffer")]), r2.target = e2.getPlugin(To).lastFrame, r2.updateCameraProperties(null == n2 ? void 0 : n2.cameraObject), true;
    }
    get uiConfig() {
      var e2;
      return null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.uiConfig;
    }
  }
  Ku.PluginType = "TAA";
  class Ju {
    static async GetDataUrl(e2, { mimeType: t2 = "image/png", rect: r2 = { x: 0, y: 0, width: e2.width, height: e2.height, assumeClientRect: false }, displayPixelRatio: n2 = 1, scale: i2 = 1 }) {
      var s2, o2, a2;
      const l2 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      l2.width = r2.width * i2 * n2, l2.height = r2.height * i2 * n2, r2.assumeClientRect && (r2.x *= e2.width / (n2 * e2.clientWidth), r2.y *= e2.height / (n2 * e2.clientHeight), r2.width *= e2.width / (n2 * e2.clientWidth), r2.height *= e2.height / (n2 * e2.clientHeight));
      const c2 = l2.getContext("2d");
      if (!c2)
        return console.error("snapshot: cannot create context"), "";
      const u2 = e2.style.background || (null === (s2 = e2.parentElement) || void 0 === s2 ? void 0 : s2.style.background) || "";
      if (u2.includes("url")) {
        const t3 = null === (o2 = /url\("(.*)"\)/gi.exec(u2)) || void 0 === o2 ? void 0 : o2[1];
        if (t3) {
          const i3 = new Image();
          i3.src = t3, await new Promise((e3, t4) => {
            i3.onload = () => e3(), i3.onerror = () => t4(), i3.complete && e3();
          }), c2.drawImage(i3, i3.width * r2.x * n2 / e2.width, i3.height * r2.y * n2 / e2.height, i3.width * r2.width * n2 / e2.width, i3.height * r2.height * n2 / e2.height, 0, 0, l2.width, l2.height);
        }
      } else
        c2.fillStyle = e2.style.background || (null === (a2 = e2.parentElement) || void 0 === a2 ? void 0 : a2.style.backgroundColor) || "#00000000", c2.fillRect(0, 0, l2.width, l2.height);
      null == c2 || c2.drawImage(e2, r2.x * n2, r2.y * n2, r2.width * n2, r2.height * n2, 0, 0, l2.width, l2.height);
      const h2 = c2.canvas.toDataURL(t2);
      return l2.remove(), h2;
    }
    static async GetImage(e2, t2 = {}) {
      const r2 = await this.GetDataUrl(e2, t2);
      return new Promise((e3, t3) => {
        const n2 = new Image();
        n2.onload = () => {
          e3(n2);
        }, n2.src = r2;
      });
    }
    static async GetBlob(e2, t2 = {}) {
      return await (await fetch(await this.GetDataUrl(e2, t2))).blob();
    }
    static async GetFile(e2, t2 = "image.png", r2 = {}) {
      var n2;
      return r2.getDataUrl ? await this.GetDataUrl(e2, r2) : new File([await this.GetBlob(e2, r2)], t2, { type: null !== (n2 = r2.mimeType) && void 0 !== n2 ? n2 : "image/png", lastModified: Dt() });
    }
  }
  var Zu = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let $u = class extends ro {
    constructor() {
      super(), this.enabled = true, this.downloadSnapshot = this.downloadSnapshot.bind(this);
    }
    async getFile(e2, t2 = {}) {
      return t2.getDataUrl = false, await this._getFile(e2, t2);
    }
    async getDataUrl(e2 = {}) {
      var t2;
      return e2.getDataUrl = true, null !== (t2 = await this._getFile("", e2)) && void 0 !== t2 ? t2 : "";
    }
    async _getFile(e2, t2 = {}) {
      var r2, n2, i2;
      const s2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.canvas;
      if (s2) {
        const r3 = this._viewer.renderer.displayCanvasScaling;
        void 0 !== t2.displayPixelRatio && t2.displayPixelRatio !== r3 && (this._viewer.renderer.displayCanvasScaling = t2.displayPixelRatio);
        const o2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPlugin(To);
        if (t2.waitForProgressive && o2 && void 0 === t2.timeout)
          for (; !o2.isConverged(true); )
            await Dc(64);
        else
          await Dc(null !== (i2 = t2.timeout) && void 0 !== i2 ? i2 : 200);
        t2.displayPixelRatio = 1;
        const a2 = await Ju.GetFile(s2, e2, t2);
        return t2.displayPixelRatio = this._viewer.renderer.displayCanvasScaling, this._viewer.renderer.displayCanvasScaling = r3, a2;
      }
    }
    async downloadSnapshot(e2 = "snapshot.png", t2 = {}) {
      const r2 = await this.getFile(e2, t2);
      r2 && wt(r2);
    }
  };
  $u.PluginType = "CanvasSnipper", Zu([rt("Download .png", { limitedUi: true })], $u.prototype, "downloadSnapshot", null), $u = Zu([lt("Image Export")], $u);
  var eh = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let th = 1, rh = class {
    constructor(e2, t2, r2, i2, s2) {
      this.position = new n.Pa4(), this.target = new n.Pa4(), this.quaternion = new n._fP(), this.up = new n.Pa4(), this.name = "Camera View", this.snap = "", this.focusView = () => {
      }, this.deleteView = () => {
      }, this.uiConfig = at(this.name, this), e2 && (this.position = e2), t2 && (this.target = t2), r2 && (this.up = r2), i2 && (this.quaternion = i2), s2 && (this.snap = s2), this.name = "Camera View" + th++;
    }
    _nameChanged() {
      var e2, t2;
      this.uiConfig && (this.uiConfig.label = this.name, null === (t2 = (e2 = this.uiConfig).uiRefresh) || void 0 === t2 || t2.call(e2));
    }
  };
  eh([Ce(), et()], rh.prototype, "position", void 0), eh([Ce(), et()], rh.prototype, "target", void 0), eh([Ce(), et()], rh.prototype, "quaternion", void 0), eh([Ce(), et()], rh.prototype, "up", void 0), eh([Ce(), nt()], rh.prototype, "name", void 0), eh([st()], rh.prototype, "snap", void 0), eh([rt()], rh.prototype, "focusView", void 0), eh([rt()], rh.prototype, "deleteView", void 0), rh = eh([Be("CameraView")], rh);
  class nh extends ro {
    constructor() {
      super(), this.enabled = true, this._cameraViews = [], this.viewLooping = false, this.viewPauseTime = 200, this.animEase = "easeInOutSine", this.animDuration = 1e3, this.rotationOffset = 0.25, this.interpolateMode = "spherical", this.animateOnScroll = false, this.seekOnScroll = false, this._animating = false, this.dependencies = [], this._scrollAnimationState = 0, this.scrollAnimationDamping = 0.1, this._updaters = [], this._lastFrameTime = 0, this._fadeDisabled = false, this._viewQueue = [], this._animationLooping = false, this._infiniteLooping = true, this._driver = (e2) => ({ start: () => this._updaters.push({ u: e2, time: 0 }), stop: () => this._updaters.splice(this._updaters.findIndex((t2) => t2.u === e2), 1) }), this.focusNext = (e2 = true) => {
        if (this._animating)
          return;
        if (this._cameraViews.length < 2)
          return;
        let t2 = this._cameraViews.findIndex((e3) => e3 === this._currentView);
        t2 < 0 && (t2 = -1), t2 += 1, e2 ? t2 %= this._cameraViews.length : t2 = Math.min(t2, this._cameraViews.length - 1), this.focusView(this._cameraViews[t2]);
      }, this.focusPrevious = (e2 = true) => {
        if (this._animating)
          return;
        if (this._cameraViews.length < 2 || !this._currentView)
          return;
        let t2 = this._cameraViews.findIndex((e3) => e3 === this._currentView);
        t2 < 0 && (t2 = 0), t2 -= 1, t2 = e2 ? (t2 + this._cameraViews.length) % this._cameraViews.length : Math.max(t2, 0), this.focusView(this._cameraViews[t2]);
      }, this._popAnimations = [], this.uiConfig = { type: "folder", label: "Camera Views", children: [() => [...this._cameraViews.map((e2) => e2.uiConfig)], ...ot(this)] }, this.addCurrentView = this.addCurrentView.bind(this), this.animateAllViews = this.animateAllViews.bind(this), this.recordAllViews = this.recordAllViews.bind(this), this.resetToFirstView = this.resetToFirstView.bind(this), this._wheel = this._wheel.bind(this), this._pointerMove = this._pointerMove.bind(this), this._postFrame = this._postFrame.bind(this);
    }
    get animationLooping() {
      return this._animationLooping;
    }
    get animating() {
      return this._animating;
    }
    get camViews() {
      return this._cameraViews;
    }
    _wheel(e2) {
      this.enabled && (this.seekOnScroll && !this._animating || Math.abs(e2.deltaY) > 1e-3 && (this._scrollAnimationState = -1 * Math.sign(e2.deltaY)));
    }
    _pointerMove(e2) {
      var t2;
      if (this.enabled && !this._animating && this.seekOnScroll) {
        const r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.activeCamera;
        if (!r2)
          return;
        const i2 = new n.$V(), s2 = r2.position, o2 = r2.target, a2 = new n._fP().setFromUnitVectors(r2.cameraObject.up, new n.Pa4(0, 1, 0)), l2 = a2.clone().invert(), c2 = s2.clone().sub(o2);
        c2.applyQuaternion(a2), i2.setFromVector3(c2), i2.theta += this.rotationOffset * e2.movementX / this._viewer.canvas.clientWidth, i2.phi += this.rotationOffset * e2.movementY / this._viewer.canvas.clientHeight, i2.makeSafe(), c2.setFromSpherical(i2), c2.applyQuaternion(l2), s2.copy(o2).add(c2), r2.positionUpdated(false), r2.targetUpdated();
      }
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      let t2 = false;
      e2.addEventListener("preFrame", (e3) => {
        this.seekOnScroll || this._animating ? this._viewer.scene.activeCamera.interactionsEnabled && (this._viewer.scene.activeCamera.interactionsEnabled = false, t2 = true) : t2 && (this._viewer.scene.activeCamera.interactionsEnabled = true, t2 = false);
      }), e2.addEventListener("postFrame", this._postFrame), window.addEventListener("wheel", this._wheel), window.addEventListener("pointermove", this._pointerMove);
    }
    _postFrame() {
      var e2, t2;
      if (!this._viewer)
        return;
      if (!this.enabled || !this._animating)
        return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e2 = this._viewer.getPluginByType("FrameFade")) || void 0 === e2 || e2.enable(nh.PluginType), this._fadeDisabled = false));
      const r2 = Dt() / 1e3;
      this._lastFrameTime < 1 && (this._lastFrameTime = r2 - 1 / 60);
      let n2 = r2 - this._lastFrameTime;
      this._lastFrameTime = r2, n2 *= this.animateOnScroll ? this._scrollAnimationState : 1;
      const i2 = null === (t2 = this._viewer.getPluginByType("Progressive")) || void 0 === t2 ? void 0 : t2.postFrameConvergedRecordingDelta();
      if (i2 && i2 > 0 && (n2 = i2), 0 !== i2 && (n2 *= 1e3, !(n2 <= 0 || (this._updaters.forEach((e3) => {
        let t3 = n2;
        e3.time + t3 < 0 && (t3 = -e3.time), e3.time += t3, Math.abs(t3) > 1e-3 && e3.u(t3);
      }), this._scrollAnimationState < 1e-3 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping, this._fadeDisabled)))) {
        const e3 = this._viewer.getPluginByType("FrameFade");
        e3 && (e3.disable(nh.PluginType), this._fadeDisabled = true);
      }
    }
    async onRemove(e2) {
      return e2.removeEventListener("postFrame", this._postFrame), window.removeEventListener("wheel", this._wheel), window.removeEventListener("pointermove", this._pointerMove), super.onRemove(e2);
    }
    async _animationLoop() {
      if (!this._animationLooping) {
        for (this._animationLooping = true; (this.viewLooping || !this._infiniteLooping) && this.enabled && !(this._cameraViews.length < 1); ) {
          if (0 === this._viewQueue.length) {
            if (!this._infiniteLooping)
              break;
            this._viewQueue.push(...this._cameraViews);
          }
          await this.animateToView(this._viewQueue.shift()), await Dc(2 + this.viewPauseTime);
        }
        this._animationLooping = false;
      }
    }
    async animateAllViews() {
      if (this.enabled && !(this.viewLooping || this._cameraViews.length < 2)) {
        for (; this._viewQueue.length > 0; )
          this._viewQueue.pop();
        this._viewQueue.push(...this._cameraViews), this._viewQueue.push(this._viewQueue.shift()), this._infiniteLooping = false, await this._animationLoop(), this._infiniteLooping = true;
      }
    }
    async resetToFirstView(e2 = 100) {
      this.enabled && (this._currentView = void 0, await this.animateToView(this._cameraViews[0], e2), await Dc(2));
    }
    async recordAllViews(e2) {
      var t2;
      if (!this.enabled)
        return;
      const r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("CanvasRecorder");
      return r2 && r2.enabled && (await this.resetToFirstView(), r2.startRecording()) ? new Promise((t3, n2) => {
        const i2 = () => {
          r2.removeEventListener("start", s2), r2.removeEventListener("stop", i2), r2.removeEventListener("error", o2);
        }, s2 = async () => {
          i2(), null == e2 || e2(), await this.animateAllViews();
          const n3 = await r2.stopRecording();
          n3 && yt(n3, "recording.mp4"), t3();
        }, o2 = async () => {
          i2(), n2();
        };
        r2.addEventListener("start", s2), r2.addEventListener("stop", i2), r2.addEventListener("error", o2);
      }) : void 0;
    }
    async addCurrentView() {
      var e2, t2, r2, n2, i2;
      if (!this.enabled)
        return;
      const s2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.activeCamera;
      if (!s2)
        return;
      const o2 = this.getCurrentCameraView(s2);
      o2.snap = await (null === (r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin($u)) || void 0 === r2 ? void 0 : r2.getDataUrl({ displayPixelRatio: 0.25, mimeType: "image/jpg" })) || "", this._cameraViews.push(o2), null === (i2 = (n2 = this.uiConfig).uiRefresh) || void 0 === i2 || i2.call(n2);
    }
    getCurrentCameraView(e2) {
      var t2;
      if (e2 || (e2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.activeCamera), !e2)
        return new rh();
      const r2 = new n.Pa4(), i2 = e2.cameraObject.matrixWorld;
      r2.x = i2.elements[4], r2.y = i2.elements[5], r2.z = i2.elements[6];
      const s2 = new rh(e2.position.clone(), e2.target.clone(), r2.normalize(), e2.cameraObject.quaternion.clone(), "");
      return s2.focusView = async () => this.focusView(s2), s2.deleteView = () => this.deleteView(s2), s2;
    }
    async focusView(e2) {
      return this.animateToView(e2);
    }
    deleteView(e2) {
      var t2, r2;
      const n2 = this._cameraViews.indexOf(e2);
      n2 >= 0 && this._cameraViews.splice(n2, 1), null === (r2 = (t2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(t2);
    }
    async stopAllAnimations() {
      for (this.viewLooping = false, this._popAnimations.forEach((e2) => {
        var t2;
        return null === (t2 = null == e2 ? void 0 : e2.stop) || void 0 === t2 ? void 0 : t2.call(e2);
      }), this._popAnimations = []; this._animating || this._animationLooping; )
        await Dc(100);
    }
    async animateToView(e2, t2, r2) {
      var i2;
      const s2 = null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.scene.activeCamera;
      if (!s2)
        return;
      if (this._animating && (this._popAnimations.forEach((e3) => {
        var t3;
        return null === (t3 = null == e3 ? void 0 : e3.stop) || void 0 === t3 ? void 0 : t3.call(e3);
      }), await Dc(100), this._animating))
        return void console.warn("todo: still animating?");
      this._currentView = e2, this._animating = true, this.dispatchEvent({ type: "startViewChange", view: e2 }), void 0 === t2 && (t2 = this.animDuration);
      const o2 = "function" == typeof r2 ? r2 : kc[r2 || this.animEase], a2 = this._driver, l2 = [];
      this._popAnimations = [];
      const c2 = this._popAnimations;
      if ("spherical" === this.interpolateMode)
        l2.push(async function(e3, t3, r3, i3, s3, o3) {
          const a3 = e3.target.clone(), l3 = new n.Pa4(), c3 = new n.Pa4(), u2 = sh(e3.cameraObject, a3), h2 = sh(t3, t3.target), p2 = new n.$V();
          return ih({ from: 0, to: 1, duration: r3, ease: i3, driver: s3, onUpdate: (r4) => {
            p2.phi = oh(u2.phi, h2.phi, r4), p2.theta = oh(u2.theta, h2.theta, r4), p2.radius = te(u2.radius, h2.radius, r4), l3.copy(a3).lerp(t3.target, r4), c3.setFromSpherical(p2), c3.add(l3), e3.position = c3, e3.target = l3, e3.positionUpdated(false), e3.targetUpdated();
          }, onComplete: () => {
            e3.position = t3.position, e3.target = t3.target, e3.positionUpdated(false), e3.targetUpdated();
          } }, o3);
        }(s2, e2, t2, o2, a2, c2));
      else if ("linear" === this.interpolateMode) {
        l2.push(ih({ from: s2.position.clone(), to: e2.position.clone(), duration: t2, ease: o2, driver: a2, onUpdate: (e3) => s2.position = e3, onComplete: () => s2.position = e2.position }, c2)), l2.push(ih({ from: s2.target.clone(), to: e2.target.clone(), duration: t2, ease: o2, driver: a2, onUpdate: (e3) => {
          s2.target = e3, s2.targetUpdated();
        }, onComplete: () => {
          s2.target = e2.target, s2.targetUpdated();
        } }, c2));
        const r3 = s2.cameraObject.quaternion.clone(), i3 = new n._fP();
        l2.push(ih({ from: 0, to: 1, duration: t2, ease: o2, driver: a2, onUpdate: (t3) => {
          i3.copy(r3).slerp(e2.quaternion, t3), s2.cameraObject.quaternion.copy(i3), s2.cameraObject.updateProjectionMatrix();
        }, onComplete: () => {
          s2.cameraObject.quaternion.copy(e2.quaternion), s2.cameraObject.updateProjectionMatrix();
        } }, c2));
      }
      await Promise.all(l2), this._animating = false, this.dispatchEvent({ type: "viewChange", view: e2 }), await Dc(10);
    }
    fromJSON(e2, t2) {
      var r2, n2;
      return this._cameraViews.forEach((e3) => this.deleteView(e3)), super.fromJSON(e2, t2) ? (this._cameraViews.forEach((e3) => e3.focusView = async () => this.focusView(e3)), this._cameraViews.forEach((e3) => e3.deleteView = () => this.deleteView(e3)), null === (n2 = (r2 = this.uiConfig).uiRefresh) || void 0 === n2 || n2.call(r2), this) : null;
    }
    async animateToObject(e2, t2 = 4, r2, i2, s2 = { min: 0.5, max: 5 }) {
      if (!this._viewer)
        return;
      const o2 = new k().expandByObject(e2 || this._viewer.scene.modelRoot.modelObject, false, true), a2 = o2.getCenter(new n.Pa4()), l2 = o2.getSize(new n.Pa4()).length() / 2;
      await this.animateToTarget(Math.min(s2.max, Math.max(s2.min, l2 * t2)), a2, r2, i2);
    }
    async animateToTarget(e2, t2, r2, i2) {
      const s2 = this.getCurrentCameraView();
      s2.target.copy(t2);
      const o2 = new n.Pa4().subVectors(s2.target, s2.position).normalize();
      s2.position.copy(o2.multiplyScalar(-e2).add(s2.target)), await this.animateToView(s2, r2, i2);
    }
  }
  async function ih(e2, t2) {
    const r2 = e2.onComplete, n2 = e2.onStop;
    return e2 = { ...e2 }, new Promise((i2, s2) => {
      e2.onComplete = () => {
        null == r2 || r2(), i2();
      }, e2.onStop = () => {
        null == n2 || n2(), i2();
      };
      const o2 = Ic(e2);
      t2.push(o2);
    });
  }
  function sh(e2, t2) {
    const r2 = e2.position.clone();
    r2.sub(t2);
    const i2 = new n.$V().setFromVector3(r2);
    return i2.makeSafe(), i2;
  }
  function oh(e2, t2, r2) {
    const n2 = t2 - e2;
    return n2 >= Math.PI ? e2 + (n2 - 2 * Math.PI) * r2 : n2 <= -Math.PI ? e2 + (n2 + 2 * Math.PI) * r2 : e2 + n2 * r2;
  }
  function ah(e2, t2, r2) {
    const n2 = (1 - r2) * Math.cos(e2) + r2 * Math.cos(t2), i2 = (1 - r2) * Math.sin(e2) + r2 * Math.sin(t2);
    return Math.atan2(i2, n2);
  }
  nh.PluginType = "CameraViews", eh([Ce("cameraViews")], nh.prototype, "_cameraViews", void 0), eh([M(nh.prototype._animationLoop), Ce(), Je("Loop All Views", { limitedUi: true })], nh.prototype, "viewLooping", void 0), eh([Ce(), nt("View Pause Time")], nh.prototype, "viewPauseTime", void 0), eh([Ce(), tt("Ease", Object.keys(kc).map((e2) => ({ label: e2 })))], nh.prototype, "animEase", void 0), eh([Ce(), $e("Duration", [10, 1e4], 10, { limitedUi: true })], nh.prototype, "animDuration", void 0), eh([Ce(), $e("RotationOffset", [0.2, 0.75], 0.01)], nh.prototype, "rotationOffset", void 0), eh([Ce(), tt("Interpolation", ["spherical", "linear"].map((e2) => ({ label: e2 })))], nh.prototype, "interpolateMode", void 0), eh([Je(), Ce()], nh.prototype, "seekOnScroll", void 0), eh([rt("Animate All Views", { limitedUi: true })], nh.prototype, "animateAllViews", null), eh([rt("Record All Views")], nh.prototype, "recordAllViews", null), eh([rt("Add Current View")], nh.prototype, "addCurrentView", null), eh([rt("Focus Next")], nh.prototype, "focusNext", void 0), eh([rt("Focus Previous")], nh.prototype, "focusPrevious", void 0);
  const lh = new n.Pa4();
  function ch(e2, t2, r2) {
    let n2 = e2.dot(t2);
    n2 = Math.min(Math.max(n2, -1), 1);
    const i2 = Math.acos(n2) * r2;
    return lh.copy(e2).multiplyScalar(n2).sub(t2).negate().normalize(), e2.multiplyScalar(Math.cos(i2)).add(lh.multiplyScalar(Math.sin(i2)));
  }
  var uh = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class hh extends ro {
    constructor(e2 = true) {
      super(), this.enabled = true, this.light = new su("#cceeff", 1), this.lightLayers = 1, this._preRender = () => {
        var e3, t2, r2;
        if (!this.enabled)
          return void (this.light.layers.mask = 0);
        const n2 = null !== (t2 = null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.renderer.frameCount) && void 0 !== t2 ? t2 : 0;
        (n2 < 1 || n2 > 5) && this.light.randomizePosition(n2 < 5 ? 0 : n2), this.light.layers.mask = this.lightLayers, this.light.updateShadowParams(), null === (r2 = this._cameraHelper) || void 0 === r2 || r2.update();
      }, this._setDirty = this._setDirty.bind(this), this.enabled = e2;
    }
    get cameraHelper() {
      return this._cameraHelper;
    }
    async onAdded(e2) {
      await super.onAdded(e2), this._cameraHelper = new n.Rki(this.light.shadow.camera), this._cameraHelper.visible = false, this._cameraHelper.userData.bboxVisible = false, e2.scene.add(this._cameraHelper), e2.scene.addLight(this.light, { addToRoot: true }), e2.addEventListener("preRender", this._preRender);
    }
    async onRemove(e2) {
      return e2.removeEventListener("preRender", this._preRender), this.light.removeFromParent(), super.onRemove(e2);
    }
    _setDirty(e2 = false) {
      var t2, r2;
      e2 ? null === (t2 = this._viewer) || void 0 === t2 || t2.scene.setDirty() : null === (r2 = this._viewer) || void 0 === r2 || r2.setDirty();
    }
    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = { type: "folder", label: "Progressive Shadow", children: [{ type: "checkbox", label: "Enabled", property: [this, "enabled"], onChange: this._setDirty }, { type: "folder", label: "Directional Light", children: [{ type: "checkbox", label: "Visible", property: [this.light, "visible"], onChange: this._setDirty }, { type: "slider", label: "Intensity", bounds: [0, 10], property: [this.light, "intensity"], onChange: this._setDirty }, { type: "color", label: "Color", property: [this.light, "color"], onChange: this._setDirty }, { type: "checkbox", label: "Shadow Enabled", property: [this.light.shadowParams, "enabled"], onChange: [this.light.updateShadowParams, this._setDirty] }, { type: "slider", bounds: [0, 1], property: [this.light.randomParams, "focus"], onChange: this._setDirty }, { type: "slider", bounds: [0, 1], property: [this.light.randomParams, "spread"], onChange: this._setDirty }, { type: "slider", bounds: [0.01, 60], property: [this.light.randomParams, "distanceScale"], onChange: this._setDirty }, { type: "vec3", bounds: [-5, 5], property: [this.light.randomParams, "direction"], onChange: this._setDirty }, { type: "slider", bounds: [0.01, 10], property: [this.light.shadowParams, "radius"], onChange: [this.light.updateShadowParams, this._setDirty] }, { type: "slider", bounds: [0.01, 30], property: [this.light.shadowParams, "frustumSize"], onChange: [this.light.updateShadowParams, this._setDirty] }, { type: "slider", bounds: [-0.01, 0.01], property: [this.light.shadowParams, "bias"], onChange: [this.light.updateShadowParams, this._setDirty] }] }] };
    }
  }
  hh.PluginType = "RandomizedDirectionalLight", uh([Ce()], hh.prototype, "enabled", void 0), uh([Ce("rdLight")], hh.prototype, "light", void 0), uh([Ce()], hh.prototype, "lightLayers", void 0);
  var ph, dh = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let fh = ph = class extends ro {
    constructor(e2 = false) {
      super(), this.enabled = false, this.worldRadius = 100, this.tripodHeight = 10, this._paramsChanged = this._paramsChanged.bind(this), this.enabled = e2;
    }
    _paramsChanged() {
      var e2, t2, r2, i2, s2, o2, a2, l2, c2, u2, h2;
      const p2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getBackground(true);
      if (this.enabled && p2 && p2 !== vo)
        if (p2.isDataTexture)
          p2.mapping = n.dSO;
        else if (confirm("Background must be same as environment, do you want to change it?")) {
          const e3 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("SimpleBackgroundEnvUiPlugin1");
          e3 ? (e3.envmapBg = true, null === (i2 = (r2 = e3.uiConfig).uiRefresh) || void 0 === i2 || i2.call(r2, "postFrame", true)) : null === (s2 = this._viewer) || void 0 === s2 || s2.setBackground(vo);
        } else
          this.enabled = false;
      const d2 = null === (c2 = null === (l2 = null === (a2 = null === (o2 = this._viewer) || void 0 === o2 ? void 0 : o2.renderer) || void 0 === a2 ? void 0 : a2.rendererObject) || void 0 === l2 ? void 0 : l2.background.getBoxMesh2()) || void 0 === c2 ? void 0 : c2.material, f2 = null !== (u2 = null == d2 ? void 0 : d2.uniforms) && void 0 !== u2 ? u2 : n.Vj0.cube.uniforms;
      f2.tripodHeight || (f2.tripodHeight = { value: 1 }), f2.worldRadius || (f2.worldRadius = { value: 1 }), f2.tripodHeight.value = this.tripodHeight, f2.worldRadius.value = this.worldRadius, d2 && (!this.enabled && d2.defines.HDRi_GROUND_PROJ ? delete d2.defines.HDRi_GROUND_PROJ : this.enabled && (d2.defines.HDRi_GROUND_PROJ = "1"), d2.needsUpdate = true), null === (h2 = this._viewer) || void 0 === h2 || h2.setDirty();
    }
    async onAdded(e2) {
      var t2, r2, i2;
      await super.onAdded(e2), (null === (i2 = null === (r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.renderer) || void 0 === r2 ? void 0 : r2.rendererObject) || void 0 === i2 ? void 0 : i2.background.getBoxMesh()) && console.error("HDRi Ground Plugin must be added before setting any cube or env map"), n.Vj0.cube.fragmentShader = n.Vj0.cube.fragmentShader.replace("void main() {", "\n#ifdef HDRi_GROUND_PROJ\nfloat intersectPlane1(const in vec3 r0,const in vec3 rd,const in vec3 n,const in vec3 p0){float t=dot(p0-r0,n)/(dot(n,rd)+1e-6);return t<0.?1000.:t;}float intersectSphere1(in vec3 ro,in vec3 rd,in vec3 sph,in float rad){vec3 oc=ro-sph;float b=dot(oc,rd);float c=dot(oc,oc)-rad*rad;float t=b*b-c;return t<0.?t:-b+sqrt(t);}\n#define PI_HALF  1.5707963267948966\nuniform float worldRadius;uniform float tripodHeight;vec3 hdriProject(){vec3 p=normalize(vWorldDirection);vec3 camPos=cameraPosition;camPos.y-=tripodHeight;float t=intersectSphere1(camPos,p,vec3(0.,0.,0.),worldRadius);if(t>0.){float t2=intersectPlane1(camPos,p,vec3(0,-1,0),vec3(0.,-tripodHeight,0.));p=(camPos+min(t,t2)*p)/worldRadius;}else p=vec3(0.,1.,0.);return p;}\n#endif\n\nvoid main() {"), n.Vj0.cube.fragmentShader = n.Vj0.cube.fragmentShader.replace("vec3 vReflect = vWorldDirection;", "\nvec3 vReflect = \n#ifdef HDRi_GROUND_PROJ\nhdriProject()\n#else\nvWorldDirection\n#endif\n;\n"), e2.scene.addEventListener("environmentChanged", this._paramsChanged);
    }
  };
  fh.PluginType = "HDRiGroundPlugin", dh([Ce(), M(ph.prototype._paramsChanged), Je("Enabled")], fh.prototype, "enabled", void 0), dh([Ce(), M(ph.prototype._paramsChanged), $e("World Radius", [1, 1e3])], fh.prototype, "worldRadius", void 0), dh([Ce(), M(ph.prototype._paramsChanged), $e("Tripod height", [0, 50])], fh.prototype, "tripodHeight", void 0), fh = ph = dh([lt("HDRi Ground")], fh);
  var mh = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  const _h = { uniforms: { colorTexture: { value: null }, tNormalDepth: { value: null }, blurTexture: { value: null }, cocTexture: { value: null }, cocTextureSize: { value: new n.FM8() }, cameraNearFar: { value: new n.FM8() } }, vertexShader: Io, fragmentShader: Ht + "\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 cocTextureSize;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;uniform vec2 crossCenter;uniform float crossRadius;uniform float crossAlpha;uniform vec3 crossColor;float smoothBoundary(float d,float smooothFactor){smooothFactor*=0.5;float value=smoothstep(-smooothFactor,smooothFactor,d);return value;}float circle(vec2 p,float r){return min((length(p)-r),-(length(p)-r-0.01));}float computeCoc(){float depth=getDepth(vUv);if(depth>1.-0.01)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){vec4 blur=blurTextureTexelToLinear(texture2D(blurTexture,vUv));float scale=0.5;blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,-1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,-1.)/cocTextureSize));blur/=5.;vec2 uvNearest=(floor(vUv*cocTextureSize)+0.5)/cocTextureSize;float coc=abs(min(2.*cocTextureTexelToLinear(texture2D(cocTexture,uvNearest)).a-1.,computeCoc()));float cocLower=0.005;float cocHigher=0.3;vec4 outColor=vec4(mix(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,blur.rgb,smoothstep(cocLower,cocHigher,coc)),1.);vec2 d=vUv-crossCenter;if(length(d)>crossRadius+0.05){float dist=circle(d,crossRadius);gl_FragColor=outColor;}else{d.x*=cocTextureSize.x/cocTextureSize.y;float dist=circle(d,crossRadius);dist=smoothBoundary(dist,2.*fwidth(dist));vec4 color=outColor;vec3 dofCircleColor=mix(crossColor,color.rgb,1.-crossAlpha);gl_FragColor=vec4(mix(color.rgb,dofCircleColor,dist),color.a);}\n#include <encodings_fragment>\n}" }, gh = (jt({ uniforms: { cocTexture: { value: null }, colorTexture: { value: null }, colorTextureSize: { value: new n.FM8() }, direction: { value: new n.FM8() } }, vertexShader: Io, fragmentShader: "#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;const float MAXIMUM_BLUR_SIZE=16.;const float SIGMA=5.;const int NUM_SAMPLES=4;float normpdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}vec3 weightedBlur(){float cocIn=2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv)).a-1.;float kernelRadius=MAXIMUM_BLUR_SIZE*cocIn;vec2 invSize=1./colorTextureSize;cocIn*=cocIn*cocIn;float centreSpaceWeight=normpdf(0.,SIGMA)*abs(cocIn);float weightSum=centreSpaceWeight;vec3 centreSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb;vec3 diffuseSum=centreSample*weightSum;vec2 delta=invSize*kernelRadius/float(NUM_SAMPLES);for(int i=1;i<=NUM_SAMPLES;i++){float spaceWeight=normpdf(float(i),SIGMA);vec2 texcoord=direction*delta*float(i);vec4 rightSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv+texcoord));vec4 leftSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv-texcoord));float leftCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv-texcoord)).a-1.);float rightCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv+texcoord)).a-1.);leftCocWeight*=leftCocWeight*leftCocWeight;rightCocWeight*=rightCocWeight*rightCocWeight;diffuseSum+=((leftSample.rgb*leftCocWeight)+(rightSample.rgb*rightCocWeight))*spaceWeight;weightSum+=(spaceWeight*(leftCocWeight+rightCocWeight));}return diffuseSum/weightSum;}void main(){gl_FragColor=vec4(weightedBlur(),1.);\n#include <encodings_fragment>\n}" }, "colorTexture", "cocTexture"), jt({ uniforms: { colorTexture: { value: null }, colorTextureSize: { value: new n.FM8() }, direction: { value: new n.FM8() }, frameCount: { value: 0 }, blurRadius: { value: 16 } }, vertexShader: Io, fragmentShader: Po + "\n" + uu + "\n#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform float blurRadius;vec4 CircularBlur(){vec4 color=colorTextureTexelToLinear(texture2D(colorTexture,vUv));\n#ifdef DOF_MODE\nfloat blurDist=blurRadius*(2.*color.a-1.);\n#else\nfloat blurDist=blurRadius*color.a;\n#endif\nfloat rnd=PI2*random3(vec3(vUv,frameCount*0.1));float costheta=cos(rnd);float sintheta=sin(rnd);vec4 rotationMatrix=vec4(costheta,-sintheta,sintheta,costheta);vec3 colorSum=vec3(0.);float weightSum=0.001;vec2 ofs;vec4 sampleColor;setPds();\n#pragma unroll_loop_start\nfor(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));sampleColor=colorTextureTexelToLinear(texture2D(colorTexture,vUv+blurDist*ofs/colorTextureSize.xy));\n#ifdef DOF_MODE\nsampleColor.a=abs(sampleColor.a*2.-1.);sampleColor.a*=sampleColor.a*sampleColor.a;\n#endif\ncolorSum+=sampleColor.rgb*sampleColor.a;weightSum+=sampleColor.a;}\n#pragma unroll_loop_end\ncolorSum/=weightSum;return vec4(saturate(colorSum),1.);}void main(){gl_FragColor=CircularBlur();\n#include <encodings_fragment>\n}", defines: { DOF_MODE: 1 } }, "colorTexture"));
  class vh extends zt {
    constructor() {
      super(_h, "colorTexture", "cocTexture", "blurTexture"), this.dofBlurMaterial = gh, this.nearFarBlurScale = new n.FM8(0.25, 0.25), this.focalDepthRange = new n.FM8(0.5, 1.5), this.crossCenter = new n.FM8(0.5, 0.5), this.crossRadius = 0.04, this.crossAlpha = 1, this.crossColor = new Ae(16750848), this.uiConfig = { type: "folder", label: "Depth of Field", children: [{ type: "checkbox", label: "Enabled", limitedUi: true, property: [this, "enabled"] }, { type: "slider", label: "Depth Range", bounds: [0.5, 3], property: [this.focalDepthRange, "y"] }, { type: "slider", label: "Near Blur scale", bounds: [0, 1], property: [this.nearFarBlurScale, "x"] }, { type: "slider", label: "Far Blur scale", bounds: [0, 1], property: [this.nearFarBlurScale, "y"] }] }, this.material.extensions.derivatives = true, this.computeCocMaterial = jt({ uniforms: { colorTexture: { value: null }, tNormalDepth: this.uniforms.tNormalDepth, cameraNearFar: this.uniforms.cameraNearFar, nearFarBlurScale: this.uniforms.nearFarBlurScale, focalDepthRange: this.uniforms.focalDepthRange }, vertexShader: Io, fragmentShader: Ht + "\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;float computeCoc(){float depth=getDepth(vUv);if(depth==1.)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*computeCoc()+0.5);\n#include <encodings_fragment>\n}" }, "colorTexture"), this.expandCocMaterial = jt({ uniforms: { colorTexture: { value: null }, colorTextureSize: { value: new n.FM8() }, direction: { value: new n.FM8() }, tNormalDepth: this.uniforms.tNormalDepth, nearFarBlurScale: this.uniforms.nearFarBlurScale }, vertexShader: Io, fragmentShader: Ht + "\n#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;uniform vec2 nearFarBlurScale;const float MAXIMUM_BLUR_SIZE=4.;float expandNear(const in vec2 offset,const in bool isBackground){float coc=0.;vec2 sampleOffsets=MAXIMUM_BLUR_SIZE*offset/5.;float coc0=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv)).a-1.;float coc1=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-5.*sampleOffsets)).a-1.;float coc2=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-4.*sampleOffsets)).a-1.;float coc3=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-3.*sampleOffsets)).a-1.;float coc4=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-2.*sampleOffsets)).a-1.;float coc5=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-1.*sampleOffsets)).a-1.;float coc6=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+1.*sampleOffsets)).a-1.;float coc7=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+2.*sampleOffsets)).a-1.;float coc8=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+3.*sampleOffsets)).a-1.;float coc9=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+4.*sampleOffsets)).a-1.;float coc10=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+5.*sampleOffsets)).a-1.;if(isBackground){coc=abs(coc0)*0.095474+(abs(coc1)+abs(coc10))*0.084264+(abs(coc2)+abs(coc9))*0.088139+(abs(coc3)+abs(coc8))*0.091276+(abs(coc4)+abs(coc7))*0.093585+(abs(coc5)+abs(coc6))*0.094998;}else{coc=min(coc0,0.);coc=min(coc1*0.3,coc);coc=min(coc2*0.5,coc);coc=min(coc3*0.75,coc);coc=min(coc4*0.8,coc);coc=min(coc5*0.95,coc);coc=min(coc6*0.95,coc);coc=min(coc7*0.8,coc);coc=min(coc8*0.75,coc);coc=min(coc9*0.5,coc);coc=min(coc10*0.3,coc);if(abs(coc0)>abs(coc))coc=coc0;}return coc;}void main(){vec2 offset=2.*direction/colorTextureSize;bool isBackground=getDepth(vUv)>1.-0.001;float coc=expandNear(offset,isBackground);gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*coc+0.5);\n#include <encodings_fragment>\n}" }, "colorTexture");
    }
    render(e2, t2, r2, i2, s2) {
      if (!this.enabled)
        return;
      const o2 = e2.baseRenderer, a2 = { minFilter: n.TyD, magFilter: n.TyD, type: n.cLu, encoding: n.rnI, sizeMultiplier: 0.5, isAntialiased: false, format: n.wk1, depthBuffer: false, generateMipmaps: false }, l2 = o2.getTempTarget(a2), c2 = o2.getTempTarget(a2);
      if (this.computeCocMaterial.uniforms.colorTexture.value = r2.texture, o2.blit(void 0, l2, { material: this.computeCocMaterial }), this.expandCocMaterial.uniforms.colorTexture.value = l2.texture, this.expandCocMaterial.uniforms.direction.value.set(1, 0), o2.blit(void 0, c2, { material: this.expandCocMaterial }), this.expandCocMaterial.uniforms.colorTexture.value = c2.texture, this.expandCocMaterial.uniforms.direction.value.set(0, 1), o2.blit(void 0, l2, { material: this.expandCocMaterial }), this.dofBlurMaterial.uniforms.frameCount)
        this.dofBlurMaterial.uniforms.colorTexture.value = l2.texture, o2.blit(void 0, c2, { material: this.dofBlurMaterial });
      else {
        const e3 = o2.getTempTarget(a2);
        this.dofBlurMaterial.uniforms.cocTexture.value = l2.texture, this.dofBlurMaterial.uniforms.colorTexture.value = l2.texture, this.dofBlurMaterial.uniforms.direction.value.set(1, 0), o2.blit(void 0, e3, { material: this.dofBlurMaterial }), this.dofBlurMaterial.uniforms.colorTexture.value = e3.texture, this.dofBlurMaterial.uniforms.direction.value.set(0, 1), o2.blit(void 0, c2, { material: this.dofBlurMaterial }), o2.releaseTempTarget(e3);
      }
      this.material.uniforms.blurTexture.value = c2.texture, this.material.uniforms.cocTexture.value = l2.texture, super.render(e2, t2, r2, i2, s2), o2.releaseTempTarget(l2), o2.releaseTempTarget(c2);
    }
  }
  mh([Ce(), G()], vh.prototype, "nearFarBlurScale", void 0), mh([Ce(), G()], vh.prototype, "focalDepthRange", void 0), mh([G()], vh.prototype, "crossCenter", void 0), mh([G()], vh.prototype, "crossRadius", void 0), mh([G()], vh.prototype, "crossAlpha", void 0), mh([G()], vh.prototype, "crossColor", void 0);
  var Ah = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class bh extends io {
    constructor(e2 = true, t2 = false) {
      super(), this.passId = "depthOfField", this._beforeFilters = ["progressive", "tonemap", "screen"], this._afterFilters = ["render"], this._requiredFilters = ["render"], this.dependencies = [lo], this.enableEdit = false, this._focalPointHit = new n.Pa4(0, 0, 0), this.crossFadeTime = 200, this._focalPointHitTime = 0, this._tempVec = new n.Pa4(), this.enabled = e2, this.enableEdit = t2, this._onObjectHit = this._onObjectHit.bind(this), this.setDirty = this.setDirty.bind(this);
    }
    passCtor(e2) {
      return new vh();
    }
    setFocalPoint(e2, t2 = true, r2 = false) {
      var n2, i2;
      this._focalPointHit.copy(e2), t2 && (null === (i2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPlugin(Oc)) || void 0 === i2 || i2.startTransition(this._frameFadeTime)), r2 && (this._focalPointHitTime = Dt()), this.setDirty();
    }
    getFocalPoint() {
      return this._focalPointHit;
    }
    get depthRange() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.focalDepthRange.y) && void 0 !== t2 ? t2 : 0;
    }
    set depthRange(e2) {
      this.pass && (this.pass.passObject.focalDepthRange.y = e2), this.setDirty();
    }
    get nearBlurScale() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.nearFarBlurScale.x) && void 0 !== t2 ? t2 : 0;
    }
    set nearBlurScale(e2) {
      this.pass && (this.pass.passObject.nearFarBlurScale.x = e2), this.setDirty();
    }
    get farBlurScale() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.nearFarBlurScale.y) && void 0 !== t2 ? t2 : 0;
    }
    set farBlurScale(e2) {
      this.pass && (this.pass.passObject.nearFarBlurScale.y = e2), this.setDirty();
    }
    get _frameFadeTime() {
      return 2.5 * this.crossFadeTime;
    }
    _onObjectHit(e2) {
      var t2, r2;
      this._pass && e2.intersects.intersect && this.enabled && this.enableEdit && (this._focalPointHit.copy(e2.intersects.intersect.point), this._focalPointHitTime = e2.time, e2.intersects.selectedObject = null, null === (r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Oc)) || void 0 === r2 || r2.startTransition(this._frameFadeTime), this.setDirty());
    }
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2), null === (t2 = e2.getPluginByType("Picking")) || void 0 === t2 || t2.addEventListener("hitObject", this._onObjectHit);
    }
    async onRemove(e2) {
      var t2;
      return null === (t2 = e2.getPluginByType("Picking")) || void 0 === t2 || t2.removeEventListener("hitObject", this._onObjectHit), super.onRemove(e2);
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    _update(e2) {
      var t2, r2;
      if (!super._update(e2))
        return false;
      const i2 = null === (t2 = this.pass) || void 0 === t2 ? void 0 : t2.passObject;
      if (!i2)
        return false;
      const s2 = e2.getPlugin(lo);
      null == s2 || s2.updateShaderProperties(i2.material), i2.dofBlurMaterial.uniforms.frameCount && (null === (r2 = e2.renderer) || void 0 === r2 || r2.updateShaderProperties(i2.dofBlurMaterial));
      const o2 = e2.scene.activeCamera;
      if (!o2)
        return false;
      o2.cameraObject.updateMatrixWorld(true), o2.updateShaderProperties(i2.material), this._tempVec.subVectors(this._focalPointHit, o2.cameraObject.position), i2.focalDepthRange.x = this._tempVec.length(), i2.focalDepthRange.x *= o2.cameraObject.getWorldDirection(new n.Pa4()).dot(this._tempVec.normalize());
      let a2 = (Dt() - this._focalPointHitTime) / this.crossFadeTime;
      if (a2 = 1 - Math.min(1, Math.max(0, a2)), Math.abs(a2 - i2.crossAlpha) > 0.01 && (i2.crossAlpha = a2, this.setDirty()), a2 > 0) {
        const e3 = this._tempVec.copy(this._focalPointHit).project(o2.cameraObject).addScalar(1).divideScalar(2);
        i2.crossCenter.set(e3.x, e3.y), i2.computeCocMaterial.uniformsNeedUpdate = true, i2.expandCocMaterial.uniformsNeedUpdate = true;
      }
      return true;
    }
    get uiConfig() {
      var e2, t2, r2, n2, i2;
      if (this._uiConfig)
        return this._uiConfig;
      const s2 = null === (t2 = null === (e2 = this._pass) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.uiConfig;
      return s2 ? (null === (n2 = null === (r2 = s2.children) || void 0 === r2 ? void 0 : r2.map((e3) => A(e3))) || void 0 === n2 || n2.flat(2).forEach((e3) => e3 && (e3.onChange = this.setDirty)), null === (i2 = s2.children) || void 0 === i2 || i2.push({ type: "checkbox", label: "Enable Edit", limitedUi: true, property: [this, "enableEdit"] }), this._uiConfig = s2, s2) : {};
    }
  }
  bh.PluginType = "DepthOfField", Ah([Ce()], bh.prototype, "enableEdit", void 0), Ah([Ce("focalPoint")], bh.prototype, "_focalPointHit", void 0), Ah([Ce()], bh.prototype, "crossFadeTime", void 0);
  var yh, xh = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let wh = yh = class extends ro {
    constructor(e2 = true) {
      super(), this.enabled = true, this.radius = 0.015, this.intensity = 1, this.tolerance = 1.5, this._defines = {}, this.onlySSCSDebug = false, this.stepCount = 2, this.dependencies = [lo, to], this.materialExtension = { shaderExtender: (e3, t2, r2) => {
        if (!e3.defines.SSCS_ENABLED)
          return;
        const i2 = w`
                #ifndef D_sceneBoundingRadius
                #define D_sceneBoundingRadius
                uniform float sceneBoundingRadius;
                #endif
                float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, vec3 lightDirection ) {
                    vec3 ray_origin_view = -vViewPosition;
                    float rnd = interleavedGradientNoise(gl_FragCoord.xy, frameCount+34.);
                    float cameraDist = length(cameraPositionWorld);
//                    float radius = mix((cameraNearFar.y) + ray_origin_view.z, -ray_origin_view.z - cameraNearFar.x, rnd * 0.5 + 0.5)*sscsRadius;
                    float radius = mix((cameraDist + sceneBoundingRadius) + ray_origin_view.z, -ray_origin_view.z - max(0.0, cameraDist - sceneBoundingRadius), rnd * 0.5 + 0.5)*sscsRadius;
                    vec3 state = vec3(1.,(rnd+0.5)/float(SSCS_STEP_COUNT),2.);
                    traceRay(ray_origin_view, normalize(lightDirection) * radius, sscsTolerance * radius * 2., state, SSCS_STEP_COUNT);
                    state.z = state.z > 0.99 ? 1. : max(0.,min(state.z * state.z * (1.-sscsIntensity), 1.));
                    
                #if defined(SSCS_DEBUG) && SSCS_DEBUG > 0
                    return state.z;
                #endif
            `, s2 = `
#if SSCS_ENABLED

    uniform float sscsIntensity;
    uniform float sscsRadius;
    uniform float sscsTolerance;

    ${Do}
    
    #define THREE_PACKING_INCLUDED
    ${ko}
    
    ${Ht}
    ${Po}
    
    ${Ro}

#endif
            
            ` + n.WdD.shadowmap_pars_fragment.replace("float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {", `${i2}
`).replace("return shadow;", "return min(shadow, state.z);");
        e3.fragmentShader = e3.fragmentShader.replace("#include <shadowmap_pars_fragment>", s2), e3.fragmentShader = e3.fragmentShader.replace("#include <lights_fragment_begin>", n.WdD.lights_fragment_begin), e3.fragmentShader = e3.fragmentShader.replace("directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;", "directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ], directLight.direction ) : 1.0;").replace("directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;", "directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ], directLight.direction ) : 1.0;");
      }, onObjectRender: (e3, t2, r2) => {
        var n2;
        const i2 = t2.materialObject;
        let s2 = this.enabled && false !== r2.userData.screenSpaceRendering && !(null === (n2 = i2.userData) || void 0 === n2 ? void 0 : n2.sscsDisabled) ? 1 : 0;
        i2.defines.SSCS_ENABLED !== s2 && (i2.defines.SSCS_ENABLED = s2, i2.needsUpdate = true), s2 = this._defines.SSCS_STEP_COUNT, i2.defines.SSCS_STEP_COUNT !== s2 && (i2.defines.SSCS_STEP_COUNT = s2, i2.needsUpdate = true), s2 = +this._defines.SSCS_DEBUG, i2.defines.SSCS_DEBUG !== s2 && (i2.defines.SSCS_DEBUG = s2, i2.needsUpdate = true);
      }, parsFragmentSnippet: () => "\n", extraUniforms: { ...yh._uniforms }, computeCacheKey: (e3) => this.enabled ? "1" : "0", isCompatible: (e3) => e3.isMeshStandardMaterial2, updaters: () => {
        var e3, t2, r2, n2, i2;
        return [null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.getPlugin(lo), null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(To), null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.scene.activeCamera, null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.renderer, null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.scene];
      } }, this.enabled = e2, this.userData = { setDirty: () => {
        var e3;
        null === (e3 = this._viewer) || void 0 === e3 || e3.setDirty();
      } };
    }
    async onAdded(e2) {
      var t2, r2;
      await super.onAdded(e2), null === (r2 = null === (t2 = e2.getPlugin(to)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === r2 || r2.registerMaterialExtension(this.materialExtension);
    }
    async onRemove(e2) {
      var t2, r2;
      return null === (r2 = null === (t2 = e2.getPlugin(to)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === r2 || r2.unregisterMaterialExtension(this.materialExtension), super.onRemove(e2);
    }
  };
  wh.PluginType = "SSContactShadows", wh._uniforms = { tNormalDepth: { value: null }, frameCount: { value: 0 }, projection: { value: new n.yGw() }, cameraPositionWorld: { value: new n.Pa4() }, cameraNearFar: { value: new n.FM8(0.1, 1e3) }, sceneBoundingRadius: { value: 0 } }, xh([Je("Enabled"), Ce()], wh.prototype, "enabled", void 0), xh([G({ uniforms: yh._uniforms, propKey: "sscsRadius" }), $e("Radius", [1e-4, 0.1], 1e-4), Ce()], wh.prototype, "radius", void 0), xh([G({ uniforms: yh._uniforms, propKey: "sscsIntensity" }), $e("Intensity", [1e-4, 1], 1e-4), Ce()], wh.prototype, "intensity", void 0), xh([G({ uniforms: yh._uniforms, propKey: "sscsTolerance" }), $e("Tolerance", [0.1, 5]), Ce()], wh.prototype, "tolerance", void 0), xh([V("SSCS_DEBUG", void 0, true), Je("Debug only SSCS"), Ce()], wh.prototype, "onlySSCSDebug", void 0), xh([V("SSCS_STEP_COUNT", void 0, true), $e("Step count", [1, 8], 1), Ce()], wh.prototype, "stepCount", void 0), wh = yh = xh([lt("Screen Space Contact Shadows")], wh);
  class Eh {
    constructor(e2 = 4) {
      this.pool = e2, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
    }
    _initWorker(e2) {
      if (!this.workers[e2]) {
        const t2 = this.workerCreator();
        t2.addEventListener("message", this._onMessage.bind(this, e2)), this.workers[e2] = t2;
      }
    }
    _getIdleWorker() {
      for (let e2 = 0; e2 < this.pool; e2++)
        if (!(this.workerStatus & 1 << e2))
          return e2;
      return -1;
    }
    _onMessage(e2, t2) {
      const r2 = this.workersResolve[e2];
      if (r2 && r2(t2), this.queue.length) {
        const { resolve: t3, msg: r3, transfer: n2 } = this.queue.shift();
        this.workersResolve[e2] = t3, this.workers[e2].postMessage(r3, n2);
      } else
        this.workerStatus ^= 1 << e2;
    }
    setWorkerCreator(e2) {
      this.workerCreator = e2;
    }
    setWorkerLimit(e2) {
      this.pool = e2;
    }
    postMessage(e2, t2) {
      return new Promise((r2) => {
        const n2 = this._getIdleWorker();
        -1 !== n2 ? (this._initWorker(n2), this.workerStatus |= 1 << n2, this.workersResolve[n2] = r2, this.workers[n2].postMessage(e2, t2)) : this.queue.push({ resolve: r2, msg: e2, transfer: t2 });
      });
    }
    dispose() {
      this.workers.forEach((e2) => e2.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
    }
  }
  class Sh {
    constructor() {
      this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
    }
  }
  class Ch {
    constructor(e2, t2, r2, n2) {
      this._dataView = new DataView(e2.buffer, e2.byteOffset + t2, r2), this._littleEndian = n2, this._offset = 0;
    }
    _nextUint8() {
      const e2 = this._dataView.getUint8(this._offset);
      return this._offset += 1, e2;
    }
    _nextUint16() {
      const e2 = this._dataView.getUint16(this._offset, this._littleEndian);
      return this._offset += 2, e2;
    }
    _nextUint32() {
      const e2 = this._dataView.getUint32(this._offset, this._littleEndian);
      return this._offset += 4, e2;
    }
    _nextUint64() {
      const e2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
      return this._offset += 8, e2;
    }
    _nextInt32() {
      const e2 = this._dataView.getInt32(this._offset, this._littleEndian);
      return this._offset += 4, e2;
    }
    _skip(e2) {
      return this._offset += e2, this;
    }
    _scan(e2, t2 = 0) {
      const r2 = this._offset;
      let n2 = 0;
      for (; this._dataView.getUint8(this._offset) !== t2 && n2 < e2; )
        n2++, this._offset++;
      return n2 < e2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + r2, n2);
    }
  }
  new Uint8Array([0]);
  const Mh = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
  function Th(e2) {
    return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e2) : Buffer.from(e2).toString("utf8");
  }
  let Ih, kh, Dh;
  const Ph = { env: { emscripten_notify_memory_growth: function(e2) {
    Dh = new Uint8Array(kh.exports.memory.buffer);
  } } };
  class Bh {
    init() {
      return Ih || (Ih = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + Rh).then((e2) => e2.arrayBuffer()).then((e2) => WebAssembly.instantiate(e2, Ph)).then(this._init) : WebAssembly.instantiate(Buffer.from(Rh, "base64"), Ph).then(this._init), Ih);
    }
    _init(e2) {
      kh = e2.instance, Ph.env.emscripten_notify_memory_growth(0);
    }
    decode(e2, t2 = 0) {
      if (!kh)
        throw new Error("ZSTDDecoder: Await .init() before decoding.");
      const r2 = e2.byteLength, n2 = kh.exports.malloc(r2);
      Dh.set(e2, n2), t2 = t2 || Number(kh.exports.ZSTD_findDecompressedSize(n2, r2));
      const i2 = kh.exports.malloc(t2), s2 = kh.exports.ZSTD_decompress(i2, t2, n2, r2), o2 = Dh.slice(i2, i2 + s2);
      return kh.exports.free(n2), kh.exports.free(i2), o2;
    }
  }
  const Rh = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", Lh = /* @__PURE__ */ new WeakMap();
  let Oh, Fh = 0;
  class Uh extends n.aNw {
    constructor(e2) {
      super(e2), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new Eh(), this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
    }
    setTranscoderPath(e2) {
      return this.transcoderPath = e2, this;
    }
    setWorkerLimit(e2) {
      return this.workerPool.setWorkerLimit(e2), this;
    }
    detectSupport(e2) {
      return this.workerConfig = { astcSupported: e2.extensions.has("WEBGL_compressed_texture_astc"), etc1Supported: e2.extensions.has("WEBGL_compressed_texture_etc1"), etc2Supported: e2.extensions.has("WEBGL_compressed_texture_etc"), dxtSupported: e2.extensions.has("WEBGL_compressed_texture_s3tc"), bptcSupported: e2.extensions.has("EXT_texture_compression_bptc"), pvrtcSupported: e2.extensions.has("WEBGL_compressed_texture_pvrtc") || e2.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc") }, e2.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = false), this;
    }
    init() {
      if (!this.transcoderPending) {
        const e2 = new n.hH6(this.manager);
        e2.setPath(this.transcoderPath), e2.setWithCredentials(this.withCredentials);
        const t2 = e2.loadAsync("basis_transcoder.js"), r2 = new n.hH6(this.manager);
        r2.setPath(this.transcoderPath), r2.setResponseType("arraybuffer"), r2.setWithCredentials(this.withCredentials);
        const i2 = r2.loadAsync("basis_transcoder.wasm");
        this.transcoderPending = Promise.all([t2, i2]).then(([e3, t3]) => {
          const r3 = Uh.BasisWorker.toString(), n2 = ["/* constants */", "let _EngineFormat = " + JSON.stringify(Uh.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(Uh.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(Uh.BasisFormat), "/* basis_transcoder.js */", e3, "/* worker */", r3.substring(r3.indexOf("{") + 1, r3.lastIndexOf("}"))].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([n2])), this.transcoderBinary = t3, this.workerPool.setWorkerCreator(() => {
            const e4 = new Worker(this.workerSourceURL), t4 = this.transcoderBinary.slice(0);
            return e4.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: t4 }, [t4]), e4;
          });
        }), Fh > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), Fh++;
      }
      return this.transcoderPending;
    }
    load(e2, t2, r2, i2) {
      if (null === this.workerConfig)
        throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
      const s2 = new n.hH6(this.manager);
      s2.setResponseType("arraybuffer"), s2.setWithCredentials(this.withCredentials), s2.load(e2, (e3) => {
        if (Lh.has(e3))
          return Lh.get(e3).promise.then(t2).catch(i2);
        this.createTexture(e3).then((e4) => t2 ? t2(e4) : null).catch(i2);
      }, r2, i2);
    }
    _createTextureFrom(e2) {
      const { mipmaps: t2, width: r2, height: i2, format: s2, type: o2, error: a2, dfdTransferFn: l2, dfdFlags: c2 } = e2;
      if ("error" === o2)
        return Promise.reject(a2);
      const u2 = new n.EB7(t2, r2, i2, s2, n.ywz);
      return u2.minFilter = 1 === t2.length ? n.wem : n.D1R, u2.magFilter = n.wem, u2.generateMipmaps = false, u2.needsUpdate = true, u2.encoding = 2 === l2 ? n.knz : n.rnI, u2.premultiplyAlpha = !!(1 & c2), u2;
    }
    createTexture(e2, t2 = {}) {
      const r2 = function(e3) {
        const t3 = new Uint8Array(e3.buffer, e3.byteOffset, Mh.length);
        if (t3[0] !== Mh[0] || t3[1] !== Mh[1] || t3[2] !== Mh[2] || t3[3] !== Mh[3] || t3[4] !== Mh[4] || t3[5] !== Mh[5] || t3[6] !== Mh[6] || t3[7] !== Mh[7] || t3[8] !== Mh[8] || t3[9] !== Mh[9] || t3[10] !== Mh[10] || t3[11] !== Mh[11])
          throw new Error("Missing KTX 2.0 identifier.");
        const r3 = new Sh(), n2 = 17 * Uint32Array.BYTES_PER_ELEMENT, i3 = new Ch(e3, Mh.length, n2, true);
        r3.vkFormat = i3._nextUint32(), r3.typeSize = i3._nextUint32(), r3.pixelWidth = i3._nextUint32(), r3.pixelHeight = i3._nextUint32(), r3.pixelDepth = i3._nextUint32(), r3.layerCount = i3._nextUint32(), r3.faceCount = i3._nextUint32();
        const s3 = i3._nextUint32();
        r3.supercompressionScheme = i3._nextUint32();
        const o2 = i3._nextUint32(), a2 = i3._nextUint32(), l2 = i3._nextUint32(), c2 = i3._nextUint32(), u2 = i3._nextUint64(), h2 = i3._nextUint64(), p2 = new Ch(e3, Mh.length + n2, 3 * s3 * 8, true);
        for (let t4 = 0; t4 < s3; t4++)
          r3.levels.push({ levelData: new Uint8Array(e3.buffer, e3.byteOffset + p2._nextUint64(), p2._nextUint64()), uncompressedByteLength: p2._nextUint64() });
        const d2 = new Ch(e3, o2, a2, true), f2 = { vendorId: d2._skip(4)._nextUint16(), descriptorType: d2._nextUint16(), versionNumber: d2._nextUint16(), descriptorBlockSize: d2._nextUint16(), colorModel: d2._nextUint8(), colorPrimaries: d2._nextUint8(), transferFunction: d2._nextUint8(), flags: d2._nextUint8(), texelBlockDimension: [d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8()], bytesPlane: [d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8()], samples: [] }, m2 = (f2.descriptorBlockSize / 4 - 6) / 4;
        for (let e4 = 0; e4 < m2; e4++) {
          const t4 = { bitOffset: d2._nextUint16(), bitLength: d2._nextUint8(), channelType: d2._nextUint8(), samplePosition: [d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 };
          64 & t4.channelType ? (t4.sampleLower = d2._nextInt32(), t4.sampleUpper = d2._nextInt32()) : (t4.sampleLower = d2._nextUint32(), t4.sampleUpper = d2._nextUint32()), f2.samples[e4] = t4;
        }
        r3.dataFormatDescriptor.length = 0, r3.dataFormatDescriptor.push(f2);
        const _2 = new Ch(e3, l2, c2, true);
        for (; _2._offset < c2; ) {
          const e4 = _2._nextUint32(), t4 = _2._scan(e4), n3 = Th(t4), i4 = _2._scan(e4 - t4.byteLength);
          r3.keyValue[n3] = n3.match(/^ktx/i) ? Th(i4) : i4, _2._offset % 4 && _2._skip(4 - _2._offset % 4);
        }
        if (h2 <= 0)
          return r3;
        const g2 = new Ch(e3, u2, h2, true), v2 = g2._nextUint16(), A2 = g2._nextUint16(), b2 = g2._nextUint32(), y2 = g2._nextUint32(), x2 = g2._nextUint32(), w2 = g2._nextUint32(), E2 = [];
        for (let e4 = 0; e4 < s3; e4++)
          E2.push({ imageFlags: g2._nextUint32(), rgbSliceByteOffset: g2._nextUint32(), rgbSliceByteLength: g2._nextUint32(), alphaSliceByteOffset: g2._nextUint32(), alphaSliceByteLength: g2._nextUint32() });
        const S2 = u2 + g2._offset, C2 = S2 + b2, M2 = C2 + y2, T2 = M2 + x2, I2 = new Uint8Array(e3.buffer, e3.byteOffset + S2, b2), k2 = new Uint8Array(e3.buffer, e3.byteOffset + C2, y2), D2 = new Uint8Array(e3.buffer, e3.byteOffset + M2, x2), P2 = new Uint8Array(e3.buffer, e3.byteOffset + T2, w2);
        return r3.globalData = { endpointCount: v2, selectorCount: A2, imageDescs: E2, endpointsData: I2, selectorsData: k2, tablesData: D2, extendedData: P2 }, r3;
      }(new Uint8Array(e2));
      if (0 !== r2.vkFormat)
        return async function(e3) {
          const { vkFormat: t3, pixelWidth: r3, pixelHeight: i3, pixelDepth: s3 } = e3;
          if (void 0 === Nh[t3])
            throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
          const o2 = e3.levels[0];
          let a2, l2;
          if (0 === e3.supercompressionScheme)
            a2 = o2.levelData;
          else {
            if (2 !== e3.supercompressionScheme)
              throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
            Oh || (Oh = new Promise(async (e4) => {
              const t4 = new Bh();
              await t4.init(), e4(t4);
            })), a2 = (await Oh).decode(o2.levelData, o2.uncompressedByteLength);
          }
          l2 = jh[t3] === n.VzW ? new Float32Array(a2.buffer, a2.byteOffset, a2.byteLength / Float32Array.BYTES_PER_ELEMENT) : jh[t3] === n.cLu ? new Uint16Array(a2.buffer, a2.byteOffset, a2.byteLength / Uint16Array.BYTES_PER_ELEMENT) : a2;
          const c2 = 0 === s3 ? new n.IEO(l2, r3, i3) : new n.JUT(l2, r3, i3, s3);
          return c2.type = jh[t3], c2.format = Nh[t3], c2.encoding = zh[t3] || n.rnI, c2.needsUpdate = true, Promise.resolve(c2);
        }(r2);
      const i2 = t2, s2 = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: e2, taskConfig: i2 }, [e2])).then((e3) => this._createTextureFrom(e3.data));
      return Lh.set(e2, { promise: s2 }), s2;
    }
    dispose() {
      return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), Fh--, this;
    }
  }
  Uh.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }, Uh.TranscoderFormat = { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16 }, Uh.EngineFormat = { RGBAFormat: n.wk1, RGBA_ASTC_4x4_Format: n.ptH, RGBA_BPTC_Format: n.bsb, RGBA_ETC2_EAC_Format: n.ekQ, RGBA_PVRTC_4BPPV1_Format: n.eaV, RGBA_S3TC_DXT5_Format: n.ILR, RGB_ETC1_Format: n.fto, RGB_ETC2_Format: n.l0P, RGB_PVRTC_4BPPV1_Format: n._AM, RGB_S3TC_DXT1_Format: n.wuA }, Uh.BasisWorker = function() {
    let e2, t2, r2;
    const n2 = _EngineFormat, i2 = _TranscoderFormat, s2 = _BasisFormat;
    self.addEventListener("message", function(o3) {
      const u2 = o3.data;
      switch (u2.type) {
        case "init":
          e2 = u2.config, h2 = u2.transcoderBinary, t2 = new Promise((e3) => {
            r2 = { wasmBinary: h2, onRuntimeInitialized: e3 }, BASIS(r2);
          }).then(() => {
            r2.initializeBasis(), void 0 === r2.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
          });
          break;
        case "transcode":
          t2.then(() => {
            try {
              const { width: t3, height: o4, hasAlpha: h3, mipmaps: p2, format: d2, dfdTransferFn: f2, dfdFlags: m2 } = function(t4) {
                const o5 = new r2.KTX2File(new Uint8Array(t4));
                function u3() {
                  o5.close(), o5.delete();
                }
                if (!o5.isValid())
                  throw u3(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
                const h4 = o5.isUASTC() ? s2.UASTC_4x4 : s2.ETC1S, p3 = o5.getWidth(), d3 = o5.getHeight(), f3 = o5.getLevels(), m3 = o5.getHasAlpha(), _3 = o5.getDFDTransferFunc(), g2 = o5.getDFDFlags(), { transcoderFormat: v2, engineFormat: A2 } = function(t5, r3, o6, u4) {
                  let h5, p4;
                  const d4 = t5 === s2.ETC1S ? a2 : l2;
                  for (let n3 = 0; n3 < d4.length; n3++) {
                    const i3 = d4[n3];
                    if (e2[i3.if] && i3.basisFormat.includes(t5) && !(u4 && i3.transcoderFormat.length < 2) && (!i3.needsPowerOfTwo || c2(r3) && c2(o6)))
                      return h5 = i3.transcoderFormat[u4 ? 1 : 0], p4 = i3.engineFormat[u4 ? 1 : 0], { transcoderFormat: h5, engineFormat: p4 };
                  }
                  return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), h5 = i2.RGBA32, p4 = n2.RGBAFormat, { transcoderFormat: h5, engineFormat: p4 };
                }(h4, p3, d3, m3);
                if (!p3 || !d3 || !f3)
                  throw u3(), new Error("THREE.KTX2Loader:	Invalid texture");
                if (!o5.startTranscoding())
                  throw u3(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                const b2 = [];
                for (let e3 = 0; e3 < f3; e3++) {
                  const t5 = o5.getImageLevelInfo(e3, 0, 0), r3 = t5.origWidth, n3 = t5.origHeight, i3 = new Uint8Array(o5.getImageTranscodedSizeInBytes(e3, 0, 0, v2));
                  if (!o5.transcodeImage(i3, e3, 0, 0, v2, 0, -1, -1))
                    throw u3(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                  b2.push({ data: i3, width: r3, height: n3 });
                }
                return u3(), { width: p3, height: d3, hasAlpha: m3, mipmaps: b2, format: A2, dfdTransferFn: _3, dfdFlags: g2 };
              }(u2.buffer), _2 = [];
              for (let e3 = 0; e3 < p2.length; ++e3)
                _2.push(p2[e3].data.buffer);
              self.postMessage({ type: "transcode", id: u2.id, width: t3, height: o4, hasAlpha: h3, mipmaps: p2, format: d2, dfdTransferFn: f2, dfdFlags: m2 }, _2);
            } catch (e3) {
              console.error(e3), self.postMessage({ type: "error", id: u2.id, error: e3.message });
            }
          });
      }
      var h2;
    });
    const o2 = [{ if: "astcSupported", basisFormat: [s2.UASTC_4x4], transcoderFormat: [i2.ASTC_4x4, i2.ASTC_4x4], engineFormat: [n2.RGBA_ASTC_4x4_Format, n2.RGBA_ASTC_4x4_Format], priorityETC1S: 1 / 0, priorityUASTC: 1, needsPowerOfTwo: false }, { if: "bptcSupported", basisFormat: [s2.ETC1S, s2.UASTC_4x4], transcoderFormat: [i2.BC7_M5, i2.BC7_M5], engineFormat: [n2.RGBA_BPTC_Format, n2.RGBA_BPTC_Format], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: false }, { if: "dxtSupported", basisFormat: [s2.ETC1S, s2.UASTC_4x4], transcoderFormat: [i2.BC1, i2.BC3], engineFormat: [n2.RGB_S3TC_DXT1_Format, n2.RGBA_S3TC_DXT5_Format], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: false }, { if: "etc2Supported", basisFormat: [s2.ETC1S, s2.UASTC_4x4], transcoderFormat: [i2.ETC1, i2.ETC2], engineFormat: [n2.RGB_ETC2_Format, n2.RGBA_ETC2_EAC_Format], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: false }, { if: "etc1Supported", basisFormat: [s2.ETC1S, s2.UASTC_4x4], transcoderFormat: [i2.ETC1], engineFormat: [n2.RGB_ETC1_Format], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: false }, { if: "pvrtcSupported", basisFormat: [s2.ETC1S, s2.UASTC_4x4], transcoderFormat: [i2.PVRTC1_4_RGB, i2.PVRTC1_4_RGBA], engineFormat: [n2.RGB_PVRTC_4BPPV1_Format, n2.RGBA_PVRTC_4BPPV1_Format], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: true }], a2 = o2.sort(function(e3, t3) {
      return e3.priorityETC1S - t3.priorityETC1S;
    }), l2 = o2.sort(function(e3, t3) {
      return e3.priorityUASTC - t3.priorityUASTC;
    });
    function c2(e3) {
      return e3 <= 2 || 0 == (e3 & e3 - 1) && 0 !== e3;
    }
  };
  const Nh = { 109: n.wk1, 97: n.wk1, 37: n.wk1, 43: n.wk1, 103: n.av9, 83: n.av9, 16: n.av9, 22: n.av9, 100: n.hEm, 76: n.hEm, 15: n.hEm, 9: n.hEm }, jh = { 109: n.VzW, 97: n.cLu, 37: n.ywz, 43: n.ywz, 103: n.VzW, 83: n.cLu, 16: n.ywz, 22: n.ywz, 100: n.VzW, 76: n.cLu, 15: n.ywz, 9: n.ywz }, zh = { 43: n.knz, 22: n.knz, 15: n.knz }, Gh = "KHR_texture_basisu";
  class Vh extends r {
    constructor() {
      super(...arguments), this.dependencies = [to];
    }
    async onAdded(e2) {
      var t2, r2, n2, i2;
      this._importer || (this._importer = new ir(class extends Uh {
        constructor(t3) {
          super(t3), this.setTranscoderPath("https://cdn.jsdelivr.net/gh/BinomialLLC/basis_universal@master/webgl/transcoder/build/").detectSupport(e2.renderer.rendererObject);
        }
        async createTexture(e3, t3) {
          const r3 = e3.map((e4) => new Uint8Array(e4.slice(0))), n3 = await super.createTexture(e3, t3);
          return n3.source._sourceImgBuffer = r3, n3.userData.mimeType = "image/ktx2", n3;
        }
      }, ["ktx2"], false)), Js.Importers.push(this._importer), null === (i2 = null === (n2 = null === (r2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.exporter) || void 0 === r2 ? void 0 : r2.getExporter("gltf", "glb")) || void 0 === n2 ? void 0 : n2.extensions) || void 0 === i2 || i2.push(Qh);
    }
    async onDispose(e2) {
      this._importer = void 0;
    }
    async onRemove(e2) {
      this._importer && Js.Importers.splice(Js.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }
  }
  Vh.PluginType = "KTX2LoadPlugin";
  const Qh = (e2) => ({ writeTexture: (t2, r2) => {
    if ("image/ktx2" !== t2.userData.mimeType)
      return;
    if (void 0 !== r2.source)
      return void console.warn("ktx2 export: source already set");
    const n2 = t2.source._sourceImgBuffer;
    if (!n2 || !n2.length)
      return void console.warn("ktx2 export: no source buffer for ktx2");
    r2.extensions = r2.extensions || {};
    const i2 = {}, s2 = new Blob(Array.isArray(n2) ? n2 : [n2], { type: "image/ktx2" });
    i2.source = e2.processImageBlob(s2, t2), r2.extensions[Gh] = i2, e2.extensionsUsed[Gh] = true;
  } });
  class Hh {
    constructor(e2) {
      this.presets = [], this.name = "", this.selected = void 0, e2 && (this.name = e2);
    }
    async apply(e2, t2, r2) {
      var n2, i2;
      if (!t2)
        return void (this.selected = void 0);
      let s2 = this.presets.find((e3) => e3.path === t2.path);
      return s2 || (this.presets.push(t2), s2 = t2), this.selected = s2, null === (i2 = null === (n2 = e2.getManager()) || void 0 === n2 ? void 0 : n2.importer) || void 0 === i2 ? void 0 : i2.importAsset(s2, r2);
    }
  }
  class Wh extends Hh {
    constructor() {
      super(...arguments), this.name = "Background";
    }
    async apply(e2, t2) {
      const r2 = await super.apply(e2, t2), i2 = null == r2 ? void 0 : r2[0];
      return i2 && (i2.encoding = n.knz, await e2.setBackground(i2)), i2;
    }
  }
  class qh extends Hh {
    constructor() {
      super(...arguments), this.name = "Environment";
    }
    async apply(e2, t2) {
      const r2 = await super.apply(e2, t2), n2 = null == r2 ? void 0 : r2[0];
      return n2 && await e2.scene.setEnvironment(n2), n2;
    }
  }
  class Xh extends Hh {
    constructor() {
      super(...arguments), this.name = "GemEnvironment";
    }
    async apply(e2, t2) {
      const r2 = await super.apply(e2, t2), n2 = null == r2 ? void 0 : r2[0];
      return _(e2.getPluginByType("Diamond"), "envMap", n2), n2;
    }
  }
  class Yh extends Hh {
    async apply(e2, t2) {
      var r2, n2;
      const i2 = await super.apply(e2, t2, { processImported: false });
      return i2 ? null === (n2 = null === (r2 = e2.getManager()) || void 0 === r2 ? void 0 : r2.importer) || void 0 === n2 ? void 0 : n2.processImported(i2) : void 0;
    }
  }
  class Kh extends Yh {
    constructor() {
      super(...arguments), this.name = "MaterialLibraries";
    }
    async apply(e2, t2) {
      const r2 = await super.apply(e2, t2);
      return r2 && await e2.alert("Material Library successfully imported."), r2;
    }
  }
  class Jh extends ro {
    constructor() {
      super(...arguments), this.toJSON = null, this.enabled = true, this.presetGroups = [], this.uiConfig = { type: "folder", label: "Presets", expanded: true, limitedUi: true, children: [() => this.presetGroups.map((e2) => ({ type: "dropdown", label: e2.name, limitedUi: true, children: [{ value: "", label: "none" }, ...e2.presets.map((e3) => ({ label: e3.path.split("/").pop(), value: e3.path }))], getValue: () => {
        var t2;
        return (null === (t2 = e2.selected) || void 0 === t2 ? void 0 : t2.path) || "";
      }, setValue: (t2) => {
        e2.apply(this._viewer, e2.presets.find((e3) => e3.path === t2));
      } })), { type: "button", label: "Download Selection", limitedUi: true, value: () => {
        const e2 = this.exportPresets();
        wt(new File([JSON.stringify(e2, null, 2)], "preset.template.json", { type: "application/json" }));
      } }, { type: "button", label: "Export Preset Groups", hidden: true, limitedUi: false, value: () => {
        const e2 = this.exportPresetGroups();
        wt(new File([JSON.stringify(e2, null, 2)], "presetGroups.json", { type: "application/json" }));
      } }] };
    }
    async onAdded(e2) {
      var t2, r2;
      await super.onAdded(e2), this.presetGroups.push(new Wh()), this.presetGroups.push(new qh()), this.presetGroups.push(new Xh()), this.presetGroups.push(new Yh("Ground")), this.presetGroups.push(new Yh("CameraViews")), this.presetGroups.push(new Yh("MaterialConfiguration")), this.presetGroups.push(new Kh()), null === (r2 = (t2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(t2, "postFrame", true);
    }
    exportPresets() {
      const e2 = Object.fromEntries(this.presetGroups.map((e3) => {
        var t2;
        return [e3.name, (null === (t2 = e3.selected) || void 0 === t2 ? void 0 : t2.path) || void 0];
      }).filter(([, e3]) => e3));
      return e2.type = Jh.PluginType, e2;
    }
    async fromJSON(e2, t2) {
      var r2, n2;
      if (!super.fromJSON(e2, t2))
        return null;
      const i2 = { ...e2 };
      delete i2.type;
      const s2 = [];
      for (const [e3, t3] of Object.entries(i2)) {
        const r3 = this.presetGroups.find((t4) => t4.name === e3), n3 = null == r3 ? void 0 : r3.presets;
        if (!r3 || !n3)
          continue;
        const i3 = "string" == typeof t3 ? { path: t3 } : t3;
        s2.push(r3.apply(this._viewer, i3));
      }
      return await Promise.all(s2), null === (n2 = (r2 = this.uiConfig).uiRefresh) || void 0 === n2 || n2.call(r2, "postFrame", true), this;
    }
    loadPresetGroups(e2) {
      var t2;
      for (const [r2, n2] of Object.entries(e2)) {
        const e3 = null === (t2 = this.presetGroups.find((e4) => e4.name === r2)) || void 0 === t2 ? void 0 : t2.presets;
        null == e3 || e3.push(...n2);
      }
    }
    exportPresetGroups() {
      return Object.fromEntries(this.presetGroups.map((e2) => [e2.name, e2.presets.map((e3) => e3.path)]).filter(([, e2]) => e2.length > 0));
    }
  }
  Jh.PluginType = "PresetLibraryPlugin";
  var Zh = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let $h = class extends ro {
    constructor() {
      super(), this.enabled = true, this.dependencies = [to], this.scenes = [], this.assets = {}, this.toJSON = void 0, this._isPlaying = false, this._isPlayingLoop = false, this._options = {}, this.minSceneTime = 2e3, this.loadScenes = this.loadScenes.bind(this), this.play = this.play.bind(this), this.stop = this.stop.bind(this), this.downloadScenes = this.downloadScenes.bind(this), this.promptLoadScenes = this.promptLoadScenes.bind(this);
    }
    get loadedScenes() {
      return this.scenes.length;
    }
    async promptLoadScenes() {
      const e2 = await Et(true, false, "model/gltf");
      await this.loadScenes(e2);
    }
    async loadScenes(e2) {
      var t2, r2;
      const n2 = await Promise.all(e2.map(async (e3) => await e3.arrayBuffer()));
      for (let t3 = 0; t3 < e2.length; t3++) {
        const r3 = e2[t3];
        this.scenes.push({ [r3.name]: new Uint8Array(n2[t3]) }), this.assets[r3.name] = { path: r3.name, file: r3 };
      }
      null === (r2 = null === (t2 = this.uiConfig) || void 0 === t2 ? void 0 : t2.uiRefresh) || void 0 === r2 || r2.call(t2);
    }
    async play() {
      var e2;
      if (!this._viewer)
        return;
      if (this._isPlaying || this._isPlayingLoop)
        return;
      this._isPlaying = true, this._isPlayingLoop = true;
      const t2 = this._viewer.getPluginByType("AssetManagerBasicPopupPlugin");
      null == t2 || t2.enabled, t2 && (t2.enabled = false);
      const r2 = this._viewer.getPluginByType("FrameFade"), n2 = this._viewer.getPluginByType("GLTFAnimation"), i2 = this._viewer.getPluginByType("CameraViews");
      for (; this._isPlaying; )
        for (const s2 of this.scenes) {
          if (!this._isPlaying)
            break;
          const o2 = Object.keys(s2);
          null == n2 || n2.stopAnimation(false), await (null == i2 ? void 0 : i2.stopAllAnimations()), this._viewer.scene.removeSceneModels(), this._viewer.renderEnabled = false;
          for (const t3 of o2) {
            let r3 = this.assets[t3];
            r3 || (r3 = { path: t3, file: new File([s2[t3]], t3) }, this.assets[t3] = r3), await (null === (e2 = this._viewer.getManager()) || void 0 === e2 ? void 0 : e2.addAssetSingle(r3, this._options));
          }
          if (!this._isPlaying)
            break;
          this._viewer.renderEnabled = true, t2 && (t2.enabled = false), r2 && (r2.enabled = true, await r2.startTransition(1e3));
          const a2 = [Dc(this.minSceneTime)];
          n2 && a2.push(n2.playAnimation()), i2 && a2.push(i2.animateAllViews()), await Promise.all(a2);
        }
      this._isPlayingLoop = false;
    }
    stop() {
      this._isPlaying = false;
    }
    async downloadScenes() {
      const e2 = {};
      for (const t3 of this.scenes)
        for (const r2 of Object.keys(t3)) {
          const n2 = e2[r2] ? r2 + "_" : r2;
          e2[n2] = t3[n2];
        }
      const t2 = Fs(e2);
      yt(new Blob([t2], { type: "application/zip" }), "scenes.glbloop");
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const t2 = this;
      Js.Importers.push(new ir(class extends Qs {
        load(e3, r2, n2, i2) {
          super.load(e3, (e4) => {
            t2.loadScenes([...e4.values()]), null == r2 || r2(null), Dc(100).then(t2.play);
          }, n2, i2);
        }
      }, ["glbloop"], true));
    }
  };
  $h.PluginType = "SceneLoopPlugin", Zh([Ze("Loaded scenes")], $h.prototype, "loadedScenes", null), Zh([rt("Load Scenes")], $h.prototype, "promptLoadScenes", null), Zh([Ze("Playing")], $h.prototype, "_isPlaying", void 0), Zh([nt("Min Scene Time")], $h.prototype, "minSceneTime", void 0), Zh([rt("Play")], $h.prototype, "play", null), Zh([rt("Stop")], $h.prototype, "stop", null), Zh([rt("Download Scenes")], $h.prototype, "downloadScenes", null), $h = Zh([lt("Scene Loop")], $h);
  var ep = __webpackgi_require__2(701), tp = __webpackgi_require__2.n(ep), rp = __webpackgi_require__2(236), np = __webpackgi_require__2.n(rp), ip = __webpackgi_require__2(850), sp = __webpackgi_require__2.n(ip), op = __webpackgi_require__2(182), ap = __webpackgi_require__2.n(op), lp = __webpackgi_require__2(213), cp = __webpackgi_require__2.n(lp), up = __webpackgi_require__2(798), hp = {};
  up.Z && up.Z.locals && (hp.locals = up.Z.locals);
  var pp, dp = 0, fp = {};
  fp.styleTagTransform = cp(), fp.setAttributes = sp(), fp.insert = function(e2, t2) {
    (t2.target || document.head).appendChild(e2);
  }, fp.domAPI = np(), fp.insertStyleElement = ap(), hp.use = function(e2) {
    return fp.options = e2 || {}, dp++ || (pp = tp()(up.Z, fp)), hp;
  }, hp.unuse = function() {
    dp > 0 && !--dp && (pp(), pp = null);
  };
  var mp, _p = hp, gp = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let vp = mp = class extends ro {
    constructor() {
      super(), this.enabled = true, this.dependencies = [to], this._popupDiv = St({ id: "assetManagerPopup", addToBody: false, innerHTML: "" });
      const e2 = St({ id: "assetManagerPopupClose", addToBody: false, innerHTML: "&#10005" });
      e2.addEventListener("click", () => {
        this._popupDiv.style.display = "none";
      }), this._popupContent = St({ id: "assetManagerPopupContent", addToBody: false, innerHTML: "" }), this.enabled || (this._popupDiv.style.display = "none"), this._popupDiv.appendChild(e2), this._popupDiv.appendChild(this._popupContent);
    }
    _onEnabledChange() {
      this.enabled || (this._popupDiv.style.display = "none");
    }
    _updatePopupDiv(e2) {
      if (!this._popupContent)
        return;
      if (!this.enabled)
        return void (this._popupDiv.style.display = "none");
      let t2 = "";
      e2.forEach((e3, r2) => {
        t2 += `<span class="processState">${e3.state}</span>: ${r2.split("/").pop()} ${e3.progress ? " - " + e3.progress : ""}<br>`;
      }), this._popupContent.innerHTML = t2, 0 === e2.size ? this._popupDiv.style.display = "none" : this._popupDiv.style.display = "block";
    }
    async onAdded(e2) {
      var t2, r2, n2, i2;
      await super.onAdded(e2), _p.use({ target: e2.container }), e2.container.appendChild(this._popupDiv);
      const s2 = /* @__PURE__ */ new Map();
      null === (r2 = null === (t2 = e2.getManager()) || void 0 === t2 ? void 0 : t2.importer) || void 0 === r2 || r2.addEventListener("importFile", (e3) => {
        "done" !== e3.state ? s2.set(e3.path, { state: e3.state, progress: e3.progress ? (100 * e3.progress).toFixed(0) + "%" : void 0 }) : s2.delete(e3.path), this._updatePopupDiv(s2);
      }), null === (i2 = null === (n2 = e2.getManager()) || void 0 === n2 ? void 0 : n2.exporter) || void 0 === i2 || i2.addEventListener("exportFile", (e3) => {
        "done" !== e3.state ? s2.set(e3.obj.name, { state: e3.state, progress: e3.progress ? (100 * e3.progress).toFixed(0) + "%" : void 0 }) : s2.delete(e3.obj.name), this._updatePopupDiv(s2);
      });
    }
  };
  vp.PluginType = "AssetManagerBasicPopupPlugin", gp([Je("Enabled"), M(mp.prototype._onEnabledChange), Ce()], vp.prototype, "enabled", void 0), vp = mp = gp([lt("Asset manager popup")], vp);
  class Ap extends zt {
    constructor(e2) {
      super({ vertexShader: i.vertexShader, uniforms: { tDiffuse: { value: null } }, defines: {}, fragmentShader: `
                varying vec2 vUv;
                ${e2[0]}
                void main() {
                    gl_FragColor = tDiffuseTexelToLinear (texture2D(tDiffuse, vUv));
                    #glMarker
                    ${e2[1]}
                }
                ` }, "tDiffuse"), this.uiConfig = void 0, this.customMaterial = new Ut();
    }
    render(e2, t2, r2, n2, i2) {
      super.render(e2, t2, r2, n2, i2), this.needsSwap = true;
    }
  }
  class bp extends io {
    constructor(e2 = true, t2 = true) {
      super(), this.depthTonemap = e2, this.passId = "combinedPost", this.dependencies = [lo], this.toJSON = void 0, this._beforeFilters = [], this._afterFilters = ["render"], this._requiredFilters = ["render"], this._renderToScreen = true, this._setDirty = this._setDirty.bind(this), this._renderToScreen = t2;
    }
    get renderToScreen() {
      return this._renderToScreen;
    }
    async onAdded(e2) {
      var t2, r2;
      return (null === (r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.screenShader) || void 0 === r2 ? void 0 : r2.isShaderPass2) && (this._renderToScreen = false), this._renderToScreen && _(e2.renderer.passes.find((e3) => "screen" === e3.passId), "enabled", false, true, true), super.onAdded(e2);
    }
    passCtor(e2) {
      var t2, r2, n2, i2;
      const s2 = e2.screenShader, o2 = ["", ""];
      this._renderToScreen && !s2.isShaderPass2 && (o2[0] = Array.isArray(s2) ? s2[0] : (null === (t2 = s2) || void 0 === t2 ? void 0 : t2.pars) || "", o2[1] = Array.isArray(s2) ? s2[1] : "string" == typeof s2 ? s2 : (null === (r2 = s2) || void 0 === r2 ? void 0 : r2.main) || "");
      const a2 = new Ap(o2);
      return _(null === (i2 = null === (n2 = a2.uiConfig) || void 0 === n2 ? void 0 : n2.children) || void 0 === i2 ? void 0 : i2.find((e3) => {
        var t3;
        return "Enabled" === (null === (t3 = e3) || void 0 === t3 ? void 0 : t3.label);
      }), "hidden", true, true), a2;
    }
    _update(e2) {
      var t2;
      return !!super._update(e2) && (this._pass.passObject.updateShaderProperties(null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(lo)), true);
    }
    _setDirty() {
      this.pass && (this.pass.dirty = true);
    }
    get uiConfig() {
      var e2, t2, r2;
      return null !== (r2 = null === (t2 = null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.uiConfig) && void 0 !== r2 ? r2 : {};
    }
    addExtension(e2) {
      this.pass.passObject.material.registerMaterialExtensions([e2]);
    }
  }
  bp.PluginType = "CombinedPostPlugin";
  var yp = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class xp extends ro {
    constructor() {
      super(...arguments), this.enabled = true, this.dependencies = [bp];
    }
    get uiConfig() {
      var e2;
      return null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.uiConfig;
    }
    get config() {
      return this._extension;
    }
    disposeExtension() {
    }
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2), this._extension = this.generateExtension(e2), null === (t2 = e2.getPlugin(bp)) || void 0 === t2 || t2.addExtension(this._extension);
    }
    async onRemove(e2) {
      this.disposeExtension(), this._extension = void 0, await super.onRemove(e2);
    }
  }
  yp([Ce("extension")], xp.prototype, "_extension", void 0), yp([Ce()], xp.prototype, "enabled", void 0);
  class wp {
    constructor() {
      this.uiConfig = void 0, this.enabled = true;
    }
    shaderExtender(e2, t2, r2) {
      this.enabled && (e2.fragmentShader = qt(e2.fragmentShader, "#glMarker", " \n            gl_FragColor = LinearTosRGB(gl_FragColor);\n            #glMarker\n        "));
    }
    computeCacheKey(e2) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e2) {
      return true;
    }
  }
  class Ep extends xp {
    generateExtension(e2) {
      return new wp();
    }
  }
  Ep.PluginType = "GammaCorrection";
  var Sp, Cp = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  const Mp = n.dZ3;
  let Tp = Sp = class {
    constructor(e2, t2 = true, r2 = true) {
      this.depthTonemap = t2, this.toneMapping = n.LY2, this.tonemapBackground = true, this.clipBackground = false, this.exposure = 1, this._renderToScreen = true, this.enabled = true, this._rendererState = {}, this.extraUniforms = { tNormalDepth: { value: null }, tGBufferFlags: { value: null }, opacity: { value: 1 } }, this.parsFragmentSnippet = (e3, t3) => this.enabled ? w`
            ${this.depthTonemap ? Ht : ""}
            #define USE_DEPTH_TONEMAP ${this.depthTonemap ? "1" : "0"}
            uniform float opacity;
            ${"vec4 ToneMapping(in vec4 color){vec4 outColor=opacity*color;\n#if USE_DEPTH_TONEMAP > 0\nbool doTonemap=getGBufferFlags(vUv).x>0.5;float depth=getDepth(vUv);\n#if TONEMAP_BACKGROUND < 1 || TRANSPARENT_BACKGROUND > 0\nbool isBackground=depth>0.9999;if(isBackground)doTonemap=false;\n#endif\nif(doTonemap){\n#endif\n#if defined( TONE_MAPPING )\noutColor.rgb=toneMapping(outColor.rgb);\n#endif\n#if USE_DEPTH_TONEMAP > 0\n}else{\n#if TRANSPARENT_BACKGROUND > 0\nif(isBackground)outColor.a=0.;\n#endif\n}if(depth<0.00001)outColor.a=0.;\n#endif\nreturn outColor;}"}
        ` : "", this._combinedPostPlugin = e2.getPlugin(bp), this._setDirty = this._setDirty.bind(this), this._renderToScreen = r2, this.depthTonemap = t2;
    }
    shaderExtender(e2, t2, r2) {
      this.enabled && (e2.fragmentShader = qt(e2.fragmentShader, "#glMarker", " \n            gl_FragColor = ToneMapping(gl_FragColor);\n            #glMarker\n        "));
    }
    onObjectRender(e2, t2, r2) {
      if (!this.enabled)
        return;
      const { toneMapping: i2, toneMappingExposure: s2, outputEncoding: o2 } = r2;
      this._rendererState.toneMapping = i2, this._rendererState.toneMappingExposure = s2, this._rendererState.outputEncoding = o2;
      let a2 = this.tonemapBackground ? "1" : "0";
      t2.materialObject.defines.TONEMAP_BACKGROUND !== a2 && (t2.materialObject.defines.TONEMAP_BACKGROUND = a2, t2.materialObject.needsUpdate = true), a2 = this.clipBackground ? "1" : "0", t2.materialObject.defines.TRANSPARENT_BACKGROUND !== a2 && (t2.materialObject.defines.TRANSPARENT_BACKGROUND = a2, t2.materialObject.needsUpdate = true), r2.toneMapping = this.toneMapping, r2.toneMappingExposure = this.exposure, r2.outputEncoding = n.knz, t2.materialObject.toneMapped = true, t2.materialObject.needsUpdate = true;
    }
    onAfterRender(e2, t2, r2) {
      r2.toneMapping = this._rendererState.toneMapping, r2.toneMappingExposure = this._rendererState.toneMappingExposure, r2.outputEncoding = this._rendererState.outputEncoding;
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e2) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e2) {
      return true;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = true);
    }
    setDirty() {
      this._setDirty();
    }
  };
  Tp.PluginType = "Tonemap", Cp([tt("Mode", [["Linear", n.EoG], ["Reinhard", n.CdI], ["Cineon", n.YGz], ["ACESFilmic", n.LY2], ["Uncharted2", Mp]].map((e2) => ({ label: e2[0], value: e2[1] })), { limitedUi: true }), M(Sp.prototype._setDirty), Ce()], Tp.prototype, "toneMapping", void 0), Cp([Je("Tonemap Background", { limitedUi: true }), Ce()], Tp.prototype, "tonemapBackground", void 0), Cp([M(Sp.prototype._setDirty), Je("Clip Background"), Ce()], Tp.prototype, "clipBackground", void 0), Cp([M(Sp.prototype._setDirty), $e("Exposure", [0, 2 * Math.PI], 0.01, { limitedUi: true }), Ce()], Tp.prototype, "exposure", void 0), Tp = Sp = Cp([lt("Tonemapping")], Tp);
  class Ip extends xp {
    constructor(e2 = true) {
      super(), this.depthTonemap = e2, this.depthTonemap = e2;
    }
    fromJSON(e2, t2) {
      return e2.pass && ((e2 = { ...e2 }).extension = { ...e2.pass }, delete e2.extension.enabled, delete e2.pass), super.fromJSON(e2, t2);
    }
    generateExtension(e2) {
      return new Tp(e2, this.depthTonemap);
    }
    get exposure() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.exposure) && void 0 !== t2 ? t2 : 1;
    }
    set exposure(e2) {
      this._extension && (this._extension.exposure = e2, this._extension.setDirty());
    }
    get toneMapping() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.toneMapping) && void 0 !== t2 ? t2 : n.EoG;
    }
    set toneMapping(e2) {
      this._extension && (this._extension.toneMapping = e2, this._extension.setDirty());
    }
  }
  Ip.PluginType = "Tonemap", n.WdD.tonemapping_pars_fragment = n.WdD.tonemapping_pars_fragment.replace("vec3 CustomToneMapping( vec3 color ) { return color; }", "\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n	// John Hable's filmic operator from Uncharted 2 video game\n	color *= toneMappingExposure;\n	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( 1.0 ) ) );\n\n}\n\nvec3 CustomToneMapping( vec3 color ) { return Uncharted2ToneMapping( color ); }\n\n");
  var kp, Dp = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let Pp = kp = class {
    constructor(e2) {
      this.enabled = false, this.intensity = 1, this.lutMap = void 0, this.extraUniforms = { intensity: { value: 1 }, lutSize: { value: 1 } }, this.parsFragmentSnippet = (e3, t2) => this.enabled ? "#if USE_LUT == 1\nuniform float lutSize;uniform float intensity;\n#if USE_3DTEXTURE == 1\nprecision highp sampler3D;uniform sampler3D lut3d;\n#else\nuniform sampler2D lut;vec3 lutLookup(sampler2D tex,float size,vec3 rgb){float sliceHeight=1./size;float yPixelHeight=1./(size*size);float slice=rgb.b*size;float interp=fract(slice);float slice0=slice-interp;float centeredInterp=interp-0.5;float slice1=slice0+sign(centeredInterp);float greenOffset=clamp(rgb.g*sliceHeight,yPixelHeight*0.5,sliceHeight-yPixelHeight*0.5);vec2 uv0=vec2(rgb.r,slice0*sliceHeight+greenOffset);vec2 uv1=vec2(rgb.r,slice1*sliceHeight+greenOffset);vec3 sample0=texture2D(tex,uv0).rgb;vec3 sample1=texture2D(tex,uv1).rgb;return mix(sample0,sample1,abs(centeredInterp));}\n#endif\nvec4 colorLookUp(in vec4 color){vec4 outColor;float pixelWidth=1./lutSize;float halfPixelWidth=0.5/lutSize;vec3 uvw=vec3(halfPixelWidth)+color.rgb*(1.-pixelWidth);float lutFac=step(0.0001,getGBufferFlags(vUv).a);\n#if USE_3DTEXTURE == 1\noutColor=vec4(texture(lut3d,uvw).rgb,color.a);\n#else\noutColor=vec4(lutLookup(lut,lutSize,uvw),color.a);\n#endif\noutColor=mix(color,outColor,lutFac);return vec4(mix(color,outColor,intensity));}\n#endif\n" : "", this._combinedPostPlugin = e2.getPlugin(bp), this._setDirty = this._setDirty.bind(this);
    }
    shaderExtender(e2, t2, r2) {
      this.enabled && (e2.fragmentShader = qt(e2.fragmentShader, "#glMarker", " \n            #if USE_LUT == 1\n                gl_FragColor = colorLookUp(gl_FragColor);\n            #endif\n            #glMarker\n        "));
    }
    onObjectRender(e2, t2, r2) {
      if (this.enabled)
        if (this.lutMap) {
          const e3 = this.lutMap.texture3D ? 1 : 0;
          t2.materialObject.defines.USE_3DTEXTURE !== e3 && (t2.materialObject.defines.USE_3DTEXTURE = e3, t2.materialObject.needsUpdate = true);
          let r3 = 1;
          this.lutMap.texture3D ? (t2.materialObject.uniforms.lut3d = { value: this.lutMap.texture3D }, t2.materialObject.uniforms.lut3d.value.needsUpdate = true, r3 = this.lutMap.texture3D.image.width) : this.lutMap.texture && (t2.materialObject.uniforms.lut = { value: this.lutMap.texture }, t2.materialObject.uniforms.lut.value.needsUpdate = true, r3 = this.lutMap.texture.image.width), t2.materialObject.uniforms.lutSize.value = r3, t2.materialObject.uniforms.intensity.value = this.intensity, t2.materialObject.defines.USE_LUT = 1;
        } else
          t2.materialObject.defines.USE_3DTEXTURE = 0, t2.materialObject.defines.USE_LUT = 0, t2.materialObject.needsUpdate = true;
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e2) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e2) {
      return true;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = true);
    }
  };
  Dp([Ce(), M(kp.prototype._setDirty), Je("Enable")], Pp.prototype, "enabled", void 0), Dp([Ce(), M(kp.prototype._setDirty), $e("Intensity")], Pp.prototype, "intensity", void 0), Dp([M(kp.prototype._setDirty), st("LUT"), Ce()], Pp.prototype, "lutMap", void 0), Pp = kp = Dp([lt("LUT")], Pp);
  class Bp extends xp {
    generateExtension(e2) {
      return new Pp(e2);
    }
  }
  Bp.PluginType = "LUT";
  var Rp, Lp = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let Op = Rp = class {
    constructor(e2) {
      this.enabled = false, this.power = 0.5, this.bgcolor = new n.Ilk(0), this.extraUniforms = { power: { value: 1 }, bgcolor: { value: new n.Ilk() } }, this.parsFragmentSnippet = (e3, t2) => this.enabled ? w`
            uniform float power;
            uniform vec3 bgcolor;
            ${"vec4 Vignette(in vec4 color){vec2 uv=vUv*(1.-vUv);float vig=uv.x*uv.y*16.;vig=pow(vig,power);return vec4(mix(color.rgb,vec3(bgcolor),1.-vig),color.a);}"}
        ` : "", this._combinedPostPlugin = e2.getPlugin(bp), this._setDirty = this._setDirty.bind(this);
    }
    shaderExtender(e2, t2, r2) {
      this.enabled && (e2.fragmentShader = qt(e2.fragmentShader, "#glMarker", " \n            gl_FragColor = Vignette(gl_FragColor);\n            #glMarker\n        "));
    }
    onObjectRender(e2, t2, r2) {
      this.enabled && (t2.materialObject.uniforms.power.value = this.power, t2.materialObject.uniforms.bgcolor.value.copy(this.bgcolor));
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e2) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e2) {
      return true;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = true);
    }
    setDirty() {
      this._setDirty();
    }
  };
  Op.PluginType = "Vignette", Lp([M(Rp.prototype._setDirty), Je("Enable"), Ce()], Op.prototype, "enabled", void 0), Lp([M(Rp.prototype._setDirty), $e("Power", [0.1, 4], 0.01, { limitedUi: true }), Ce()], Op.prototype, "power", void 0), Lp([M(Rp.prototype._setDirty), it("Color"), Ce()], Op.prototype, "bgcolor", void 0), Op = Rp = Lp([lt("Vignette")], Op);
  class Fp extends xp {
    constructor() {
      super();
    }
    generateExtension(e2) {
      return new Op(e2);
    }
    get power() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.power) && void 0 !== t2 ? t2 : 1;
    }
    set power(e2) {
      this._extension && (this._extension.power = e2, this._extension.setDirty());
    }
    get color() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.bgcolor) && void 0 !== t2 ? t2 : new n.Ilk();
    }
    set color(e2) {
      this._extension && (this._extension.bgcolor.copy(e2), this._extension.setDirty());
    }
  }
  Fp.PluginType = "Vignette";
  var Up, Np = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let jp = Up = class {
    constructor(e2) {
      this.enabled = false, this.aberrationIntensity = 0.01, this.extraUniforms = { aberrationIntensity: { value: 1 } }, this.parsFragmentSnippet = (e3, t2) => this.enabled ? w`
            uniform float aberrationIntensity;
            ${"vec4 chromaticAberration(){vec2 distFromCenter=vUv-0.5;vec2 aberrated=aberrationIntensity*pow(distFromCenter,vec2(2.));vec4 color=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));vec4 outColor=vec4(tDiffuseTexelToLinear(texture2D(tDiffuse,vUv+aberrated)).r,color.g,tDiffuseTexelToLinear(texture2D(tDiffuse,vUv-aberrated)).b,color.a);return outColor;}"}
        ` : "", this._combinedPostPlugin = e2.getPlugin(bp), this._setDirty = this._setDirty.bind(this);
    }
    shaderExtender(e2, t2, r2) {
      this.enabled && (e2.fragmentShader = qt(e2.fragmentShader, "#glMarker", " \n            gl_FragColor = chromaticAberration();\n            #glMarker\n        "));
    }
    onObjectRender(e2, t2, r2) {
      this.enabled && (t2.materialObject.uniforms.aberrationIntensity.value = this.aberrationIntensity);
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e2) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e2) {
      return true;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = true);
    }
    setDirty() {
      this._setDirty();
    }
  };
  jp.PluginType = "ChromaticAberration", Np([M(Up.prototype._setDirty), Je("Enable"), Ce()], jp.prototype, "enabled", void 0), Np([M(Up.prototype._setDirty), $e("Intensity", [0, 0.1], 1e-3, { limitedUi: true }), Ce()], jp.prototype, "aberrationIntensity", void 0), jp = Up = Np([lt("ChromaticAberration")], jp);
  class zp extends xp {
    constructor() {
      super();
    }
    generateExtension(e2) {
      return new jp(e2);
    }
    get intensity() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.aberrationIntensity) && void 0 !== t2 ? t2 : 1;
    }
    set intensity(e2) {
      this._extension && (this._extension.aberrationIntensity = e2, this._extension.setDirty());
    }
  }
  zp.PluginType = "ChromaticAberration";
  var Gp, Vp = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let Qp = Gp = class {
    constructor(e2) {
      this.enabled = false, this.grainMultiply = false, this.grainIntensity = 10, this.extraUniforms = { grainIntensity: { value: 1 }, grainMultiply: { value: 1 } }, this.parsFragmentSnippet = (e3, t2) => this.enabled ? w`
            uniform float grainIntensity;
            uniform bool grainMultiply;
            ${"vec4 grain(in vec4 color){float x=(vUv.x+4.)*(vUv.y+4.)*(10.);vec4 grain=vec4(mod((mod(x,13.)+1.)*(mod(x,123.)+1.),0.01)-0.005)*grainIntensity;vec4 outColor=color;if(grainMultiply){grain=1.-grain;outColor.rgb=color.rgb*vec3(grain);}else{outColor.rgb=color.rgb+vec3(grain);}return outColor;}"}
        ` : "", this._combinedPostPlugin = e2.getPlugin(bp), this._setDirty = this._setDirty.bind(this);
    }
    shaderExtender(e2, t2, r2) {
      this.enabled && (e2.fragmentShader = qt(e2.fragmentShader, "#glMarker", " \n            gl_FragColor = grain(gl_FragColor);\n            #glMarker\n        "));
    }
    onObjectRender(e2, t2, r2) {
      this.enabled && (t2.materialObject.uniforms.grainIntensity.value = this.grainIntensity, t2.materialObject.uniforms.grainMultiply.value = this.grainMultiply);
    }
    getUiConfig() {
      return this.uiConfig;
    }
    computeCacheKey(e2) {
      return this.enabled ? "1" : "0";
    }
    isCompatible(e2) {
      return true;
    }
    _setDirty() {
      this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = true);
    }
    setDirty() {
      this._setDirty();
    }
  };
  Vp([M(Gp.prototype._setDirty), Je("Enable"), Ce()], Qp.prototype, "enabled", void 0), Vp([M(Gp.prototype._setDirty), Je("Multiply"), Ce()], Qp.prototype, "grainMultiply", void 0), Vp([M(Gp.prototype._setDirty), $e("Intensity", [0, 20], 0.01, { limitedUi: true }), Ce()], Qp.prototype, "grainIntensity", void 0), Qp = Gp = Vp([lt("FilmicGrain")], Qp);
  class Hp extends xp {
    constructor() {
      super();
    }
    generateExtension(e2) {
      return new Qp(e2);
    }
    get intensity() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.grainIntensity) && void 0 !== t2 ? t2 : 1;
    }
    set intensity(e2) {
      this._extension && (this._extension.grainIntensity = e2, this._extension.setDirty());
    }
    get multiply() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._extension) || void 0 === e2 ? void 0 : e2.grainMultiply) && void 0 !== t2 && t2;
    }
    set multiply(e2) {
      this._extension && (this._extension.grainMultiply = e2, this._extension.setDirty());
    }
  }
  async function Wp(e2, { ground: t2 = true, bloom: r2 = true, depthTonemap: n2 = true, enableDrop: i2 = false } = {}) {
    await e2.addPlugin(lo), await e2.addPlugin(yo), i2 && await e2.addPlugin(wo), await e2.addPlugin(new To(32)), await e2.addPlugin(new bp()), await e2.addPlugin(new zp()), await e2.addPlugin(new Ip(n2 || !e2.useRgbm)), await e2.addPlugin(new Bp()), await e2.addPlugin(new Fp()), await e2.addPlugin(new Hp()), await e2.addPlugin(new Ep()), await e2.addPlugin(No), await e2.addPlugin(Qo), await e2.addPlugin(Gc), await e2.addPlugin(Oc), await e2.addPlugin(Wc), t2 && await e2.addPlugin(_u), r2 && await e2.addPlugin(bu), await e2.addPlugin(xu), await e2.addPlugin(Cu), await e2.addPlugin(Du), await e2.addPlugin(Fu), await e2.addPlugin(zu), await e2.addPlugin(Xu, false), await e2.addPlugin(Ku), await e2.addPlugin(nh), await e2.addPlugin(hh, false), await e2.addPlugin(fh, false), await e2.addPlugin(bh, false), await e2.addPlugin(wh, false), await e2.addPlugin(Vh), await e2.addPlugin(Jh), await e2.addPlugin($h);
  }
  async function qp(e2, { debug: t2 = false, ground: r2 = true, bloom: n2 = true, depthTonemap: i2 = false, importPopup: s2 = true, enableDrop: o2 = false } = {}) {
    var a2;
    const l2 = new go(e2);
    t2 && await l2.addPlugin(Yc);
    const c2 = await l2.addPlugin(to, void 0, void 0, { storage: caches ? await caches.open("webgi-cache-storage") : void 0 });
    return s2 && await l2.addPlugin(vp), await Wp(l2, { ground: r2, bloom: n2, depthTonemap: i2, enableDrop: o2 }), l2.renderer.refreshPipeline(), null === (a2 = c2.importer) || void 0 === a2 || a2.processors.add("model", { forAssetType: "model", process: (e3, t3) => e3 }), l2;
  }
  Hp.PluginType = "FilmicGrain";
  let Xp = 0;
  class Yp extends HTMLElement {
    constructor() {
      super(), this._initialized = false, this._state = { src: "", environment: "" }, this._models = {}, this._refreshingModels = false, this._refreshingEnvironment = false, this.viewerIndex = Xp++, this.canvasId = "webgi-viewer-" + this.viewerIndex, this.attachShadow({ mode: "open" }), this.wrapper = document.createElement("div"), this.wrapper.style.width = "100%", this.wrapper.style.height = "100%", this.wrapper.style.display = "block", this.canvas = At(), this.canvas.setAttribute("id", this.canvasId);
      const e2 = document.createElement("style");
      e2.textContent = E`
            #${this.canvasId}{
              width: 100%; height: 100%; z-index: 1;
              display: block;
            }
        `, this.wrapper.append(this.canvas), this.shadowRoot.append(e2, this.wrapper), this._initialize().then(async () => this.refreshAll());
    }
    async refreshAll() {
      await Promise.all([this.refreshModelSource(), this.refreshEnvironment()]);
    }
    async _initialize() {
      this._initialized || (this.viewer = await qp({ canvas: this.canvas, useRgbm: "true" === this._getAttr("rgbm", "true"), useGBufferDepth: "true" === this._getAttr("depth-prepass", "true") }, { debug: "true" === this._getAttr("debug", "false"), ground: "baked" === this._getAttr("ground", "baked"), bloom: "true" === this._getAttr("bloom", "true"), depthTonemap: true }), this._initialized = true, this.dispatchEvent(new Event("initialized")));
    }
    connectedCallback() {
      console.log("WebGiViewerElement added to page."), this.viewer && (this.viewer.resize(), this.viewer.enabled = true);
    }
    disconnectedCallback() {
      console.log("WebGiViewerElement removed from page."), this.viewer && (this.viewer.enabled = false);
    }
    adoptedCallback() {
      console.log("WebGiViewerElement moved to new page."), this.viewer && (this.viewer.resize(), this.viewer.enabled = true);
    }
    static get observedAttributes() {
      return ["src", "environment"];
    }
    attributeChangedCallback(e2, t2, r2) {
      console.log("WebGiViewerElement attributes changed.", e2, t2, r2), this.refreshAll();
    }
    clearModels() {
    }
    async refreshModelSource() {
      if (!this.viewer)
        return;
      const e2 = this._getAttr("src", "");
      if (e2 === this._state.src)
        return;
      if (this._refreshingModels)
        return;
      this._refreshingModels = true;
      const t2 = [e2], r2 = [], n2 = [];
      for (const e3 of t2)
        !this._models[e3] && e3 && (this._models[e3] = this.viewer.getManager().importer.importPath(e3, { autoScale: "true" === this._getAttr("auto-scale", "true"), autoCenter: "true" === this._getAttr("auto-center", "true"), processImported: false }));
      for (const [e3, i2] of Object.entries(this._models))
        t2.includes(e3) ? r2.push(i2) : n2.push(i2);
      await Promise.all([Promise.all(r2).then(async (e3) => Promise.all(e3.map(async (e4) => this.viewer.getManager().importer.processImported(e4)))).then((e3) => {
        for (const t3 of e3)
          for (const e4 of t3)
            e4 && "model" === e4.assetType && this.viewer.scene.addSceneObject(e4);
      }), Promise.all(n2).then((e3) => {
        for (const t3 of e3)
          for (const e4 of t3)
            e4 && "model" === e4.assetType && e4.modelObject.removeFromParent();
      })]), this._state.src = e2, this._refreshingModels = false;
    }
    async refreshEnvironment() {
      if (!this.viewer)
        return;
      if (!this.hasAttribute("environment"))
        return void (this._state.environment = null);
      const e2 = this._getAttr("environment", "");
      if (e2 === this._state.src)
        return;
      if (this._refreshingEnvironment)
        return;
      this._refreshingEnvironment = true;
      const t2 = this.viewer.scene.getEnvironment(), r2 = e2 ? await this.viewer.getManager().importer.importSinglePath(e2) : void 0;
      r2 && "texture" !== r2.assetType || await this.viewer.scene.setEnvironment(r2), null == t2 || t2.dispose(), this._state.environment = e2, this._refreshingEnvironment = false;
    }
    _getAttr(e2, t2) {
      return this.hasAttribute(e2) ? this.getAttribute(e2) : t2;
    }
  }
  window && window.customElements && !window.customElements.get("webgi-viewer") && window.customElements.define("webgi-viewer", Yp);
  class Kp {
    constructor(e2) {
      var t2, r2, n2;
      this._basePath = null !== (t2 = null == e2 ? void 0 : e2.basePath) && void 0 !== t2 ? t2 : "", this._assets = null !== (n2 = null === (r2 = null == e2 ? void 0 : e2.assets) || void 0 === r2 ? void 0 : r2.map((e3) => this._resolveAsset(e3))) && void 0 !== n2 ? n2 : [];
    }
    get basePath() {
      return this._basePath;
    }
    get assets() {
      return this._assets;
    }
    find(e2) {
      const t2 = this._assets.find(e2);
      return null != t2 ? t2 : void 0;
    }
    _resolveAsset(e2) {
      return { ...e2, path: bt([this._basePath, e2.path]) };
    }
  }
  class Jp extends r {
    constructor(...e2) {
      super(), this._assets = e2;
    }
    addAssetList(e2) {
      this._assets.push(e2);
    }
    removeAssetList(e2) {
      const t2 = this._assets.indexOf(e2);
      t2 >= 0 && this._assets.splice(t2, 1);
    }
    async findAssetRegex(e2) {
      for (const t2 of this._assets) {
        const r2 = t2.find((t3) => {
          var r3, n2;
          return t3 && (e2.test(t3.path) || e2.test(null !== (n2 = null === (r3 = t3.file) || void 0 === r3 ? void 0 : r3.name) && void 0 !== n2 ? n2 : ""));
        });
        if (r2)
          return r2;
      }
      console.warn("Asset not found:", e2);
    }
    async findAsset(e2) {
      return this.findAssetRegex(e2.query);
    }
    async findAssetSimple(e2, t2 = false) {
      return this.findAssetRegex(new RegExp(e2, t2 ? "i" : ""));
    }
  }
  var Zp = {}, $p = function(e2) {
    return URL.createObjectURL(new Blob([e2], { type: "text/javascript" }));
  }, ed = function(e2) {
    return new Worker(e2);
  };
  try {
    URL.revokeObjectURL($p(""));
  } catch (ru2) {
    $p = function(e2) {
      return "data:application/javascript;charset=UTF-8," + encodeURI(e2);
    }, ed = function(e2) {
      return new Worker(e2, { type: "module" });
    };
  }
  var td = Uint8Array, rd = Uint16Array, nd = Uint32Array, id = new td([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), sd = new td([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), od = new td([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), ad = function(e2, t2) {
    for (var r2 = new rd(31), n2 = 0; n2 < 31; ++n2)
      r2[n2] = t2 += 1 << e2[n2 - 1];
    var i2 = new nd(r2[30]);
    for (n2 = 1; n2 < 30; ++n2)
      for (var s2 = r2[n2]; s2 < r2[n2 + 1]; ++s2)
        i2[s2] = s2 - r2[n2] << 5 | n2;
    return [r2, i2];
  }, ld = ad(id, 2), cd = ld[0], ud = ld[1];
  cd[28] = 258, ud[258] = 28;
  for (var hd = ad(sd, 0), pd = hd[0], dd = hd[1], fd = new rd(32768), md = 0; md < 32768; ++md) {
    var _d = (43690 & md) >>> 1 | (21845 & md) << 1;
    _d = (61680 & (_d = (52428 & _d) >>> 2 | (13107 & _d) << 2)) >>> 4 | (3855 & _d) << 4, fd[md] = ((65280 & _d) >>> 8 | (255 & _d) << 8) >>> 1;
  }
  var gd = function(e2, t2, r2) {
    for (var n2 = e2.length, i2 = 0, s2 = new rd(t2); i2 < n2; ++i2)
      ++s2[e2[i2] - 1];
    var o2, a2 = new rd(t2);
    for (i2 = 0; i2 < t2; ++i2)
      a2[i2] = a2[i2 - 1] + s2[i2 - 1] << 1;
    if (r2) {
      o2 = new rd(1 << t2);
      var l2 = 15 - t2;
      for (i2 = 0; i2 < n2; ++i2)
        if (e2[i2])
          for (var c2 = i2 << 4 | e2[i2], u2 = t2 - e2[i2], h2 = a2[e2[i2] - 1]++ << u2, p2 = h2 | (1 << u2) - 1; h2 <= p2; ++h2)
            o2[fd[h2] >>> l2] = c2;
    } else
      for (o2 = new rd(n2), i2 = 0; i2 < n2; ++i2)
        e2[i2] && (o2[i2] = fd[a2[e2[i2] - 1]++] >>> 15 - e2[i2]);
    return o2;
  }, vd = new td(288);
  for (md = 0; md < 144; ++md)
    vd[md] = 8;
  for (md = 144; md < 256; ++md)
    vd[md] = 9;
  for (md = 256; md < 280; ++md)
    vd[md] = 7;
  for (md = 280; md < 288; ++md)
    vd[md] = 8;
  var Ad = new td(32);
  for (md = 0; md < 32; ++md)
    Ad[md] = 5;
  var bd = gd(vd, 9, 0), yd = gd(vd, 9, 1), xd = gd(Ad, 5, 0), wd = gd(Ad, 5, 1), Ed = function(e2) {
    for (var t2 = e2[0], r2 = 1; r2 < e2.length; ++r2)
      e2[r2] > t2 && (t2 = e2[r2]);
    return t2;
  }, Sd = function(e2, t2, r2) {
    var n2 = t2 / 8 | 0;
    return (e2[n2] | e2[n2 + 1] << 8) >> (7 & t2) & r2;
  }, Cd = function(e2, t2) {
    var r2 = t2 / 8 | 0;
    return (e2[r2] | e2[r2 + 1] << 8 | e2[r2 + 2] << 16) >> (7 & t2);
  }, Md = function(e2) {
    return (e2 / 8 | 0) + (7 & e2 && 1);
  }, Td = function(e2, t2, r2) {
    (null == t2 || t2 < 0) && (t2 = 0), (null == r2 || r2 > e2.length) && (r2 = e2.length);
    var n2 = new (e2 instanceof rd ? rd : e2 instanceof nd ? nd : td)(r2 - t2);
    return n2.set(e2.subarray(t2, r2)), n2;
  }, Id = function(e2, t2, r2) {
    var n2 = e2.length;
    if (!n2 || r2 && !r2.l && n2 < 5)
      return t2 || new td(0);
    var i2 = !t2 || r2, s2 = !r2 || r2.i;
    r2 || (r2 = {}), t2 || (t2 = new td(3 * n2));
    var o2 = function(e3) {
      var r3 = t2.length;
      if (e3 > r3) {
        var n3 = new td(Math.max(2 * r3, e3));
        n3.set(t2), t2 = n3;
      }
    }, a2 = r2.f || 0, l2 = r2.p || 0, c2 = r2.b || 0, u2 = r2.l, h2 = r2.d, p2 = r2.m, d2 = r2.n, f2 = 8 * n2;
    do {
      if (!u2) {
        r2.f = a2 = Sd(e2, l2, 1);
        var m2 = Sd(e2, l2 + 1, 3);
        if (l2 += 3, !m2) {
          var _2 = e2[(M2 = Md(l2) + 4) - 4] | e2[M2 - 3] << 8, g2 = M2 + _2;
          if (g2 > n2) {
            if (s2)
              throw "unexpected EOF";
            break;
          }
          i2 && o2(c2 + _2), t2.set(e2.subarray(M2, g2), c2), r2.b = c2 += _2, r2.p = l2 = 8 * g2;
          continue;
        }
        if (1 == m2)
          u2 = yd, h2 = wd, p2 = 9, d2 = 5;
        else {
          if (2 != m2)
            throw "invalid block type";
          var v2 = Sd(e2, l2, 31) + 257, A2 = Sd(e2, l2 + 10, 15) + 4, b2 = v2 + Sd(e2, l2 + 5, 31) + 1;
          l2 += 14;
          for (var y2 = new td(b2), x2 = new td(19), w2 = 0; w2 < A2; ++w2)
            x2[od[w2]] = Sd(e2, l2 + 3 * w2, 7);
          l2 += 3 * A2;
          var E2 = Ed(x2), S2 = (1 << E2) - 1, C2 = gd(x2, E2, 1);
          for (w2 = 0; w2 < b2; ) {
            var M2, T2 = C2[Sd(e2, l2, S2)];
            if (l2 += 15 & T2, (M2 = T2 >>> 4) < 16)
              y2[w2++] = M2;
            else {
              var I2 = 0, k2 = 0;
              for (16 == M2 ? (k2 = 3 + Sd(e2, l2, 3), l2 += 2, I2 = y2[w2 - 1]) : 17 == M2 ? (k2 = 3 + Sd(e2, l2, 7), l2 += 3) : 18 == M2 && (k2 = 11 + Sd(e2, l2, 127), l2 += 7); k2--; )
                y2[w2++] = I2;
            }
          }
          var D2 = y2.subarray(0, v2), P2 = y2.subarray(v2);
          p2 = Ed(D2), d2 = Ed(P2), u2 = gd(D2, p2, 1), h2 = gd(P2, d2, 1);
        }
        if (l2 > f2) {
          if (s2)
            throw "unexpected EOF";
          break;
        }
      }
      i2 && o2(c2 + 131072);
      for (var B2 = (1 << p2) - 1, R2 = (1 << d2) - 1, L2 = l2; ; L2 = l2) {
        var O2 = (I2 = u2[Cd(e2, l2) & B2]) >>> 4;
        if ((l2 += 15 & I2) > f2) {
          if (s2)
            throw "unexpected EOF";
          break;
        }
        if (!I2)
          throw "invalid length/literal";
        if (O2 < 256)
          t2[c2++] = O2;
        else {
          if (256 == O2) {
            L2 = l2, u2 = null;
            break;
          }
          var F2 = O2 - 254;
          if (O2 > 264) {
            var U2 = id[w2 = O2 - 257];
            F2 = Sd(e2, l2, (1 << U2) - 1) + cd[w2], l2 += U2;
          }
          var N2 = h2[Cd(e2, l2) & R2], j2 = N2 >>> 4;
          if (!N2)
            throw "invalid distance";
          if (l2 += 15 & N2, P2 = pd[j2], j2 > 3 && (U2 = sd[j2], P2 += Cd(e2, l2) & (1 << U2) - 1, l2 += U2), l2 > f2) {
            if (s2)
              throw "unexpected EOF";
            break;
          }
          i2 && o2(c2 + 131072);
          for (var z2 = c2 + F2; c2 < z2; c2 += 4)
            t2[c2] = t2[c2 - P2], t2[c2 + 1] = t2[c2 + 1 - P2], t2[c2 + 2] = t2[c2 + 2 - P2], t2[c2 + 3] = t2[c2 + 3 - P2];
          c2 = z2;
        }
      }
      r2.l = u2, r2.p = L2, r2.b = c2, u2 && (a2 = 1, r2.m = p2, r2.d = h2, r2.n = d2);
    } while (!a2);
    return c2 == t2.length ? t2 : Td(t2, 0, c2);
  }, kd = function(e2, t2, r2) {
    r2 <<= 7 & t2;
    var n2 = t2 / 8 | 0;
    e2[n2] |= r2, e2[n2 + 1] |= r2 >>> 8;
  }, Dd = function(e2, t2, r2) {
    r2 <<= 7 & t2;
    var n2 = t2 / 8 | 0;
    e2[n2] |= r2, e2[n2 + 1] |= r2 >>> 8, e2[n2 + 2] |= r2 >>> 16;
  }, Pd = function(e2, t2) {
    for (var r2 = [], n2 = 0; n2 < e2.length; ++n2)
      e2[n2] && r2.push({ s: n2, f: e2[n2] });
    var i2 = r2.length, s2 = r2.slice();
    if (!i2)
      return [Nd, 0];
    if (1 == i2) {
      var o2 = new td(r2[0].s + 1);
      return o2[r2[0].s] = 1, [o2, 1];
    }
    r2.sort(function(e3, t3) {
      return e3.f - t3.f;
    }), r2.push({ s: -1, f: 25001 });
    var a2 = r2[0], l2 = r2[1], c2 = 0, u2 = 1, h2 = 2;
    for (r2[0] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 }; u2 != i2 - 1; )
      a2 = r2[r2[c2].f < r2[h2].f ? c2++ : h2++], l2 = r2[c2 != u2 && r2[c2].f < r2[h2].f ? c2++ : h2++], r2[u2++] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 };
    var p2 = s2[0].s;
    for (n2 = 1; n2 < i2; ++n2)
      s2[n2].s > p2 && (p2 = s2[n2].s);
    var d2 = new rd(p2 + 1), f2 = Bd(r2[u2 - 1], d2, 0);
    if (f2 > t2) {
      n2 = 0;
      var m2 = 0, _2 = f2 - t2, g2 = 1 << _2;
      for (s2.sort(function(e3, t3) {
        return d2[t3.s] - d2[e3.s] || e3.f - t3.f;
      }); n2 < i2; ++n2) {
        var v2 = s2[n2].s;
        if (!(d2[v2] > t2))
          break;
        m2 += g2 - (1 << f2 - d2[v2]), d2[v2] = t2;
      }
      for (m2 >>>= _2; m2 > 0; ) {
        var A2 = s2[n2].s;
        d2[A2] < t2 ? m2 -= 1 << t2 - d2[A2]++ - 1 : ++n2;
      }
      for (; n2 >= 0 && m2; --n2) {
        var b2 = s2[n2].s;
        d2[b2] == t2 && (--d2[b2], ++m2);
      }
      f2 = t2;
    }
    return [new td(d2), f2];
  }, Bd = function(e2, t2, r2) {
    return -1 == e2.s ? Math.max(Bd(e2.l, t2, r2 + 1), Bd(e2.r, t2, r2 + 1)) : t2[e2.s] = r2;
  }, Rd = function(e2) {
    for (var t2 = e2.length; t2 && !e2[--t2]; )
      ;
    for (var r2 = new rd(++t2), n2 = 0, i2 = e2[0], s2 = 1, o2 = function(e3) {
      r2[n2++] = e3;
    }, a2 = 1; a2 <= t2; ++a2)
      if (e2[a2] == i2 && a2 != t2)
        ++s2;
      else {
        if (!i2 && s2 > 2) {
          for (; s2 > 138; s2 -= 138)
            o2(32754);
          s2 > 2 && (o2(s2 > 10 ? s2 - 11 << 5 | 28690 : s2 - 3 << 5 | 12305), s2 = 0);
        } else if (s2 > 3) {
          for (o2(i2), --s2; s2 > 6; s2 -= 6)
            o2(8304);
          s2 > 2 && (o2(s2 - 3 << 5 | 8208), s2 = 0);
        }
        for (; s2--; )
          o2(i2);
        s2 = 1, i2 = e2[a2];
      }
    return [r2.subarray(0, n2), t2];
  }, Ld = function(e2, t2) {
    for (var r2 = 0, n2 = 0; n2 < t2.length; ++n2)
      r2 += e2[n2] * t2[n2];
    return r2;
  }, Od = function(e2, t2, r2) {
    var n2 = r2.length, i2 = Md(t2 + 2);
    e2[i2] = 255 & n2, e2[i2 + 1] = n2 >>> 8, e2[i2 + 2] = 255 ^ e2[i2], e2[i2 + 3] = 255 ^ e2[i2 + 1];
    for (var s2 = 0; s2 < n2; ++s2)
      e2[i2 + s2 + 4] = r2[s2];
    return 8 * (i2 + 4 + n2);
  }, Fd = function(e2, t2, r2, n2, i2, s2, o2, a2, l2, c2, u2) {
    kd(t2, u2++, r2), ++i2[256];
    for (var h2 = Pd(i2, 15), p2 = h2[0], d2 = h2[1], f2 = Pd(s2, 15), m2 = f2[0], _2 = f2[1], g2 = Rd(p2), v2 = g2[0], A2 = g2[1], b2 = Rd(m2), y2 = b2[0], x2 = b2[1], w2 = new rd(19), E2 = 0; E2 < v2.length; ++E2)
      w2[31 & v2[E2]]++;
    for (E2 = 0; E2 < y2.length; ++E2)
      w2[31 & y2[E2]]++;
    for (var S2 = Pd(w2, 7), C2 = S2[0], M2 = S2[1], T2 = 19; T2 > 4 && !C2[od[T2 - 1]]; --T2)
      ;
    var I2, k2, D2, P2, B2 = c2 + 5 << 3, R2 = Ld(i2, vd) + Ld(s2, Ad) + o2, L2 = Ld(i2, p2) + Ld(s2, m2) + o2 + 14 + 3 * T2 + Ld(w2, C2) + (2 * w2[16] + 3 * w2[17] + 7 * w2[18]);
    if (B2 <= R2 && B2 <= L2)
      return Od(t2, u2, e2.subarray(l2, l2 + c2));
    if (kd(t2, u2, 1 + (L2 < R2)), u2 += 2, L2 < R2) {
      I2 = gd(p2, d2, 0), k2 = p2, D2 = gd(m2, _2, 0), P2 = m2;
      var O2 = gd(C2, M2, 0);
      for (kd(t2, u2, A2 - 257), kd(t2, u2 + 5, x2 - 1), kd(t2, u2 + 10, T2 - 4), u2 += 14, E2 = 0; E2 < T2; ++E2)
        kd(t2, u2 + 3 * E2, C2[od[E2]]);
      u2 += 3 * T2;
      for (var F2 = [v2, y2], U2 = 0; U2 < 2; ++U2) {
        var N2 = F2[U2];
        for (E2 = 0; E2 < N2.length; ++E2) {
          var j2 = 31 & N2[E2];
          kd(t2, u2, O2[j2]), u2 += C2[j2], j2 > 15 && (kd(t2, u2, N2[E2] >>> 5 & 127), u2 += N2[E2] >>> 12);
        }
      }
    } else
      I2 = bd, k2 = vd, D2 = xd, P2 = Ad;
    for (E2 = 0; E2 < a2; ++E2)
      if (n2[E2] > 255) {
        j2 = n2[E2] >>> 18 & 31, Dd(t2, u2, I2[j2 + 257]), u2 += k2[j2 + 257], j2 > 7 && (kd(t2, u2, n2[E2] >>> 23 & 31), u2 += id[j2]);
        var z2 = 31 & n2[E2];
        Dd(t2, u2, D2[z2]), u2 += P2[z2], z2 > 3 && (Dd(t2, u2, n2[E2] >>> 5 & 8191), u2 += sd[z2]);
      } else
        Dd(t2, u2, I2[n2[E2]]), u2 += k2[n2[E2]];
    return Dd(t2, u2, I2[256]), u2 + k2[256];
  }, Ud = new nd([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), Nd = new td(0), jd = function(e2, t2, r2, n2, i2, s2) {
    var o2 = e2.length, a2 = new td(n2 + o2 + 5 * (1 + Math.ceil(o2 / 7e3)) + i2), l2 = a2.subarray(n2, a2.length - i2), c2 = 0;
    if (!t2 || o2 < 8)
      for (var u2 = 0; u2 <= o2; u2 += 65535) {
        var h2 = u2 + 65535;
        h2 < o2 ? c2 = Od(l2, c2, e2.subarray(u2, h2)) : (l2[u2] = s2, c2 = Od(l2, c2, e2.subarray(u2, o2)));
      }
    else {
      for (var p2 = Ud[t2 - 1], d2 = p2 >>> 13, f2 = 8191 & p2, m2 = (1 << r2) - 1, _2 = new rd(32768), g2 = new rd(m2 + 1), v2 = Math.ceil(r2 / 3), A2 = 2 * v2, b2 = function(t3) {
        return (e2[t3] ^ e2[t3 + 1] << v2 ^ e2[t3 + 2] << A2) & m2;
      }, y2 = new nd(25e3), x2 = new rd(288), w2 = new rd(32), E2 = 0, S2 = 0, C2 = (u2 = 0, 0), M2 = 0, T2 = 0; u2 < o2; ++u2) {
        var I2 = b2(u2), k2 = 32767 & u2, D2 = g2[I2];
        if (_2[k2] = D2, g2[I2] = k2, M2 <= u2) {
          var P2 = o2 - u2;
          if ((E2 > 7e3 || C2 > 24576) && P2 > 423) {
            c2 = Fd(e2, l2, 0, y2, x2, w2, S2, C2, T2, u2 - T2, c2), C2 = E2 = S2 = 0, T2 = u2;
            for (var B2 = 0; B2 < 286; ++B2)
              x2[B2] = 0;
            for (B2 = 0; B2 < 30; ++B2)
              w2[B2] = 0;
          }
          var R2 = 2, L2 = 0, O2 = f2, F2 = k2 - D2 & 32767;
          if (P2 > 2 && I2 == b2(u2 - F2))
            for (var U2 = Math.min(d2, P2) - 1, N2 = Math.min(32767, u2), j2 = Math.min(258, P2); F2 <= N2 && --O2 && k2 != D2; ) {
              if (e2[u2 + R2] == e2[u2 + R2 - F2]) {
                for (var z2 = 0; z2 < j2 && e2[u2 + z2] == e2[u2 + z2 - F2]; ++z2)
                  ;
                if (z2 > R2) {
                  if (R2 = z2, L2 = F2, z2 > U2)
                    break;
                  var G2 = Math.min(F2, z2 - 2), V2 = 0;
                  for (B2 = 0; B2 < G2; ++B2) {
                    var Q2 = u2 - F2 + B2 + 32768 & 32767, H2 = Q2 - _2[Q2] + 32768 & 32767;
                    H2 > V2 && (V2 = H2, D2 = Q2);
                  }
                }
              }
              F2 += (k2 = D2) - (D2 = _2[k2]) + 32768 & 32767;
            }
          if (L2) {
            y2[C2++] = 268435456 | ud[R2] << 18 | dd[L2];
            var W2 = 31 & ud[R2], q2 = 31 & dd[L2];
            S2 += id[W2] + sd[q2], ++x2[257 + W2], ++w2[q2], M2 = u2 + R2, ++E2;
          } else
            y2[C2++] = e2[u2], ++x2[e2[u2]];
        }
      }
      c2 = Fd(e2, l2, s2, y2, x2, w2, S2, C2, T2, u2 - T2, c2), !s2 && 7 & c2 && (c2 = Od(l2, c2 + 1, Nd));
    }
    return Td(a2, 0, n2 + Md(c2) + i2);
  }, zd = function() {
    for (var e2 = new nd(256), t2 = 0; t2 < 256; ++t2) {
      for (var r2 = t2, n2 = 9; --n2; )
        r2 = (1 & r2 && 3988292384) ^ r2 >>> 1;
      e2[t2] = r2;
    }
    return e2;
  }(), Gd = function() {
    var e2 = -1;
    return { p: function(t2) {
      for (var r2 = e2, n2 = 0; n2 < t2.length; ++n2)
        r2 = zd[255 & r2 ^ t2[n2]] ^ r2 >>> 8;
      e2 = r2;
    }, d: function() {
      return ~e2;
    } };
  }, Vd = function() {
    var e2 = 1, t2 = 0;
    return { p: function(r2) {
      for (var n2 = e2, i2 = t2, s2 = r2.length, o2 = 0; o2 != s2; ) {
        for (var a2 = Math.min(o2 + 2655, s2); o2 < a2; ++o2)
          i2 += n2 += r2[o2];
        n2 = (65535 & n2) + 15 * (n2 >> 16), i2 = (65535 & i2) + 15 * (i2 >> 16);
      }
      e2 = n2, t2 = i2;
    }, d: function() {
      return (255 & (e2 %= 65521)) << 24 | e2 >>> 8 << 16 | (255 & (t2 %= 65521)) << 8 | t2 >>> 8;
    } };
  }, Qd = function(e2, t2, r2, n2, i2) {
    return jd(e2, null == t2.level ? 6 : t2.level, null == t2.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e2.length)))) : 12 + t2.mem, r2, n2, !i2);
  }, Hd = function(e2, t2) {
    var r2 = {};
    for (var n2 in e2)
      r2[n2] = e2[n2];
    for (var n2 in t2)
      r2[n2] = t2[n2];
    return r2;
  }, Wd = function(e2, t2, r2) {
    for (var n2 = e2(), i2 = e2.toString(), s2 = i2.slice(i2.indexOf("[") + 1, i2.lastIndexOf("]")).replace(/ /g, "").split(","), o2 = 0; o2 < n2.length; ++o2) {
      var a2 = n2[o2], l2 = s2[o2];
      if ("function" == typeof a2) {
        t2 += ";" + l2 + "=";
        var c2 = a2.toString();
        if (a2.prototype)
          if (-1 != c2.indexOf("[native code]")) {
            var u2 = c2.indexOf(" ", 8) + 1;
            t2 += c2.slice(u2, c2.indexOf("(", u2));
          } else
            for (var h2 in t2 += c2, a2.prototype)
              t2 += ";" + l2 + ".prototype." + h2 + "=" + a2.prototype[h2].toString();
        else
          t2 += c2;
      } else
        r2[l2] = a2;
    }
    return [t2, r2];
  }, qd = [], Xd = function(e2, t2, r2, n2) {
    var i2;
    if (!qd[r2]) {
      for (var s2 = "", o2 = {}, a2 = e2.length - 1, l2 = 0; l2 < a2; ++l2)
        s2 = (i2 = Wd(e2[l2], s2, o2))[0], o2 = i2[1];
      qd[r2] = Wd(e2[a2], s2, o2);
    }
    var c2 = Hd({}, qd[r2][1]);
    return function(e3, t3, r3, n3, i3) {
      var s3 = ed(Zp[t3] || (Zp[t3] = $p(e3)));
      return s3.onerror = function(e4) {
        return i3(e4.error, null);
      }, s3.onmessage = function(e4) {
        return i3(null, e4.data);
      }, s3.postMessage(r3, n3), s3;
    }(qd[r2][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t2.toString() + "}", r2, c2, function(e3) {
      var t3 = [];
      for (var r3 in e3)
        (e3[r3] instanceof td || e3[r3] instanceof rd || e3[r3] instanceof nd) && t3.push((e3[r3] = new e3[r3].constructor(e3[r3])).buffer);
      return t3;
    }(c2), n2);
  }, Yd = function() {
    return [td, rd, nd, id, sd, od, cd, pd, yd, wd, fd, gd, Ed, Sd, Cd, Md, Td, Id, Sf, tf, rf];
  }, Kd = function() {
    return [td, rd, nd, id, sd, od, ud, dd, bd, vd, xd, Ad, fd, Ud, Nd, gd, kd, Dd, Pd, Bd, Rd, Ld, Od, Fd, Md, Td, jd, Qd, yf, tf];
  }, Jd = function() {
    return [hf, ff, uf, Gd, zd];
  }, Zd = function() {
    return [pf, df];
  }, $d = function() {
    return [mf, uf, Vd];
  }, ef = function() {
    return [_f];
  }, tf = function(e2) {
    return postMessage(e2, [e2.buffer]);
  }, rf = function(e2) {
    return e2 && e2.size && new td(e2.size);
  }, nf = function(e2, t2, r2, n2, i2, s2) {
    var o2 = Xd(r2, n2, i2, function(e3, t3) {
      o2.terminate(), s2(e3, t3);
    });
    return o2.postMessage([e2, t2], t2.consume ? [e2.buffer] : []), function() {
      o2.terminate();
    };
  }, sf = function(e2) {
    return e2.ondata = function(e3, t2) {
      return postMessage([e3, t2], [e3.buffer]);
    }, function(t2) {
      return e2.push(t2.data[0], t2.data[1]);
    };
  }, of = function(e2, t2, r2, n2, i2) {
    var s2, o2 = Xd(e2, n2, i2, function(e3, r3) {
      e3 ? (o2.terminate(), t2.ondata.call(t2, e3)) : (r3[1] && o2.terminate(), t2.ondata.call(t2, e3, r3[0], r3[1]));
    });
    o2.postMessage(r2), t2.push = function(e3, r3) {
      if (s2)
        throw "stream finished";
      if (!t2.ondata)
        throw "no stream handler";
      o2.postMessage([e3, s2 = r3], [e3.buffer]);
    }, t2.terminate = function() {
      o2.terminate();
    };
  }, af = function(e2, t2) {
    return e2[t2] | e2[t2 + 1] << 8;
  }, lf = function(e2, t2) {
    return (e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24) >>> 0;
  }, cf = function(e2, t2) {
    return lf(e2, t2) + 4294967296 * lf(e2, t2 + 4);
  }, uf = function(e2, t2, r2) {
    for (; r2; ++t2)
      e2[t2] = r2, r2 >>>= 8;
  }, hf = function(e2, t2) {
    var r2 = t2.filename;
    if (e2[0] = 31, e2[1] = 139, e2[2] = 8, e2[8] = t2.level < 2 ? 4 : 9 == t2.level ? 2 : 0, e2[9] = 3, 0 != t2.mtime && uf(e2, 4, Math.floor(new Date(t2.mtime || Date.now()) / 1e3)), r2) {
      e2[3] = 8;
      for (var n2 = 0; n2 <= r2.length; ++n2)
        e2[n2 + 10] = r2.charCodeAt(n2);
    }
  }, pf = function(e2) {
    if (31 != e2[0] || 139 != e2[1] || 8 != e2[2])
      throw "invalid gzip data";
    var t2 = e2[3], r2 = 10;
    4 & t2 && (r2 += e2[10] | 2 + (e2[11] << 8));
    for (var n2 = (t2 >> 3 & 1) + (t2 >> 4 & 1); n2 > 0; n2 -= !e2[r2++])
      ;
    return r2 + (2 & t2);
  }, df = function(e2) {
    var t2 = e2.length;
    return (e2[t2 - 4] | e2[t2 - 3] << 8 | e2[t2 - 2] << 16 | e2[t2 - 1] << 24) >>> 0;
  }, ff = function(e2) {
    return 10 + (e2.filename && e2.filename.length + 1 || 0);
  }, mf = function(e2, t2) {
    var r2 = t2.level, n2 = 0 == r2 ? 0 : r2 < 6 ? 1 : 9 == r2 ? 3 : 2;
    e2[0] = 120, e2[1] = n2 << 6 | (n2 ? 32 - 2 * n2 : 1);
  }, _f = function(e2) {
    if (8 != (15 & e2[0]) || e2[0] >>> 4 > 7 || (e2[0] << 8 | e2[1]) % 31)
      throw "invalid zlib data";
    if (32 & e2[1])
      throw "invalid zlib data: preset dictionaries not supported";
  };
  function gf(e2, t2) {
    return t2 || "function" != typeof e2 || (t2 = e2, e2 = {}), this.ondata = t2, e2;
  }
  var vf = function() {
    function e2(e3, t2) {
      t2 || "function" != typeof e3 || (t2 = e3, e3 = {}), this.ondata = t2, this.o = e3 || {};
    }
    return e2.prototype.p = function(e3, t2) {
      this.ondata(Qd(e3, this.o, 0, 0, !t2), t2);
    }, e2.prototype.push = function(e3, t2) {
      if (this.d)
        throw "stream finished";
      if (!this.ondata)
        throw "no stream handler";
      this.d = t2, this.p(e3, t2 || false);
    }, e2;
  }(), Af = function() {
    return function(e2, t2) {
      of([Kd, function() {
        return [sf, vf];
      }], this, gf.call(this, e2, t2), function(e3) {
        var t3 = new vf(e3.data);
        onmessage = sf(t3);
      }, 6);
    };
  }();
  function bf(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return nf(e2, t2, [Kd], function(e3) {
      return tf(yf(e3.data[0], e3.data[1]));
    }, 0, r2);
  }
  function yf(e2, t2) {
    return Qd(e2, t2 || {}, 0, 0);
  }
  var xf = function() {
    function e2(e3) {
      this.s = {}, this.p = new td(0), this.ondata = e3;
    }
    return e2.prototype.e = function(e3) {
      if (this.d)
        throw "stream finished";
      if (!this.ondata)
        throw "no stream handler";
      var t2 = this.p.length, r2 = new td(t2 + e3.length);
      r2.set(this.p), r2.set(e3, t2), this.p = r2;
    }, e2.prototype.c = function(e3) {
      this.d = this.s.i = e3 || false;
      var t2 = this.s.b, r2 = Id(this.p, this.o, this.s);
      this.ondata(Td(r2, t2, this.s.b), this.d), this.o = Td(r2, this.s.b - 32768), this.s.b = this.o.length, this.p = Td(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    }, e2.prototype.push = function(e3, t2) {
      this.e(e3), this.c(t2);
    }, e2;
  }(), wf = function() {
    return function(e2) {
      this.ondata = e2, of([Yd, function() {
        return [sf, xf];
      }], this, 0, function() {
        var e3 = new xf();
        onmessage = sf(e3);
      }, 7);
    };
  }();
  function Ef(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return nf(e2, t2, [Yd], function(e3) {
      return tf(Sf(e3.data[0], rf(e3.data[1])));
    }, 1, r2);
  }
  function Sf(e2, t2) {
    return Id(e2, t2);
  }
  var Cf = function() {
    function e2(e3, t2) {
      this.c = Gd(), this.l = 0, this.v = 1, vf.call(this, e3, t2);
    }
    return e2.prototype.push = function(e3, t2) {
      vf.prototype.push.call(this, e3, t2);
    }, e2.prototype.p = function(e3, t2) {
      this.c.p(e3), this.l += e3.length;
      var r2 = Qd(e3, this.o, this.v && ff(this.o), t2 && 8, !t2);
      this.v && (hf(r2, this.o), this.v = 0), t2 && (uf(r2, r2.length - 8, this.c.d()), uf(r2, r2.length - 4, this.l)), this.ondata(r2, t2);
    }, e2;
  }(), Mf = function() {
    return function(e2, t2) {
      of([Kd, Jd, function() {
        return [sf, vf, Cf];
      }], this, gf.call(this, e2, t2), function(e3) {
        var t3 = new Cf(e3.data);
        onmessage = sf(t3);
      }, 8);
    };
  }();
  function Tf(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return nf(e2, t2, [Kd, Jd, function() {
      return [If];
    }], function(e3) {
      return tf(If(e3.data[0], e3.data[1]));
    }, 2, r2);
  }
  function If(e2, t2) {
    t2 || (t2 = {});
    var r2 = Gd(), n2 = e2.length;
    r2.p(e2);
    var i2 = Qd(e2, t2, ff(t2), 8), s2 = i2.length;
    return hf(i2, t2), uf(i2, s2 - 8, r2.d()), uf(i2, s2 - 4, n2), i2;
  }
  var kf = function() {
    function e2(e3) {
      this.v = 1, xf.call(this, e3);
    }
    return e2.prototype.push = function(e3, t2) {
      if (xf.prototype.e.call(this, e3), this.v) {
        var r2 = this.p.length > 3 ? pf(this.p) : 4;
        if (r2 >= this.p.length && !t2)
          return;
        this.p = this.p.subarray(r2), this.v = 0;
      }
      if (t2) {
        if (this.p.length < 8)
          throw "invalid gzip stream";
        this.p = this.p.subarray(0, -8);
      }
      xf.prototype.c.call(this, t2);
    }, e2;
  }(), Df = function() {
    return function(e2) {
      this.ondata = e2, of([Yd, Zd, function() {
        return [sf, xf, kf];
      }], this, 0, function() {
        var e3 = new kf();
        onmessage = sf(e3);
      }, 9);
    };
  }();
  function Pf(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return nf(e2, t2, [Yd, Zd, function() {
      return [Bf];
    }], function(e3) {
      return tf(Bf(e3.data[0]));
    }, 3, r2);
  }
  function Bf(e2, t2) {
    return Id(e2.subarray(pf(e2), -8), t2 || new td(df(e2)));
  }
  var Rf = function() {
    function e2(e3, t2) {
      this.c = Vd(), this.v = 1, vf.call(this, e3, t2);
    }
    return e2.prototype.push = function(e3, t2) {
      vf.prototype.push.call(this, e3, t2);
    }, e2.prototype.p = function(e3, t2) {
      this.c.p(e3);
      var r2 = Qd(e3, this.o, this.v && 2, t2 && 4, !t2);
      this.v && (mf(r2, this.o), this.v = 0), t2 && uf(r2, r2.length - 4, this.c.d()), this.ondata(r2, t2);
    }, e2;
  }(), Lf = function() {
    return function(e2, t2) {
      of([Kd, $d, function() {
        return [sf, vf, Rf];
      }], this, gf.call(this, e2, t2), function(e3) {
        var t3 = new Rf(e3.data);
        onmessage = sf(t3);
      }, 10);
    };
  }();
  function Of(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return nf(e2, t2, [Kd, $d, function() {
      return [Ff];
    }], function(e3) {
      return tf(Ff(e3.data[0], e3.data[1]));
    }, 4, r2);
  }
  function Ff(e2, t2) {
    t2 || (t2 = {});
    var r2 = Vd();
    r2.p(e2);
    var n2 = Qd(e2, t2, 2, 4);
    return mf(n2, t2), uf(n2, n2.length - 4, r2.d()), n2;
  }
  var Uf = function() {
    function e2(e3) {
      this.v = 1, xf.call(this, e3);
    }
    return e2.prototype.push = function(e3, t2) {
      if (xf.prototype.e.call(this, e3), this.v) {
        if (this.p.length < 2 && !t2)
          return;
        this.p = this.p.subarray(2), this.v = 0;
      }
      if (t2) {
        if (this.p.length < 4)
          throw "invalid zlib stream";
        this.p = this.p.subarray(0, -4);
      }
      xf.prototype.c.call(this, t2);
    }, e2;
  }(), Nf = function() {
    return function(e2) {
      this.ondata = e2, of([Yd, ef, function() {
        return [sf, xf, Uf];
      }], this, 0, function() {
        var e3 = new Uf();
        onmessage = sf(e3);
      }, 11);
    };
  }();
  function jf(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return nf(e2, t2, [Yd, ef, function() {
      return [zf];
    }], function(e3) {
      return tf(zf(e3.data[0], rf(e3.data[1])));
    }, 5, r2);
  }
  function zf(e2, t2) {
    return Id((_f(e2), e2.subarray(2, -4)), t2);
  }
  var Gf = function() {
    function e2(e3) {
      this.G = kf, this.I = xf, this.Z = Uf, this.ondata = e3;
    }
    return e2.prototype.push = function(e3, t2) {
      if (!this.ondata)
        throw "no stream handler";
      if (this.s)
        this.s.push(e3, t2);
      else {
        if (this.p && this.p.length) {
          var r2 = new td(this.p.length + e3.length);
          r2.set(this.p), r2.set(e3, this.p.length);
        } else
          this.p = e3;
        if (this.p.length > 2) {
          var n2 = this, i2 = function() {
            n2.ondata.apply(n2, arguments);
          };
          this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i2) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i2) : new this.Z(i2), this.s.push(this.p, t2), this.p = null;
        }
      }
    }, e2;
  }(), Vf = function() {
    function e2(e3) {
      this.G = Df, this.I = wf, this.Z = Nf, this.ondata = e3;
    }
    return e2.prototype.push = function(e3, t2) {
      Gf.prototype.push.call(this, e3, t2);
    }, e2;
  }();
  function Qf(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    return 31 == e2[0] && 139 == e2[1] && 8 == e2[2] ? Pf(e2, t2, r2) : 8 != (15 & e2[0]) || e2[0] >> 4 > 7 || (e2[0] << 8 | e2[1]) % 31 ? Ef(e2, t2, r2) : jf(e2, t2, r2);
  }
  function Hf(e2, t2) {
    return 31 == e2[0] && 139 == e2[1] && 8 == e2[2] ? Bf(e2, t2) : 8 != (15 & e2[0]) || e2[0] >> 4 > 7 || (e2[0] << 8 | e2[1]) % 31 ? Sf(e2, t2) : zf(e2, t2);
  }
  var Wf = function(e2, t2, r2, n2) {
    for (var i2 in e2) {
      var s2 = e2[i2], o2 = t2 + i2;
      s2 instanceof td ? r2[o2] = [s2, n2] : Array.isArray(s2) ? r2[o2] = [s2[0], Hd(n2, s2[1])] : Wf(s2, o2 + "/", r2, n2);
    }
  }, qf = "undefined" != typeof TextEncoder && new TextEncoder(), Xf = "undefined" != typeof TextDecoder && new TextDecoder(), Yf = 0;
  try {
    Xf.decode(Nd, { stream: true }), Yf = 1;
  } catch (ru2) {
  }
  var Kf = function(e2) {
    for (var t2 = "", r2 = 0; ; ) {
      var n2 = e2[r2++], i2 = (n2 > 127) + (n2 > 223) + (n2 > 239);
      if (r2 + i2 > e2.length)
        return [t2, Td(e2, r2 - 1)];
      i2 ? 3 == i2 ? (n2 = ((15 & n2) << 18 | (63 & e2[r2++]) << 12 | (63 & e2[r2++]) << 6 | 63 & e2[r2++]) - 65536, t2 += String.fromCharCode(55296 | n2 >> 10, 56320 | 1023 & n2)) : t2 += 1 & i2 ? String.fromCharCode((31 & n2) << 6 | 63 & e2[r2++]) : String.fromCharCode((15 & n2) << 12 | (63 & e2[r2++]) << 6 | 63 & e2[r2++]) : t2 += String.fromCharCode(n2);
    }
  }, Jf = function() {
    function e2(e3) {
      this.ondata = e3, Yf ? this.t = new TextDecoder() : this.p = Nd;
    }
    return e2.prototype.push = function(e3, t2) {
      if (!this.ondata)
        throw "no callback";
      if (t2 = !!t2, this.t) {
        if (this.ondata(this.t.decode(e3, { stream: true }), t2), t2) {
          if (this.t.decode().length)
            throw "invalid utf-8 data";
          this.t = null;
        }
      } else {
        if (!this.p)
          throw "stream finished";
        var r2 = new td(this.p.length + e3.length);
        r2.set(this.p), r2.set(e3, this.p.length);
        var n2 = Kf(r2), i2 = n2[0], s2 = n2[1];
        if (t2) {
          if (s2.length)
            throw "invalid utf-8 data";
          this.p = null;
        } else
          this.p = s2;
        this.ondata(i2, t2);
      }
    }, e2;
  }(), Zf = function() {
    function e2(e3) {
      this.ondata = e3;
    }
    return e2.prototype.push = function(e3, t2) {
      if (!this.ondata)
        throw "no callback";
      if (this.d)
        throw "stream finished";
      this.ondata($f(e3), this.d = t2 || false);
    }, e2;
  }();
  function $f(e2, t2) {
    if (t2) {
      for (var r2 = new td(e2.length), n2 = 0; n2 < e2.length; ++n2)
        r2[n2] = e2.charCodeAt(n2);
      return r2;
    }
    if (qf)
      return qf.encode(e2);
    var i2 = e2.length, s2 = new td(e2.length + (e2.length >> 1)), o2 = 0, a2 = function(e3) {
      s2[o2++] = e3;
    };
    for (n2 = 0; n2 < i2; ++n2) {
      if (o2 + 5 > s2.length) {
        var l2 = new td(o2 + 8 + (i2 - n2 << 1));
        l2.set(s2), s2 = l2;
      }
      var c2 = e2.charCodeAt(n2);
      c2 < 128 || t2 ? a2(c2) : c2 < 2048 ? (a2(192 | c2 >> 6), a2(128 | 63 & c2)) : c2 > 55295 && c2 < 57344 ? (a2(240 | (c2 = 65536 + (1047552 & c2) | 1023 & e2.charCodeAt(++n2)) >> 18), a2(128 | c2 >> 12 & 63), a2(128 | c2 >> 6 & 63), a2(128 | 63 & c2)) : (a2(224 | c2 >> 12), a2(128 | c2 >> 6 & 63), a2(128 | 63 & c2));
    }
    return Td(s2, 0, o2);
  }
  function em(e2, t2) {
    if (t2) {
      for (var r2 = "", n2 = 0; n2 < e2.length; n2 += 16384)
        r2 += String.fromCharCode.apply(null, e2.subarray(n2, n2 + 16384));
      return r2;
    }
    if (Xf)
      return Xf.decode(e2);
    var i2 = Kf(e2), s2 = i2[0];
    if (i2[1].length)
      throw "invalid utf-8 data";
    return s2;
  }
  var tm = function(e2) {
    return 1 == e2 ? 3 : e2 < 6 ? 2 : 9 == e2 ? 1 : 0;
  }, rm = function(e2, t2) {
    return t2 + 30 + af(e2, t2 + 26) + af(e2, t2 + 28);
  }, nm = function(e2, t2, r2) {
    var n2 = af(e2, t2 + 28), i2 = em(e2.subarray(t2 + 46, t2 + 46 + n2), !(2048 & af(e2, t2 + 8))), s2 = t2 + 46 + n2, o2 = lf(e2, t2 + 20), a2 = r2 && 4294967295 == o2 ? im(e2, s2) : [o2, lf(e2, t2 + 24), lf(e2, t2 + 42)], l2 = a2[0], c2 = a2[1], u2 = a2[2];
    return [af(e2, t2 + 10), l2, c2, i2, s2 + af(e2, t2 + 30) + af(e2, t2 + 32), u2];
  }, im = function(e2, t2) {
    for (; 1 != af(e2, t2); t2 += 4 + af(e2, t2 + 2))
      ;
    return [cf(e2, t2 + 12), cf(e2, t2 + 4), cf(e2, t2 + 20)];
  }, sm = function(e2) {
    var t2 = 0;
    if (e2)
      for (var r2 in e2) {
        var n2 = e2[r2].length;
        if (n2 > 65535)
          throw "extra field too long";
        t2 += n2 + 4;
      }
    return t2;
  }, om = function(e2, t2, r2, n2, i2, s2, o2, a2) {
    var l2 = n2.length, c2 = r2.extra, u2 = a2 && a2.length, h2 = sm(c2);
    uf(e2, t2, null != o2 ? 33639248 : 67324752), t2 += 4, null != o2 && (e2[t2++] = 20, e2[t2++] = r2.os), e2[t2] = 20, t2 += 2, e2[t2++] = r2.flag << 1 | (null == s2 && 8), e2[t2++] = i2 && 8, e2[t2++] = 255 & r2.compression, e2[t2++] = r2.compression >> 8;
    var p2 = new Date(null == r2.mtime ? Date.now() : r2.mtime), d2 = p2.getFullYear() - 1980;
    if (d2 < 0 || d2 > 119)
      throw "date not in range 1980-2099";
    if (uf(e2, t2, d2 << 25 | p2.getMonth() + 1 << 21 | p2.getDate() << 16 | p2.getHours() << 11 | p2.getMinutes() << 5 | p2.getSeconds() >>> 1), t2 += 4, null != s2 && (uf(e2, t2, r2.crc), uf(e2, t2 + 4, s2), uf(e2, t2 + 8, r2.size)), uf(e2, t2 + 12, l2), uf(e2, t2 + 14, h2), t2 += 16, null != o2 && (uf(e2, t2, u2), uf(e2, t2 + 6, r2.attrs), uf(e2, t2 + 10, o2), t2 += 14), e2.set(n2, t2), t2 += l2, h2)
      for (var f2 in c2) {
        var m2 = c2[f2], _2 = m2.length;
        uf(e2, t2, +f2), uf(e2, t2 + 2, _2), e2.set(m2, t2 + 4), t2 += 4 + _2;
      }
    return u2 && (e2.set(a2, t2), t2 += u2), t2;
  }, am = function(e2, t2, r2, n2, i2) {
    uf(e2, t2, 101010256), uf(e2, t2 + 8, r2), uf(e2, t2 + 10, r2), uf(e2, t2 + 12, n2), uf(e2, t2 + 16, i2);
  }, lm = function() {
    function e2(e3) {
      this.filename = e3, this.c = Gd(), this.size = 0, this.compression = 0;
    }
    return e2.prototype.process = function(e3, t2) {
      this.ondata(null, e3, t2);
    }, e2.prototype.push = function(e3, t2) {
      if (!this.ondata)
        throw "no callback - add to ZIP archive before pushing";
      this.c.p(e3), this.size += e3.length, t2 && (this.crc = this.c.d()), this.process(e3, t2 || false);
    }, e2;
  }(), cm = function() {
    function e2(e3, t2) {
      var r2 = this;
      t2 || (t2 = {}), lm.call(this, e3), this.d = new vf(t2, function(e4, t3) {
        r2.ondata(null, e4, t3);
      }), this.compression = 8, this.flag = tm(t2.level);
    }
    return e2.prototype.process = function(e3, t2) {
      try {
        this.d.push(e3, t2);
      } catch (e4) {
        this.ondata(e4, null, t2);
      }
    }, e2.prototype.push = function(e3, t2) {
      lm.prototype.push.call(this, e3, t2);
    }, e2;
  }(), um = function() {
    function e2(e3, t2) {
      var r2 = this;
      t2 || (t2 = {}), lm.call(this, e3), this.d = new Af(t2, function(e4, t3, n2) {
        r2.ondata(e4, t3, n2);
      }), this.compression = 8, this.flag = tm(t2.level), this.terminate = this.d.terminate;
    }
    return e2.prototype.process = function(e3, t2) {
      this.d.push(e3, t2);
    }, e2.prototype.push = function(e3, t2) {
      lm.prototype.push.call(this, e3, t2);
    }, e2;
  }(), hm = function() {
    function e2(e3) {
      this.ondata = e3, this.u = [], this.d = 1;
    }
    return e2.prototype.add = function(e3) {
      var t2 = this;
      if (2 & this.d)
        throw "stream finished";
      var r2 = $f(e3.filename), n2 = r2.length, i2 = e3.comment, s2 = i2 && $f(i2), o2 = n2 != e3.filename.length || s2 && i2.length != s2.length, a2 = n2 + sm(e3.extra) + 30;
      if (n2 > 65535)
        throw "filename too long";
      var l2 = new td(a2);
      om(l2, 0, e3, r2, o2);
      var c2 = [l2], u2 = function() {
        for (var e4 = 0, r3 = c2; e4 < r3.length; e4++) {
          var n3 = r3[e4];
          t2.ondata(null, n3, false);
        }
        c2 = [];
      }, h2 = this.d;
      this.d = 0;
      var p2 = this.u.length, d2 = Hd(e3, { f: r2, u: o2, o: s2, t: function() {
        e3.terminate && e3.terminate();
      }, r: function() {
        if (u2(), h2) {
          var e4 = t2.u[p2 + 1];
          e4 ? e4.r() : t2.d = 1;
        }
        h2 = 1;
      } }), f2 = 0;
      e3.ondata = function(r3, n3, i3) {
        if (r3)
          t2.ondata(r3, n3, i3), t2.terminate();
        else if (f2 += n3.length, c2.push(n3), i3) {
          var s3 = new td(16);
          uf(s3, 0, 134695760), uf(s3, 4, e3.crc), uf(s3, 8, f2), uf(s3, 12, e3.size), c2.push(s3), d2.c = f2, d2.b = a2 + f2 + 16, d2.crc = e3.crc, d2.size = e3.size, h2 && d2.r(), h2 = 1;
        } else
          h2 && u2();
      }, this.u.push(d2);
    }, e2.prototype.end = function() {
      var e3 = this;
      if (2 & this.d) {
        if (1 & this.d)
          throw "stream finishing";
        throw "stream finished";
      }
      this.d ? this.e() : this.u.push({ r: function() {
        1 & e3.d && (e3.u.splice(-1, 1), e3.e());
      }, t: function() {
      } }), this.d = 3;
    }, e2.prototype.e = function() {
      for (var e3 = 0, t2 = 0, r2 = 0, n2 = 0, i2 = this.u; n2 < i2.length; n2++)
        r2 += 46 + (l2 = i2[n2]).f.length + sm(l2.extra) + (l2.o ? l2.o.length : 0);
      for (var s2 = new td(r2 + 22), o2 = 0, a2 = this.u; o2 < a2.length; o2++) {
        var l2 = a2[o2];
        om(s2, e3, l2, l2.f, l2.u, l2.c, t2, l2.o), e3 += 46 + l2.f.length + sm(l2.extra) + (l2.o ? l2.o.length : 0), t2 += l2.b;
      }
      am(s2, e3, this.u.length, r2, t2), this.ondata(null, s2, true), this.d = 2;
    }, e2.prototype.terminate = function() {
      for (var e3 = 0, t2 = this.u; e3 < t2.length; e3++)
        t2[e3].t();
      this.d = 2;
    }, e2;
  }();
  function pm(e2, t2, r2) {
    if (r2 || (r2 = t2, t2 = {}), "function" != typeof r2)
      throw "no callback";
    var n2 = {};
    Wf(e2, "", n2, t2);
    var i2 = Object.keys(n2), s2 = i2.length, o2 = 0, a2 = 0, l2 = s2, c2 = new Array(s2), u2 = [], h2 = function() {
      for (var e3 = 0; e3 < u2.length; ++e3)
        u2[e3]();
    }, p2 = function() {
      var e3 = new td(a2 + 22), t3 = o2, n3 = a2 - o2;
      a2 = 0;
      for (var i3 = 0; i3 < l2; ++i3) {
        var s3 = c2[i3];
        try {
          var u3 = s3.c.length;
          om(e3, a2, s3, s3.f, s3.u, u3);
          var h3 = 30 + s3.f.length + sm(s3.extra), p3 = a2 + h3;
          e3.set(s3.c, p3), om(e3, o2, s3, s3.f, s3.u, u3, a2, s3.m), o2 += 16 + h3 + (s3.m ? s3.m.length : 0), a2 = p3 + u3;
        } catch (e4) {
          return r2(e4, null);
        }
      }
      am(e3, o2, c2.length, n3, t3), r2(null, e3);
    };
    s2 || p2();
    for (var d2 = function(e3) {
      var t3 = i2[e3], l3 = n2[t3], d3 = l3[0], f3 = l3[1], m2 = Gd(), _2 = d3.length;
      m2.p(d3);
      var g2 = $f(t3), v2 = g2.length, A2 = f3.comment, b2 = A2 && $f(A2), y2 = b2 && b2.length, x2 = sm(f3.extra), w2 = 0 == f3.level ? 0 : 8, E2 = function(n3, i3) {
        if (n3)
          h2(), r2(n3, null);
        else {
          var l4 = i3.length;
          c2[e3] = Hd(f3, { size: _2, crc: m2.d(), c: i3, f: g2, m: b2, u: v2 != t3.length || b2 && A2.length != y2, compression: w2 }), o2 += 30 + v2 + x2 + l4, a2 += 76 + 2 * (v2 + x2) + (y2 || 0) + l4, --s2 || p2();
        }
      };
      if (v2 > 65535 && E2("filename too long", null), w2)
        if (_2 < 16e4)
          try {
            E2(null, yf(d3, f3));
          } catch (e4) {
            E2(e4, null);
          }
        else
          u2.push(bf(d3, f3, E2));
      else
        E2(null, d3);
    }, f2 = 0; f2 < l2; ++f2)
      d2(f2);
    return h2;
  }
  function dm(e2, t2) {
    t2 || (t2 = {});
    var r2 = {}, n2 = [];
    Wf(e2, "", r2, t2);
    var i2 = 0, s2 = 0;
    for (var o2 in r2) {
      var a2 = r2[o2], l2 = a2[0], c2 = a2[1], u2 = 0 == c2.level ? 0 : 8, h2 = (w2 = $f(o2)).length, p2 = c2.comment, d2 = p2 && $f(p2), f2 = d2 && d2.length, m2 = sm(c2.extra);
      if (h2 > 65535)
        throw "filename too long";
      var _2 = u2 ? yf(l2, c2) : l2, g2 = _2.length, v2 = Gd();
      v2.p(l2), n2.push(Hd(c2, { size: l2.length, crc: v2.d(), c: _2, f: w2, m: d2, u: h2 != o2.length || d2 && p2.length != f2, o: i2, compression: u2 })), i2 += 30 + h2 + m2 + g2, s2 += 76 + 2 * (h2 + m2) + (f2 || 0) + g2;
    }
    for (var A2 = new td(s2 + 22), b2 = i2, y2 = s2 - i2, x2 = 0; x2 < n2.length; ++x2) {
      var w2 = n2[x2];
      om(A2, w2.o, w2, w2.f, w2.u, w2.c.length);
      var E2 = 30 + w2.f.length + sm(w2.extra);
      A2.set(w2.c, w2.o + E2), om(A2, i2, w2, w2.f, w2.u, w2.c.length, w2.o, w2.m), i2 += 16 + E2 + (w2.m ? w2.m.length : 0);
    }
    return am(A2, i2, n2.length, y2, b2), A2;
  }
  var fm = function() {
    function e2() {
    }
    return e2.prototype.push = function(e3, t2) {
      this.ondata(null, e3, t2);
    }, e2.compression = 0, e2;
  }(), mm = function() {
    function e2() {
      var e3 = this;
      this.i = new xf(function(t2, r2) {
        e3.ondata(null, t2, r2);
      });
    }
    return e2.prototype.push = function(e3, t2) {
      try {
        this.i.push(e3, t2);
      } catch (r2) {
        this.ondata(r2, e3, t2);
      }
    }, e2.compression = 8, e2;
  }(), _m = function() {
    function e2(e3, t2) {
      var r2 = this;
      t2 < 32e4 ? this.i = new xf(function(e4, t3) {
        r2.ondata(null, e4, t3);
      }) : (this.i = new wf(function(e4, t3, n2) {
        r2.ondata(e4, t3, n2);
      }), this.terminate = this.i.terminate);
    }
    return e2.prototype.push = function(e3, t2) {
      this.i.terminate && (e3 = Td(e3, 0)), this.i.push(e3, t2);
    }, e2.compression = 8, e2;
  }(), gm = function() {
    function e2(e3) {
      this.onfile = e3, this.k = [], this.o = { 0: fm }, this.p = Nd;
    }
    return e2.prototype.push = function(e3, t2) {
      var r2 = this;
      if (!this.onfile)
        throw "no callback";
      if (!this.p)
        throw "stream finished";
      if (this.c > 0) {
        var n2 = Math.min(this.c, e3.length), i2 = e3.subarray(0, n2);
        if (this.c -= n2, this.d ? this.d.push(i2, !this.c) : this.k[0].push(i2), (e3 = e3.subarray(n2)).length)
          return this.push(e3, t2);
      } else {
        var s2 = 0, o2 = 0, a2 = void 0, l2 = void 0;
        this.p.length ? e3.length ? ((l2 = new td(this.p.length + e3.length)).set(this.p), l2.set(e3, this.p.length)) : l2 = this.p : l2 = e3;
        for (var c2 = l2.length, u2 = this.c, h2 = u2 && this.d, p2 = function() {
          var e4, t3 = lf(l2, o2);
          if (67324752 == t3) {
            s2 = 1, a2 = o2, d2.d = null, d2.c = 0;
            var n3 = af(l2, o2 + 6), i3 = af(l2, o2 + 8), h3 = 2048 & n3, p3 = 8 & n3, f3 = af(l2, o2 + 26), m2 = af(l2, o2 + 28);
            if (c2 > o2 + 30 + f3 + m2) {
              var _2 = [];
              d2.k.unshift(_2), s2 = 2;
              var g2, v2 = lf(l2, o2 + 18), A2 = lf(l2, o2 + 22), b2 = em(l2.subarray(o2 + 30, o2 += 30 + f3), !h3);
              4294967295 == v2 ? (e4 = p3 ? [-2] : im(l2, o2), v2 = e4[0], A2 = e4[1]) : p3 && (v2 = -1), o2 += m2, d2.c = v2;
              var y2 = { name: b2, compression: i3, start: function() {
                if (!y2.ondata)
                  throw "no callback";
                if (v2) {
                  var e5 = r2.o[i3];
                  if (!e5)
                    throw "unknown compression type " + i3;
                  (g2 = v2 < 0 ? new e5(b2) : new e5(b2, v2, A2)).ondata = function(e6, t5, r3) {
                    y2.ondata(e6, t5, r3);
                  };
                  for (var t4 = 0, n4 = _2; t4 < n4.length; t4++) {
                    var s3 = n4[t4];
                    g2.push(s3, false);
                  }
                  r2.k[0] == _2 && r2.c ? r2.d = g2 : g2.push(Nd, true);
                } else
                  y2.ondata(null, Nd, true);
              }, terminate: function() {
                g2 && g2.terminate && g2.terminate();
              } };
              v2 >= 0 && (y2.size = v2, y2.originalSize = A2), d2.onfile(y2);
            }
            return "break";
          }
          if (u2) {
            if (134695760 == t3)
              return a2 = o2 += 12 + (-2 == u2 && 8), s2 = 3, d2.c = 0, "break";
            if (33639248 == t3)
              return a2 = o2 -= 4, s2 = 3, d2.c = 0, "break";
          }
        }, d2 = this; o2 < c2 - 4 && "break" !== p2(); ++o2)
          ;
        if (this.p = Nd, u2 < 0) {
          var f2 = s2 ? l2.subarray(0, a2 - 12 - (-2 == u2 && 8) - (134695760 == lf(l2, a2 - 16) && 4)) : l2.subarray(0, o2);
          h2 ? h2.push(f2, !!s2) : this.k[+(2 == s2)].push(f2);
        }
        if (2 & s2)
          return this.push(l2.subarray(o2), t2);
        this.p = l2.subarray(o2);
      }
      if (t2) {
        if (this.c)
          throw "invalid zip file";
        this.p = null;
      }
    }, e2.prototype.register = function(e3) {
      this.o[e3.compression] = e3;
    }, e2;
  }();
  function vm(e2, t2) {
    if ("function" != typeof t2)
      throw "no callback";
    for (var r2 = [], n2 = function() {
      for (var e3 = 0; e3 < r2.length; ++e3)
        r2[e3]();
    }, i2 = {}, s2 = e2.length - 22; 101010256 != lf(e2, s2); --s2)
      if (!s2 || e2.length - s2 > 65558)
        return void t2("invalid zip file", null);
    var o2 = af(e2, s2 + 8);
    o2 || t2(null, {});
    var a2 = o2, l2 = lf(e2, s2 + 16), c2 = 4294967295 == l2;
    if (c2) {
      if (s2 = lf(e2, s2 - 12), 101075792 != lf(e2, s2))
        return void t2("invalid zip file", null);
      a2 = o2 = lf(e2, s2 + 32), l2 = lf(e2, s2 + 48);
    }
    for (var u2 = function(s3) {
      var a3 = nm(e2, l2, c2), u3 = a3[0], h3 = a3[1], p2 = a3[2], d2 = a3[3], f2 = a3[4], m2 = a3[5], _2 = rm(e2, m2);
      l2 = f2;
      var g2 = function(e3, r3) {
        e3 ? (n2(), t2(e3, null)) : (i2[d2] = r3, --o2 || t2(null, i2));
      };
      if (u3)
        if (8 == u3) {
          var v2 = e2.subarray(_2, _2 + h3);
          if (h3 < 32e4)
            try {
              g2(null, Sf(v2, new td(p2)));
            } catch (e3) {
              g2(e3, null);
            }
          else
            r2.push(Ef(v2, { size: p2 }, g2));
        } else
          g2("unknown compression type " + u3, null);
      else
        g2(null, Td(e2, _2, _2 + h3));
    }, h2 = 0; h2 < a2; ++h2)
      u2();
    return n2;
  }
  function Am(e2) {
    for (var t2 = {}, r2 = e2.length - 22; 101010256 != lf(e2, r2); --r2)
      if (!r2 || e2.length - r2 > 65558)
        throw "invalid zip file";
    var n2 = af(e2, r2 + 8);
    if (!n2)
      return {};
    var i2 = lf(e2, r2 + 16), s2 = 4294967295 == i2;
    if (s2) {
      if (r2 = lf(e2, r2 - 12), 101075792 != lf(e2, r2))
        throw "invalid zip file";
      n2 = lf(e2, r2 + 32), i2 = lf(e2, r2 + 48);
    }
    for (var o2 = 0; o2 < n2; ++o2) {
      var a2 = nm(e2, i2, s2), l2 = a2[0], c2 = a2[1], u2 = a2[2], h2 = a2[3], p2 = a2[4], d2 = a2[5], f2 = rm(e2, d2);
      if (i2 = p2, l2) {
        if (8 != l2)
          throw "unknown compression type " + l2;
        t2[h2] = Sf(e2.subarray(f2, f2 + c2), new td(u2));
      } else
        t2[h2] = Td(e2, f2, f2 + c2);
    }
    return t2;
  }
  class bm extends n.yxD {
    constructor(e2) {
      super(e2), this.type = n.cLu;
    }
    parse(e2) {
      const r2 = 65536, i2 = 14, s2 = 65537, o2 = Math.pow(2.7182818, 2.2), a2 = { l: 0, c: 0, lc: 0 };
      function l2(e3, t2, r3, n2, i3) {
        for (; r3 < e3; )
          t2 = t2 << 8 | N2(n2, i3), r3 += 8;
        r3 -= e3, a2.l = t2 >> r3 & (1 << e3) - 1, a2.c = t2, a2.lc = r3;
      }
      const c2 = new Array(59);
      function u2(e3) {
        return 63 & e3;
      }
      function h2(e3) {
        return e3 >> 6;
      }
      const p2 = { c: 0, lc: 0 };
      function d2(e3, t2, r3, n2) {
        e3 = e3 << 8 | N2(r3, n2), t2 += 8, p2.c = e3, p2.lc = t2;
      }
      const f2 = { c: 0, lc: 0 };
      function m2(e3, t2, r3, n2, i3, s3, o3, a3, l3) {
        if (e3 == t2) {
          n2 < 8 && (d2(r3, n2, i3, s3), r3 = p2.c, n2 = p2.lc);
          let e4 = r3 >> (n2 -= 8);
          if (e4 = new Uint8Array([e4])[0], a3.value + e4 > l3)
            return false;
          const t3 = o3[a3.value - 1];
          for (; e4-- > 0; )
            o3[a3.value++] = t3;
        } else {
          if (!(a3.value < l3))
            return false;
          o3[a3.value++] = e3;
        }
        f2.c = r3, f2.lc = n2;
      }
      function _2(e3) {
        return 65535 & e3;
      }
      function g2(e3) {
        const t2 = _2(e3);
        return t2 > 32767 ? t2 - 65536 : t2;
      }
      const v2 = { a: 0, b: 0 };
      function A2(e3, t2) {
        const r3 = g2(e3), n2 = g2(t2), i3 = r3 + (1 & n2) + (n2 >> 1), s3 = i3, o3 = i3 - n2;
        v2.a = s3, v2.b = o3;
      }
      function b2(e3, t2) {
        const r3 = _2(e3), n2 = _2(t2), i3 = r3 - (n2 >> 1) & 65535, s3 = n2 + i3 - 32768 & 65535;
        v2.a = s3, v2.b = i3;
      }
      function y2(e3, t2, r3, n2, i3, s3, o3) {
        const a3 = o3 < 16384, l3 = r3 > i3 ? i3 : r3;
        let c3, u3, h3 = 1;
        for (; h3 <= l3; )
          h3 <<= 1;
        for (h3 >>= 1, c3 = h3, h3 >>= 1; h3 >= 1; ) {
          u3 = 0;
          const o4 = u3 + s3 * (i3 - c3), l4 = s3 * h3, p3 = s3 * c3, d3 = n2 * h3, f3 = n2 * c3;
          let m3, _3, g3, y3;
          for (; u3 <= o4; u3 += p3) {
            let i4 = u3;
            const s4 = u3 + n2 * (r3 - c3);
            for (; i4 <= s4; i4 += f3) {
              const r4 = i4 + d3, n3 = i4 + l4, s5 = n3 + d3;
              a3 ? (A2(e3[i4 + t2], e3[n3 + t2]), m3 = v2.a, g3 = v2.b, A2(e3[r4 + t2], e3[s5 + t2]), _3 = v2.a, y3 = v2.b, A2(m3, _3), e3[i4 + t2] = v2.a, e3[r4 + t2] = v2.b, A2(g3, y3), e3[n3 + t2] = v2.a, e3[s5 + t2] = v2.b) : (b2(e3[i4 + t2], e3[n3 + t2]), m3 = v2.a, g3 = v2.b, b2(e3[r4 + t2], e3[s5 + t2]), _3 = v2.a, y3 = v2.b, b2(m3, _3), e3[i4 + t2] = v2.a, e3[r4 + t2] = v2.b, b2(g3, y3), e3[n3 + t2] = v2.a, e3[s5 + t2] = v2.b);
            }
            if (r3 & h3) {
              const r4 = i4 + l4;
              a3 ? A2(e3[i4 + t2], e3[r4 + t2]) : b2(e3[i4 + t2], e3[r4 + t2]), m3 = v2.a, e3[r4 + t2] = v2.b, e3[i4 + t2] = m3;
            }
          }
          if (i3 & h3) {
            let i4 = u3;
            const s4 = u3 + n2 * (r3 - c3);
            for (; i4 <= s4; i4 += f3) {
              const r4 = i4 + d3;
              a3 ? A2(e3[i4 + t2], e3[r4 + t2]) : b2(e3[i4 + t2], e3[r4 + t2]), m3 = v2.a, e3[r4 + t2] = v2.b, e3[i4 + t2] = m3;
            }
          }
          c3 = h3, h3 >>= 1;
        }
        return u3;
      }
      function x2(e3, t2, r3, n2, o3, _3) {
        const g3 = r3.value, v3 = U2(t2, r3), A3 = U2(t2, r3);
        r3.value += 4;
        const b3 = U2(t2, r3);
        if (r3.value += 4, v3 < 0 || v3 >= s2 || A3 < 0 || A3 >= s2)
          throw new Error("Something wrong with HUF_ENCSIZE");
        const y3 = new Array(s2), x3 = new Array(16384);
        if (function(e4) {
          for (let t3 = 0; t3 < 16384; t3++)
            e4[t3] = {}, e4[t3].len = 0, e4[t3].lit = 0, e4[t3].p = null;
        }(x3), function(e4, t3, r4, n3, i3, o4) {
          const u3 = t3;
          let h3 = 0, p3 = 0;
          for (; n3 <= i3; n3++) {
            if (u3.value - t3.value > r4)
              return false;
            l2(6, h3, p3, e4, u3);
            const s3 = a2.l;
            if (h3 = a2.c, p3 = a2.lc, o4[n3] = s3, 63 == s3) {
              if (u3.value - t3.value > r4)
                throw new Error("Something wrong with hufUnpackEncTable");
              l2(8, h3, p3, e4, u3);
              let s4 = a2.l + 6;
              if (h3 = a2.c, p3 = a2.lc, n3 + s4 > i3 + 1)
                throw new Error("Something wrong with hufUnpackEncTable");
              for (; s4--; )
                o4[n3++] = 0;
              n3--;
            } else if (s3 >= 59) {
              let e5 = s3 - 59 + 2;
              if (n3 + e5 > i3 + 1)
                throw new Error("Something wrong with hufUnpackEncTable");
              for (; e5--; )
                o4[n3++] = 0;
              n3--;
            }
          }
          !function(e5) {
            for (let e6 = 0; e6 <= 58; ++e6)
              c2[e6] = 0;
            for (let t5 = 0; t5 < s2; ++t5)
              c2[e5[t5]] += 1;
            let t4 = 0;
            for (let e6 = 58; e6 > 0; --e6) {
              const r5 = t4 + c2[e6] >> 1;
              c2[e6] = t4, t4 = r5;
            }
            for (let t5 = 0; t5 < s2; ++t5) {
              const r5 = e5[t5];
              r5 > 0 && (e5[t5] = r5 | c2[r5]++ << 6);
            }
          }(o4);
        }(e3, r3, n2 - (r3.value - g3), v3, A3, y3), b3 > 8 * (n2 - (r3.value - g3)))
          throw new Error("Something wrong with hufUncompress");
        !function(e4, t3, r4, n3) {
          for (; t3 <= r4; t3++) {
            const r5 = h2(e4[t3]), s3 = u2(e4[t3]);
            if (r5 >> s3)
              throw new Error("Invalid table entry");
            if (s3 > i2) {
              const e5 = n3[r5 >> s3 - i2];
              if (e5.len)
                throw new Error("Invalid table entry");
              if (e5.lit++, e5.p) {
                const t4 = e5.p;
                e5.p = new Array(e5.lit);
                for (let r6 = 0; r6 < e5.lit - 1; ++r6)
                  e5.p[r6] = t4[r6];
              } else
                e5.p = new Array(1);
              e5.p[e5.lit - 1] = t3;
            } else if (s3) {
              let e5 = 0;
              for (let o4 = 1 << i2 - s3; o4 > 0; o4--) {
                const o5 = n3[(r5 << i2 - s3) + e5];
                if (o5.len || o5.p)
                  throw new Error("Invalid table entry");
                o5.len = s3, o5.lit = t3, e5++;
              }
            }
          }
        }(y3, v3, A3, x3), function(e4, t3, r4, n3, s3, o4, a3, l3, c3) {
          let _4 = 0, g4 = 0;
          const v4 = a3, A4 = Math.trunc(n3.value + (s3 + 7) / 8);
          for (; n3.value < A4; )
            for (d2(_4, g4, r4, n3), _4 = p2.c, g4 = p2.lc; g4 >= i2; ) {
              const s4 = t3[_4 >> g4 - i2 & 16383];
              if (s4.len)
                g4 -= s4.len, m2(s4.lit, o4, _4, g4, r4, n3, l3, c3, v4), _4 = f2.c, g4 = f2.lc;
              else {
                if (!s4.p)
                  throw new Error("hufDecode issues");
                let t4;
                for (t4 = 0; t4 < s4.lit; t4++) {
                  const i3 = u2(e4[s4.p[t4]]);
                  for (; g4 < i3 && n3.value < A4; )
                    d2(_4, g4, r4, n3), _4 = p2.c, g4 = p2.lc;
                  if (g4 >= i3 && h2(e4[s4.p[t4]]) == (_4 >> g4 - i3 & (1 << i3) - 1)) {
                    g4 -= i3, m2(s4.p[t4], o4, _4, g4, r4, n3, l3, c3, v4), _4 = f2.c, g4 = f2.lc;
                    break;
                  }
                }
                if (t4 == s4.lit)
                  throw new Error("hufDecode issues");
              }
            }
          const b4 = 8 - s3 & 7;
          for (_4 >>= b4, g4 -= b4; g4 > 0; ) {
            const e5 = t3[_4 << i2 - g4 & 16383];
            if (!e5.len)
              throw new Error("hufDecode issues");
            g4 -= e5.len, m2(e5.lit, o4, _4, g4, r4, n3, l3, c3, v4), _4 = f2.c, g4 = f2.lc;
          }
        }(y3, x3, e3, r3, b3, A3, _3, o3, { value: 0 });
      }
      function w2(e3) {
        for (let t2 = 1; t2 < e3.length; t2++) {
          const r3 = e3[t2 - 1] + e3[t2] - 128;
          e3[t2] = r3;
        }
      }
      function E2(e3, t2) {
        let r3 = 0, n2 = Math.floor((e3.length + 1) / 2), i3 = 0;
        const s3 = e3.length - 1;
        for (; !(i3 > s3 || (t2[i3++] = e3[r3++], i3 > s3)); )
          t2[i3++] = e3[n2++];
      }
      function S2(e3) {
        let t2 = e3.byteLength;
        const r3 = new Array();
        let n2 = 0;
        const i3 = new DataView(e3);
        for (; t2 > 0; ) {
          const e4 = i3.getInt8(n2++);
          if (e4 < 0) {
            const s3 = -e4;
            t2 -= s3 + 1;
            for (let e5 = 0; e5 < s3; e5++)
              r3.push(i3.getUint8(n2++));
          } else {
            const s3 = e4;
            t2 -= 2;
            const o3 = i3.getUint8(n2++);
            for (let e5 = 0; e5 < s3 + 1; e5++)
              r3.push(o3);
          }
        }
        return r3;
      }
      function C2(e3, t2, r3) {
        let n2, i3 = 1;
        for (; i3 < 64; )
          n2 = t2[e3.value], 65280 == n2 ? i3 = 64 : n2 >> 8 == 255 ? i3 += 255 & n2 : (r3[i3] = n2, i3++), e3.value++;
      }
      function M2(e3) {
        const t2 = 0.5 * Math.cos(0.7853975), r3 = 0.5 * Math.cos(3.14159 / 16), n2 = 0.5 * Math.cos(3.14159 / 8), i3 = 0.5 * Math.cos(3 * 3.14159 / 16), s3 = 0.5 * Math.cos(0.981746875), o3 = 0.5 * Math.cos(3 * 3.14159 / 8), a3 = 0.5 * Math.cos(1.374445625), l3 = new Array(4), c3 = new Array(4), u3 = new Array(4), h3 = new Array(4);
        for (let p3 = 0; p3 < 8; ++p3) {
          const d3 = 8 * p3;
          l3[0] = n2 * e3[d3 + 2], l3[1] = o3 * e3[d3 + 2], l3[2] = n2 * e3[d3 + 6], l3[3] = o3 * e3[d3 + 6], c3[0] = r3 * e3[d3 + 1] + i3 * e3[d3 + 3] + s3 * e3[d3 + 5] + a3 * e3[d3 + 7], c3[1] = i3 * e3[d3 + 1] - a3 * e3[d3 + 3] - r3 * e3[d3 + 5] - s3 * e3[d3 + 7], c3[2] = s3 * e3[d3 + 1] - r3 * e3[d3 + 3] + a3 * e3[d3 + 5] + i3 * e3[d3 + 7], c3[3] = a3 * e3[d3 + 1] - s3 * e3[d3 + 3] + i3 * e3[d3 + 5] - r3 * e3[d3 + 7], u3[0] = t2 * (e3[d3 + 0] + e3[d3 + 4]), u3[3] = t2 * (e3[d3 + 0] - e3[d3 + 4]), u3[1] = l3[0] + l3[3], u3[2] = l3[1] - l3[2], h3[0] = u3[0] + u3[1], h3[1] = u3[3] + u3[2], h3[2] = u3[3] - u3[2], h3[3] = u3[0] - u3[1], e3[d3 + 0] = h3[0] + c3[0], e3[d3 + 1] = h3[1] + c3[1], e3[d3 + 2] = h3[2] + c3[2], e3[d3 + 3] = h3[3] + c3[3], e3[d3 + 4] = h3[3] - c3[3], e3[d3 + 5] = h3[2] - c3[2], e3[d3 + 6] = h3[1] - c3[1], e3[d3 + 7] = h3[0] - c3[0];
        }
        for (let p3 = 0; p3 < 8; ++p3)
          l3[0] = n2 * e3[16 + p3], l3[1] = o3 * e3[16 + p3], l3[2] = n2 * e3[48 + p3], l3[3] = o3 * e3[48 + p3], c3[0] = r3 * e3[8 + p3] + i3 * e3[24 + p3] + s3 * e3[40 + p3] + a3 * e3[56 + p3], c3[1] = i3 * e3[8 + p3] - a3 * e3[24 + p3] - r3 * e3[40 + p3] - s3 * e3[56 + p3], c3[2] = s3 * e3[8 + p3] - r3 * e3[24 + p3] + a3 * e3[40 + p3] + i3 * e3[56 + p3], c3[3] = a3 * e3[8 + p3] - s3 * e3[24 + p3] + i3 * e3[40 + p3] - r3 * e3[56 + p3], u3[0] = t2 * (e3[p3] + e3[32 + p3]), u3[3] = t2 * (e3[p3] - e3[32 + p3]), u3[1] = l3[0] + l3[3], u3[2] = l3[1] - l3[2], h3[0] = u3[0] + u3[1], h3[1] = u3[3] + u3[2], h3[2] = u3[3] - u3[2], h3[3] = u3[0] - u3[1], e3[0 + p3] = h3[0] + c3[0], e3[8 + p3] = h3[1] + c3[1], e3[16 + p3] = h3[2] + c3[2], e3[24 + p3] = h3[3] + c3[3], e3[32 + p3] = h3[3] - c3[3], e3[40 + p3] = h3[2] - c3[2], e3[48 + p3] = h3[1] - c3[1], e3[56 + p3] = h3[0] - c3[0];
      }
      function T2(e3) {
        for (let t2 = 0; t2 < 64; ++t2) {
          const r3 = e3[0][t2], n2 = e3[1][t2], i3 = e3[2][t2];
          e3[0][t2] = r3 + 1.5747 * i3, e3[1][t2] = r3 - 0.1873 * n2 - 0.4682 * i3, e3[2][t2] = r3 + 1.8556 * n2;
        }
      }
      function I2(e3, t2, r3) {
        for (let s3 = 0; s3 < 64; ++s3)
          t2[r3 + s3] = n.A5E.toHalfFloat((i3 = e3[s3]) <= 1 ? Math.sign(i3) * Math.pow(Math.abs(i3), 2.2) : Math.sign(i3) * Math.pow(o2, Math.abs(i3) - 1));
        var i3;
      }
      function k2(e3) {
        return new DataView(e3.array.buffer, e3.offset.value, e3.size);
      }
      function D2(e3) {
        const t2 = e3.viewer.buffer.slice(e3.offset.value, e3.offset.value + e3.size), r3 = new Uint8Array(S2(t2)), n2 = new Uint8Array(r3.length);
        return w2(r3), E2(r3, n2), new DataView(n2.buffer);
      }
      function P2(e3) {
        const r3 = e3.array.slice(e3.offset.value, e3.offset.value + e3.size);
        void 0 === t && console.error("THREE.EXRLoader: External library fflate.min.js required.");
        const n2 = zf(r3), i3 = new Uint8Array(n2.length);
        return w2(n2), E2(n2, i3), new DataView(i3.buffer);
      }
      function B2(e3) {
        const t2 = e3.viewer, n2 = { value: e3.offset.value }, i3 = new Uint16Array(e3.width * e3.scanlineBlockSize * (e3.channels * e3.type)), s3 = new Uint8Array(8192);
        let o3 = 0;
        const a3 = new Array(e3.channels);
        for (let t3 = 0; t3 < e3.channels; t3++)
          a3[t3] = {}, a3[t3].start = o3, a3[t3].end = a3[t3].start, a3[t3].nx = e3.width, a3[t3].ny = e3.lines, a3[t3].size = e3.type, o3 += a3[t3].nx * a3[t3].ny * a3[t3].size;
        const l3 = H2(t2, n2), c3 = H2(t2, n2);
        if (c3 >= 8192)
          throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
        if (l3 <= c3)
          for (let e4 = 0; e4 < c3 - l3 + 1; e4++)
            s3[e4 + l3] = j2(t2, n2);
        const u3 = new Uint16Array(r2), h3 = function(e4, t3) {
          let n3 = 0;
          for (let i5 = 0; i5 < r2; ++i5)
            (0 == i5 || e4[i5 >> 3] & 1 << (7 & i5)) && (t3[n3++] = i5);
          const i4 = n3 - 1;
          for (; n3 < r2; )
            t3[n3++] = 0;
          return i4;
        }(s3, u3), p3 = U2(t2, n2);
        x2(e3.array, t2, n2, p3, i3, o3);
        for (let t3 = 0; t3 < e3.channels; ++t3) {
          const e4 = a3[t3];
          for (let r3 = 0; r3 < a3[t3].size; ++r3)
            y2(i3, e4.start + r3, e4.nx, e4.size, e4.ny, e4.nx * e4.size, h3);
        }
        !function(e4, t3, r3) {
          for (let n3 = 0; n3 < r3; ++n3)
            t3[n3] = e4[t3[n3]];
        }(u3, i3, o3);
        let d3 = 0;
        const f3 = new Uint8Array(i3.buffer.byteLength);
        for (let t3 = 0; t3 < e3.lines; t3++)
          for (let t4 = 0; t4 < e3.channels; t4++) {
            const e4 = a3[t4], r3 = e4.nx * e4.size, n3 = new Uint8Array(i3.buffer, 2 * e4.end, 2 * r3);
            f3.set(n3, d3), d3 += 2 * r3, e4.end += r3;
          }
        return new DataView(f3.buffer);
      }
      function R2(e3) {
        const r3 = e3.array.slice(e3.offset.value, e3.offset.value + e3.size);
        void 0 === t && console.error("THREE.EXRLoader: External library fflate.min.js required.");
        const n2 = zf(r3), i3 = e3.lines * e3.channels * e3.width, s3 = 1 == e3.type ? new Uint16Array(i3) : new Uint32Array(i3);
        let o3 = 0, a3 = 0;
        const l3 = new Array(4);
        for (let t2 = 0; t2 < e3.lines; t2++)
          for (let t3 = 0; t3 < e3.channels; t3++) {
            let t4 = 0;
            switch (e3.type) {
              case 1:
                l3[0] = o3, l3[1] = l3[0] + e3.width, o3 = l3[1] + e3.width;
                for (let r4 = 0; r4 < e3.width; ++r4)
                  t4 += n2[l3[0]++] << 8 | n2[l3[1]++], s3[a3] = t4, a3++;
                break;
              case 2:
                l3[0] = o3, l3[1] = l3[0] + e3.width, l3[2] = l3[1] + e3.width, o3 = l3[2] + e3.width;
                for (let r4 = 0; r4 < e3.width; ++r4)
                  t4 += n2[l3[0]++] << 24 | n2[l3[1]++] << 16 | n2[l3[2]++] << 8, s3[a3] = t4, a3++;
            }
          }
        return new DataView(s3.buffer);
      }
      function L2(e3) {
        const t2 = e3.viewer, r3 = { value: e3.offset.value }, n2 = new Uint8Array(e3.width * e3.lines * (e3.channels * e3.type * 2)), i3 = { version: z2(t2, r3), unknownUncompressedSize: z2(t2, r3), unknownCompressedSize: z2(t2, r3), acCompressedSize: z2(t2, r3), dcCompressedSize: z2(t2, r3), rleCompressedSize: z2(t2, r3), rleUncompressedSize: z2(t2, r3), rleRawSize: z2(t2, r3), totalAcUncompressedCount: z2(t2, r3), totalDcUncompressedCount: z2(t2, r3), acCompression: z2(t2, r3) };
        if (i3.version < 2)
          throw new Error("EXRLoader.parse: " + J2.compression + " version " + i3.version + " is unsupported");
        const s3 = new Array();
        let o3 = H2(t2, r3) - 2;
        for (; o3 > 0; ) {
          const e4 = O2(t2.buffer, r3), n3 = j2(t2, r3), i4 = n3 >> 2 & 3, a4 = new Int8Array([(n3 >> 4) - 1])[0], l4 = j2(t2, r3);
          s3.push({ name: e4, index: a4, type: l4, compression: i4 }), o3 -= e4.length + 3;
        }
        const a3 = J2.channels, l3 = new Array(e3.channels);
        for (let t3 = 0; t3 < e3.channels; ++t3) {
          const r4 = l3[t3] = {}, n3 = a3[t3];
          r4.name = n3.name, r4.compression = 0, r4.decoded = false, r4.type = n3.pixelType, r4.pLinear = n3.pLinear, r4.width = e3.width, r4.height = e3.lines;
        }
        const c3 = { idx: new Array(3) };
        for (let t3 = 0; t3 < e3.channels; ++t3) {
          const e4 = l3[t3];
          for (let r4 = 0; r4 < s3.length; ++r4) {
            const n3 = s3[r4];
            e4.name == n3.name && (e4.compression = n3.compression, n3.index >= 0 && (c3.idx[n3.index] = t3), e4.offset = t3);
          }
        }
        let u3, h3, p3;
        if (i3.acCompressedSize > 0)
          switch (i3.acCompression) {
            case 0:
              u3 = new Uint16Array(i3.totalAcUncompressedCount), x2(e3.array, t2, r3, i3.acCompressedSize, u3, i3.totalAcUncompressedCount);
              break;
            case 1:
              const n3 = zf(e3.array.slice(r3.value, r3.value + i3.totalAcUncompressedCount));
              u3 = new Uint16Array(n3.buffer), r3.value += i3.totalAcUncompressedCount;
          }
        if (i3.dcCompressedSize > 0) {
          const t3 = { array: e3.array, offset: r3, size: i3.dcCompressedSize };
          h3 = new Uint16Array(P2(t3).buffer), r3.value += i3.dcCompressedSize;
        }
        i3.rleRawSize > 0 && (p3 = S2(zf(e3.array.slice(r3.value, r3.value + i3.rleCompressedSize)).buffer), r3.value += i3.rleCompressedSize);
        let d3 = 0;
        const f3 = new Array(l3.length);
        for (let e4 = 0; e4 < f3.length; ++e4)
          f3[e4] = new Array();
        for (let t3 = 0; t3 < e3.lines; ++t3)
          for (let t4 = 0; t4 < l3.length; ++t4)
            f3[t4].push(d3), d3 += l3[t4].width * e3.type * 2;
        !function(e4, t3, r4, n3, i4, s4) {
          let o4 = new DataView(s4.buffer);
          const a4 = r4[e4.idx[0]].width, l4 = r4[e4.idx[0]].height, c4 = Math.floor(a4 / 8), u4 = Math.ceil(a4 / 8), h4 = Math.ceil(l4 / 8), p4 = a4 - 8 * (u4 - 1), d4 = l4 - 8 * (h4 - 1), f4 = { value: 0 }, m3 = new Array(3), _3 = new Array(3), g3 = new Array(3), v3 = new Array(3), A3 = new Array(3);
          for (let r5 = 0; r5 < 3; ++r5)
            A3[r5] = t3[e4.idx[r5]], m3[r5] = r5 < 1 ? 0 : m3[r5 - 1] + u4 * h4, _3[r5] = new Float32Array(64), g3[r5] = new Uint16Array(64), v3[r5] = new Uint16Array(64 * u4);
          for (let t4 = 0; t4 < h4; ++t4) {
            let s5 = 8;
            t4 == h4 - 1 && (s5 = d4);
            let a5 = 8;
            for (let e5 = 0; e5 < u4; ++e5) {
              e5 == u4 - 1 && (a5 = p4);
              for (let e6 = 0; e6 < 3; ++e6)
                g3[e6].fill(0), g3[e6][0] = i4[m3[e6]++], C2(f4, n3, g3[e6]), b3 = g3[e6], (y3 = _3[e6])[0] = Q2(b3[0]), y3[1] = Q2(b3[1]), y3[2] = Q2(b3[5]), y3[3] = Q2(b3[6]), y3[4] = Q2(b3[14]), y3[5] = Q2(b3[15]), y3[6] = Q2(b3[27]), y3[7] = Q2(b3[28]), y3[8] = Q2(b3[2]), y3[9] = Q2(b3[4]), y3[10] = Q2(b3[7]), y3[11] = Q2(b3[13]), y3[12] = Q2(b3[16]), y3[13] = Q2(b3[26]), y3[14] = Q2(b3[29]), y3[15] = Q2(b3[42]), y3[16] = Q2(b3[3]), y3[17] = Q2(b3[8]), y3[18] = Q2(b3[12]), y3[19] = Q2(b3[17]), y3[20] = Q2(b3[25]), y3[21] = Q2(b3[30]), y3[22] = Q2(b3[41]), y3[23] = Q2(b3[43]), y3[24] = Q2(b3[9]), y3[25] = Q2(b3[11]), y3[26] = Q2(b3[18]), y3[27] = Q2(b3[24]), y3[28] = Q2(b3[31]), y3[29] = Q2(b3[40]), y3[30] = Q2(b3[44]), y3[31] = Q2(b3[53]), y3[32] = Q2(b3[10]), y3[33] = Q2(b3[19]), y3[34] = Q2(b3[23]), y3[35] = Q2(b3[32]), y3[36] = Q2(b3[39]), y3[37] = Q2(b3[45]), y3[38] = Q2(b3[52]), y3[39] = Q2(b3[54]), y3[40] = Q2(b3[20]), y3[41] = Q2(b3[22]), y3[42] = Q2(b3[33]), y3[43] = Q2(b3[38]), y3[44] = Q2(b3[46]), y3[45] = Q2(b3[51]), y3[46] = Q2(b3[55]), y3[47] = Q2(b3[60]), y3[48] = Q2(b3[21]), y3[49] = Q2(b3[34]), y3[50] = Q2(b3[37]), y3[51] = Q2(b3[47]), y3[52] = Q2(b3[50]), y3[53] = Q2(b3[56]), y3[54] = Q2(b3[59]), y3[55] = Q2(b3[61]), y3[56] = Q2(b3[35]), y3[57] = Q2(b3[36]), y3[58] = Q2(b3[48]), y3[59] = Q2(b3[49]), y3[60] = Q2(b3[57]), y3[61] = Q2(b3[58]), y3[62] = Q2(b3[62]), y3[63] = Q2(b3[63]), M2(_3[e6]);
              T2(_3);
              for (let t5 = 0; t5 < 3; ++t5)
                I2(_3[t5], v3[t5], 64 * e5);
            }
            let l5 = 0;
            for (let n4 = 0; n4 < 3; ++n4) {
              const i5 = r4[e4.idx[n4]].type;
              for (let e5 = 8 * t4; e5 < 8 * t4 + s5; ++e5) {
                l5 = A3[n4][e5];
                for (let t5 = 0; t5 < c4; ++t5) {
                  const r5 = 64 * t5 + 8 * (7 & e5);
                  o4.setUint16(l5 + 0 * i5, v3[n4][r5 + 0], true), o4.setUint16(l5 + 2 * i5, v3[n4][r5 + 1], true), o4.setUint16(l5 + 4 * i5, v3[n4][r5 + 2], true), o4.setUint16(l5 + 6 * i5, v3[n4][r5 + 3], true), o4.setUint16(l5 + 8 * i5, v3[n4][r5 + 4], true), o4.setUint16(l5 + 10 * i5, v3[n4][r5 + 5], true), o4.setUint16(l5 + 12 * i5, v3[n4][r5 + 6], true), o4.setUint16(l5 + 14 * i5, v3[n4][r5 + 7], true), l5 += 16 * i5;
                }
              }
              if (c4 != u4)
                for (let e5 = 8 * t4; e5 < 8 * t4 + s5; ++e5) {
                  const t5 = A3[n4][e5] + 8 * c4 * 2 * i5, r5 = 64 * c4 + 8 * (7 & e5);
                  for (let e6 = 0; e6 < a5; ++e6)
                    o4.setUint16(t5 + 2 * e6 * i5, v3[n4][r5 + e6], true);
                }
            }
          }
          var b3, y3;
          const x3 = new Uint16Array(a4);
          o4 = new DataView(s4.buffer);
          for (let t4 = 0; t4 < 3; ++t4) {
            r4[e4.idx[t4]].decoded = true;
            const n4 = r4[e4.idx[t4]].type;
            if (2 == r4[t4].type)
              for (let e5 = 0; e5 < l4; ++e5) {
                const r5 = A3[t4][e5];
                for (let e6 = 0; e6 < a4; ++e6)
                  x3[e6] = o4.getUint16(r5 + 2 * e6 * n4, true);
                for (let e6 = 0; e6 < a4; ++e6)
                  o4.setFloat32(r5 + 2 * e6 * n4, Q2(x3[e6]), true);
              }
          }
        }(c3, f3, l3, u3, h3, n2);
        for (let t3 = 0; t3 < l3.length; ++t3) {
          const r4 = l3[t3];
          if (!r4.decoded) {
            if (2 !== r4.compression)
              throw new Error("EXRLoader.parse: unsupported channel compression");
            {
              let i4 = 0, s4 = 0;
              for (let o4 = 0; o4 < e3.lines; ++o4) {
                let e4 = f3[t3][i4];
                for (let t4 = 0; t4 < r4.width; ++t4) {
                  for (let t5 = 0; t5 < 2 * r4.type; ++t5)
                    n2[e4++] = p3[s4 + t5 * r4.width * r4.height];
                  s4++;
                }
                i4++;
              }
            }
          }
        }
        return new DataView(n2.buffer);
      }
      function O2(e3, t2) {
        const r3 = new Uint8Array(e3);
        let n2 = 0;
        for (; 0 != r3[t2.value + n2]; )
          n2 += 1;
        const i3 = new TextDecoder().decode(r3.slice(t2.value, t2.value + n2));
        return t2.value = t2.value + n2 + 1, i3;
      }
      function F2(e3, t2) {
        const r3 = e3.getInt32(t2.value, true);
        return t2.value = t2.value + 4, r3;
      }
      function U2(e3, t2) {
        const r3 = e3.getUint32(t2.value, true);
        return t2.value = t2.value + 4, r3;
      }
      function N2(e3, t2) {
        const r3 = e3[t2.value];
        return t2.value = t2.value + 1, r3;
      }
      function j2(e3, t2) {
        const r3 = e3.getUint8(t2.value);
        return t2.value = t2.value + 1, r3;
      }
      const z2 = function(e3, t2) {
        const r3 = Number(e3.getBigInt64(t2.value, true));
        return t2.value += 8, r3;
      };
      function G2(e3, t2) {
        const r3 = e3.getFloat32(t2.value, true);
        return t2.value += 4, r3;
      }
      function V2(e3, t2) {
        return n.A5E.toHalfFloat(G2(e3, t2));
      }
      function Q2(e3) {
        const t2 = (31744 & e3) >> 10, r3 = 1023 & e3;
        return (e3 >> 15 ? -1 : 1) * (t2 ? 31 === t2 ? r3 ? NaN : 1 / 0 : Math.pow(2, t2 - 15) * (1 + r3 / 1024) : r3 / 1024 * 6103515625e-14);
      }
      function H2(e3, t2) {
        const r3 = e3.getUint16(t2.value, true);
        return t2.value += 2, r3;
      }
      function W2(e3, t2) {
        return Q2(H2(e3, t2));
      }
      function q2(e3, t2, r3, n2, i3) {
        return "string" === n2 || "stringvector" === n2 || "iccProfile" === n2 ? function(e4, t3, r4) {
          const n3 = new TextDecoder().decode(new Uint8Array(e4).slice(t3.value, t3.value + r4));
          return t3.value = t3.value + r4, n3;
        }(t2, r3, i3) : "chlist" === n2 ? function(e4, t3, r4, n3) {
          const i4 = r4.value, s3 = [];
          for (; r4.value < i4 + n3 - 1; ) {
            const n4 = O2(t3, r4), i5 = F2(e4, r4), o3 = j2(e4, r4);
            r4.value += 3;
            const a3 = F2(e4, r4), l3 = F2(e4, r4);
            s3.push({ name: n4, pixelType: i5, pLinear: o3, xSampling: a3, ySampling: l3 });
          }
          return r4.value += 1, s3;
        }(e3, t2, r3, i3) : "chromaticities" === n2 ? function(e4, t3) {
          return { redX: G2(e4, t3), redY: G2(e4, t3), greenX: G2(e4, t3), greenY: G2(e4, t3), blueX: G2(e4, t3), blueY: G2(e4, t3), whiteX: G2(e4, t3), whiteY: G2(e4, t3) };
        }(e3, r3) : "compression" === n2 ? function(e4, t3) {
          return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][j2(e4, t3)];
        }(e3, r3) : "box2i" === n2 ? function(e4, t3) {
          return { xMin: U2(e4, t3), yMin: U2(e4, t3), xMax: U2(e4, t3), yMax: U2(e4, t3) };
        }(e3, r3) : "lineOrder" === n2 ? function(e4, t3) {
          return ["INCREASING_Y"][j2(e4, t3)];
        }(e3, r3) : "float" === n2 ? G2(e3, r3) : "v2f" === n2 ? function(e4, t3) {
          return [G2(e4, t3), G2(e4, t3)];
        }(e3, r3) : "v3f" === n2 ? function(e4, t3) {
          return [G2(e4, t3), G2(e4, t3), G2(e4, t3)];
        }(e3, r3) : "int" === n2 ? F2(e3, r3) : "rational" === n2 ? function(e4, t3) {
          return [F2(e4, t3), U2(e4, t3)];
        }(e3, r3) : "timecode" === n2 ? function(e4, t3) {
          return [U2(e4, t3), U2(e4, t3)];
        }(e3, r3) : "preview" === n2 ? (r3.value += i3, "skipped") : void (r3.value += i3);
      }
      const X2 = new DataView(e2), Y2 = new Uint8Array(e2), K2 = { value: 0 }, J2 = function(e3, t2, r3) {
        const n2 = {};
        if (20000630 != e3.getUint32(0, true))
          throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.");
        n2.version = e3.getUint8(4);
        const i3 = e3.getUint8(5);
        n2.spec = { singleTile: !!(2 & i3), longName: !!(4 & i3), deepFormat: !!(8 & i3), multiPart: !!(16 & i3) }, r3.value = 8;
        let s3 = true;
        for (; s3; ) {
          const i4 = O2(t2, r3);
          if (0 == i4)
            s3 = false;
          else {
            const s4 = O2(t2, r3), o3 = q2(e3, t2, r3, s4, U2(e3, r3));
            void 0 === o3 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${s4}'.`) : n2[i4] = o3;
          }
        }
        if (0 != (-5 & i3))
          throw console.error("EXRHeader:", n2), new Error("THREE.EXRLoader: provided file is currently unsupported.");
        return n2;
      }(X2, e2, K2), Z2 = function(e3, t2, r3, i3, s3) {
        const o3 = { size: 0, viewer: t2, array: r3, offset: i3, width: e3.dataWindow.xMax - e3.dataWindow.xMin + 1, height: e3.dataWindow.yMax - e3.dataWindow.yMin + 1, channels: e3.channels.length, bytesPerLine: null, lines: null, inputSize: null, type: e3.channels[0].pixelType, uncompress: null, getter: null, format: null, encoding: null };
        switch (e3.compression) {
          case "NO_COMPRESSION":
            o3.lines = 1, o3.uncompress = k2;
            break;
          case "RLE_COMPRESSION":
            o3.lines = 1, o3.uncompress = D2;
            break;
          case "ZIPS_COMPRESSION":
            o3.lines = 1, o3.uncompress = P2;
            break;
          case "ZIP_COMPRESSION":
            o3.lines = 16, o3.uncompress = P2;
            break;
          case "PIZ_COMPRESSION":
            o3.lines = 32, o3.uncompress = B2;
            break;
          case "PXR24_COMPRESSION":
            o3.lines = 16, o3.uncompress = R2;
            break;
          case "DWAA_COMPRESSION":
            o3.lines = 32, o3.uncompress = L2;
            break;
          case "DWAB_COMPRESSION":
            o3.lines = 256, o3.uncompress = L2;
            break;
          default:
            throw new Error("EXRLoader.parse: " + e3.compression + " is unsupported");
        }
        if (o3.scanlineBlockSize = o3.lines, 1 == o3.type)
          switch (s3) {
            case n.VzW:
              o3.getter = W2, o3.inputSize = 2;
              break;
            case n.cLu:
              o3.getter = H2, o3.inputSize = 2;
          }
        else {
          if (2 != o3.type)
            throw new Error("EXRLoader.parse: unsupported pixelType " + o3.type + " for " + e3.compression + ".");
          switch (s3) {
            case n.VzW:
              o3.getter = G2, o3.inputSize = 4;
              break;
            case n.cLu:
              o3.getter = V2, o3.inputSize = 4;
          }
        }
        o3.blockCount = (e3.dataWindow.yMax + 1) / o3.scanlineBlockSize;
        for (let e4 = 0; e4 < o3.blockCount; e4++)
          z2(t2, i3);
        o3.outputChannels = 3 == o3.channels ? 4 : o3.channels;
        const a3 = o3.width * o3.height * o3.outputChannels;
        switch (s3) {
          case n.VzW:
            o3.byteArray = new Float32Array(a3), o3.channels < o3.outputChannels && o3.byteArray.fill(1, 0, a3);
            break;
          case n.cLu:
            o3.byteArray = new Uint16Array(a3), o3.channels < o3.outputChannels && o3.byteArray.fill(15360, 0, a3);
            break;
          default:
            console.error("THREE.EXRLoader: unsupported type: ", s3);
        }
        return o3.bytesPerLine = o3.width * o3.inputSize * o3.channels, 4 == o3.outputChannels ? (o3.format = n.wk1, o3.encoding = n.rnI) : (o3.format = n.hEm, o3.encoding = n.rnI), o3;
      }(J2, X2, Y2, K2, this.type), $2 = { value: 0 }, ee2 = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
      for (let e3 = 0; e3 < Z2.height / Z2.scanlineBlockSize; e3++) {
        const t2 = U2(X2, K2);
        Z2.size = U2(X2, K2), Z2.lines = t2 + Z2.scanlineBlockSize > Z2.height ? Z2.height - t2 : Z2.scanlineBlockSize;
        const r3 = Z2.size < Z2.lines * Z2.bytesPerLine ? Z2.uncompress(Z2) : k2(Z2);
        K2.value += Z2.size;
        for (let t3 = 0; t3 < Z2.scanlineBlockSize; t3++) {
          const n2 = t3 + e3 * Z2.scanlineBlockSize;
          if (n2 >= Z2.height)
            break;
          for (let e4 = 0; e4 < Z2.channels; e4++) {
            const i3 = ee2[J2.channels[e4].name];
            for (let s3 = 0; s3 < Z2.width; s3++) {
              $2.value = (t3 * (Z2.channels * Z2.width) + e4 * Z2.width + s3) * Z2.inputSize;
              const o3 = (Z2.height - 1 - n2) * (Z2.width * Z2.outputChannels) + s3 * Z2.outputChannels + i3;
              Z2.byteArray[o3] = Z2.getter(r3, $2);
            }
          }
        }
      }
      return { header: J2, width: Z2.width, height: Z2.height, data: Z2.byteArray, format: Z2.format, encoding: Z2.encoding, type: this.type };
    }
    setDataType(e2) {
      return this.type = e2, this;
    }
    load(e2, t2, r2, i2) {
      return super.load(e2, function(e3, r3) {
        e3.encoding = r3.encoding, e3.minFilter = n.wem, e3.magFilter = n.wem, e3.generateMipmaps = false, e3.flipY = false, t2 && t2(e3, r3);
      }, r2, i2);
    }
  }
  class ym extends r {
    constructor() {
      super(...arguments), this.dependencies = [to];
    }
    async onAdded(e2) {
      this._importer || (this._importer = new ir(class extends bm {
        constructor(t2) {
          super(t2), this.setDataType(Zs(e2.renderer.rendererObject));
        }
      }, ["exr"], false)), Js.Importers.push(this._importer);
    }
    async onDispose(e2) {
      this._importer = void 0;
    }
    async onRemove(e2) {
      this._importer && Js.Importers.splice(Js.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }
  }
  function xm(e2, t2, r2) {
    const n2 = r2.length - e2 - 1;
    if (t2 >= r2[n2])
      return n2 - 1;
    if (t2 <= r2[e2])
      return e2;
    let i2 = e2, s2 = n2, o2 = Math.floor((i2 + s2) / 2);
    for (; t2 < r2[o2] || t2 >= r2[o2 + 1]; )
      t2 < r2[o2] ? s2 = o2 : i2 = o2, o2 = Math.floor((i2 + s2) / 2);
    return o2;
  }
  function wm(e2, t2) {
    let r2 = 1;
    for (let t3 = 2; t3 <= e2; ++t3)
      r2 *= t3;
    let n2 = 1;
    for (let e3 = 2; e3 <= t2; ++e3)
      n2 *= e3;
    for (let r3 = 2; r3 <= e2 - t2; ++r3)
      n2 *= r3;
    return r2 / n2;
  }
  ym.PluginType = "EXRLoadPlugin";
  class Em extends n.Hyl {
    constructor(e2, t2, r2, i2, s2) {
      super(), this.degree = e2, this.knots = t2, this.controlPoints = [], this.startKnot = i2 || 0, this.endKnot = s2 || this.knots.length - 1;
      for (let e3 = 0; e3 < r2.length; ++e3) {
        const t3 = r2[e3];
        this.controlPoints[e3] = new n.Ltg(t3.x, t3.y, t3.z, t3.w);
      }
    }
    getPoint(e2, t2 = new n.Pa4()) {
      const r2 = t2, i2 = this.knots[this.startKnot] + e2 * (this.knots[this.endKnot] - this.knots[this.startKnot]), s2 = function(e3, t3, r3, i3) {
        const s3 = xm(e3, i3, t3), o2 = function(e4, t4, r4, n2) {
          const i4 = [], s4 = [], o3 = [];
          i4[0] = 1;
          for (let a3 = 1; a3 <= r4; ++a3) {
            s4[a3] = t4 - n2[e4 + 1 - a3], o3[a3] = n2[e4 + a3] - t4;
            let r5 = 0;
            for (let e5 = 0; e5 < a3; ++e5) {
              const t5 = o3[e5 + 1], n3 = s4[a3 - e5], l2 = i4[e5] / (t5 + n3);
              i4[e5] = r5 + t5 * l2, r5 = n3 * l2;
            }
            i4[a3] = r5;
          }
          return i4;
        }(s3, i3, e3, t3), a2 = new n.Ltg(0, 0, 0, 0);
        for (let t4 = 0; t4 <= e3; ++t4) {
          const n2 = r3[s3 - e3 + t4], i4 = o2[t4], l2 = n2.w * i4;
          a2.x += n2.x * l2, a2.y += n2.y * l2, a2.z += n2.z * l2, a2.w += n2.w * i4;
        }
        return a2;
      }(this.degree, this.knots, this.controlPoints, i2);
      return 1 !== s2.w && s2.divideScalar(s2.w), r2.set(s2.x, s2.y, s2.z);
    }
    getTangent(e2, t2 = new n.Pa4()) {
      const r2 = t2, i2 = this.knots[0] + e2 * (this.knots[this.knots.length - 1] - this.knots[0]), s2 = function(e3, t3, r3, i3, s3) {
        const o2 = function(e4, t4, r4, i4, s4) {
          const o3 = s4 < e4 ? s4 : e4, a2 = [], l2 = xm(e4, i4, t4), c2 = function(e5, t5, r5, n2, i5) {
            const s5 = [];
            for (let e6 = 0; e6 <= r5; ++e6)
              s5[e6] = 0;
            const o4 = [];
            for (let e6 = 0; e6 <= n2; ++e6)
              o4[e6] = s5.slice(0);
            const a3 = [];
            for (let e6 = 0; e6 <= r5; ++e6)
              a3[e6] = s5.slice(0);
            a3[0][0] = 1;
            const l3 = s5.slice(0), c3 = s5.slice(0);
            for (let n3 = 1; n3 <= r5; ++n3) {
              l3[n3] = t5 - i5[e5 + 1 - n3], c3[n3] = i5[e5 + n3] - t5;
              let r6 = 0;
              for (let e6 = 0; e6 < n3; ++e6) {
                const t6 = c3[e6 + 1], i6 = l3[n3 - e6];
                a3[n3][e6] = t6 + i6;
                const s6 = a3[e6][n3 - 1] / a3[n3][e6];
                a3[e6][n3] = r6 + t6 * s6, r6 = i6 * s6;
              }
              a3[n3][n3] = r6;
            }
            for (let e6 = 0; e6 <= r5; ++e6)
              o4[0][e6] = a3[e6][r5];
            for (let e6 = 0; e6 <= r5; ++e6) {
              let t6 = 0, i6 = 1;
              const l4 = [];
              for (let e7 = 0; e7 <= r5; ++e7)
                l4[e7] = s5.slice(0);
              l4[0][0] = 1;
              for (let s6 = 1; s6 <= n2; ++s6) {
                let n3 = 0;
                const c4 = e6 - s6, u4 = r5 - s6;
                e6 >= s6 && (l4[i6][0] = l4[t6][0] / a3[u4 + 1][c4], n3 = l4[i6][0] * a3[c4][u4]);
                const h2 = e6 - 1 <= u4 ? s6 - 1 : r5 - e6;
                for (let e7 = c4 >= -1 ? 1 : -c4; e7 <= h2; ++e7)
                  l4[i6][e7] = (l4[t6][e7] - l4[t6][e7 - 1]) / a3[u4 + 1][c4 + e7], n3 += l4[i6][e7] * a3[c4 + e7][u4];
                e6 <= u4 && (l4[i6][s6] = -l4[t6][s6 - 1] / a3[u4 + 1][e6], n3 += l4[i6][s6] * a3[e6][u4]), o4[s6][e6] = n3;
                const p2 = t6;
                t6 = i6, i6 = p2;
              }
            }
            let u3 = r5;
            for (let e6 = 1; e6 <= n2; ++e6) {
              for (let t6 = 0; t6 <= r5; ++t6)
                o4[e6][t6] *= u3;
              u3 *= r5 - e6;
            }
            return o4;
          }(l2, i4, e4, o3, t4), u2 = [];
          for (let e5 = 0; e5 < r4.length; ++e5) {
            const t5 = r4[e5].clone(), n2 = t5.w;
            t5.x *= n2, t5.y *= n2, t5.z *= n2, u2[e5] = t5;
          }
          for (let t5 = 0; t5 <= o3; ++t5) {
            const r5 = u2[l2 - e4].clone().multiplyScalar(c2[t5][0]);
            for (let n2 = 1; n2 <= e4; ++n2)
              r5.add(u2[l2 - e4 + n2].clone().multiplyScalar(c2[t5][n2]));
            a2[t5] = r5;
          }
          for (let e5 = o3 + 1; e5 <= s4 + 1; ++e5)
            a2[e5] = new n.Ltg(0, 0, 0);
          return a2;
        }(e3, t3, r3, i3, s3);
        return function(e4) {
          const t4 = e4.length, r4 = [], i4 = [];
          for (let s5 = 0; s5 < t4; ++s5) {
            const t5 = e4[s5];
            r4[s5] = new n.Pa4(t5.x, t5.y, t5.z), i4[s5] = t5.w;
          }
          const s4 = [];
          for (let e5 = 0; e5 < t4; ++e5) {
            const t5 = r4[e5].clone();
            for (let r5 = 1; r5 <= e5; ++r5)
              t5.sub(s4[e5 - r5].clone().multiplyScalar(wm(e5, r5) * i4[r5]));
            s4[e5] = t5.divideScalar(i4[0]);
          }
          return s4;
        }(o2);
      }(this.degree, this.knots, this.controlPoints, i2, 1);
      return r2.copy(s2[1]).normalize(), r2;
    }
  }
  let Sm, Cm, Mm;
  class Tm extends n.aNw {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, i2) {
      const s2 = this, o2 = "" === s2.path ? n.Zp0.extractUrlBase(e2) : s2.path, a2 = new n.hH6(this.manager);
      a2.setPath(s2.path), a2.setResponseType("arraybuffer"), a2.setRequestHeader(s2.requestHeader), a2.setWithCredentials(s2.withCredentials), a2.load(e2, function(r3) {
        try {
          t2(s2.parse(r3, o2));
        } catch (t3) {
          i2 ? i2(t3) : console.error(t3), s2.manager.itemError(e2);
        }
      }, r2, i2);
    }
    parse(e2, t2) {
      if (function(e3) {
        const t3 = "Kaydara FBX Binary  \0";
        return e3.byteLength >= t3.length && t3 === Hm(e3, 0, t3.length);
      }(e2))
        Sm = new Bm().parse(e2);
      else {
        const t3 = Hm(e2);
        if (!function(e3) {
          const t4 = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
          let r3 = 0;
          function n2(t5) {
            const n3 = e3[t5 - 1];
            return e3 = e3.slice(r3 + t5), r3++, n3;
          }
          for (let e4 = 0; e4 < t4.length; ++e4)
            if (n2(1) === t4[e4])
              return false;
          return true;
        }(t3))
          throw new Error("THREE.FBXLoader: Unknown format.");
        if (Om(t3) < 7e3)
          throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Om(t3));
        Sm = new Pm().parse(t3);
      }
      const r2 = new n.dpR(this.manager).setPath(this.resourcePath || t2).setCrossOrigin(this.crossOrigin);
      return new Im(r2, this.manager).parse(Sm);
    }
  }
  class Im {
    constructor(e2, t2) {
      this.textureLoader = e2, this.manager = t2;
    }
    parse() {
      Cm = this.parseConnections();
      const e2 = this.parseImages(), t2 = this.parseTextures(e2), r2 = this.parseMaterials(t2), n2 = this.parseDeformers(), i2 = new km().parse(n2);
      return this.parseScene(n2, i2, r2), Mm;
    }
    parseConnections() {
      const e2 = /* @__PURE__ */ new Map();
      return "Connections" in Sm && Sm.Connections.connections.forEach(function(t2) {
        const r2 = t2[0], n2 = t2[1], i2 = t2[2];
        e2.has(r2) || e2.set(r2, { parents: [], children: [] });
        const s2 = { ID: n2, relationship: i2 };
        e2.get(r2).parents.push(s2), e2.has(n2) || e2.set(n2, { parents: [], children: [] });
        const o2 = { ID: r2, relationship: i2 };
        e2.get(n2).children.push(o2);
      }), e2;
    }
    parseImages() {
      const e2 = {}, t2 = {};
      if ("Video" in Sm.Objects) {
        const r2 = Sm.Objects.Video;
        for (const n2 in r2) {
          const i2 = r2[n2];
          if (e2[parseInt(n2)] = i2.RelativeFilename || i2.Filename, "Content" in i2) {
            const e3 = i2.Content instanceof ArrayBuffer && i2.Content.byteLength > 0, s2 = "string" == typeof i2.Content && "" !== i2.Content;
            if (e3 || s2) {
              const e4 = this.parseImage(r2[n2]);
              t2[i2.RelativeFilename || i2.Filename] = e4;
            }
          }
        }
      }
      for (const r2 in e2) {
        const n2 = e2[r2];
        void 0 !== t2[n2] ? e2[r2] = t2[n2] : e2[r2] = e2[r2].split("\\").pop();
      }
      return e2;
    }
    parseImage(e2) {
      const t2 = e2.Content, r2 = e2.RelativeFilename || e2.Filename, n2 = r2.slice(r2.lastIndexOf(".") + 1).toLowerCase();
      let i2;
      switch (n2) {
        case "bmp":
          i2 = "image/bmp";
          break;
        case "jpg":
        case "jpeg":
          i2 = "image/jpeg";
          break;
        case "png":
          i2 = "image/png";
          break;
        case "tif":
          i2 = "image/tiff";
          break;
        case "tga":
          null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", r2), i2 = "image/tga";
          break;
        default:
          return void console.warn('FBXLoader: Image type "' + n2 + '" is not supported.');
      }
      if ("string" == typeof t2)
        return "data:" + i2 + ";base64," + t2;
      {
        const e3 = new Uint8Array(t2);
        return window.URL.createObjectURL(new Blob([e3], { type: i2 }));
      }
    }
    parseTextures(e2) {
      const t2 = /* @__PURE__ */ new Map();
      if ("Texture" in Sm.Objects) {
        const r2 = Sm.Objects.Texture;
        for (const n2 in r2) {
          const i2 = this.parseTexture(r2[n2], e2);
          t2.set(parseInt(n2), i2);
        }
      }
      return t2;
    }
    parseTexture(e2, t2) {
      const r2 = this.loadTexture(e2, t2);
      r2.ID = e2.id, r2.name = e2.attrName;
      const i2 = e2.WrapModeU, s2 = e2.WrapModeV, o2 = void 0 !== i2 ? i2.value : 0, a2 = void 0 !== s2 ? s2.value : 0;
      if (r2.wrapS = 0 === o2 ? n.rpg : n.uWy, r2.wrapT = 0 === a2 ? n.rpg : n.uWy, "Scaling" in e2) {
        const t3 = e2.Scaling.value;
        r2.repeat.x = t3[0], r2.repeat.y = t3[1];
      }
      if ("Translation" in e2) {
        const t3 = e2.Translation.value;
        r2.offset.x = t3[0], r2.offset.y = t3[1];
      }
      return r2;
    }
    loadTexture(e2, t2) {
      let r2;
      const i2 = this.textureLoader.path, s2 = Cm.get(e2.id).children;
      let o2;
      void 0 !== s2 && s2.length > 0 && void 0 !== t2[s2[0].ID] && (r2 = t2[s2[0].ID], 0 !== r2.indexOf("blob:") && 0 !== r2.indexOf("data:") || this.textureLoader.setPath(void 0));
      const a2 = e2.FileName.slice(-3).toLowerCase();
      if ("tga" === a2) {
        const t3 = this.manager.getHandler(".tga");
        null === t3 ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e2.RelativeFilename), o2 = new n.xEZ()) : (t3.setPath(this.textureLoader.path), o2 = t3.load(r2));
      } else
        "psd" === a2 ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e2.RelativeFilename), o2 = new n.xEZ()) : o2 = this.textureLoader.load(r2);
      return this.textureLoader.setPath(i2), o2;
    }
    parseMaterials(e2) {
      const t2 = /* @__PURE__ */ new Map();
      if ("Material" in Sm.Objects) {
        const r2 = Sm.Objects.Material;
        for (const n2 in r2) {
          const i2 = this.parseMaterial(r2[n2], e2);
          null !== i2 && t2.set(parseInt(n2), i2);
        }
      }
      return t2;
    }
    parseMaterial(e2, t2) {
      const r2 = e2.id, i2 = e2.attrName;
      let s2 = e2.ShadingModel;
      if ("object" == typeof s2 && (s2 = s2.value), !Cm.has(r2))
        return null;
      const o2 = this.parseParameters(e2, t2, r2);
      let a2;
      switch (s2.toLowerCase()) {
        case "phong":
          a2 = new n.xoR();
          break;
        case "lambert":
          a2 = new n.YBo();
          break;
        default:
          console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s2), a2 = new n.xoR();
      }
      return a2.setValues(o2), a2.name = i2, a2;
    }
    parseParameters(e2, t2, r2) {
      const i2 = {};
      e2.BumpFactor && (i2.bumpScale = e2.BumpFactor.value), e2.Diffuse ? i2.color = new n.Ilk().fromArray(e2.Diffuse.value) : !e2.DiffuseColor || "Color" !== e2.DiffuseColor.type && "ColorRGB" !== e2.DiffuseColor.type || (i2.color = new n.Ilk().fromArray(e2.DiffuseColor.value)), e2.DisplacementFactor && (i2.displacementScale = e2.DisplacementFactor.value), e2.Emissive ? i2.emissive = new n.Ilk().fromArray(e2.Emissive.value) : !e2.EmissiveColor || "Color" !== e2.EmissiveColor.type && "ColorRGB" !== e2.EmissiveColor.type || (i2.emissive = new n.Ilk().fromArray(e2.EmissiveColor.value)), e2.EmissiveFactor && (i2.emissiveIntensity = parseFloat(e2.EmissiveFactor.value)), e2.Opacity && (i2.opacity = parseFloat(e2.Opacity.value)), i2.opacity < 1 && (i2.transparent = true), e2.ReflectionFactor && (i2.reflectivity = e2.ReflectionFactor.value), e2.Shininess && (i2.shininess = e2.Shininess.value), e2.Specular ? i2.specular = new n.Ilk().fromArray(e2.Specular.value) : e2.SpecularColor && "Color" === e2.SpecularColor.type && (i2.specular = new n.Ilk().fromArray(e2.SpecularColor.value));
      const s2 = this;
      return Cm.get(r2).children.forEach(function(e3) {
        const r3 = e3.relationship;
        switch (r3) {
          case "Bump":
            i2.bumpMap = s2.getTexture(t2, e3.ID);
            break;
          case "Maya|TEX_ao_map":
            i2.aoMap = s2.getTexture(t2, e3.ID);
            break;
          case "DiffuseColor":
          case "Maya|TEX_color_map":
            i2.map = s2.getTexture(t2, e3.ID), void 0 !== i2.map && (i2.map.encoding = n.knz);
            break;
          case "DisplacementColor":
            i2.displacementMap = s2.getTexture(t2, e3.ID);
            break;
          case "EmissiveColor":
            i2.emissiveMap = s2.getTexture(t2, e3.ID), void 0 !== i2.emissiveMap && (i2.emissiveMap.encoding = n.knz);
            break;
          case "NormalMap":
          case "Maya|TEX_normal_map":
            i2.normalMap = s2.getTexture(t2, e3.ID);
            break;
          case "ReflectionColor":
            i2.envMap = s2.getTexture(t2, e3.ID), void 0 !== i2.envMap && (i2.envMap.mapping = n.dSO, i2.envMap.encoding = n.knz);
            break;
          case "SpecularColor":
            i2.specularMap = s2.getTexture(t2, e3.ID), void 0 !== i2.specularMap && (i2.specularMap.encoding = n.knz);
            break;
          case "TransparentColor":
          case "TransparencyFactor":
            i2.alphaMap = s2.getTexture(t2, e3.ID), i2.transparent = true;
            break;
          default:
            console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", r3);
        }
      }), i2;
    }
    getTexture(e2, t2) {
      return "LayeredTexture" in Sm.Objects && t2 in Sm.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t2 = Cm.get(t2).children[0].ID), e2.get(t2);
    }
    parseDeformers() {
      const e2 = {}, t2 = {};
      if ("Deformer" in Sm.Objects) {
        const r2 = Sm.Objects.Deformer;
        for (const n2 in r2) {
          const i2 = r2[n2], s2 = Cm.get(parseInt(n2));
          if ("Skin" === i2.attrType) {
            const t3 = this.parseSkeleton(s2, r2);
            t3.ID = n2, s2.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), t3.geometryID = s2.parents[0].ID, e2[n2] = t3;
          } else if ("BlendShape" === i2.attrType) {
            const e3 = { id: n2 };
            e3.rawTargets = this.parseMorphTargets(s2, r2), e3.id = n2, s2.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t2[n2] = e3;
          }
        }
      }
      return { skeletons: e2, morphTargets: t2 };
    }
    parseSkeleton(e2, t2) {
      const r2 = [];
      return e2.children.forEach(function(e3) {
        const i2 = t2[e3.ID];
        if ("Cluster" !== i2.attrType)
          return;
        const s2 = { ID: e3.ID, indices: [], weights: [], transformLink: new n.yGw().fromArray(i2.TransformLink.a) };
        "Indexes" in i2 && (s2.indices = i2.Indexes.a, s2.weights = i2.Weights.a), r2.push(s2);
      }), { rawBones: r2, bones: [] };
    }
    parseMorphTargets(e2, t2) {
      const r2 = [];
      for (let n2 = 0; n2 < e2.children.length; n2++) {
        const i2 = e2.children[n2], s2 = t2[i2.ID], o2 = { name: s2.attrName, initialWeight: s2.DeformPercent, id: s2.id, fullWeights: s2.FullWeights.a };
        if ("BlendShapeChannel" !== s2.attrType)
          return;
        o2.geoID = Cm.get(parseInt(i2.ID)).children.filter(function(e3) {
          return void 0 === e3.relationship;
        })[0].ID, r2.push(o2);
      }
      return r2;
    }
    parseScene(e2, t2, r2) {
      Mm = new n.ZAu();
      const i2 = this.parseModels(e2.skeletons, t2, r2), s2 = Sm.Objects.Model, o2 = this;
      i2.forEach(function(e3) {
        const t3 = s2[e3.ID];
        o2.setLookAtProperties(e3, t3), Cm.get(e3.ID).parents.forEach(function(t4) {
          const r3 = i2.get(t4.ID);
          void 0 !== r3 && r3.add(e3);
        }), null === e3.parent && Mm.add(e3);
      }), this.bindSkeleton(e2.skeletons, t2, i2), this.createAmbientLight(), Mm.traverse(function(e3) {
        if (e3.userData.transformData) {
          e3.parent && (e3.userData.transformData.parentMatrix = e3.parent.matrix, e3.userData.transformData.parentMatrixWorld = e3.parent.matrixWorld);
          const t3 = Gm(e3.userData.transformData);
          e3.applyMatrix4(t3), e3.updateWorldMatrix();
        }
      });
      const a2 = new Dm().parse();
      1 === Mm.children.length && Mm.children[0].isGroup && (Mm.children[0].animations = a2, Mm = Mm.children[0]), Mm.animations = a2;
    }
    parseModels(e2, t2, r2) {
      const i2 = /* @__PURE__ */ new Map(), s2 = Sm.Objects.Model;
      for (const o2 in s2) {
        const a2 = parseInt(o2), l2 = s2[o2], c2 = Cm.get(a2);
        let u2 = this.buildSkeleton(c2, e2, a2, l2.attrName);
        if (!u2) {
          switch (l2.attrType) {
            case "Camera":
              u2 = this.createCamera(c2);
              break;
            case "Light":
              u2 = this.createLight(c2);
              break;
            case "Mesh":
              u2 = this.createMesh(c2, t2, r2);
              break;
            case "NurbsCurve":
              u2 = this.createCurve(c2, t2);
              break;
            case "LimbNode":
            case "Root":
              u2 = new n.N$j();
              break;
            default:
              u2 = new n.ZAu();
          }
          u2.name = l2.attrName ? n.iUV.sanitizeNodeName(l2.attrName) : "", u2.ID = a2;
        }
        this.getTransformData(u2, l2), i2.set(a2, u2);
      }
      return i2;
    }
    buildSkeleton(e2, t2, r2, i2) {
      let s2 = null;
      return e2.parents.forEach(function(e3) {
        for (const o2 in t2) {
          const a2 = t2[o2];
          a2.rawBones.forEach(function(t3, o3) {
            if (t3.ID === e3.ID) {
              const e4 = s2;
              s2 = new n.N$j(), s2.matrixWorld.copy(t3.transformLink), s2.name = i2 ? n.iUV.sanitizeNodeName(i2) : "", s2.ID = r2, a2.bones[o3] = s2, null !== e4 && s2.add(e4);
            }
          });
        }
      }), s2;
    }
    createCamera(e2) {
      let t2, r2;
      if (e2.children.forEach(function(e3) {
        const t3 = Sm.Objects.NodeAttribute[e3.ID];
        void 0 !== t3 && (r2 = t3);
      }), void 0 === r2)
        t2 = new n.Tme();
      else {
        let e3 = 0;
        void 0 !== r2.CameraProjectionType && 1 === r2.CameraProjectionType.value && (e3 = 1);
        let i2 = 1;
        void 0 !== r2.NearPlane && (i2 = r2.NearPlane.value / 1e3);
        let s2 = 1e3;
        void 0 !== r2.FarPlane && (s2 = r2.FarPlane.value / 1e3);
        let o2 = window.innerWidth, a2 = window.innerHeight;
        void 0 !== r2.AspectWidth && void 0 !== r2.AspectHeight && (o2 = r2.AspectWidth.value, a2 = r2.AspectHeight.value);
        const l2 = o2 / a2;
        let c2 = 45;
        void 0 !== r2.FieldOfView && (c2 = r2.FieldOfView.value);
        const u2 = r2.FocalLength ? r2.FocalLength.value : null;
        switch (e3) {
          case 0:
            t2 = new n.cPb(c2, l2, i2, s2), null !== u2 && t2.setFocalLength(u2);
            break;
          case 1:
            t2 = new n.iKG(-o2 / 2, o2 / 2, a2 / 2, -a2 / 2, i2, s2);
            break;
          default:
            console.warn("THREE.FBXLoader: Unknown camera type " + e3 + "."), t2 = new n.Tme();
        }
      }
      return t2;
    }
    createLight(e2) {
      let t2, r2;
      if (e2.children.forEach(function(e3) {
        const t3 = Sm.Objects.NodeAttribute[e3.ID];
        void 0 !== t3 && (r2 = t3);
      }), void 0 === r2)
        t2 = new n.Tme();
      else {
        let e3;
        e3 = void 0 === r2.LightType ? 0 : r2.LightType.value;
        let i2 = 16777215;
        void 0 !== r2.Color && (i2 = new n.Ilk().fromArray(r2.Color.value));
        let s2 = void 0 === r2.Intensity ? 1 : r2.Intensity.value / 100;
        void 0 !== r2.CastLightOnObject && 0 === r2.CastLightOnObject.value && (s2 = 0);
        let o2 = 0;
        void 0 !== r2.FarAttenuationEnd && (o2 = void 0 !== r2.EnableFarAttenuation && 0 === r2.EnableFarAttenuation.value ? 0 : r2.FarAttenuationEnd.value);
        const a2 = 1;
        switch (e3) {
          case 0:
            t2 = new n.cek(i2, s2, o2, a2);
            break;
          case 1:
            t2 = new n.Ox3(i2, s2);
            break;
          case 2:
            let e4 = Math.PI / 3;
            void 0 !== r2.InnerAngle && (e4 = n.M8C.degToRad(r2.InnerAngle.value));
            let l2 = 0;
            void 0 !== r2.OuterAngle && (l2 = n.M8C.degToRad(r2.OuterAngle.value), l2 = Math.max(l2, 1)), t2 = new n.PMe(i2, s2, o2, e4, l2, a2);
            break;
          default:
            console.warn("THREE.FBXLoader: Unknown light type " + r2.LightType.value + ", defaulting to a PointLight."), t2 = new n.cek(i2, s2);
        }
        void 0 !== r2.CastShadows && 1 === r2.CastShadows.value && (t2.castShadow = true);
      }
      return t2;
    }
    createMesh(e2, t2, r2) {
      let i2, s2 = null, o2 = null;
      const a2 = [];
      return e2.children.forEach(function(e3) {
        t2.has(e3.ID) && (s2 = t2.get(e3.ID)), r2.has(e3.ID) && a2.push(r2.get(e3.ID));
      }), a2.length > 1 ? o2 = a2 : a2.length > 0 ? o2 = a2[0] : (o2 = new n.xoR({ color: 13421772 }), a2.push(o2)), "color" in s2.attributes && a2.forEach(function(e3) {
        e3.vertexColors = true;
      }), s2.FBX_Deformer ? (i2 = new n.TUv(s2, o2), i2.normalizeSkinWeights()) : i2 = new n.Kj0(s2, o2), i2;
    }
    createCurve(e2, t2) {
      const r2 = e2.children.reduce(function(e3, r3) {
        return t2.has(r3.ID) && (e3 = t2.get(r3.ID)), e3;
      }, null), i2 = new n.nls({ color: 3342591, linewidth: 1 });
      return new n.x12(r2, i2);
    }
    getTransformData(e2, t2) {
      const r2 = {};
      "InheritType" in t2 && (r2.inheritType = parseInt(t2.InheritType.value)), r2.eulerOrder = "RotationOrder" in t2 ? Vm(t2.RotationOrder.value) : "ZYX", "Lcl_Translation" in t2 && (r2.translation = t2.Lcl_Translation.value), "PreRotation" in t2 && (r2.preRotation = t2.PreRotation.value), "Lcl_Rotation" in t2 && (r2.rotation = t2.Lcl_Rotation.value), "PostRotation" in t2 && (r2.postRotation = t2.PostRotation.value), "Lcl_Scaling" in t2 && (r2.scale = t2.Lcl_Scaling.value), "ScalingOffset" in t2 && (r2.scalingOffset = t2.ScalingOffset.value), "ScalingPivot" in t2 && (r2.scalingPivot = t2.ScalingPivot.value), "RotationOffset" in t2 && (r2.rotationOffset = t2.RotationOffset.value), "RotationPivot" in t2 && (r2.rotationPivot = t2.RotationPivot.value), e2.userData.transformData = r2;
    }
    setLookAtProperties(e2, t2) {
      "LookAtProperty" in t2 && Cm.get(e2.ID).children.forEach(function(t3) {
        if ("LookAtProperty" === t3.relationship) {
          const r2 = Sm.Objects.Model[t3.ID];
          if ("Lcl_Translation" in r2) {
            const t4 = r2.Lcl_Translation.value;
            void 0 !== e2.target ? (e2.target.position.fromArray(t4), Mm.add(e2.target)) : e2.lookAt(new n.Pa4().fromArray(t4));
          }
        }
      });
    }
    bindSkeleton(e2, t2, r2) {
      const i2 = this.parsePoseNodes();
      for (const s2 in e2) {
        const o2 = e2[s2];
        Cm.get(parseInt(o2.ID)).parents.forEach(function(e3) {
          if (t2.has(e3.ID)) {
            const t3 = e3.ID;
            Cm.get(t3).parents.forEach(function(e4) {
              r2.has(e4.ID) && r2.get(e4.ID).bind(new n.OdW(o2.bones), i2[e4.ID]);
            });
          }
        });
      }
    }
    parsePoseNodes() {
      const e2 = {};
      if ("Pose" in Sm.Objects) {
        const t2 = Sm.Objects.Pose;
        for (const r2 in t2)
          if ("BindPose" === t2[r2].attrType && t2[r2].NbPoseNodes > 0) {
            const i2 = t2[r2].PoseNode;
            Array.isArray(i2) ? i2.forEach(function(t3) {
              e2[t3.Node] = new n.yGw().fromArray(t3.Matrix.a);
            }) : e2[i2.Node] = new n.yGw().fromArray(i2.Matrix.a);
          }
      }
      return e2;
    }
    createAmbientLight() {
      if ("GlobalSettings" in Sm && "AmbientColor" in Sm.GlobalSettings) {
        const e2 = Sm.GlobalSettings.AmbientColor.value, t2 = e2[0], r2 = e2[1], i2 = e2[2];
        if (0 !== t2 || 0 !== r2 || 0 !== i2) {
          const e3 = new n.Ilk(t2, r2, i2);
          Mm.add(new n.Mig(e3, 1));
        }
      }
    }
  }
  class km {
    parse(e2) {
      const t2 = /* @__PURE__ */ new Map();
      if ("Geometry" in Sm.Objects) {
        const r2 = Sm.Objects.Geometry;
        for (const n2 in r2) {
          const i2 = Cm.get(parseInt(n2)), s2 = this.parseGeometry(i2, r2[n2], e2);
          t2.set(parseInt(n2), s2);
        }
      }
      return t2;
    }
    parseGeometry(e2, t2, r2) {
      switch (t2.attrType) {
        case "Mesh":
          return this.parseMeshGeometry(e2, t2, r2);
        case "NurbsCurve":
          return this.parseNurbsGeometry(t2);
      }
    }
    parseMeshGeometry(e2, t2, r2) {
      const n2 = r2.skeletons, i2 = [], s2 = e2.parents.map(function(e3) {
        return Sm.Objects.Model[e3.ID];
      });
      if (0 === s2.length)
        return;
      const o2 = e2.children.reduce(function(e3, t3) {
        return void 0 !== n2[t3.ID] && (e3 = n2[t3.ID]), e3;
      }, null);
      e2.children.forEach(function(e3) {
        void 0 !== r2.morphTargets[e3.ID] && i2.push(r2.morphTargets[e3.ID]);
      });
      const a2 = s2[0], l2 = {};
      "RotationOrder" in a2 && (l2.eulerOrder = Vm(a2.RotationOrder.value)), "InheritType" in a2 && (l2.inheritType = parseInt(a2.InheritType.value)), "GeometricTranslation" in a2 && (l2.translation = a2.GeometricTranslation.value), "GeometricRotation" in a2 && (l2.rotation = a2.GeometricRotation.value), "GeometricScaling" in a2 && (l2.scale = a2.GeometricScaling.value);
      const c2 = Gm(l2);
      return this.genGeometry(t2, o2, i2, c2);
    }
    genGeometry(e2, t2, r2, i2) {
      const s2 = new n.u9r();
      e2.attrName && (s2.name = e2.attrName);
      const o2 = this.parseGeoNode(e2, t2), a2 = this.genBuffers(o2), l2 = new n.a$l(a2.vertex, 3);
      if (l2.applyMatrix4(i2), s2.setAttribute("position", l2), a2.colors.length > 0 && s2.setAttribute("color", new n.a$l(a2.colors, 3)), t2 && (s2.setAttribute("skinIndex", new n.qlB(a2.weightsIndices, 4)), s2.setAttribute("skinWeight", new n.a$l(a2.vertexWeights, 4)), s2.FBX_Deformer = t2), a2.normal.length > 0) {
        const e3 = new n.Vkp().getNormalMatrix(i2), t3 = new n.a$l(a2.normal, 3);
        t3.applyNormalMatrix(e3), s2.setAttribute("normal", t3);
      }
      if (a2.uvs.forEach(function(e3, t3) {
        let r3 = "uv" + (t3 + 1).toString();
        0 === t3 && (r3 = "uv"), s2.setAttribute(r3, new n.a$l(a2.uvs[t3], 2));
      }), o2.material && "AllSame" !== o2.material.mappingType) {
        let e3 = a2.materialIndex[0], t3 = 0;
        if (a2.materialIndex.forEach(function(r3, n2) {
          r3 !== e3 && (s2.addGroup(t3, n2 - t3, e3), e3 = r3, t3 = n2);
        }), s2.groups.length > 0) {
          const t4 = s2.groups[s2.groups.length - 1], r3 = t4.start + t4.count;
          r3 !== a2.materialIndex.length && s2.addGroup(r3, a2.materialIndex.length - r3, e3);
        }
        0 === s2.groups.length && s2.addGroup(0, a2.materialIndex.length, a2.materialIndex[0]);
      }
      return this.addMorphTargets(s2, e2, r2, i2), s2;
    }
    parseGeoNode(e2, t2) {
      const r2 = {};
      if (r2.vertexPositions = void 0 !== e2.Vertices ? e2.Vertices.a : [], r2.vertexIndices = void 0 !== e2.PolygonVertexIndex ? e2.PolygonVertexIndex.a : [], e2.LayerElementColor && (r2.color = this.parseVertexColors(e2.LayerElementColor[0])), e2.LayerElementMaterial && (r2.material = this.parseMaterialIndices(e2.LayerElementMaterial[0])), e2.LayerElementNormal && (r2.normal = this.parseNormals(e2.LayerElementNormal[0])), e2.LayerElementUV) {
        r2.uv = [];
        let t3 = 0;
        for (; e2.LayerElementUV[t3]; )
          e2.LayerElementUV[t3].UV && r2.uv.push(this.parseUVs(e2.LayerElementUV[t3])), t3++;
      }
      return r2.weightTable = {}, null !== t2 && (r2.skeleton = t2, t2.rawBones.forEach(function(e3, t3) {
        e3.indices.forEach(function(n2, i2) {
          void 0 === r2.weightTable[n2] && (r2.weightTable[n2] = []), r2.weightTable[n2].push({ id: t3, weight: e3.weights[i2] });
        });
      })), r2;
    }
    genBuffers(e2) {
      const t2 = { vertex: [], normal: [], colors: [], uvs: [], materialIndex: [], vertexWeights: [], weightsIndices: [] };
      let r2 = 0, n2 = 0, i2 = false, s2 = [], o2 = [], a2 = [], l2 = [], c2 = [], u2 = [];
      const h2 = this;
      return e2.vertexIndices.forEach(function(p2, d2) {
        let f2, m2 = false;
        p2 < 0 && (p2 ^= -1, m2 = true);
        let _2 = [], g2 = [];
        if (s2.push(3 * p2, 3 * p2 + 1, 3 * p2 + 2), e2.color) {
          const t3 = Nm(d2, r2, p2, e2.color);
          a2.push(t3[0], t3[1], t3[2]);
        }
        if (e2.skeleton) {
          if (void 0 !== e2.weightTable[p2] && e2.weightTable[p2].forEach(function(e3) {
            g2.push(e3.weight), _2.push(e3.id);
          }), g2.length > 4) {
            i2 || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), i2 = true);
            const e3 = [0, 0, 0, 0], t3 = [0, 0, 0, 0];
            g2.forEach(function(r3, n3) {
              let i3 = r3, s3 = _2[n3];
              t3.forEach(function(t4, r4, n4) {
                if (i3 > t4) {
                  n4[r4] = i3, i3 = t4;
                  const o3 = e3[r4];
                  e3[r4] = s3, s3 = o3;
                }
              });
            }), _2 = e3, g2 = t3;
          }
          for (; g2.length < 4; )
            g2.push(0), _2.push(0);
          for (let e3 = 0; e3 < 4; ++e3)
            c2.push(g2[e3]), u2.push(_2[e3]);
        }
        if (e2.normal) {
          const t3 = Nm(d2, r2, p2, e2.normal);
          o2.push(t3[0], t3[1], t3[2]);
        }
        e2.material && "AllSame" !== e2.material.mappingType && (f2 = Nm(d2, r2, p2, e2.material)[0], f2 < 0 && (console.warn("THREE.FBXLoader: Invalid material index:", f2), f2 = 0)), e2.uv && e2.uv.forEach(function(e3, t3) {
          const n3 = Nm(d2, r2, p2, e3);
          void 0 === l2[t3] && (l2[t3] = []), l2[t3].push(n3[0]), l2[t3].push(n3[1]);
        }), n2++, m2 && (h2.genFace(t2, e2, s2, f2, o2, a2, l2, c2, u2, n2), r2++, n2 = 0, s2 = [], o2 = [], a2 = [], l2 = [], c2 = [], u2 = []);
      }), t2;
    }
    genFace(e2, t2, r2, n2, i2, s2, o2, a2, l2, c2) {
      for (let u2 = 2; u2 < c2; u2++)
        e2.vertex.push(t2.vertexPositions[r2[0]]), e2.vertex.push(t2.vertexPositions[r2[1]]), e2.vertex.push(t2.vertexPositions[r2[2]]), e2.vertex.push(t2.vertexPositions[r2[3 * (u2 - 1)]]), e2.vertex.push(t2.vertexPositions[r2[3 * (u2 - 1) + 1]]), e2.vertex.push(t2.vertexPositions[r2[3 * (u2 - 1) + 2]]), e2.vertex.push(t2.vertexPositions[r2[3 * u2]]), e2.vertex.push(t2.vertexPositions[r2[3 * u2 + 1]]), e2.vertex.push(t2.vertexPositions[r2[3 * u2 + 2]]), t2.skeleton && (e2.vertexWeights.push(a2[0]), e2.vertexWeights.push(a2[1]), e2.vertexWeights.push(a2[2]), e2.vertexWeights.push(a2[3]), e2.vertexWeights.push(a2[4 * (u2 - 1)]), e2.vertexWeights.push(a2[4 * (u2 - 1) + 1]), e2.vertexWeights.push(a2[4 * (u2 - 1) + 2]), e2.vertexWeights.push(a2[4 * (u2 - 1) + 3]), e2.vertexWeights.push(a2[4 * u2]), e2.vertexWeights.push(a2[4 * u2 + 1]), e2.vertexWeights.push(a2[4 * u2 + 2]), e2.vertexWeights.push(a2[4 * u2 + 3]), e2.weightsIndices.push(l2[0]), e2.weightsIndices.push(l2[1]), e2.weightsIndices.push(l2[2]), e2.weightsIndices.push(l2[3]), e2.weightsIndices.push(l2[4 * (u2 - 1)]), e2.weightsIndices.push(l2[4 * (u2 - 1) + 1]), e2.weightsIndices.push(l2[4 * (u2 - 1) + 2]), e2.weightsIndices.push(l2[4 * (u2 - 1) + 3]), e2.weightsIndices.push(l2[4 * u2]), e2.weightsIndices.push(l2[4 * u2 + 1]), e2.weightsIndices.push(l2[4 * u2 + 2]), e2.weightsIndices.push(l2[4 * u2 + 3])), t2.color && (e2.colors.push(s2[0]), e2.colors.push(s2[1]), e2.colors.push(s2[2]), e2.colors.push(s2[3 * (u2 - 1)]), e2.colors.push(s2[3 * (u2 - 1) + 1]), e2.colors.push(s2[3 * (u2 - 1) + 2]), e2.colors.push(s2[3 * u2]), e2.colors.push(s2[3 * u2 + 1]), e2.colors.push(s2[3 * u2 + 2])), t2.material && "AllSame" !== t2.material.mappingType && (e2.materialIndex.push(n2), e2.materialIndex.push(n2), e2.materialIndex.push(n2)), t2.normal && (e2.normal.push(i2[0]), e2.normal.push(i2[1]), e2.normal.push(i2[2]), e2.normal.push(i2[3 * (u2 - 1)]), e2.normal.push(i2[3 * (u2 - 1) + 1]), e2.normal.push(i2[3 * (u2 - 1) + 2]), e2.normal.push(i2[3 * u2]), e2.normal.push(i2[3 * u2 + 1]), e2.normal.push(i2[3 * u2 + 2])), t2.uv && t2.uv.forEach(function(t3, r3) {
          void 0 === e2.uvs[r3] && (e2.uvs[r3] = []), e2.uvs[r3].push(o2[r3][0]), e2.uvs[r3].push(o2[r3][1]), e2.uvs[r3].push(o2[r3][2 * (u2 - 1)]), e2.uvs[r3].push(o2[r3][2 * (u2 - 1) + 1]), e2.uvs[r3].push(o2[r3][2 * u2]), e2.uvs[r3].push(o2[r3][2 * u2 + 1]);
        });
    }
    addMorphTargets(e2, t2, r2, n2) {
      if (0 === r2.length)
        return;
      e2.morphTargetsRelative = true, e2.morphAttributes.position = [];
      const i2 = this;
      r2.forEach(function(r3) {
        r3.rawTargets.forEach(function(r4) {
          const s2 = Sm.Objects.Geometry[r4.geoID];
          void 0 !== s2 && i2.genMorphGeometry(e2, t2, s2, n2, r4.name);
        });
      });
    }
    genMorphGeometry(e2, t2, r2, i2, s2) {
      const o2 = void 0 !== t2.PolygonVertexIndex ? t2.PolygonVertexIndex.a : [], a2 = void 0 !== r2.Vertices ? r2.Vertices.a : [], l2 = void 0 !== r2.Indexes ? r2.Indexes.a : [], c2 = 3 * e2.attributes.position.count, u2 = new Float32Array(c2);
      for (let e3 = 0; e3 < l2.length; e3++) {
        const t3 = 3 * l2[e3];
        u2[t3] = a2[3 * e3], u2[t3 + 1] = a2[3 * e3 + 1], u2[t3 + 2] = a2[3 * e3 + 2];
      }
      const h2 = { vertexIndices: o2, vertexPositions: u2 }, p2 = this.genBuffers(h2), d2 = new n.a$l(p2.vertex, 3);
      d2.name = s2 || r2.attrName, d2.applyMatrix4(i2), e2.morphAttributes.position.push(d2);
    }
    parseNormals(e2) {
      const t2 = e2.MappingInformationType, r2 = e2.ReferenceInformationType, n2 = e2.Normals.a;
      let i2 = [];
      return "IndexToDirect" === r2 && ("NormalIndex" in e2 ? i2 = e2.NormalIndex.a : "NormalsIndex" in e2 && (i2 = e2.NormalsIndex.a)), { dataSize: 3, buffer: n2, indices: i2, mappingType: t2, referenceType: r2 };
    }
    parseUVs(e2) {
      const t2 = e2.MappingInformationType, r2 = e2.ReferenceInformationType, n2 = e2.UV.a;
      let i2 = [];
      return "IndexToDirect" === r2 && (i2 = e2.UVIndex.a), { dataSize: 2, buffer: n2, indices: i2, mappingType: t2, referenceType: r2 };
    }
    parseVertexColors(e2) {
      const t2 = e2.MappingInformationType, r2 = e2.ReferenceInformationType, n2 = e2.Colors.a;
      let i2 = [];
      return "IndexToDirect" === r2 && (i2 = e2.ColorIndex.a), { dataSize: 4, buffer: n2, indices: i2, mappingType: t2, referenceType: r2 };
    }
    parseMaterialIndices(e2) {
      const t2 = e2.MappingInformationType, r2 = e2.ReferenceInformationType;
      if ("NoMappingInformation" === t2)
        return { dataSize: 1, buffer: [0], indices: [0], mappingType: "AllSame", referenceType: r2 };
      const n2 = e2.Materials.a, i2 = [];
      for (let e3 = 0; e3 < n2.length; ++e3)
        i2.push(e3);
      return { dataSize: 1, buffer: n2, indices: i2, mappingType: t2, referenceType: r2 };
    }
    parseNurbsGeometry(e2) {
      if (void 0 === Em)
        return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new n.u9r();
      const t2 = parseInt(e2.Order);
      if (isNaN(t2))
        return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e2.Order, e2.id), new n.u9r();
      const r2 = t2 - 1, i2 = e2.KnotVector.a, s2 = [], o2 = e2.Points.a;
      for (let e3 = 0, t3 = o2.length; e3 < t3; e3 += 4)
        s2.push(new n.Ltg().fromArray(o2, e3));
      let a2, l2;
      if ("Closed" === e2.Form)
        s2.push(s2[0]);
      else if ("Periodic" === e2.Form) {
        a2 = r2, l2 = i2.length - 1 - a2;
        for (let e3 = 0; e3 < r2; ++e3)
          s2.push(s2[e3]);
      }
      const c2 = new Em(r2, i2, s2, a2, l2).getPoints(12 * s2.length);
      return new n.u9r().setFromPoints(c2);
    }
  }
  class Dm {
    parse() {
      const e2 = [], t2 = this.parseClips();
      if (void 0 !== t2)
        for (const r2 in t2) {
          const n2 = t2[r2], i2 = this.addClip(n2);
          e2.push(i2);
        }
      return e2;
    }
    parseClips() {
      if (void 0 === Sm.Objects.AnimationCurve)
        return;
      const e2 = this.parseAnimationCurveNodes();
      this.parseAnimationCurves(e2);
      const t2 = this.parseAnimationLayers(e2);
      return this.parseAnimStacks(t2);
    }
    parseAnimationCurveNodes() {
      const e2 = Sm.Objects.AnimationCurveNode, t2 = /* @__PURE__ */ new Map();
      for (const r2 in e2) {
        const n2 = e2[r2];
        if (null !== n2.attrName.match(/S|R|T|DeformPercent/)) {
          const e3 = { id: n2.id, attr: n2.attrName, curves: {} };
          t2.set(e3.id, e3);
        }
      }
      return t2;
    }
    parseAnimationCurves(e2) {
      const t2 = Sm.Objects.AnimationCurve;
      for (const r2 in t2) {
        const n2 = { id: t2[r2].id, times: t2[r2].KeyTime.a.map(Fm), values: t2[r2].KeyValueFloat.a }, i2 = Cm.get(n2.id);
        if (void 0 !== i2) {
          const t3 = i2.parents[0].ID, r3 = i2.parents[0].relationship;
          r3.match(/X/) ? e2.get(t3).curves.x = n2 : r3.match(/Y/) ? e2.get(t3).curves.y = n2 : r3.match(/Z/) ? e2.get(t3).curves.z = n2 : r3.match(/d|DeformPercent/) && e2.has(t3) && (e2.get(t3).curves.morph = n2);
        }
      }
    }
    parseAnimationLayers(e2) {
      const t2 = Sm.Objects.AnimationLayer, r2 = /* @__PURE__ */ new Map();
      for (const i2 in t2) {
        const t3 = [], s2 = Cm.get(parseInt(i2));
        void 0 !== s2 && (s2.children.forEach(function(r3, i3) {
          if (e2.has(r3.ID)) {
            const s3 = e2.get(r3.ID);
            if (void 0 !== s3.curves.x || void 0 !== s3.curves.y || void 0 !== s3.curves.z) {
              if (void 0 === t3[i3]) {
                const e3 = Cm.get(r3.ID).parents.filter(function(e4) {
                  return void 0 !== e4.relationship;
                })[0].ID;
                if (void 0 !== e3) {
                  const s4 = Sm.Objects.Model[e3.toString()];
                  if (void 0 === s4)
                    return void console.warn("THREE.FBXLoader: Encountered a unused curve.", r3);
                  const o2 = { modelName: s4.attrName ? n.iUV.sanitizeNodeName(s4.attrName) : "", ID: s4.id, initialPosition: [0, 0, 0], initialRotation: [0, 0, 0], initialScale: [1, 1, 1] };
                  Mm.traverse(function(e4) {
                    e4.ID === s4.id && (o2.transform = e4.matrix, e4.userData.transformData && (o2.eulerOrder = e4.userData.transformData.eulerOrder));
                  }), o2.transform || (o2.transform = new n.yGw()), "PreRotation" in s4 && (o2.preRotation = s4.PreRotation.value), "PostRotation" in s4 && (o2.postRotation = s4.PostRotation.value), t3[i3] = o2;
                }
              }
              t3[i3] && (t3[i3][s3.attr] = s3);
            } else if (void 0 !== s3.curves.morph) {
              if (void 0 === t3[i3]) {
                const e3 = Cm.get(r3.ID).parents.filter(function(e4) {
                  return void 0 !== e4.relationship;
                })[0].ID, s4 = Cm.get(e3).parents[0].ID, o2 = Cm.get(s4).parents[0].ID, a2 = Cm.get(o2).parents[0].ID, l2 = Sm.Objects.Model[a2], c2 = { modelName: l2.attrName ? n.iUV.sanitizeNodeName(l2.attrName) : "", morphName: Sm.Objects.Deformer[e3].attrName };
                t3[i3] = c2;
              }
              t3[i3][s3.attr] = s3;
            }
          }
        }), r2.set(parseInt(i2), t3));
      }
      return r2;
    }
    parseAnimStacks(e2) {
      const t2 = Sm.Objects.AnimationStack, r2 = {};
      for (const n2 in t2) {
        const i2 = Cm.get(parseInt(n2)).children;
        i2.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
        const s2 = e2.get(i2[0].ID);
        r2[n2] = { name: t2[n2].attrName, layer: s2 };
      }
      return r2;
    }
    addClip(e2) {
      let t2 = [];
      const r2 = this;
      return e2.layer.forEach(function(e3) {
        t2 = t2.concat(r2.generateTracks(e3));
      }), new n.m7l(e2.name, -1, t2);
    }
    generateTracks(e2) {
      const t2 = [];
      let r2 = new n.Pa4(), i2 = new n._fP(), s2 = new n.Pa4();
      if (e2.transform && e2.transform.decompose(r2, i2, s2), r2 = r2.toArray(), i2 = new n.USm().setFromQuaternion(i2, e2.eulerOrder).toArray(), s2 = s2.toArray(), void 0 !== e2.T && Object.keys(e2.T.curves).length > 0) {
        const n2 = this.generateVectorTrack(e2.modelName, e2.T.curves, r2, "position");
        void 0 !== n2 && t2.push(n2);
      }
      if (void 0 !== e2.R && Object.keys(e2.R.curves).length > 0) {
        const r3 = this.generateRotationTrack(e2.modelName, e2.R.curves, i2, e2.preRotation, e2.postRotation, e2.eulerOrder);
        void 0 !== r3 && t2.push(r3);
      }
      if (void 0 !== e2.S && Object.keys(e2.S.curves).length > 0) {
        const r3 = this.generateVectorTrack(e2.modelName, e2.S.curves, s2, "scale");
        void 0 !== r3 && t2.push(r3);
      }
      if (void 0 !== e2.DeformPercent) {
        const r3 = this.generateMorphTrack(e2);
        void 0 !== r3 && t2.push(r3);
      }
      return t2;
    }
    generateVectorTrack(e2, t2, r2, i2) {
      const s2 = this.getTimesForAllAxes(t2), o2 = this.getKeyframeTrackValues(s2, t2, r2);
      return new n.yC1(e2 + "." + i2, s2, o2);
    }
    generateRotationTrack(e2, t2, r2, i2, s2, o2) {
      void 0 !== t2.x && (this.interpolateRotations(t2.x), t2.x.values = t2.x.values.map(n.M8C.degToRad)), void 0 !== t2.y && (this.interpolateRotations(t2.y), t2.y.values = t2.y.values.map(n.M8C.degToRad)), void 0 !== t2.z && (this.interpolateRotations(t2.z), t2.z.values = t2.z.values.map(n.M8C.degToRad));
      const a2 = this.getTimesForAllAxes(t2), l2 = this.getKeyframeTrackValues(a2, t2, r2);
      void 0 !== i2 && ((i2 = i2.map(n.M8C.degToRad)).push(o2), i2 = new n.USm().fromArray(i2), i2 = new n._fP().setFromEuler(i2)), void 0 !== s2 && ((s2 = s2.map(n.M8C.degToRad)).push(o2), s2 = new n.USm().fromArray(s2), s2 = new n._fP().setFromEuler(s2).invert());
      const c2 = new n._fP(), u2 = new n.USm(), h2 = [];
      for (let e3 = 0; e3 < l2.length; e3 += 3)
        u2.set(l2[e3], l2[e3 + 1], l2[e3 + 2], o2), c2.setFromEuler(u2), void 0 !== i2 && c2.premultiply(i2), void 0 !== s2 && c2.multiply(s2), c2.toArray(h2, e3 / 3 * 4);
      return new n.iLg(e2 + ".quaternion", a2, h2);
    }
    generateMorphTrack(e2) {
      const t2 = e2.DeformPercent.curves.morph, r2 = t2.values.map(function(e3) {
        return e3 / 100;
      }), i2 = Mm.getObjectByName(e2.modelName).morphTargetDictionary[e2.morphName];
      return new n.dUE(e2.modelName + ".morphTargetInfluences[" + i2 + "]", t2.times, r2);
    }
    getTimesForAllAxes(e2) {
      let t2 = [];
      if (void 0 !== e2.x && (t2 = t2.concat(e2.x.times)), void 0 !== e2.y && (t2 = t2.concat(e2.y.times)), void 0 !== e2.z && (t2 = t2.concat(e2.z.times)), t2 = t2.sort(function(e3, t3) {
        return e3 - t3;
      }), t2.length > 1) {
        let e3 = 1, r2 = t2[0];
        for (let n2 = 1; n2 < t2.length; n2++) {
          const i2 = t2[n2];
          i2 !== r2 && (t2[e3] = i2, r2 = i2, e3++);
        }
        t2 = t2.slice(0, e3);
      }
      return t2;
    }
    getKeyframeTrackValues(e2, t2, r2) {
      const n2 = r2, i2 = [];
      let s2 = -1, o2 = -1, a2 = -1;
      return e2.forEach(function(e3) {
        if (t2.x && (s2 = t2.x.times.indexOf(e3)), t2.y && (o2 = t2.y.times.indexOf(e3)), t2.z && (a2 = t2.z.times.indexOf(e3)), -1 !== s2) {
          const e4 = t2.x.values[s2];
          i2.push(e4), n2[0] = e4;
        } else
          i2.push(n2[0]);
        if (-1 !== o2) {
          const e4 = t2.y.values[o2];
          i2.push(e4), n2[1] = e4;
        } else
          i2.push(n2[1]);
        if (-1 !== a2) {
          const e4 = t2.z.values[a2];
          i2.push(e4), n2[2] = e4;
        } else
          i2.push(n2[2]);
      }), i2;
    }
    interpolateRotations(e2) {
      for (let t2 = 1; t2 < e2.values.length; t2++) {
        const r2 = e2.values[t2 - 1], n2 = e2.values[t2] - r2, i2 = Math.abs(n2);
        if (i2 >= 180) {
          const s2 = i2 / 180, o2 = n2 / s2;
          let a2 = r2 + o2;
          const l2 = e2.times[t2 - 1], c2 = (e2.times[t2] - l2) / s2;
          let u2 = l2 + c2;
          const h2 = [], p2 = [];
          for (; u2 < e2.times[t2]; )
            h2.push(u2), u2 += c2, p2.push(a2), a2 += o2;
          e2.times = Wm(e2.times, t2, h2), e2.values = Wm(e2.values, t2, p2);
        }
      }
    }
  }
  class Pm {
    getPrevNode() {
      return this.nodeStack[this.currentIndent - 2];
    }
    getCurrentNode() {
      return this.nodeStack[this.currentIndent - 1];
    }
    getCurrentProp() {
      return this.currentProp;
    }
    pushStack(e2) {
      this.nodeStack.push(e2), this.currentIndent += 1;
    }
    popStack() {
      this.nodeStack.pop(), this.currentIndent -= 1;
    }
    setCurrentProp(e2, t2) {
      this.currentProp = e2, this.currentPropName = t2;
    }
    parse(e2) {
      this.currentIndent = 0, this.allNodes = new Lm(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
      const t2 = this, r2 = e2.split(/[\r\n]+/);
      return r2.forEach(function(e3, n2) {
        const i2 = e3.match(/^[\s\t]*;/), s2 = e3.match(/^[\s\t]*$/);
        if (i2 || s2)
          return;
        const o2 = e3.match("^\\t{" + t2.currentIndent + "}(\\w+):(.*){", ""), a2 = e3.match("^\\t{" + t2.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), l2 = e3.match("^\\t{" + (t2.currentIndent - 1) + "}}");
        o2 ? t2.parseNodeBegin(e3, o2) : a2 ? t2.parseNodeProperty(e3, a2, r2[++n2]) : l2 ? t2.popStack() : e3.match(/^[^\s\t}]/) && t2.parseNodePropertyContinued(e3);
      }), this.allNodes;
    }
    parseNodeBegin(e2, t2) {
      const r2 = t2[1].trim().replace(/^"/, "").replace(/"$/, ""), n2 = t2[2].split(",").map(function(e3) {
        return e3.trim().replace(/^"/, "").replace(/"$/, "");
      }), i2 = { name: r2 }, s2 = this.parseNodeAttr(n2), o2 = this.getCurrentNode();
      0 === this.currentIndent ? this.allNodes.add(r2, i2) : r2 in o2 ? ("PoseNode" === r2 ? o2.PoseNode.push(i2) : void 0 !== o2[r2].id && (o2[r2] = {}, o2[r2][o2[r2].id] = o2[r2]), "" !== s2.id && (o2[r2][s2.id] = i2)) : "number" == typeof s2.id ? (o2[r2] = {}, o2[r2][s2.id] = i2) : "Properties70" !== r2 && (o2[r2] = "PoseNode" === r2 ? [i2] : i2), "number" == typeof s2.id && (i2.id = s2.id), "" !== s2.name && (i2.attrName = s2.name), "" !== s2.type && (i2.attrType = s2.type), this.pushStack(i2);
    }
    parseNodeAttr(e2) {
      let t2 = e2[0];
      "" !== e2[0] && (t2 = parseInt(e2[0]), isNaN(t2) && (t2 = e2[0]));
      let r2 = "", n2 = "";
      return e2.length > 1 && (r2 = e2[1].replace(/^(\w+)::/, ""), n2 = e2[2]), { id: t2, name: r2, type: n2 };
    }
    parseNodeProperty(e2, t2, r2) {
      let n2 = t2[1].replace(/^"/, "").replace(/"$/, "").trim(), i2 = t2[2].replace(/^"/, "").replace(/"$/, "").trim();
      "Content" === n2 && "," === i2 && (i2 = r2.replace(/"/g, "").replace(/,$/, "").trim());
      const s2 = this.getCurrentNode();
      if ("Properties70" !== s2.name) {
        if ("C" === n2) {
          const e3 = i2.split(",").slice(1), t3 = parseInt(e3[0]), r3 = parseInt(e3[1]);
          let o2 = i2.split(",").slice(3);
          o2 = o2.map(function(e4) {
            return e4.trim().replace(/^"/, "");
          }), n2 = "connections", i2 = [t3, r3], function(e4, t4) {
            for (let r4 = 0, n3 = e4.length, i3 = t4.length; r4 < i3; r4++, n3++)
              e4[n3] = t4[r4];
          }(i2, o2), void 0 === s2[n2] && (s2[n2] = []);
        }
        "Node" === n2 && (s2.id = i2), n2 in s2 && Array.isArray(s2[n2]) ? s2[n2].push(i2) : "a" !== n2 ? s2[n2] = i2 : s2.a = i2, this.setCurrentProp(s2, n2), "a" === n2 && "," !== i2.slice(-1) && (s2.a = Qm(i2));
      } else
        this.parseNodeSpecialProperty(e2, n2, i2);
    }
    parseNodePropertyContinued(e2) {
      const t2 = this.getCurrentNode();
      t2.a += e2, "," !== e2.slice(-1) && (t2.a = Qm(t2.a));
    }
    parseNodeSpecialProperty(e2, t2, r2) {
      const n2 = r2.split('",').map(function(e3) {
        return e3.trim().replace(/^\"/, "").replace(/\s/, "_");
      }), i2 = n2[0], s2 = n2[1], o2 = n2[2], a2 = n2[3];
      let l2 = n2[4];
      switch (s2) {
        case "int":
        case "enum":
        case "bool":
        case "ULongLong":
        case "double":
        case "Number":
        case "FieldOfView":
          l2 = parseFloat(l2);
          break;
        case "Color":
        case "ColorRGB":
        case "Vector3D":
        case "Lcl_Translation":
        case "Lcl_Rotation":
        case "Lcl_Scaling":
          l2 = Qm(l2);
      }
      this.getPrevNode()[i2] = { type: s2, type2: o2, flag: a2, value: l2 }, this.setCurrentProp(this.getPrevNode(), i2);
    }
  }
  class Bm {
    parse(e2) {
      const t2 = new Rm(e2);
      t2.skip(23);
      const r2 = t2.getUint32();
      if (r2 < 6400)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + r2);
      const n2 = new Lm();
      for (; !this.endOfContent(t2); ) {
        const e3 = this.parseNode(t2, r2);
        null !== e3 && n2.add(e3.name, e3);
      }
      return n2;
    }
    endOfContent(e2) {
      return e2.size() % 16 == 0 ? (e2.getOffset() + 160 + 16 & -16) >= e2.size() : e2.getOffset() + 160 + 16 >= e2.size();
    }
    parseNode(e2, t2) {
      const r2 = {}, n2 = t2 >= 7500 ? e2.getUint64() : e2.getUint32(), i2 = t2 >= 7500 ? e2.getUint64() : e2.getUint32();
      t2 >= 7500 ? e2.getUint64() : e2.getUint32();
      const s2 = e2.getUint8(), o2 = e2.getString(s2);
      if (0 === n2)
        return null;
      const a2 = [];
      for (let t3 = 0; t3 < i2; t3++)
        a2.push(this.parseProperty(e2));
      const l2 = a2.length > 0 ? a2[0] : "", c2 = a2.length > 1 ? a2[1] : "", u2 = a2.length > 2 ? a2[2] : "";
      for (r2.singleProperty = 1 === i2 && e2.getOffset() === n2; n2 > e2.getOffset(); ) {
        const n3 = this.parseNode(e2, t2);
        null !== n3 && this.parseSubNode(o2, r2, n3);
      }
      return r2.propertyList = a2, "number" == typeof l2 && (r2.id = l2), "" !== c2 && (r2.attrName = c2), "" !== u2 && (r2.attrType = u2), "" !== o2 && (r2.name = o2), r2;
    }
    parseSubNode(e2, t2, r2) {
      if (true === r2.singleProperty) {
        const e3 = r2.propertyList[0];
        Array.isArray(e3) ? (t2[r2.name] = r2, r2.a = e3) : t2[r2.name] = e3;
      } else if ("Connections" === e2 && "C" === r2.name) {
        const e3 = [];
        r2.propertyList.forEach(function(t3, r3) {
          0 !== r3 && e3.push(t3);
        }), void 0 === t2.connections && (t2.connections = []), t2.connections.push(e3);
      } else if ("Properties70" === r2.name)
        Object.keys(r2).forEach(function(e3) {
          t2[e3] = r2[e3];
        });
      else if ("Properties70" === e2 && "P" === r2.name) {
        let e3 = r2.propertyList[0], n2 = r2.propertyList[1];
        const i2 = r2.propertyList[2], s2 = r2.propertyList[3];
        let o2;
        0 === e3.indexOf("Lcl ") && (e3 = e3.replace("Lcl ", "Lcl_")), 0 === n2.indexOf("Lcl ") && (n2 = n2.replace("Lcl ", "Lcl_")), o2 = "Color" === n2 || "ColorRGB" === n2 || "Vector" === n2 || "Vector3D" === n2 || 0 === n2.indexOf("Lcl_") ? [r2.propertyList[4], r2.propertyList[5], r2.propertyList[6]] : r2.propertyList[4], t2[e3] = { type: n2, type2: i2, flag: s2, value: o2 };
      } else
        void 0 === t2[r2.name] ? "number" == typeof r2.id ? (t2[r2.name] = {}, t2[r2.name][r2.id] = r2) : t2[r2.name] = r2 : "PoseNode" === r2.name ? (Array.isArray(t2[r2.name]) || (t2[r2.name] = [t2[r2.name]]), t2[r2.name].push(r2)) : void 0 === t2[r2.name][r2.id] && (t2[r2.name][r2.id] = r2);
    }
    parseProperty(e2) {
      const r2 = e2.getString(1);
      let n2;
      switch (r2) {
        case "C":
          return e2.getBoolean();
        case "D":
          return e2.getFloat64();
        case "F":
          return e2.getFloat32();
        case "I":
          return e2.getInt32();
        case "L":
          return e2.getInt64();
        case "R":
          return n2 = e2.getUint32(), e2.getArrayBuffer(n2);
        case "S":
          return n2 = e2.getUint32(), e2.getString(n2);
        case "Y":
          return e2.getInt16();
        case "b":
        case "c":
        case "d":
        case "f":
        case "i":
        case "l":
          const i2 = e2.getUint32(), s2 = e2.getUint32(), o2 = e2.getUint32();
          if (0 === s2)
            switch (r2) {
              case "b":
              case "c":
                return e2.getBooleanArray(i2);
              case "d":
                return e2.getFloat64Array(i2);
              case "f":
                return e2.getFloat32Array(i2);
              case "i":
                return e2.getInt32Array(i2);
              case "l":
                return e2.getInt64Array(i2);
            }
          void 0 === t && console.error("THREE.FBXLoader: External library fflate.min.js required.");
          const a2 = zf(new Uint8Array(e2.getArrayBuffer(o2))), l2 = new Rm(a2.buffer);
          switch (r2) {
            case "b":
            case "c":
              return l2.getBooleanArray(i2);
            case "d":
              return l2.getFloat64Array(i2);
            case "f":
              return l2.getFloat32Array(i2);
            case "i":
              return l2.getInt32Array(i2);
            case "l":
              return l2.getInt64Array(i2);
          }
          break;
        default:
          throw new Error("THREE.FBXLoader: Unknown property type " + r2);
      }
    }
  }
  class Rm {
    constructor(e2, t2) {
      this.dv = new DataView(e2), this.offset = 0, this.littleEndian = void 0 === t2 || t2;
    }
    getOffset() {
      return this.offset;
    }
    size() {
      return this.dv.buffer.byteLength;
    }
    skip(e2) {
      this.offset += e2;
    }
    getBoolean() {
      return 1 == (1 & this.getUint8());
    }
    getBooleanArray(e2) {
      const t2 = [];
      for (let r2 = 0; r2 < e2; r2++)
        t2.push(this.getBoolean());
      return t2;
    }
    getUint8() {
      const e2 = this.dv.getUint8(this.offset);
      return this.offset += 1, e2;
    }
    getInt16() {
      const e2 = this.dv.getInt16(this.offset, this.littleEndian);
      return this.offset += 2, e2;
    }
    getInt32() {
      const e2 = this.dv.getInt32(this.offset, this.littleEndian);
      return this.offset += 4, e2;
    }
    getInt32Array(e2) {
      const t2 = [];
      for (let r2 = 0; r2 < e2; r2++)
        t2.push(this.getInt32());
      return t2;
    }
    getUint32() {
      const e2 = this.dv.getUint32(this.offset, this.littleEndian);
      return this.offset += 4, e2;
    }
    getInt64() {
      let e2, t2;
      return this.littleEndian ? (e2 = this.getUint32(), t2 = this.getUint32()) : (t2 = this.getUint32(), e2 = this.getUint32()), 2147483648 & t2 ? (t2 = 4294967295 & ~t2, e2 = 4294967295 & ~e2, 4294967295 === e2 && (t2 = t2 + 1 & 4294967295), e2 = e2 + 1 & 4294967295, -(4294967296 * t2 + e2)) : 4294967296 * t2 + e2;
    }
    getInt64Array(e2) {
      const t2 = [];
      for (let r2 = 0; r2 < e2; r2++)
        t2.push(this.getInt64());
      return t2;
    }
    getUint64() {
      let e2, t2;
      return this.littleEndian ? (e2 = this.getUint32(), t2 = this.getUint32()) : (t2 = this.getUint32(), e2 = this.getUint32()), 4294967296 * t2 + e2;
    }
    getFloat32() {
      const e2 = this.dv.getFloat32(this.offset, this.littleEndian);
      return this.offset += 4, e2;
    }
    getFloat32Array(e2) {
      const t2 = [];
      for (let r2 = 0; r2 < e2; r2++)
        t2.push(this.getFloat32());
      return t2;
    }
    getFloat64() {
      const e2 = this.dv.getFloat64(this.offset, this.littleEndian);
      return this.offset += 8, e2;
    }
    getFloat64Array(e2) {
      const t2 = [];
      for (let r2 = 0; r2 < e2; r2++)
        t2.push(this.getFloat64());
      return t2;
    }
    getArrayBuffer(e2) {
      const t2 = this.dv.buffer.slice(this.offset, this.offset + e2);
      return this.offset += e2, t2;
    }
    getString(e2) {
      let t2 = [];
      for (let r3 = 0; r3 < e2; r3++)
        t2[r3] = this.getUint8();
      const r2 = t2.indexOf(0);
      return r2 >= 0 && (t2 = t2.slice(0, r2)), n.Zp0.decodeText(new Uint8Array(t2));
    }
  }
  class Lm {
    add(e2, t2) {
      this[e2] = t2;
    }
  }
  function Om(e2) {
    const t2 = e2.match(/FBXVersion: (\d+)/);
    if (t2)
      return parseInt(t2[1]);
    throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
  }
  function Fm(e2) {
    return e2 / 46186158e3;
  }
  const Um = [];
  function Nm(e2, t2, r2, n2) {
    let i2;
    switch (n2.mappingType) {
      case "ByPolygonVertex":
        i2 = e2;
        break;
      case "ByPolygon":
        i2 = t2;
        break;
      case "ByVertice":
        i2 = r2;
        break;
      case "AllSame":
        i2 = n2.indices[0];
        break;
      default:
        console.warn("THREE.FBXLoader: unknown attribute mapping type " + n2.mappingType);
    }
    "IndexToDirect" === n2.referenceType && (i2 = n2.indices[i2]);
    const s2 = i2 * n2.dataSize, o2 = s2 + n2.dataSize;
    return function(e3, t3, r3, n3) {
      for (let i3 = r3, s3 = 0; i3 < n3; i3++, s3++)
        e3[s3] = t3[i3];
      return e3;
    }(Um, n2.buffer, s2, o2);
  }
  const jm = new n.USm(), zm = new n.Pa4();
  function Gm(e2) {
    const t2 = new n.yGw(), r2 = new n.yGw(), i2 = new n.yGw(), s2 = new n.yGw(), o2 = new n.yGw(), a2 = new n.yGw(), l2 = new n.yGw(), c2 = new n.yGw(), u2 = new n.yGw(), h2 = new n.yGw(), p2 = new n.yGw(), d2 = new n.yGw(), f2 = e2.inheritType ? e2.inheritType : 0;
    if (e2.translation && t2.setPosition(zm.fromArray(e2.translation)), e2.preRotation) {
      const t3 = e2.preRotation.map(n.M8C.degToRad);
      t3.push(e2.eulerOrder || n.USm.DefaultOrder), r2.makeRotationFromEuler(jm.fromArray(t3));
    }
    if (e2.rotation) {
      const t3 = e2.rotation.map(n.M8C.degToRad);
      t3.push(e2.eulerOrder || n.USm.DefaultOrder), i2.makeRotationFromEuler(jm.fromArray(t3));
    }
    if (e2.postRotation) {
      const t3 = e2.postRotation.map(n.M8C.degToRad);
      t3.push(e2.eulerOrder || n.USm.DefaultOrder), s2.makeRotationFromEuler(jm.fromArray(t3)), s2.invert();
    }
    e2.scale && o2.scale(zm.fromArray(e2.scale)), e2.scalingOffset && l2.setPosition(zm.fromArray(e2.scalingOffset)), e2.scalingPivot && a2.setPosition(zm.fromArray(e2.scalingPivot)), e2.rotationOffset && c2.setPosition(zm.fromArray(e2.rotationOffset)), e2.rotationPivot && u2.setPosition(zm.fromArray(e2.rotationPivot)), e2.parentMatrixWorld && (p2.copy(e2.parentMatrix), h2.copy(e2.parentMatrixWorld));
    const m2 = r2.clone().multiply(i2).multiply(s2), _2 = new n.yGw();
    _2.extractRotation(h2);
    const g2 = new n.yGw();
    g2.copyPosition(h2);
    const v2 = g2.clone().invert().multiply(h2), A2 = _2.clone().invert().multiply(v2), b2 = o2, y2 = new n.yGw();
    if (0 === f2)
      y2.copy(_2).multiply(m2).multiply(A2).multiply(b2);
    else if (1 === f2)
      y2.copy(_2).multiply(A2).multiply(m2).multiply(b2);
    else {
      const e3 = new n.yGw().scale(new n.Pa4().setFromMatrixScale(p2)).clone().invert(), t3 = A2.clone().multiply(e3);
      y2.copy(_2).multiply(m2).multiply(t3).multiply(b2);
    }
    const x2 = u2.clone().invert(), w2 = a2.clone().invert();
    let E2 = t2.clone().multiply(c2).multiply(u2).multiply(r2).multiply(i2).multiply(s2).multiply(x2).multiply(l2).multiply(a2).multiply(o2).multiply(w2);
    const S2 = new n.yGw().copyPosition(E2), C2 = h2.clone().multiply(S2);
    return d2.copyPosition(C2), E2 = d2.clone().multiply(y2), E2.premultiply(h2.invert()), E2;
  }
  function Vm(e2) {
    const t2 = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
    return 6 === (e2 = e2 || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t2[0]) : t2[e2];
  }
  function Qm(e2) {
    return e2.split(",").map(function(e3) {
      return parseFloat(e3);
    });
  }
  function Hm(e2, t2, r2) {
    return void 0 === t2 && (t2 = 0), void 0 === r2 && (r2 = e2.byteLength), n.Zp0.decodeText(new Uint8Array(e2, t2, r2));
  }
  function Wm(e2, t2, r2) {
    return e2.slice(0, t2).concat(r2).concat(e2.slice(t2));
  }
  class qm extends r {
    constructor() {
      super(...arguments), this.dependencies = [to], this._importer = new ir(Tm, ["fbx"], true);
    }
    async onAdded(e2) {
      Js.Importers.push(this._importer);
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      Js.Importers.splice(Js.Importers.indexOf(this._importer), 1);
    }
  }
  qm.PluginType = "FBXLoadPlugin";
  const Xm = /* @__PURE__ */ new WeakMap();
  class Ym extends n.aNw {
    constructor(e2) {
      super(e2), this.libraryPath = "", this.libraryPending = null, this.libraryBinary = null, this.libraryConfig = {}, this.url = "", this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.workerConfig = {}, this.materials = [], this.warnings = [];
    }
    setLibraryPath(e2) {
      return this.libraryPath = e2, this;
    }
    setWorkerLimit(e2) {
      return this.workerLimit = e2, this;
    }
    load(e2, t2, r2, i2) {
      const s2 = new n.hH6(this.manager);
      s2.setPath(this.path), s2.setResponseType("arraybuffer"), s2.setRequestHeader(this.requestHeader), this.url = e2, s2.load(e2, (r3) => {
        if (Xm.has(r3))
          return Xm.get(r3).promise.then(t2).catch(i2);
        this.decodeObjects(r3, e2).then((e3) => {
          e3.userData.warnings = this.warnings, t2(e3);
        }).catch((e3) => i2(e3));
      }, r2, i2);
    }
    debug() {
      console.log("Task load: ", this.workerPool.map((e2) => e2._taskLoad));
    }
    decodeObjects(e2, t2) {
      let r2, n2;
      const i2 = e2.byteLength, s2 = this._getWorker(i2).then((t3) => (r2 = t3, n2 = this.workerNextTaskID++, new Promise((t4, i3) => {
        r2._callbacks[n2] = { resolve: t4, reject: i3 }, r2.postMessage({ type: "decode", id: n2, buffer: e2 }, [e2]);
      }))).then((e3) => this._createGeometry(e3.data)).catch((e3) => {
        throw e3;
      });
      return s2.catch(() => true).then(() => {
        r2 && n2 && this._releaseTask(r2, n2);
      }), Xm.set(e2, { url: t2, promise: s2 }), s2;
    }
    parse(e2, t2, r2) {
      this.decodeObjects(e2, "").then((e3) => {
        e3.userData.warnings = this.warnings, t2(e3);
      }).catch((e3) => r2(e3));
    }
    _compareMaterials(e2) {
      const t2 = {};
      t2.name = e2.name, t2.color = {}, t2.color.r = e2.color.r, t2.color.g = e2.color.g, t2.color.b = e2.color.b, t2.type = e2.type;
      for (let e3 = 0; e3 < this.materials.length; e3++) {
        const r2 = this.materials[e3], n2 = {};
        if (n2.name = r2.name, n2.color = {}, n2.color.r = r2.color.r, n2.color.g = r2.color.g, n2.color.b = r2.color.b, n2.type = r2.type, JSON.stringify(t2) === JSON.stringify(n2))
          return r2;
      }
      return this.materials.push(e2), e2;
    }
    _createMaterial(e2) {
      if (void 0 === e2)
        return new n.Wid({ color: new n.Ilk(1, 1, 1), metalness: 0.8, name: "default", side: 2 });
      const t2 = e2.diffuseColor, r2 = new n.Ilk(t2.r / 255, t2.g / 255, t2.b / 255);
      0 === t2.r && 0 === t2.g && 0 === t2.b && (r2.r = 1, r2.g = 1, r2.b = 1);
      const i2 = new n.Wid({ color: r2, name: e2.name, side: 2, transparent: e2.transparency > 0, opacity: 1 - e2.transparency }), s2 = new n.dpR();
      for (let t3 = 0; t3 < e2.textures.length; t3++) {
        const r3 = e2.textures[t3];
        if (null !== r3.image) {
          const e3 = s2.load(r3.image);
          switch (r3.type) {
            case "Diffuse":
              i2.map = e3;
              break;
            case "Bump":
              i2.bumpMap = e3;
              break;
            case "Transparency":
              i2.alphaMap = e3, i2.transparent = true;
              break;
            case "Emap":
              i2.envMap = e3;
          }
          e3.wrapS = 0 === r3.wrapU ? n.rpg : n.uWy, e3.wrapT = 0 === r3.wrapV ? n.rpg : n.uWy, e3.repeat.set(r3.repeat[0], r3.repeat[1]);
        }
      }
      return i2;
    }
    _createGeometry(e2) {
      const t2 = new n.Tme(), r2 = [], i2 = [], s2 = [];
      t2.userData.layers = e2.layers, t2.userData.groups = e2.groups, t2.userData.settings = e2.settings, t2.userData.objectType = "File3dm", t2.userData.materials = null, t2.name = this.url;
      let o2 = e2.objects;
      const a2 = e2.materials;
      for (let n2 = 0; n2 < o2.length; n2++) {
        const l2 = o2[n2], c2 = l2.attributes;
        switch (l2.objectType) {
          case "InstanceDefinition":
            i2.push(l2);
            break;
          case "InstanceReference":
            s2.push(l2);
            break;
          default:
            let n3;
            if (c2.materialIndex >= 0) {
              const e3 = a2[c2.materialIndex];
              let t3 = this._createMaterial(e3);
              t3 = this._compareMaterials(t3), n3 = this._createObject(l2, t3);
            } else {
              const e3 = this._createMaterial();
              n3 = this._createObject(l2, e3);
            }
            if (void 0 === n3)
              continue;
            const o3 = e2.layers[c2.layerIndex];
            n3.visible = !o3 || e2.layers[c2.layerIndex].visible, c2.isInstanceDefinitionObject ? r2.push(n3) : t2.add(n3);
        }
      }
      for (let e3 = 0; e3 < i2.length; e3++) {
        const a3 = i2[e3];
        o2 = [];
        for (let e4 = 0; e4 < a3.attributes.objectIds.length; e4++) {
          const t3 = a3.attributes.objectIds[e4];
          for (let e5 = 0; e5 < r2.length; e5++)
            t3 === r2[e5].userData.attributes.id && o2.push(r2[e5]);
        }
        for (let e4 = 0; e4 < s2.length; e4++) {
          const r3 = s2[e4];
          if (r3.geometry.parentIdefId === a3.attributes.id) {
            const e5 = new n.Tme(), i3 = r3.geometry.xform.array, s3 = new n.yGw();
            s3.set(i3[0], i3[1], i3[2], i3[3], i3[4], i3[5], i3[6], i3[7], i3[8], i3[9], i3[10], i3[11], i3[12], i3[13], i3[14], i3[15]), e5.applyMatrix4(s3);
            for (let t3 = 0; t3 < o2.length; t3++)
              e5.add(o2[t3].clone(true));
            t2.add(e5);
          }
        }
      }
      return t2.userData.materials = this.materials, t2;
    }
    _createObject(e2, t2) {
      const r2 = new n.s4_(), i2 = e2.attributes;
      let s2, o2, a2, l2;
      switch (e2.objectType) {
        case "Point":
        case "PointSet":
          s2 = r2.parse(e2.geometry), s2.attributes.hasOwnProperty("color") ? o2 = new n.UY4({ vertexColors: true, sizeAttenuation: false, size: 2 }) : (a2 = i2.drawColor, l2 = new n.Ilk(a2.r / 255, a2.g / 255, a2.b / 255), o2 = new n.UY4({ color: l2, sizeAttenuation: false, size: 2 })), o2 = this._compareMaterials(o2);
          const c2 = new n.woe(s2, o2);
          return c2.userData.attributes = i2, c2.userData.objectType = e2.objectType, i2.name && (c2.name = i2.name), c2;
        case "Mesh":
        case "Extrusion":
        case "SubD":
        case "Brep":
          if (null === e2.geometry)
            return;
          s2 = r2.parse(e2.geometry), s2.attributes.hasOwnProperty("color") && (t2.vertexColors = true), null === t2 && (t2 = this._createMaterial(), t2 = this._compareMaterials(t2));
          const u2 = new n.Kj0(s2, t2);
          return u2.castShadow = i2.castsShadows, u2.receiveShadow = i2.receivesShadows, u2.userData.attributes = i2, u2.userData.objectType = e2.objectType, i2.name && (u2.name = i2.name), u2;
        case "Curve":
          s2 = r2.parse(e2.geometry), a2 = i2.drawColor, l2 = new n.Ilk(a2.r / 255, a2.g / 255, a2.b / 255), o2 = new n.nls({ color: l2 }), o2 = this._compareMaterials(o2);
          const h2 = new n.x12(s2, o2);
          return h2.userData.attributes = i2, h2.userData.objectType = e2.objectType, i2.name && (h2.name = i2.name), h2;
        case "TextDot":
          s2 = e2.geometry;
          const p2 = document.createElement("canvas").getContext("2d"), d2 = `${s2.fontHeight}px ${s2.fontFace}`;
          p2.font = d2;
          const f2 = p2.measureText(s2.text).width + 10, m2 = s2.fontHeight + 10, _2 = window.devicePixelRatio;
          p2.canvas.width = f2 * _2, p2.canvas.height = m2 * _2, p2.canvas.style.width = f2 + "px", p2.canvas.style.height = m2 + "px", p2.setTransform(_2, 0, 0, _2, 0, 0), p2.font = d2, p2.textBaseline = "middle", p2.textAlign = "center", l2 = i2.drawColor, p2.fillStyle = `rgba(${l2.r},${l2.g},${l2.b},${l2.a})`, p2.fillRect(0, 0, f2, m2), p2.fillStyle = "white", p2.fillText(s2.text, f2 / 2, m2 / 2);
          const g2 = new n.ROQ(p2.canvas);
          g2.minFilter = n.wem, g2.wrapS = n.uWy, g2.wrapT = n.uWy, o2 = new n.xeV({ map: g2, depthTest: false });
          const v2 = new n.jyi(o2);
          return v2.position.set(s2.point[0], s2.point[1], s2.point[2]), v2.scale.set(f2 / 10, m2 / 10, 1), v2.userData.attributes = i2, v2.userData.objectType = e2.objectType, i2.name && (v2.name = i2.name), v2;
        case "Light":
          let A2;
          switch (s2 = e2.geometry, s2.lightStyle.name) {
            case "LightStyle_WorldPoint":
              A2 = new n.cek(), A2.castShadow = i2.castsShadows, A2.position.set(s2.location[0], s2.location[1], s2.location[2]), A2.shadow.normalBias = 0.1;
              break;
            case "LightStyle_WorldSpot":
              A2 = new n.PMe(), A2.castShadow = i2.castsShadows, A2.position.set(s2.location[0], s2.location[1], s2.location[2]), A2.target.position.set(s2.direction[0], s2.direction[1], s2.direction[2]), A2.angle = s2.spotAngleRadians, A2.shadow.normalBias = 0.1;
              break;
            case "LightStyle_WorldRectangular":
              A2 = new n.T_f();
              const e3 = Math.abs(s2.width[2]), t3 = Math.abs(s2.length[0]);
              A2.position.set(s2.location[0] - t3 / 2, s2.location[1], s2.location[2] - e3 / 2), A2.height = t3, A2.width = e3, A2.lookAt(new n.Pa4(s2.direction[0], s2.direction[1], s2.direction[2]));
              break;
            case "LightStyle_WorldDirectional":
              A2 = new n.Ox3(), A2.castShadow = i2.castsShadows, A2.position.set(s2.location[0], s2.location[1], s2.location[2]), A2.target.position.set(s2.direction[0], s2.direction[1], s2.direction[2]), A2.shadow.normalBias = 0.1;
          }
          return A2 && (A2.intensity = s2.intensity, a2 = s2.diffuse, l2 = new n.Ilk(a2.r / 255, a2.g / 255, a2.b / 255), A2.color = l2, A2.userData.attributes = i2, A2.userData.objectType = e2.objectType), A2;
      }
    }
    _initLibrary() {
      if (!this.libraryPending) {
        const e2 = new n.hH6(this.manager);
        e2.setPath(this.libraryPath);
        const t2 = new Promise((t3, r3) => {
          e2.load("rhino3dm.js", t3, void 0, r3);
        }), r2 = new n.hH6(this.manager);
        r2.setPath(this.libraryPath), r2.setResponseType("arraybuffer");
        const i2 = new Promise((e3, t3) => {
          r2.load("rhino3dm.wasm", e3, void 0, t3);
        });
        this.libraryPending = Promise.all([t2, i2]).then(([e3, t3]) => {
          this.libraryConfig.wasmBinary = t3;
          const r3 = Km.toString(), n2 = ["/* rhino3dm.js */", e3, "/* worker */", r3.substring(r3.indexOf("{") + 1, r3.lastIndexOf("}"))].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([n2]));
        });
      }
      return this.libraryPending;
    }
    _getWorker(e2) {
      return this._initLibrary().then(() => {
        if (this.workerPool.length < this.workerLimit) {
          const e3 = new Worker(this.workerSourceURL);
          e3._callbacks = {}, e3._taskCosts = {}, e3._taskLoad = 0, e3.postMessage({ type: "init", libraryConfig: this.libraryConfig }), e3.onmessage = (t3) => {
            const r2 = t3.data;
            switch (r2.type) {
              case "warning":
                this.warnings.push(r2.data), console.warn(r2.data);
                break;
              case "decode":
                e3._callbacks[r2.id].resolve(r2);
                break;
              case "error":
                e3._callbacks[r2.id].reject(r2);
                break;
              default:
                console.error('THREE.Rhino3dmLoader: Unexpected message, "' + r2.type + '"');
            }
          }, this.workerPool.push(e3);
        } else
          this.workerPool.sort(function(e3, t3) {
            return e3._taskLoad > t3._taskLoad ? -1 : 1;
          });
        const t2 = this.workerPool[this.workerPool.length - 1];
        return t2._taskLoad += e2, t2;
      });
    }
    _releaseTask(e2, t2) {
      e2._taskLoad -= e2._taskCosts[t2], delete e2._callbacks[t2], delete e2._taskCosts[t2];
    }
    dispose() {
      for (let e2 = 0; e2 < this.workerPool.length; ++e2)
        this.workerPool[e2].terminate();
      return this.workerPool.length = 0, this;
    }
  }
  function Km() {
    let e2, t2, r2, n2;
    function i2(e3, t3) {
      const i3 = e3.geometry(), a2 = e3.attributes();
      let l2, c2, u2, h2, p2, d2 = i3.objectType;
      switch (d2) {
        case r2.ObjectType.Curve:
          const e4 = o2(i3, 100);
          u2 = {}, c2 = {}, h2 = {}, u2.itemSize = 3, u2.type = "Float32Array", u2.array = [];
          for (let t4 = 0; t4 < e4.length; t4++)
            u2.array.push(e4[t4][0]), u2.array.push(e4[t4][1]), u2.array.push(e4[t4][2]);
          c2.position = u2, h2.attributes = c2, l2 = { data: h2 };
          break;
        case r2.ObjectType.Point:
          const f2 = i3.location;
          u2 = {};
          const m2 = {};
          c2 = {}, h2 = {}, u2.itemSize = 3, u2.type = "Float32Array", u2.array = [f2[0], f2[1], f2[2]];
          const _2 = a2.drawColor(t3);
          m2.itemSize = 3, m2.type = "Float32Array", m2.array = [_2.r / 255, _2.g / 255, _2.b / 255], c2.position = u2, c2.color = m2, h2.attributes = c2, l2 = { data: h2 };
          break;
        case r2.ObjectType.PointSet:
        case r2.ObjectType.Mesh:
          l2 = i3.toThreejsJSON();
          break;
        case r2.ObjectType.Brep:
          const g2 = i3.faces();
          p2 = new r2.Mesh();
          for (let e5 = 0; e5 < g2.count; e5++) {
            const t4 = g2.get(e5), n3 = t4.getMesh(r2.MeshType.Any);
            n3 && (p2.append(n3), n3.delete()), t4.delete();
          }
          p2.faces().count > 0 && (p2.compact(), l2 = p2.toThreejsJSON(), g2.delete()), p2.delete();
          break;
        case r2.ObjectType.Extrusion:
          p2 = i3.getMesh(r2.MeshType.Any), p2 && (l2 = p2.toThreejsJSON(), p2.delete());
          break;
        case r2.ObjectType.TextDot:
          l2 = s2(i3);
          break;
        case r2.ObjectType.Light:
          l2 = s2(i3), "LightStyle_WorldLinear" === l2.lightStyle.name && self.postMessage({ type: "warning", id: n2, data: { message: `THREE.3DMLoader: No conversion exists for ${d2.constructor.name} ${l2.lightStyle.name}`, type: "no conversion", guid: a2.id } });
          break;
        case r2.ObjectType.InstanceReference:
          l2 = s2(i3), l2.xform = s2(i3.xform), l2.xform.array = i3.xform.toFloatArray(true);
          break;
        case r2.ObjectType.SubD:
          i3.subdivide(3), p2 = r2.Mesh.createFromSubDControlNet(i3), p2 && (l2 = p2.toThreejsJSON(), p2.delete());
          break;
        default:
          self.postMessage({ type: "warning", id: n2, data: { message: `THREE.3DMLoader: Conversion not implemented for ${d2.constructor.name}`, type: "not implemented", guid: a2.id } });
      }
      if (l2)
        return c2 = s2(a2), c2.geometry = s2(i3), a2.groupCount > 0 && (c2.groupIds = a2.getGroupList()), a2.userStringCount > 0 && (c2.userStrings = a2.getUserStrings()), i3.userStringCount > 0 && (c2.geometry.userStrings = i3.getUserStrings()), c2.drawColor = a2.drawColor(t3), d2 = d2.constructor.name, d2 = d2.substring(11, d2.length), { geometry: l2, attributes: c2, objectType: d2 };
      self.postMessage({ type: "warning", id: n2, data: { message: `THREE.3DMLoader: ${d2.constructor.name} has no associated mesh geometry.`, type: "missing mesh", guid: a2.id } });
    }
    function s2(e3) {
      const t3 = {};
      for (const r3 in e3) {
        const n3 = e3[r3];
        "function" != typeof n3 && ("object" == typeof n3 && null !== n3 && n3.hasOwnProperty("constructor") ? t3[r3] = { name: n3.constructor.name, value: n3.value } : t3[r3] = n3);
      }
      return t3;
    }
    function o2(e3, t3) {
      let n3 = t3, i3 = [];
      const s3 = [];
      if (e3 instanceof r2.LineCurve)
        return [e3.pointAtStart, e3.pointAtEnd];
      if (e3 instanceof r2.PolylineCurve) {
        n3 = e3.pointCount;
        for (let t4 = 0; t4 < n3; t4++)
          i3.push(e3.point(t4));
        return i3;
      }
      if (e3 instanceof r2.PolyCurve) {
        const t4 = e3.segmentCount;
        for (let r3 = 0; r3 < t4; r3++) {
          const t5 = e3.segmentCurve(r3), s4 = o2(t5, n3);
          i3 = i3.concat(s4), t5.delete();
        }
        return i3;
      }
      if (e3 instanceof r2.ArcCurve && (n3 = Math.floor(e3.angleDegrees / 5), n3 = n3 < 2 ? 2 : n3), e3 instanceof r2.NurbsCurve && 1 === e3.degree) {
        const t4 = e3.tryGetPolyline();
        for (let e4 = 0; e4 < t4.count; e4++)
          i3.push(t4.get(e4));
        return t4.delete(), i3;
      }
      const a2 = e3.domain, l2 = n3 - 1;
      for (let t4 = 0; t4 < n3; t4++) {
        const r3 = a2[0] + t4 / l2 * (a2[1] - a2[0]);
        if (r3 === a2[0] || r3 === a2[1]) {
          s3.push(r3);
          continue;
        }
        const n4 = e3.tangentAt(r3), i4 = e3.tangentAt(s3.slice(-1)[0]), o3 = n4[0] * n4[0] + n4[1] * n4[1] + n4[2] * n4[2], c2 = i4[0] * i4[0] + i4[1] * i4[1] + i4[2] * i4[2], u2 = Math.sqrt(o3 * c2);
        let h2;
        if (0 === u2)
          h2 = Math.PI / 2;
        else {
          const e4 = (n4.x * i4.x + n4.y * i4.y + n4.z * i4.z) / u2;
          h2 = Math.acos(Math.max(-1, Math.min(1, e4)));
        }
        h2 < 0.1 || s3.push(r3);
      }
      return i3 = s3.map((t4) => e3.pointAt(t4)), i3;
    }
    onmessage = function(o3) {
      const a2 = o3.data;
      switch (a2.type) {
        case "init":
          t2 = a2.libraryConfig;
          const o4 = t2.wasmBinary;
          let l2;
          e2 = new Promise(function(e3) {
            l2 = { wasmBinary: o4, onRuntimeInitialized: e3 }, rhino3dm(l2);
          }).then(() => {
            r2 = l2;
          });
          break;
        case "decode":
          n2 = a2.id;
          const c2 = a2.buffer;
          e2.then(() => {
            try {
              const e3 = function(e4, t3) {
                const r3 = new Uint8Array(t3), o5 = e4.File3dm.fromByteArray(r3), a3 = [], l3 = [], c3 = [], u2 = [], h2 = [], p2 = [], d2 = [], f2 = o5.objects(), m2 = f2.count;
                for (let e5 = 0; e5 < m2; e5++) {
                  const t4 = f2.get(e5), r4 = i2(t4, o5);
                  t4.delete(), r4 && a3.push(r4);
                }
                for (let e5 = 0; e5 < o5.instanceDefinitions().count(); e5++) {
                  const t4 = o5.instanceDefinitions().get(e5), r4 = s2(t4);
                  r4.objectIds = t4.getObjectIds(), a3.push({ geometry: null, attributes: r4, objectType: "InstanceDefinition" });
                }
                const _2 = [e4.TextureType.Diffuse, e4.TextureType.Bump, e4.TextureType.Transparency, e4.TextureType.Opacity, e4.TextureType.Emap], g2 = [e4.TextureType.PBR_BaseColor, e4.TextureType.PBR_Subsurface, e4.TextureType.PBR_SubsurfaceScattering, e4.TextureType.PBR_SubsurfaceScatteringRadius, e4.TextureType.PBR_Metallic, e4.TextureType.PBR_Specular, e4.TextureType.PBR_SpecularTint, e4.TextureType.PBR_Roughness, e4.TextureType.PBR_Anisotropic, e4.TextureType.PBR_Anisotropic_Rotation, e4.TextureType.PBR_Sheen, e4.TextureType.PBR_SheenTint, e4.TextureType.PBR_Clearcoat, e4.TextureType.PBR_ClearcoatBump, e4.TextureType.PBR_ClearcoatRoughness, e4.TextureType.PBR_OpacityIor, e4.TextureType.PBR_OpacityRoughness, e4.TextureType.PBR_Emission, e4.TextureType.PBR_AmbientOcclusion, e4.TextureType.PBR_Displacement];
                for (let e5 = 0; e5 < o5.materials().count(); e5++) {
                  const t4 = o5.materials().get(e5), r4 = t4.physicallyBased();
                  let i3 = s2(t4);
                  const a4 = [];
                  for (let e6 = 0; e6 < _2.length; e6++) {
                    const r5 = t4.getTexture(_2[e6]);
                    if (r5) {
                      let t5 = _2[e6].constructor.name;
                      t5 = t5.substring(12, t5.length);
                      const i4 = { type: t5 }, s3 = o5.getEmbeddedFileAsBase64(r5.fileName);
                      i4.wrapU = r5.wrapU, i4.wrapV = r5.wrapV, i4.wrapW = r5.wrapW;
                      const l4 = r5.uvwTransform.toFloatArray(true);
                      i4.repeat = [l4[0], l4[5]], s3 ? i4.image = "data:image/png;base64," + s3 : (self.postMessage({ type: "warning", id: n2, data: { message: `THREE.3DMLoader: Image for ${t5} texture not embedded in file.`, type: "missing resource" } }), i4.image = null), a4.push(i4), r5.delete();
                    }
                  }
                  if (i3.textures = a4, r4.supported) {
                    for (let e7 = 0; e7 < g2.length; e7++) {
                      const r5 = t4.getTexture(g2[e7]);
                      if (r5) {
                        const t5 = o5.getEmbeddedFileAsBase64(r5.fileName);
                        let n3 = g2[e7].constructor.name;
                        n3 = n3.substring(12, n3.length);
                        const i4 = { type: n3, image: "data:image/png;base64," + t5 };
                        a4.push(i4), r5.delete();
                      }
                    }
                    const e6 = s2(t4.physicallyBased());
                    i3 = Object.assign(e6, i3);
                  }
                  l3.push(i3), t4.delete(), r4.delete();
                }
                for (let e5 = 0; e5 < o5.layers().count(); e5++) {
                  const t4 = o5.layers().get(e5), r4 = s2(t4);
                  c3.push(r4), t4.delete();
                }
                for (let e5 = 0; e5 < o5.views().count(); e5++) {
                  const t4 = o5.views().get(e5), r4 = s2(t4);
                  u2.push(r4), t4.delete();
                }
                for (let e5 = 0; e5 < o5.namedViews().count(); e5++) {
                  const t4 = o5.namedViews().get(e5), r4 = s2(t4);
                  h2.push(r4), t4.delete();
                }
                for (let e5 = 0; e5 < o5.groups().count(); e5++) {
                  const t4 = o5.groups().get(e5), r4 = s2(t4);
                  p2.push(r4), t4.delete();
                }
                const v2 = s2(o5.settings()), A2 = o5.strings().count();
                for (let e5 = 0; e5 < A2; e5++)
                  d2.push(o5.strings().get(e5));
                return o5.delete(), { objects: a3, materials: l3, layers: c3, views: u2, namedViews: h2, groups: p2, strings: d2, settings: v2 };
              }(r2, c2);
              self.postMessage({ type: "decode", id: a2.id, data: e3 });
            } catch (e3) {
              self.postMessage({ type: "error", id: a2.id, error: e3 });
            }
          });
      }
    };
  }
  class Jm extends Ym {
    constructor(e2) {
      super(e2), this.setLibraryPath("https://cdn.jsdelivr.net/npm/rhino3dm@7.11.1/");
    }
    async loadAsync(e2, t2) {
      return await super.loadAsync(e2, t2);
    }
  }
  class Zm extends r {
    constructor() {
      super(...arguments), this.dependencies = [to], this._importer = new ir(Jm, ["3dm"], true);
    }
    async onAdded(e2) {
      Js.Importers.push(this._importer);
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      Js.Importers.splice(Js.Importers.indexOf(this._importer), 1);
    }
  }
  Zm.PluginType = "Rhino3dmLoadPlugin";
  class $m extends r {
    constructor() {
      super(...arguments), this.dependencies = [to];
    }
    async onAdded(e2) {
      const t2 = document.createElement("script");
      t2.type = "module", t2.innerHTML = "\nimport { MeshoptDecoder } from 'https://cdn.jsdelivr.net/gh/zeux/meshoptimizer@master/js/meshopt_decoder.module.js'\nwindow.MeshoptDecoder = MeshoptDecoder\n", document.head.appendChild(t2), this._script = t2;
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      this._script && (document.head.removeChild(this._script), this._script = void 0);
    }
  }
  $m.PluginType = "GLTFMeshOptPlugin";
  class e_ extends n.aNw {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, i2) {
      const s2 = this, o2 = new n.hH6(this.manager);
      o2.setPath(this.path), o2.setResponseType("arraybuffer"), o2.setRequestHeader(this.requestHeader), o2.setWithCredentials(this.withCredentials), o2.load(e2, function(r3) {
        try {
          t2(s2.parse(r3));
        } catch (t3) {
          i2 ? i2(t3) : console.error(t3), s2.manager.itemError(e2);
        }
      }, r2, i2);
    }
    parse(e2) {
      function t2(e3, t3, r3) {
        for (let n2 = 0, i3 = e3.length; n2 < i3; n2++)
          if (e3[n2] !== t3.getUint8(r3 + n2))
            return false;
        return true;
      }
      const r2 = function(e3) {
        if ("string" == typeof e3) {
          const t3 = new Uint8Array(e3.length);
          for (let r3 = 0; r3 < e3.length; r3++)
            t3[r3] = 255 & e3.charCodeAt(r3);
          return t3.buffer || t3;
        }
        return e3;
      }(e2);
      return function(e3) {
        const r3 = new DataView(e3);
        if (84 + 50 * r3.getUint32(80, true) === r3.byteLength)
          return true;
        const n2 = [115, 111, 108, 105, 100];
        for (let e4 = 0; e4 < 5; e4++)
          if (t2(n2, r3, e4))
            return false;
        return true;
      }(r2) ? function(e3) {
        const t3 = new DataView(e3), r3 = t3.getUint32(80, true);
        let i3, s2, o2, a2, l2, c2, u2, h2, p2 = false;
        for (let e4 = 0; e4 < 70; e4++)
          1129270351 == t3.getUint32(e4, false) && 82 == t3.getUint8(e4 + 4) && 61 == t3.getUint8(e4 + 5) && (p2 = true, a2 = new Float32Array(3 * r3 * 3), l2 = t3.getUint8(e4 + 6) / 255, c2 = t3.getUint8(e4 + 7) / 255, u2 = t3.getUint8(e4 + 8) / 255, h2 = t3.getUint8(e4 + 9) / 255);
        const d2 = new n.u9r(), f2 = new Float32Array(3 * r3 * 3), m2 = new Float32Array(3 * r3 * 3);
        for (let e4 = 0; e4 < r3; e4++) {
          const r4 = 84 + 50 * e4, n2 = t3.getFloat32(r4, true), h3 = t3.getFloat32(r4 + 4, true), d3 = t3.getFloat32(r4 + 8, true);
          if (p2) {
            const e5 = t3.getUint16(r4 + 48, true);
            0 == (32768 & e5) ? (i3 = (31 & e5) / 31, s2 = (e5 >> 5 & 31) / 31, o2 = (e5 >> 10 & 31) / 31) : (i3 = l2, s2 = c2, o2 = u2);
          }
          for (let l3 = 1; l3 <= 3; l3++) {
            const c3 = r4 + 12 * l3, u3 = 3 * e4 * 3 + 3 * (l3 - 1);
            f2[u3] = t3.getFloat32(c3, true), f2[u3 + 1] = t3.getFloat32(c3 + 4, true), f2[u3 + 2] = t3.getFloat32(c3 + 8, true), m2[u3] = n2, m2[u3 + 1] = h3, m2[u3 + 2] = d3, p2 && (a2[u3] = i3, a2[u3 + 1] = s2, a2[u3 + 2] = o2);
          }
        }
        return d2.setAttribute("position", new n.TlE(f2, 3)), d2.setAttribute("normal", new n.TlE(m2, 3)), p2 && (d2.setAttribute("color", new n.TlE(a2, 3)), d2.hasColors = true, d2.alpha = h2), d2;
      }(r2) : function(e3) {
        const t3 = new n.u9r(), r3 = /solid([\s\S]*?)endsolid/g, i3 = /facet([\s\S]*?)endfacet/g;
        let s2 = 0;
        const o2 = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source, a2 = new RegExp("vertex" + o2 + o2 + o2, "g"), l2 = new RegExp("normal" + o2 + o2 + o2, "g"), c2 = [], u2 = [], h2 = new n.Pa4();
        let p2, d2 = 0, f2 = 0, m2 = 0;
        for (; null !== (p2 = r3.exec(e3)); ) {
          f2 = m2;
          const e4 = p2[0];
          for (; null !== (p2 = i3.exec(e4)); ) {
            let e5 = 0, t4 = 0;
            const r5 = p2[0];
            for (; null !== (p2 = l2.exec(r5)); )
              h2.x = parseFloat(p2[1]), h2.y = parseFloat(p2[2]), h2.z = parseFloat(p2[3]), t4++;
            for (; null !== (p2 = a2.exec(r5)); )
              c2.push(parseFloat(p2[1]), parseFloat(p2[2]), parseFloat(p2[3])), u2.push(h2.x, h2.y, h2.z), e5++, m2++;
            1 !== t4 && console.error("THREE.STLLoader: Something isn't right with the normal of face number " + s2), 3 !== e5 && console.error("THREE.STLLoader: Something isn't right with the vertices of face number " + s2), s2++;
          }
          const r4 = f2, n2 = m2 - f2;
          t3.addGroup(r4, n2, d2), d2++;
        }
        return t3.setAttribute("position", new n.a$l(c2, 3)), t3.setAttribute("normal", new n.a$l(u2, 3)), t3;
      }("string" != typeof (i2 = e2) ? n.Zp0.decodeText(new Uint8Array(i2)) : i2);
      var i2;
    }
  }
  class t_ extends r {
    constructor() {
      super(...arguments), this.dependencies = [to];
    }
    async onAdded(e2) {
      this._importer || (this._importer = new ir(e_, ["stl"], true)), Js.Importers.push(this._importer);
    }
    async onDispose(e2) {
      this._importer = void 0;
    }
    async onRemove(e2) {
      this._importer && Js.Importers.splice(Js.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }
  }
  t_.PluginType = "STLLoadPlugin";
  class r_ extends n.aNw {
    constructor(e2) {
      super(e2);
    }
    load(e2, t2, r2, i2) {
      const s2 = this, o2 = "" === this.path ? n.Zp0.extractUrlBase(e2) : this.path, a2 = new n.hH6(this.manager);
      a2.setPath(this.path), a2.setRequestHeader(this.requestHeader), a2.setWithCredentials(this.withCredentials), a2.load(e2, function(r3) {
        try {
          t2(s2.parse(r3, o2));
        } catch (t3) {
          i2 ? i2(t3) : console.error(t3), s2.manager.itemError(e2);
        }
      }, r2, i2);
    }
    setMaterialOptions(e2) {
      return this.materialOptions = e2, this;
    }
    parse(e2, t2) {
      const r2 = e2.split("\n");
      let n2 = {};
      const i2 = /\s+/, s2 = {};
      for (let e3 = 0; e3 < r2.length; e3++) {
        let t3 = r2[e3];
        if (t3 = t3.trim(), 0 === t3.length || "#" === t3.charAt(0))
          continue;
        const o3 = t3.indexOf(" ");
        let a2 = o3 >= 0 ? t3.substring(0, o3) : t3;
        a2 = a2.toLowerCase();
        let l2 = o3 >= 0 ? t3.substring(o3 + 1) : "";
        if (l2 = l2.trim(), "newmtl" === a2)
          n2 = { name: l2 }, s2[l2] = n2;
        else if ("ka" === a2 || "kd" === a2 || "ks" === a2 || "ke" === a2) {
          const e4 = l2.split(i2, 3);
          n2[a2] = [parseFloat(e4[0]), parseFloat(e4[1]), parseFloat(e4[2])];
        } else
          n2[a2] = l2;
      }
      const o2 = new n_(this.resourcePath || t2, this.materialOptions);
      return o2.setCrossOrigin(this.crossOrigin), o2.setManager(this.manager), o2.setMaterials(s2), o2;
    }
  }
  class n_ {
    constructor(e2 = "", t2 = {}) {
      this.baseUrl = e2, this.options = t2, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = void 0 !== this.options.side ? this.options.side : n.Wl3, this.wrap = void 0 !== this.options.wrap ? this.options.wrap : n.rpg;
    }
    setCrossOrigin(e2) {
      return this.crossOrigin = e2, this;
    }
    setManager(e2) {
      this.manager = e2;
    }
    setMaterials(e2) {
      this.materialsInfo = this.convert(e2), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
    }
    convert(e2) {
      if (!this.options)
        return e2;
      const t2 = {};
      for (const r2 in e2) {
        const n2 = e2[r2], i2 = {};
        t2[r2] = i2;
        for (const e3 in n2) {
          let t3 = true, r3 = n2[e3];
          const s2 = e3.toLowerCase();
          switch (s2) {
            case "kd":
            case "ka":
            case "ks":
              this.options && this.options.normalizeRGB && (r3 = [r3[0] / 255, r3[1] / 255, r3[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === r3[0] && 0 === r3[1] && 0 === r3[2] && (t3 = false);
          }
          t3 && (i2[s2] = r3);
        }
      }
      return t2;
    }
    async preload() {
      for (const e2 in this.materialsInfo)
        await this.create(e2);
    }
    getIndex(e2) {
      return this.nameLookup[e2];
    }
    async getAsArray() {
      let e2 = 0;
      for (const t2 in this.materialsInfo)
        this.materialsArray[e2] = await this.create(t2), this.nameLookup[t2] = e2, e2++;
      return this.materialsArray;
    }
    async create(e2) {
      return void 0 === this.materials[e2] && await this.createMaterial_(e2), this.materials[e2];
    }
    async createMaterial_(e2) {
      const t2 = this, r2 = this.materialsInfo[e2], i2 = { name: e2, side: this.side };
      async function s2(e3, r3) {
        if (i2[e3])
          return;
        const n2 = t2.getTextureParams(r3, i2);
        return new Promise((r4, s3) => {
          let o3 = false, a3 = () => !o3 && (o3 = true) && r4();
          const l2 = t2.loadTexture((c2 = t2.baseUrl, "string" != typeof (u2 = n2.url) || "" === u2 ? "" : /^https?:\/\//i.test(u2) ? u2 : c2 + u2), void 0, (t3) => {
            i2[e3] = t3, a3();
          }, void 0, a3);
          var c2, u2;
          setTimeout(a3, 50), l2.repeat.copy(n2.scale), l2.offset.copy(n2.offset), l2.wrapS = t2.wrap, l2.wrapT = t2.wrap;
        });
      }
      const o2 = Array.from(Object.keys(r2 || {}));
      let a2 = o2.includes("d") || o2.includes("D");
      for (const e3 of o2) {
        const t3 = r2[e3];
        let o3;
        if ("" !== t3)
          switch (e3.toLowerCase()) {
            case "kd":
              i2.color = new n.Ilk().fromArray(t3);
              break;
            case "ks":
              i2.specular = new n.Ilk().fromArray(t3);
              break;
            case "ke":
              i2.emissive = new n.Ilk().fromArray(t3);
              break;
            case "map_kd":
              await s2("map", t3);
              break;
            case "map_ks":
              await s2("specularMap", t3);
              break;
            case "map_ke":
              await s2("emissiveMap", t3);
              break;
            case "norm":
              await s2("normalMap", t3);
              break;
            case "map_bump":
            case "bump":
              await s2("bumpMap", t3);
              break;
            case "map_d":
              await s2("alphaMap", t3), i2.transparent = true;
              break;
            case "ns":
              i2.shininess = parseFloat(t3);
              break;
            case "d":
              o3 = parseFloat(t3), o3 < 1 && (i2.opacity = o3, i2.transparent = true);
              break;
            case "tr":
              if (a2)
                break;
              o3 = parseFloat(t3), this.options && this.options.invertTrProperty && (o3 = 1 - o3), o3 > 0 && (i2.opacity = 1 - o3, i2.transparent = true);
          }
      }
      return this.materials[e2] = new n.xoR(i2), this.materials[e2];
    }
    getTextureParams(e2, t2) {
      const r2 = { scale: new n.FM8(1, 1), offset: new n.FM8(0, 0) }, i2 = e2.split(/\s+/);
      let s2;
      return s2 = i2.indexOf("-bm"), s2 >= 0 && (t2.bumpScale = parseFloat(i2[s2 + 1]), i2.splice(s2, 2)), s2 = i2.indexOf("-s"), s2 >= 0 && (r2.scale.set(parseFloat(i2[s2 + 1]), parseFloat(i2[s2 + 2])), i2.splice(s2, 4)), s2 = i2.indexOf("-o"), s2 >= 0 && (r2.offset.set(parseFloat(i2[s2 + 1]), parseFloat(i2[s2 + 2])), i2.splice(s2, 4)), r2.url = i2.join(" ").trim(), r2;
    }
    loadTexture(e2, t2, r2, i2, s2) {
      const o2 = void 0 !== this.manager ? this.manager : n.tEQ;
      let a2 = o2.getHandler(e2);
      null === a2 && (a2 = new n.dpR(o2)), a2.setCrossOrigin && a2.setCrossOrigin(this.crossOrigin);
      const l2 = a2.load(e2, r2, i2, s2);
      return void 0 !== t2 && (l2.mapping = t2), l2;
    }
  }
  const i_ = /^[og]\s*(.+)?/, s_ = /^mtllib /, o_ = /^usemtl /, a_ = /^usemap /, l_ = new n.Pa4(), c_ = new n.Pa4(), u_ = new n.Pa4(), h_ = new n.Pa4(), p_ = new n.Pa4();
  function d_() {
    const e2 = { objects: [], object: {}, vertices: [], normals: [], colors: [], uvs: [], materials: {}, materialLibraries: [], startObject: function(e3, t2) {
      if (this.object && false === this.object.fromDeclaration)
        return this.object.name = e3, void (this.object.fromDeclaration = false !== t2);
      const r2 = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
      if (this.object && "function" == typeof this.object._finalize && this.object._finalize(true), this.object = { name: e3 || "", fromDeclaration: false !== t2, geometry: { vertices: [], normals: [], colors: [], uvs: [], hasUVIndices: false }, materials: [], smooth: true, startMaterial: function(e4, t3) {
        const r3 = this._finalize(false);
        r3 && (r3.inherited || r3.groupCount <= 0) && this.materials.splice(r3.index, 1);
        const n2 = { index: this.materials.length, name: e4 || "", mtllib: Array.isArray(t3) && t3.length > 0 ? t3[t3.length - 1] : "", smooth: void 0 !== r3 ? r3.smooth : this.smooth, groupStart: void 0 !== r3 ? r3.groupEnd : 0, groupEnd: -1, groupCount: -1, inherited: false, clone: function(e5) {
          const t4 = { index: "number" == typeof e5 ? e5 : this.index, name: this.name, mtllib: this.mtllib, smooth: this.smooth, groupStart: 0, groupEnd: -1, groupCount: -1, inherited: false };
          return t4.clone = this.clone.bind(t4), t4;
        } };
        return this.materials.push(n2), n2;
      }, currentMaterial: function() {
        if (this.materials.length > 0)
          return this.materials[this.materials.length - 1];
      }, _finalize: function(e4) {
        const t3 = this.currentMaterial();
        if (t3 && -1 === t3.groupEnd && (t3.groupEnd = this.geometry.vertices.length / 3, t3.groupCount = t3.groupEnd - t3.groupStart, t3.inherited = false), e4 && this.materials.length > 1)
          for (let e5 = this.materials.length - 1; e5 >= 0; e5--)
            this.materials[e5].groupCount <= 0 && this.materials.splice(e5, 1);
        return e4 && 0 === this.materials.length && this.materials.push({ name: "", smooth: this.smooth }), t3;
      } }, r2 && r2.name && "function" == typeof r2.clone) {
        const e4 = r2.clone(0);
        e4.inherited = true, this.object.materials.push(e4);
      }
      this.objects.push(this.object);
    }, finalize: function() {
      this.object && "function" == typeof this.object._finalize && this.object._finalize(true);
    }, parseVertexIndex: function(e3, t2) {
      const r2 = parseInt(e3, 10);
      return 3 * (r2 >= 0 ? r2 - 1 : r2 + t2 / 3);
    }, parseNormalIndex: function(e3, t2) {
      const r2 = parseInt(e3, 10);
      return 3 * (r2 >= 0 ? r2 - 1 : r2 + t2 / 3);
    }, parseUVIndex: function(e3, t2) {
      const r2 = parseInt(e3, 10);
      return 2 * (r2 >= 0 ? r2 - 1 : r2 + t2 / 2);
    }, addVertex: function(e3, t2, r2) {
      const n2 = this.vertices, i2 = this.object.geometry.vertices;
      i2.push(n2[e3 + 0], n2[e3 + 1], n2[e3 + 2]), i2.push(n2[t2 + 0], n2[t2 + 1], n2[t2 + 2]), i2.push(n2[r2 + 0], n2[r2 + 1], n2[r2 + 2]);
    }, addVertexPoint: function(e3) {
      const t2 = this.vertices;
      this.object.geometry.vertices.push(t2[e3 + 0], t2[e3 + 1], t2[e3 + 2]);
    }, addVertexLine: function(e3) {
      const t2 = this.vertices;
      this.object.geometry.vertices.push(t2[e3 + 0], t2[e3 + 1], t2[e3 + 2]);
    }, addNormal: function(e3, t2, r2) {
      const n2 = this.normals, i2 = this.object.geometry.normals;
      i2.push(n2[e3 + 0], n2[e3 + 1], n2[e3 + 2]), i2.push(n2[t2 + 0], n2[t2 + 1], n2[t2 + 2]), i2.push(n2[r2 + 0], n2[r2 + 1], n2[r2 + 2]);
    }, addFaceNormal: function(e3, t2, r2) {
      const n2 = this.vertices, i2 = this.object.geometry.normals;
      l_.fromArray(n2, e3), c_.fromArray(n2, t2), u_.fromArray(n2, r2), p_.subVectors(u_, c_), h_.subVectors(l_, c_), p_.cross(h_), p_.normalize(), i2.push(p_.x, p_.y, p_.z), i2.push(p_.x, p_.y, p_.z), i2.push(p_.x, p_.y, p_.z);
    }, addColor: function(e3, t2, r2) {
      const n2 = this.colors, i2 = this.object.geometry.colors;
      void 0 !== n2[e3] && i2.push(n2[e3 + 0], n2[e3 + 1], n2[e3 + 2]), void 0 !== n2[t2] && i2.push(n2[t2 + 0], n2[t2 + 1], n2[t2 + 2]), void 0 !== n2[r2] && i2.push(n2[r2 + 0], n2[r2 + 1], n2[r2 + 2]);
    }, addUV: function(e3, t2, r2) {
      const n2 = this.uvs, i2 = this.object.geometry.uvs;
      i2.push(n2[e3 + 0], n2[e3 + 1]), i2.push(n2[t2 + 0], n2[t2 + 1]), i2.push(n2[r2 + 0], n2[r2 + 1]);
    }, addDefaultUV: function() {
      const e3 = this.object.geometry.uvs;
      e3.push(0, 0), e3.push(0, 0), e3.push(0, 0);
    }, addUVLine: function(e3) {
      const t2 = this.uvs;
      this.object.geometry.uvs.push(t2[e3 + 0], t2[e3 + 1]);
    }, addFace: function(e3, t2, r2, n2, i2, s2, o2, a2, l2) {
      const c2 = this.vertices.length;
      let u2 = this.parseVertexIndex(e3, c2), h2 = this.parseVertexIndex(t2, c2), p2 = this.parseVertexIndex(r2, c2);
      if (this.addVertex(u2, h2, p2), this.addColor(u2, h2, p2), void 0 !== o2 && "" !== o2) {
        const e4 = this.normals.length;
        u2 = this.parseNormalIndex(o2, e4), h2 = this.parseNormalIndex(a2, e4), p2 = this.parseNormalIndex(l2, e4), this.addNormal(u2, h2, p2);
      } else
        this.addFaceNormal(u2, h2, p2);
      if (void 0 !== n2 && "" !== n2) {
        const e4 = this.uvs.length;
        u2 = this.parseUVIndex(n2, e4), h2 = this.parseUVIndex(i2, e4), p2 = this.parseUVIndex(s2, e4), this.addUV(u2, h2, p2), this.object.geometry.hasUVIndices = true;
      } else
        this.addDefaultUV();
    }, addPointGeometry: function(e3) {
      this.object.geometry.type = "Points";
      const t2 = this.vertices.length;
      for (let r2 = 0, n2 = e3.length; r2 < n2; r2++) {
        const n3 = this.parseVertexIndex(e3[r2], t2);
        this.addVertexPoint(n3), this.addColor(n3);
      }
    }, addLineGeometry: function(e3, t2) {
      this.object.geometry.type = "Line";
      const r2 = this.vertices.length, n2 = this.uvs.length;
      for (let t3 = 0, n3 = e3.length; t3 < n3; t3++)
        this.addVertexLine(this.parseVertexIndex(e3[t3], r2));
      for (let e4 = 0, r3 = t2.length; e4 < r3; e4++)
        this.addUVLine(this.parseUVIndex(t2[e4], n2));
    } };
    return e2.startObject("", false), e2;
  }
  class f_ extends n.aNw {
    constructor(e2) {
      super(e2), this.materials = null;
    }
    load(e2, t2, r2, i2) {
      const s2 = this, o2 = new n.hH6(this.manager);
      o2.setPath(this.path), o2.setRequestHeader(this.requestHeader), o2.setWithCredentials(this.withCredentials), o2.load(e2, async function(r3) {
        try {
          t2(await s2.parse(r3));
        } catch (t3) {
          i2 ? i2(t3) : console.error(t3), s2.manager.itemError(e2);
        }
      }, r2, i2);
    }
    setMaterials(e2) {
      return this.materials = e2, this;
    }
    async parse(e2) {
      const t2 = new d_();
      -1 !== e2.indexOf("\r\n") && (e2 = e2.replace(/\r\n/g, "\n")), -1 !== e2.indexOf("\\\n") && (e2 = e2.replace(/\\\n/g, ""));
      const r2 = e2.split("\n");
      let i2 = "", s2 = "", o2 = 0, a2 = [];
      const l2 = "function" == typeof "".trimLeft;
      for (let e3 = 0, n2 = r2.length; e3 < n2; e3++)
        if (i2 = r2[e3], i2 = l2 ? i2.trimLeft() : i2.trim(), o2 = i2.length, 0 !== o2 && (s2 = i2.charAt(0), "#" !== s2))
          if ("v" === s2) {
            const e4 = i2.split(/\s+/);
            switch (e4[0]) {
              case "v":
                t2.vertices.push(parseFloat(e4[1]), parseFloat(e4[2]), parseFloat(e4[3])), e4.length >= 7 ? t2.colors.push(parseFloat(e4[4]), parseFloat(e4[5]), parseFloat(e4[6])) : t2.colors.push(void 0, void 0, void 0);
                break;
              case "vn":
                t2.normals.push(parseFloat(e4[1]), parseFloat(e4[2]), parseFloat(e4[3]));
                break;
              case "vt":
                t2.uvs.push(parseFloat(e4[1]), parseFloat(e4[2]));
            }
          } else if ("f" === s2) {
            const e4 = i2.substr(1).trim().split(/\s+/), r3 = [];
            for (let t3 = 0, n4 = e4.length; t3 < n4; t3++) {
              const n5 = e4[t3];
              if (n5.length > 0) {
                const e5 = n5.split("/");
                r3.push(e5);
              }
            }
            const n3 = r3[0];
            for (let e5 = 1, i3 = r3.length - 1; e5 < i3; e5++) {
              const i4 = r3[e5], s3 = r3[e5 + 1];
              t2.addFace(n3[0], i4[0], s3[0], n3[1], i4[1], s3[1], n3[2], i4[2], s3[2]);
            }
          } else if ("l" === s2) {
            const e4 = i2.substring(1).trim().split(" ");
            let r3 = [];
            const n3 = [];
            if (-1 === i2.indexOf("/"))
              r3 = e4;
            else
              for (let t3 = 0, i3 = e4.length; t3 < i3; t3++) {
                const i4 = e4[t3].split("/");
                "" !== i4[0] && r3.push(i4[0]), "" !== i4[1] && n3.push(i4[1]);
              }
            t2.addLineGeometry(r3, n3);
          } else if ("p" === s2) {
            const e4 = i2.substr(1).trim().split(" ");
            t2.addPointGeometry(e4);
          } else if (null !== (a2 = i_.exec(i2))) {
            const e4 = (" " + a2[0].substr(1).trim()).substr(1);
            t2.startObject(e4);
          } else if (o_.test(i2))
            t2.object.startMaterial(i2.substring(7).trim(), t2.materialLibraries);
          else if (s_.test(i2)) {
            t2.materialLibraries.push(i2.substring(7).trim());
            const e4 = i2.substring(7).trim(), r3 = this.manager.getHandler(e4);
            if (r3) {
              const t3 = await r3.loadAsync(e4).catch((e5) => {
                console.warn(e5);
              });
              t3 && this.setMaterials(t3);
            } else
              console.warn("OBJLoader2: Set MTLLoader to loading manager to load materials.");
          } else if (a_.test(i2))
            console.warn('OBJLoader2: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
          else if ("s" === s2) {
            if (a2 = i2.split(" "), a2.length > 1) {
              const e5 = a2[1].trim().toLowerCase();
              t2.object.smooth = "0" !== e5 && "off" !== e5;
            } else
              t2.object.smooth = true;
            const e4 = t2.object.currentMaterial();
            e4 && (e4.smooth = t2.object.smooth);
          } else {
            if ("\0" === i2)
              continue;
            console.warn('THREE.OBJLoader: Unexpected line: "' + i2 + '"');
          }
      t2.finalize();
      const c2 = new n.ZAu();
      if (c2.materialLibraries = [].concat(t2.materialLibraries), true == !(1 === t2.objects.length && 0 === t2.objects[0].geometry.vertices.length))
        for (let e3 = 0, r3 = t2.objects.length; e3 < r3; e3++) {
          const r4 = t2.objects[e3], i3 = r4.geometry, s3 = r4.materials, o3 = "Line" === i3.type, a3 = "Points" === i3.type;
          let l3 = false;
          if (0 === i3.vertices.length)
            continue;
          const u2 = new n.u9r();
          u2.setAttribute("position", new n.a$l(i3.vertices, 3)), i3.normals.length > 0 && u2.setAttribute("normal", new n.a$l(i3.normals, 3)), i3.colors.length > 0 && (l3 = true, u2.setAttribute("color", new n.a$l(i3.colors, 3))), true === i3.hasUVIndices && u2.setAttribute("uv", new n.a$l(i3.uvs, 2));
          const h2 = [];
          for (let e4 = 0, r5 = s3.length; e4 < r5; e4++) {
            const r6 = s3[e4], i4 = r6.name + "_" + r6.smooth + "_" + l3;
            let c3 = t2.materials[i4];
            if (null !== this.materials)
              if (c3 = await this.materials.create(r6.name), !o3 || !c3 || c3 instanceof n.nls) {
                if (a3 && c3 && !(c3 instanceof n.UY4)) {
                  const e5 = new n.UY4({ size: 10, sizeAttenuation: false });
                  n.F5T.prototype.copy.call(e5, c3), e5.color.copy(c3.color), e5.map = c3.map, c3 = e5;
                }
              } else {
                const e5 = new n.nls();
                n.F5T.prototype.copy.call(e5, c3), e5.color.copy(c3.color), c3 = e5;
              }
            void 0 === c3 && (c3 = o3 ? new n.nls() : a3 ? new n.UY4({ size: 1, sizeAttenuation: false }) : new n.xoR(), c3.name = r6.name, c3.flatShading = !r6.smooth, c3.vertexColors = l3, t2.materials[i4] = c3), h2.push(c3);
          }
          let p2;
          if (h2.length > 1) {
            for (let e4 = 0, t3 = s3.length; e4 < t3; e4++) {
              const t4 = s3[e4];
              u2.addGroup(t4.groupStart, t4.groupCount, e4);
            }
            p2 = o3 ? new n.ejS(u2, h2) : a3 ? new n.woe(u2, h2) : new n.Kj0(u2, h2);
          } else
            p2 = o3 ? new n.ejS(u2, h2[0]) : a3 ? new n.woe(u2, h2[0]) : new n.Kj0(u2, h2[0]);
          p2.name = r4.name, c2.add(p2);
        }
      else if (t2.vertices.length > 0) {
        const e3 = new n.UY4({ size: 1, sizeAttenuation: false }), r3 = new n.u9r();
        r3.setAttribute("position", new n.a$l(t2.vertices, 3)), t2.colors.length > 0 && void 0 !== t2.colors[0] && (r3.setAttribute("color", new n.a$l(t2.colors, 3)), e3.vertexColors = true);
        const i3 = new n.woe(r3, e3);
        c2.add(i3);
      }
      return c2;
    }
  }
  class m_ extends r {
    constructor() {
      super(...arguments), this.dependencies = [to], this._importer1 = new ir(f_, ["obj"], true), this._importer2 = new ir(r_, ["mtl"], false);
    }
    async onAdded(e2) {
      Js.Importers.push(this._importer1), Js.Importers.push(this._importer2);
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      Js.Importers.splice(Js.Importers.indexOf(this._importer1), 1), Js.Importers.splice(Js.Importers.indexOf(this._importer2), 1);
    }
  }
  m_.PluginType = "ObjMtlLoadPlugin";
  class __ extends n.DqL {
    constructor(e2) {
      super(e2);
    }
    parse(e2, t2) {
      const r2 = new g_(e2, 1);
      return { mipmaps: r2.mipmaps(t2), width: r2.pixelWidth, height: r2.pixelHeight, format: r2.glInternalFormat, isCubemap: 6 === r2.numberOfFaces, mipmapCount: r2.numberOfMipmapLevels };
    }
  }
  class g_ {
    constructor(e2, t2) {
      this.arrayBuffer = e2;
      const r2 = new Uint8Array(this.arrayBuffer, 0, 12);
      if (171 !== r2[0] || 75 !== r2[1] || 84 !== r2[2] || 88 !== r2[3] || 32 !== r2[4] || 49 !== r2[5] || 49 !== r2[6] || 187 !== r2[7] || 13 !== r2[8] || 10 !== r2[9] || 26 !== r2[10] || 10 !== r2[11])
        return void console.error("texture missing KTX identifier");
      const n2 = Uint32Array.BYTES_PER_ELEMENT, i2 = new DataView(this.arrayBuffer, 12, 13 * n2), s2 = 67305985 === i2.getUint32(0, true);
      this.glType = i2.getUint32(1 * n2, s2), this.glTypeSize = i2.getUint32(2 * n2, s2), this.glFormat = i2.getUint32(3 * n2, s2), this.glInternalFormat = i2.getUint32(4 * n2, s2), this.glBaseInternalFormat = i2.getUint32(5 * n2, s2), this.pixelWidth = i2.getUint32(6 * n2, s2), this.pixelHeight = i2.getUint32(7 * n2, s2), this.pixelDepth = i2.getUint32(8 * n2, s2), this.numberOfArrayElements = i2.getUint32(9 * n2, s2), this.numberOfFaces = i2.getUint32(10 * n2, s2), this.numberOfMipmapLevels = i2.getUint32(11 * n2, s2), this.bytesOfKeyValueData = i2.getUint32(12 * n2, s2), 0 === this.glType ? (this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels), 0 !== this.pixelHeight && 0 === this.pixelDepth ? 0 === this.numberOfArrayElements ? this.numberOfFaces === t2 ? this.loadType = 0 : console.warn("number of faces expected" + t2 + ", but found " + this.numberOfFaces) : console.warn("texture arrays not currently supported") : console.warn("only 2D textures currently supported")) : console.warn("only compressed formats currently supported");
    }
    mipmaps(e2) {
      const t2 = [];
      let r2 = 64 + this.bytesOfKeyValueData, n2 = this.pixelWidth, i2 = this.pixelHeight;
      const s2 = e2 ? this.numberOfMipmapLevels : 1;
      for (let e3 = 0; e3 < s2; e3++) {
        const e4 = new Int32Array(this.arrayBuffer, r2, 1)[0];
        r2 += 4;
        for (let s3 = 0; s3 < this.numberOfFaces; s3++) {
          const s4 = new Uint8Array(this.arrayBuffer, r2, e4);
          t2.push({ data: s4, width: n2, height: i2 }), r2 += e4, r2 += 3 - (e4 + 3) % 4;
        }
        n2 = Math.max(1, 0.5 * n2), i2 = Math.max(1, 0.5 * i2);
      }
      return t2;
    }
  }
  class v_ extends r {
    constructor() {
      super(...arguments), this.dependencies = [to];
    }
    async onAdded(e2) {
      this._importer || (this._importer = new ir(__, ["ktx"], false)), Js.Importers.push(this._importer);
    }
    async onDispose(e2) {
      this._importer = void 0;
    }
    async onRemove(e2) {
      this._importer && Js.Importers.splice(Js.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }
  }
  v_.PluginType = "KTXLoadPlugin";
  class A_ extends n.hH6 {
    constructor(e2) {
      super(e2), this.responseType = "blob";
    }
  }
  class b_ extends n.hH6 {
    constructor(e2) {
      super(e2), this.responseType = "blob";
    }
    load(e2, t2, r2, n2) {
      return super.load(e2, (e3) => {
        try {
          null == t2 || t2(xt(e3));
        } catch (e4) {
          null == n2 || n2(e4);
        }
      }, r2, n2);
    }
  }
  class y_ {
    async parseAsync(e2, t2) {
      var r2;
      return new Blob([JSON.stringify(e2, null, null !== (r2 = t2.jsonSpaces) && void 0 !== r2 ? r2 : 2)], { type: "application/json" });
    }
  }
  class x_ {
    async parseAsync(e2, t2) {
      return new Blob([e2], { type: "text/plain" });
    }
  }
  class w_ {
    constructor() {
      this.pluginCallbacks = [], this.register(function(e2) {
        return new B_(e2);
      }), this.register(function(e2) {
        return new R_(e2);
      }), this.register(function(e2) {
        return new L_(e2);
      }), this.register(function(e2) {
        return new U_(e2);
      }), this.register(function(e2) {
        return new N_(e2);
      }), this.register(function(e2) {
        return new O_(e2);
      }), this.register(function(e2) {
        return new j_(e2);
      }), this.register(function(e2) {
        return new F_(e2);
      }), this.register(function(e2) {
        return new z_(e2);
      });
    }
    register(e2) {
      return -1 === this.pluginCallbacks.indexOf(e2) && this.pluginCallbacks.push(e2), this;
    }
    unregister(e2) {
      return -1 !== this.pluginCallbacks.indexOf(e2) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e2), 1), this;
    }
    parse(e2, t2, r2, n2, i2) {
      const s2 = i2 || new P_(), o2 = [];
      for (let e3 = 0, t3 = this.pluginCallbacks.length; e3 < t3; e3++)
        o2.push(this.pluginCallbacks[e3](s2));
      s2.setPlugins(o2), s2.write(e2, t2, n2).catch(r2);
    }
    parseAsync(e2, t2) {
      const r2 = this;
      return new Promise(function(n2, i2) {
        r2.parse(e2, n2, i2, t2);
      });
    }
  }
  const E_ = 5121, S_ = 5123, C_ = {};
  C_[n.TyD] = 9728, C_[n.YLQ] = 9984, C_[n.aH4] = 9986, C_[n.wem] = 9729, C_[n.qyh] = 9985, C_[n.D1R] = 9987, C_[n.uWy] = 33071, C_[n.rpg] = 10497, C_[n.OoA] = 33648;
  const M_ = { scale: "scale", position: "translation", quaternion: "rotation", morphTargetInfluences: "weights" };
  function T_(e2, t2) {
    return e2.length === t2.length && e2.every(function(e3, r2) {
      return e3 === t2[r2];
    });
  }
  function I_(e2) {
    return 4 * Math.ceil(e2 / 4);
  }
  function k_(e2, t2 = 0) {
    const r2 = I_(e2.byteLength);
    if (r2 !== e2.byteLength) {
      const n2 = new Uint8Array(r2);
      if (n2.set(new Uint8Array(e2)), 0 !== t2)
        for (let i2 = e2.byteLength; i2 < r2; i2++)
          n2[i2] = t2;
      return n2.buffer;
    }
    return e2;
  }
  function D_(e2, t2) {
    if (void 0 !== e2.toBlob)
      return new Promise((r3) => e2.toBlob(r3, t2));
    let r2;
    return "image/jpeg" === t2 ? r2 = 0.92 : "image/webp" === t2 && (r2 = 0.8), e2.convertToBlob({ type: t2, quality: r2 });
  }
  class P_ {
    constructor() {
      this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = { asset: { version: "2.0", generator: "THREE.GLTFExporter" } }, this.cache = { meshes: /* @__PURE__ */ new Map(), attributes: /* @__PURE__ */ new Map(), attributesNormalized: /* @__PURE__ */ new Map(), materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), images: /* @__PURE__ */ new Map() };
    }
    setPlugins(e2) {
      this.plugins = e2;
    }
    async write(e2, t2, r2) {
      this.options = Object.assign({}, { binary: false, trs: false, onlyVisible: true, truncateDrawRange: true, maxTextureSize: 1 / 0, animations: [], includeCustomExtensions: false }, r2), this.options.animations.length > 0 && (this.options.trs = true), this.processInput(e2), await Promise.all(this.pending);
      const n2 = this, i2 = n2.buffers, s2 = n2.json;
      r2 = n2.options;
      const o2 = n2.extensionsUsed, a2 = new Blob(i2, { type: "application/octet-stream" }), l2 = Object.keys(o2);
      if (l2.length > 0 && (s2.extensionsUsed = l2), s2.buffers && s2.buffers.length > 0 && (s2.buffers[0].byteLength = a2.size), true === r2.binary) {
        const e3 = new FileReader();
        e3.readAsArrayBuffer(a2), e3.onloadend = function() {
          const r3 = k_(e3.result), n3 = new DataView(new ArrayBuffer(8));
          n3.setUint32(0, r3.byteLength, true), n3.setUint32(4, 5130562, true);
          const i3 = k_((o3 = JSON.stringify(s2), new TextEncoder().encode(o3).buffer), 32);
          var o3;
          const a3 = new DataView(new ArrayBuffer(8));
          a3.setUint32(0, i3.byteLength, true), a3.setUint32(4, 1313821514, true);
          const l3 = new ArrayBuffer(12), c2 = new DataView(l3);
          c2.setUint32(0, 1179937895, true), c2.setUint32(4, 2, true);
          const u2 = 12 + a3.byteLength + i3.byteLength + n3.byteLength + r3.byteLength;
          c2.setUint32(8, u2, true);
          const h2 = new Blob([l3, a3, i3, n3, r3], { type: "application/octet-stream" }), p2 = new FileReader();
          p2.readAsArrayBuffer(h2), p2.onloadend = function() {
            t2(p2.result);
          };
        };
      } else if (s2.buffers && s2.buffers.length > 0) {
        const e3 = new FileReader();
        e3.readAsDataURL(a2), e3.onloadend = function() {
          const r3 = e3.result;
          s2.buffers[0].uri = r3, t2(s2);
        };
      } else
        t2(s2);
    }
    serializeUserData(e2, t2) {
      if (0 === Object.keys(e2.userData).length)
        return;
      const r2 = this.options, n2 = this.extensionsUsed;
      try {
        const i2 = JSON.parse(JSON.stringify(e2.userData));
        if (r2.includeCustomExtensions && i2.gltfExtensions) {
          void 0 === t2.extensions && (t2.extensions = {});
          for (const e3 in i2.gltfExtensions)
            t2.extensions[e3] = i2.gltfExtensions[e3], n2[e3] = true;
          delete i2.gltfExtensions;
        }
        Object.keys(i2).length > 0 && (t2.extras = i2);
      } catch (t3) {
        console.warn("THREE.GLTFExporter: userData of '" + e2.name + "' won't be serialized because of JSON.stringify error - " + t3.message), console.warn({ ...e2.userData });
      }
    }
    getUID(e2, t2 = false) {
      if (false === this.uids.has(e2)) {
        const t3 = /* @__PURE__ */ new Map();
        t3.set(true, this.uid++), t3.set(false, this.uid++), this.uids.set(e2, t3);
      }
      return this.uids.get(e2).get(t2);
    }
    isNormalizedNormalAttribute(e2) {
      if (this.cache.attributesNormalized.has(e2))
        return false;
      const t2 = new n.Pa4();
      for (let r2 = 0, n2 = e2.count; r2 < n2; r2++)
        if (Math.abs(t2.fromBufferAttribute(e2, r2).length() - 1) > 5e-4)
          return false;
      return true;
    }
    createNormalizedNormalAttribute(e2) {
      const t2 = this.cache;
      if (t2.attributesNormalized.has(e2))
        return t2.attributesNormalized.get(e2);
      const r2 = e2.clone(), i2 = new n.Pa4();
      for (let e3 = 0, t3 = r2.count; e3 < t3; e3++)
        i2.fromBufferAttribute(r2, e3), 0 === i2.x && 0 === i2.y && 0 === i2.z ? i2.setX(1) : i2.normalize(), r2.setXYZ(e3, i2.x, i2.y, i2.z);
      return t2.attributesNormalized.set(e2, r2), r2;
    }
    applyTextureTransform(e2, t2) {
      let r2 = false;
      const n2 = {};
      0 === t2.offset.x && 0 === t2.offset.y || (n2.offset = t2.offset.toArray(), r2 = true), 0 !== t2.rotation && (n2.rotation = t2.rotation, r2 = true), 1 === t2.repeat.x && 1 === t2.repeat.y || (n2.scale = t2.repeat.toArray(), r2 = true), r2 && (e2.extensions = e2.extensions || {}, e2.extensions.KHR_texture_transform = n2, this.extensionsUsed.KHR_texture_transform = true);
    }
    buildMetalRoughTexture(e2, t2) {
      if (e2 === t2)
        return e2;
      function r2(e3) {
        return e3.encoding === n.knz ? function(e4) {
          return e4 < 0.04045 ? 0.0773993808 * e4 : Math.pow(0.9478672986 * e4 + 0.0521327014, 2.4);
        } : function(e4) {
          return e4;
        };
      }
      console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");
      const i2 = e2 ? e2.image : void 0, s2 = t2 ? t2.image : void 0, o2 = Math.max(i2 ? i2.width : 0, s2 ? s2.width : 0), a2 = Math.max(i2 ? i2.height : 0, s2 ? s2.height : 0), l2 = document.createElement("canvas");
      l2.width = o2, l2.height = a2;
      const c2 = l2.getContext("2d");
      c2.fillStyle = "#00ffff", c2.fillRect(0, 0, o2, a2);
      const u2 = c2.getImageData(0, 0, o2, a2);
      if (i2) {
        c2.drawImage(i2, 0, 0, o2, a2);
        const t3 = r2(e2), n2 = c2.getImageData(0, 0, o2, a2).data;
        for (let e3 = 2; e3 < n2.length; e3 += 4)
          u2.data[e3] = 256 * t3(n2[e3] / 256);
      }
      if (s2) {
        c2.drawImage(s2, 0, 0, o2, a2);
        const e3 = r2(t2), n2 = c2.getImageData(0, 0, o2, a2).data;
        for (let t3 = 1; t3 < n2.length; t3 += 4)
          u2.data[t3] = 256 * e3(n2[t3] / 256);
      }
      c2.putImageData(u2, 0, 0);
      const h2 = (e2 || t2).clone();
      return h2.source = new n.Hw6(l2), h2.encoding = n.rnI, h2;
    }
    processBuffer(e2) {
      const t2 = this.json, r2 = this.buffers;
      return t2.buffers || (t2.buffers = [{ byteLength: 0 }]), r2.push(e2), 0;
    }
    processBufferView(e2, t2, r2, n2, i2) {
      const s2 = this.json;
      let o2;
      s2.bufferViews || (s2.bufferViews = []), o2 = t2 === E_ ? 1 : t2 === S_ ? 2 : 4;
      const a2 = I_(n2 * e2.itemSize * o2), l2 = new DataView(new ArrayBuffer(a2));
      let c2 = 0;
      for (let i3 = r2; i3 < r2 + n2; i3++)
        for (let r3 = 0; r3 < e2.itemSize; r3++) {
          let n3;
          e2.itemSize > 4 ? n3 = e2.array[i3 * e2.itemSize + r3] : 0 === r3 ? n3 = e2.getX(i3) : 1 === r3 ? n3 = e2.getY(i3) : 2 === r3 ? n3 = e2.getZ(i3) : 3 === r3 && (n3 = e2.getW(i3)), 5126 === t2 ? l2.setFloat32(c2, n3, true) : 5125 === t2 ? l2.setUint32(c2, n3, true) : t2 === S_ ? l2.setUint16(c2, n3, true) : t2 === E_ && l2.setUint8(c2, n3), c2 += o2;
        }
      const u2 = { buffer: this.processBuffer(l2.buffer), byteOffset: this.byteOffset, byteLength: a2 };
      return void 0 !== i2 && (u2.target = i2), 34962 === i2 && (u2.byteStride = e2.itemSize * o2), this.byteOffset += a2, s2.bufferViews.push(u2), { id: s2.bufferViews.length - 1, byteLength: 0 };
    }
    processBufferViewImage(e2) {
      const t2 = this, r2 = t2.json;
      return r2.bufferViews || (r2.bufferViews = []), new Promise(function(n2) {
        const i2 = new FileReader();
        i2.readAsArrayBuffer(e2), i2.onloadend = function() {
          const e3 = k_(i2.result), s2 = { buffer: t2.processBuffer(e3), byteOffset: t2.byteOffset, byteLength: e3.byteLength };
          t2.byteOffset += e3.byteLength, n2(r2.bufferViews.push(s2) - 1);
        };
      });
    }
    processAccessor(e2, t2, r2, n2) {
      const i2 = this.options, s2 = this.json;
      let o2;
      if (e2.array.constructor === Float32Array)
        o2 = 5126;
      else if (e2.array.constructor === Uint32Array)
        o2 = 5125;
      else if (e2.array.constructor === Uint16Array)
        o2 = S_;
      else {
        if (e2.array.constructor !== Uint8Array)
          throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
        o2 = E_;
      }
      if (void 0 === r2 && (r2 = 0), void 0 === n2 && (n2 = e2.count), i2.truncateDrawRange && void 0 !== t2 && null === t2.index) {
        const i3 = r2 + n2, s3 = t2.drawRange.count === 1 / 0 ? e2.count : t2.drawRange.start + t2.drawRange.count;
        r2 = Math.max(r2, t2.drawRange.start), n2 = Math.min(i3, s3) - r2, n2 < 0 && (n2 = 0);
      }
      if (0 === n2)
        return null;
      const a2 = function(e3, t3, r3) {
        const n3 = { min: new Array(e3.itemSize).fill(Number.POSITIVE_INFINITY), max: new Array(e3.itemSize).fill(Number.NEGATIVE_INFINITY) };
        for (let i3 = t3; i3 < t3 + r3; i3++)
          for (let t4 = 0; t4 < e3.itemSize; t4++) {
            let r4;
            e3.itemSize > 4 ? r4 = e3.array[i3 * e3.itemSize + t4] : 0 === t4 ? r4 = e3.getX(i3) : 1 === t4 ? r4 = e3.getY(i3) : 2 === t4 ? r4 = e3.getZ(i3) : 3 === t4 && (r4 = e3.getW(i3)), n3.min[t4] = Math.min(n3.min[t4], r4), n3.max[t4] = Math.max(n3.max[t4], r4);
          }
        return n3;
      }(e2, r2, n2);
      let l2;
      void 0 !== t2 && (l2 = e2 === t2.index ? 34963 : 34962);
      const c2 = this.processBufferView(e2, o2, r2, n2, l2), u2 = { bufferView: c2.id, byteOffset: c2.byteOffset, componentType: o2, count: n2, max: a2.max, min: a2.min, type: { 1: "SCALAR", 2: "VEC2", 3: "VEC3", 4: "VEC4", 16: "MAT4" }[e2.itemSize] };
      return s2.accessors || (s2.accessors = []), s2.accessors.push(u2) - 1;
    }
    processImage(e2, t2, r2, i2 = "image/png") {
      const s2 = this, o2 = s2.cache, a2 = s2.json, l2 = s2.options, c2 = s2.pending;
      o2.images.has(e2) || o2.images.set(e2, {});
      const u2 = o2.images.get(e2), h2 = i2 + ":flipY/" + r2.toString();
      if (void 0 !== u2[h2])
        return u2[h2];
      a2.images || (a2.images = []);
      const p2 = { mimeType: i2 }, d2 = "undefined" == typeof document && "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
      d2.width = Math.min(e2.width, l2.maxTextureSize), d2.height = Math.min(e2.height, l2.maxTextureSize);
      const f2 = d2.getContext("2d");
      if (true === r2 && (f2.translate(0, d2.height), f2.scale(1, -1)), void 0 !== e2.data) {
        t2 !== n.wk1 && console.error("GLTFExporter: Only RGBAFormat is supported."), (e2.width > l2.maxTextureSize || e2.height > l2.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e2);
        const r3 = new Uint8ClampedArray(e2.height * e2.width * 4);
        for (let t3 = 0; t3 < r3.length; t3 += 4)
          r3[t3 + 0] = e2.data[t3 + 0], r3[t3 + 1] = e2.data[t3 + 1], r3[t3 + 2] = e2.data[t3 + 2], r3[t3 + 3] = e2.data[t3 + 3];
        f2.putImageData(new ImageData(r3, e2.width, e2.height), 0, 0);
      } else
        f2.drawImage(e2, 0, 0, d2.width, d2.height);
      true === l2.binary ? c2.push(D_(d2, i2).then((e3) => s2.processBufferViewImage(e3)).then((e3) => {
        p2.bufferView = e3;
      })) : void 0 !== d2.toDataURL ? p2.uri = d2.toDataURL(i2) : c2.push(D_(d2, i2).then((e3) => new FileReader().readAsDataURL(e3)).then((e3) => {
        p2.uri = e3;
      }));
      const m2 = a2.images.push(p2) - 1;
      return u2[h2] = m2, m2;
    }
    processSampler(e2) {
      const t2 = this.json;
      t2.samplers || (t2.samplers = []);
      const r2 = { magFilter: C_[e2.magFilter], minFilter: C_[e2.minFilter], wrapS: C_[e2.wrapS], wrapT: C_[e2.wrapT] };
      return t2.samplers.push(r2) - 1;
    }
    processTexture(e2) {
      const t2 = this.cache, r2 = this.json;
      if (t2.textures.has(e2))
        return t2.textures.get(e2);
      r2.textures || (r2.textures = []);
      let n2 = e2.userData.mimeType;
      "image/webp" === n2 && (n2 = "image/png"), "image/jpg" === n2 && (n2 = "image/jpeg");
      const i2 = ["image/jpeg", "image/png"];
      n2 && !i2.includes(n2) && console.error("GLTFExporter: Unsupported mime type: " + n2 + ". Cannot export texture.", e2);
      const s2 = { sampler: this.processSampler(e2), source: !n2 || i2.includes(n2) ? this.processImage(e2.image, e2.format, e2.flipY, n2) : null };
      e2.name && (s2.name = e2.name), this._invokeAll(function(t3) {
        t3.writeTexture && t3.writeTexture(e2, s2);
      });
      const o2 = r2.textures.push(s2) - 1;
      return t2.textures.set(e2, o2), o2;
    }
    processMaterial(e2) {
      const t2 = this.cache, r2 = this.json;
      if (t2.materials.has(e2))
        return t2.materials.get(e2);
      if (e2.isShaderMaterial)
        return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
      r2.materials || (r2.materials = []);
      const i2 = { pbrMetallicRoughness: {} };
      true !== e2.isMeshStandardMaterial && true !== e2.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
      const s2 = e2.color.toArray().concat([e2.opacity]);
      if (T_(s2, [1, 1, 1, 1]) || (i2.pbrMetallicRoughness.baseColorFactor = s2), e2.isMeshStandardMaterial ? (i2.pbrMetallicRoughness.metallicFactor = e2.metalness, i2.pbrMetallicRoughness.roughnessFactor = e2.roughness) : (i2.pbrMetallicRoughness.metallicFactor = 0.5, i2.pbrMetallicRoughness.roughnessFactor = 0.5), e2.metalnessMap || e2.roughnessMap) {
        const t3 = this.buildMetalRoughTexture(e2.metalnessMap, e2.roughnessMap), r3 = { index: this.processTexture(t3) };
        this.applyTextureTransform(r3, t3), i2.pbrMetallicRoughness.metallicRoughnessTexture = r3;
      }
      if (e2.map) {
        const t3 = { index: this.processTexture(e2.map) };
        this.applyTextureTransform(t3, e2.map), i2.pbrMetallicRoughness.baseColorTexture = t3;
      }
      if (e2.emissive) {
        const t3 = e2.emissive.clone().multiplyScalar(e2.emissiveIntensity), r3 = Math.max(t3.r, t3.g, t3.b);
        if (r3 > 1 && (t3.multiplyScalar(1 / r3), console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")), r3 > 0 && (i2.emissiveFactor = t3.toArray()), e2.emissiveMap) {
          const t4 = { index: this.processTexture(e2.emissiveMap) };
          this.applyTextureTransform(t4, e2.emissiveMap), i2.emissiveTexture = t4;
        }
      }
      if (e2.normalMap) {
        const t3 = { index: this.processTexture(e2.normalMap) };
        e2.normalScale && 1 !== e2.normalScale.x && (t3.scale = e2.normalScale.x), this.applyTextureTransform(t3, e2.normalMap), i2.normalTexture = t3;
      }
      if (e2.aoMap) {
        const t3 = { index: this.processTexture(e2.aoMap), texCoord: 1 };
        1 !== e2.aoMapIntensity && (t3.strength = e2.aoMapIntensity), this.applyTextureTransform(t3, e2.aoMap), i2.occlusionTexture = t3;
      }
      e2.transparent ? i2.alphaMode = "BLEND" : e2.alphaTest > 0 && (i2.alphaMode = "MASK", i2.alphaCutoff = e2.alphaTest), e2.side === n.ehD && (i2.doubleSided = true), "" !== e2.name && (i2.name = e2.name), this.serializeUserData(e2, i2), this._invokeAll(function(t3) {
        t3.writeMaterial && t3.writeMaterial(e2, i2);
      });
      const o2 = r2.materials.push(i2) - 1;
      return t2.materials.set(e2, o2), o2;
    }
    processMesh(e2) {
      const t2 = this.cache, r2 = this.json, i2 = [e2.geometry.uuid];
      if (Array.isArray(e2.material))
        for (let t3 = 0, r3 = e2.material.length; t3 < r3; t3++)
          i2.push(e2.material[t3].uuid);
      else
        i2.push(e2.material.uuid);
      const s2 = i2.join(":");
      if (t2.meshes.has(s2))
        return t2.meshes.get(s2);
      const o2 = e2.geometry;
      let a2;
      a2 = e2.isLineSegments ? 1 : e2.isLineLoop ? 2 : e2.isLine ? 3 : e2.isPoints ? 0 : e2.material.wireframe ? 1 : 4;
      const l2 = {}, c2 = {}, u2 = [], h2 = [], p2 = { uv: "TEXCOORD_0", uv2: "TEXCOORD_1", color: "COLOR_0", skinWeight: "WEIGHTS_0", skinIndex: "JOINTS_0" }, d2 = o2.getAttribute("normal");
      void 0 === d2 || this.isNormalizedNormalAttribute(d2) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), o2.setAttribute("normal", this.createNormalizedNormalAttribute(d2)));
      let f2 = null;
      for (let e3 in o2.attributes) {
        if ("morph" === e3.slice(0, 5))
          continue;
        const r3 = o2.attributes[e3];
        if (e3 = p2[e3] || e3.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(e3) || (e3 = "_" + e3), t2.attributes.has(this.getUID(r3))) {
          c2[e3] = t2.attributes.get(this.getUID(r3));
          continue;
        }
        f2 = null;
        const i3 = r3.array;
        "JOINTS_0" !== e3 || i3 instanceof Uint16Array || i3 instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), f2 = new n.TlE(new Uint16Array(i3), r3.itemSize, r3.normalized));
        const s3 = this.processAccessor(f2 || r3, o2);
        null !== s3 && (c2[e3] = s3, t2.attributes.set(this.getUID(r3), s3));
      }
      if (void 0 !== d2 && o2.setAttribute("normal", d2), 0 === Object.keys(c2).length)
        return null;
      if (void 0 !== e2.morphTargetInfluences && e2.morphTargetInfluences.length > 0) {
        const r3 = [], n2 = [], i3 = {};
        if (void 0 !== e2.morphTargetDictionary)
          for (const t3 in e2.morphTargetDictionary)
            i3[e2.morphTargetDictionary[t3]] = t3;
        for (let s3 = 0; s3 < e2.morphTargetInfluences.length; ++s3) {
          const a3 = {};
          let l3 = false;
          for (const e3 in o2.morphAttributes) {
            if ("position" !== e3 && "normal" !== e3) {
              l3 || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), l3 = true);
              continue;
            }
            const r4 = o2.morphAttributes[e3][s3], n3 = e3.toUpperCase(), i4 = o2.attributes[e3];
            if (t2.attributes.has(this.getUID(r4, true))) {
              a3[n3] = t2.attributes.get(this.getUID(r4, true));
              continue;
            }
            const c3 = r4.clone();
            if (!o2.morphTargetsRelative)
              for (let e4 = 0, t3 = r4.count; e4 < t3; e4++)
                c3.setXYZ(e4, r4.getX(e4) - i4.getX(e4), r4.getY(e4) - i4.getY(e4), r4.getZ(e4) - i4.getZ(e4));
            a3[n3] = this.processAccessor(c3, o2), t2.attributes.set(this.getUID(i4, true), a3[n3]);
          }
          h2.push(a3), r3.push(e2.morphTargetInfluences[s3]), void 0 !== e2.morphTargetDictionary && n2.push(i3[s3]);
        }
        l2.weights = r3, n2.length > 0 && (l2.extras = {}, l2.extras.targetNames = n2);
      }
      const m2 = Array.isArray(e2.material);
      if (m2 && 0 === o2.groups.length)
        return null;
      const _2 = m2 ? e2.material : [e2.material], g2 = m2 ? o2.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
      for (let e3 = 0, r3 = g2.length; e3 < r3; e3++) {
        const r4 = { mode: a2, attributes: c2 };
        if (this.serializeUserData(o2, r4), h2.length > 0 && (r4.targets = h2), null !== o2.index) {
          let n3 = this.getUID(o2.index);
          void 0 === g2[e3].start && void 0 === g2[e3].count || (n3 += ":" + g2[e3].start + ":" + g2[e3].count), t2.attributes.has(n3) ? r4.indices = t2.attributes.get(n3) : (r4.indices = this.processAccessor(o2.index, o2, g2[e3].start, g2[e3].count), t2.attributes.set(n3, r4.indices)), null === r4.indices && delete r4.indices;
        }
        const n2 = this.processMaterial(_2[g2[e3].materialIndex]);
        null !== n2 && (r4.material = n2), u2.push(r4);
      }
      l2.primitives = u2, r2.meshes || (r2.meshes = []), this._invokeAll(function(t3) {
        t3.writeMesh && t3.writeMesh(e2, l2);
      });
      const v2 = r2.meshes.push(l2) - 1;
      return t2.meshes.set(s2, v2), v2;
    }
    processCamera(e2) {
      const t2 = this.json;
      t2.cameras || (t2.cameras = []);
      const r2 = e2.isOrthographicCamera, i2 = { type: r2 ? "orthographic" : "perspective" };
      return r2 ? i2.orthographic = { xmag: 2 * e2.right, ymag: 2 * e2.top, zfar: e2.far <= 0 ? 1e-3 : e2.far, znear: e2.near < 0 ? 0 : e2.near } : i2.perspective = { aspectRatio: e2.aspect, yfov: n.M8C.degToRad(e2.fov), zfar: e2.far <= 0 ? 1e-3 : e2.far, znear: e2.near < 0 ? 0 : e2.near }, "" !== e2.name && (i2.name = e2.type), t2.cameras.push(i2) - 1;
    }
    processAnimation(e2, t2) {
      const r2 = this.json, i2 = this.nodeMap;
      r2.animations || (r2.animations = []);
      const s2 = (e2 = w_.Utils.mergeMorphTargetTracks(e2.clone(), t2)).tracks, o2 = [], a2 = [];
      for (let e3 = 0; e3 < s2.length; ++e3) {
        const r3 = s2[e3], l2 = n.iUV.parseTrackName(r3.name);
        let c2 = n.iUV.findNode(t2, l2.nodeName);
        const u2 = M_[l2.propertyName];
        if ("bones" === l2.objectName && (c2 = true === c2.isSkinnedMesh ? c2.skeleton.getBoneByName(l2.objectIndex) : void 0), !c2 || !u2)
          return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', r3.name), null;
        const h2 = 1;
        let p2, d2 = r3.values.length / r3.times.length;
        u2 === M_.morphTargetInfluences && (d2 /= c2.morphTargetInfluences.length), true === r3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (p2 = "CUBICSPLINE", d2 /= 3) : p2 = r3.getInterpolation() === n.Syv ? "STEP" : "LINEAR", a2.push({ input: this.processAccessor(new n.TlE(r3.times, h2)), output: this.processAccessor(new n.TlE(r3.values, d2)), interpolation: p2 }), o2.push({ sampler: a2.length - 1, target: { node: i2.get(c2), path: u2 } });
      }
      return r2.animations.push({ name: e2.name || "clip_" + r2.animations.length, samplers: a2, channels: o2 }), r2.animations.length - 1;
    }
    processSkin(e2) {
      const t2 = this.json, r2 = this.nodeMap, i2 = t2.nodes[r2.get(e2)], s2 = e2.skeleton;
      if (void 0 === s2)
        return null;
      const o2 = e2.skeleton.bones[0];
      if (void 0 === o2)
        return null;
      const a2 = [], l2 = new Float32Array(16 * s2.bones.length), c2 = new n.yGw();
      for (let t3 = 0; t3 < s2.bones.length; ++t3)
        a2.push(r2.get(s2.bones[t3])), c2.copy(s2.boneInverses[t3]), c2.multiply(e2.bindMatrix).toArray(l2, 16 * t3);
      return void 0 === t2.skins && (t2.skins = []), t2.skins.push({ inverseBindMatrices: this.processAccessor(new n.TlE(l2, 16)), joints: a2, skeleton: r2.get(o2) }), i2.skin = t2.skins.length - 1;
    }
    processNode(e2) {
      const t2 = this.json, r2 = this.options, n2 = this.nodeMap;
      t2.nodes || (t2.nodes = []);
      const i2 = {};
      if (r2.trs) {
        const t3 = e2.quaternion.toArray(), r3 = e2.position.toArray(), n3 = e2.scale.toArray();
        T_(t3, [0, 0, 0, 1]) || (i2.rotation = t3), T_(r3, [0, 0, 0]) || (i2.translation = r3), T_(n3, [1, 1, 1]) || (i2.scale = n3);
      } else
        e2.matrixAutoUpdate && e2.updateMatrix(), false === T_(e2.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (i2.matrix = e2.matrix.elements);
      if ("" !== e2.name && (i2.name = String(e2.name)), this.serializeUserData(e2, i2), e2.isMesh || e2.isLine || e2.isPoints) {
        const t3 = this.processMesh(e2);
        null !== t3 && (i2.mesh = t3);
      } else
        e2.isCamera && (i2.camera = this.processCamera(e2));
      if (e2.isSkinnedMesh && this.skins.push(e2), e2.children.length > 0) {
        const t3 = [];
        for (let n3 = 0, i3 = e2.children.length; n3 < i3; n3++) {
          const i4 = e2.children[n3];
          if (i4.visible || false === r2.onlyVisible) {
            const e3 = this.processNode(i4);
            null !== e3 && t3.push(e3);
          }
        }
        t3.length > 0 && (i2.children = t3);
      }
      this._invokeAll(function(t3) {
        t3.writeNode && t3.writeNode(e2, i2);
      });
      const s2 = t2.nodes.push(i2) - 1;
      return n2.set(e2, s2), s2;
    }
    processScene(e2) {
      const t2 = this.json, r2 = this.options;
      t2.scenes || (t2.scenes = [], t2.scene = 0);
      const n2 = {};
      "" !== e2.name && (n2.name = e2.name), t2.scenes.push(n2);
      const i2 = [];
      for (let t3 = 0, n3 = e2.children.length; t3 < n3; t3++) {
        const n4 = e2.children[t3];
        if (n4.visible || false === r2.onlyVisible) {
          const e3 = this.processNode(n4);
          null !== e3 && i2.push(e3);
        }
      }
      i2.length > 0 && (n2.nodes = i2), this.serializeUserData(e2, n2);
    }
    processObjects(e2) {
      const t2 = new n.xsS();
      t2.name = "AuxScene";
      for (let r2 = 0; r2 < e2.length; r2++)
        t2.children.push(e2[r2]);
      this.processScene(t2);
    }
    processInput(e2) {
      const t2 = this.options;
      e2 = e2 instanceof Array ? e2 : [e2], this._invokeAll(function(t3) {
        t3.beforeParse && t3.beforeParse(e2);
      });
      const r2 = [];
      for (let t3 = 0; t3 < e2.length; t3++)
        e2[t3] instanceof n.xsS ? this.processScene(e2[t3]) : r2.push(e2[t3]);
      r2.length > 0 && this.processObjects(r2);
      for (let e3 = 0; e3 < this.skins.length; ++e3)
        this.processSkin(this.skins[e3]);
      for (let r3 = 0; r3 < t2.animations.length; ++r3)
        this.processAnimation(t2.animations[r3], e2[0]);
      this._invokeAll(function(t3) {
        t3.afterParse && t3.afterParse(e2);
      });
    }
    _invokeAll(e2) {
      for (let t2 = 0, r2 = this.plugins.length; t2 < r2; t2++)
        e2(this.plugins[t2]);
    }
  }
  class B_ {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_lights_punctual";
    }
    writeNode(e2, t2) {
      if (!e2.isLight)
        return;
      if (!e2.isDirectionalLight && !e2.isPointLight && !e2.isSpotLight)
        return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e2);
      const r2 = this.writer, n2 = r2.json, i2 = r2.extensionsUsed, s2 = {};
      e2.name && (s2.name = e2.name), s2.color = e2.color.toArray(), s2.intensity = e2.intensity, e2.isDirectionalLight ? s2.type = "directional" : e2.isPointLight ? (s2.type = "point", e2.distance > 0 && (s2.range = e2.distance)) : e2.isSpotLight && (s2.type = "spot", e2.distance > 0 && (s2.range = e2.distance), s2.spot = {}, s2.spot.innerConeAngle = (e2.penumbra - 1) * e2.angle * -1, s2.spot.outerConeAngle = e2.angle), void 0 !== e2.decay && 2 !== e2.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !e2.target || e2.target.parent === e2 && 0 === e2.target.position.x && 0 === e2.target.position.y && -1 === e2.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), i2[this.name] || (n2.extensions = n2.extensions || {}, n2.extensions[this.name] = { lights: [] }, i2[this.name] = true);
      const o2 = n2.extensions[this.name].lights;
      o2.push(s2), t2.extensions = t2.extensions || {}, t2.extensions[this.name] = { light: o2.length - 1 };
    }
  }
  class R_ {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_unlit";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshBasicMaterial)
        return;
      const r2 = this.writer.extensionsUsed;
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = {}, r2[this.name] = true, t2.pbrMetallicRoughness.metallicFactor = 0, t2.pbrMetallicRoughness.roughnessFactor = 0.9;
    }
  }
  class L_ {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_pbrSpecularGlossiness";
    }
    writeMaterial(e2, t2) {
      if (!e2.isGLTFSpecularGlossinessMaterial)
        return;
      const r2 = this.writer, n2 = r2.extensionsUsed, i2 = {};
      t2.pbrMetallicRoughness.baseColorFactor && (i2.diffuseFactor = t2.pbrMetallicRoughness.baseColorFactor);
      const s2 = [1, 1, 1];
      if (e2.specular.toArray(s2, 0), i2.specularFactor = s2, i2.glossinessFactor = e2.glossiness, t2.pbrMetallicRoughness.baseColorTexture && (i2.diffuseTexture = t2.pbrMetallicRoughness.baseColorTexture), e2.specularMap) {
        const t3 = { index: r2.processTexture(e2.specularMap) };
        r2.applyTextureTransform(t3, e2.specularMap), i2.specularGlossinessTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, n2[this.name] = true;
    }
  }
  class O_ {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_clearcoat";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial)
        return;
      const r2 = this.writer, n2 = r2.extensionsUsed, i2 = {};
      if (i2.clearcoatFactor = e2.clearcoat, e2.clearcoatMap) {
        const t3 = { index: r2.processTexture(e2.clearcoatMap) };
        r2.applyTextureTransform(t3, e2.clearcoatMap), i2.clearcoatTexture = t3;
      }
      if (i2.clearcoatRoughnessFactor = e2.clearcoatRoughness, e2.clearcoatRoughnessMap) {
        const t3 = { index: r2.processTexture(e2.clearcoatRoughnessMap) };
        r2.applyTextureTransform(t3, e2.clearcoatRoughnessMap), i2.clearcoatRoughnessTexture = t3;
      }
      if (e2.clearcoatNormalMap) {
        const t3 = { index: r2.processTexture(e2.clearcoatNormalMap) };
        r2.applyTextureTransform(t3, e2.clearcoatNormalMap), i2.clearcoatNormalTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, n2[this.name] = true;
    }
  }
  class F_ {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_iridescence";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial)
        return;
      const r2 = this.writer, n2 = r2.extensionsUsed, i2 = {};
      if (i2.iridescenceFactor = e2.iridescence, e2.iridescenceMap) {
        const t3 = { index: r2.processTexture(e2.iridescenceMap) };
        r2.applyTextureTransform(t3, e2.iridescenceMap), i2.iridescenceTexture = t3;
      }
      if (i2.iridescenceIor = e2.iridescenceIOR, i2.iridescenceThicknessMinimum = e2.iridescenceThicknessRange[0], i2.iridescenceThicknessMaximum = e2.iridescenceThicknessRange[1], e2.iridescenceThicknessMap) {
        const t3 = { index: r2.processTexture(e2.iridescenceThicknessMap) };
        r2.applyTextureTransform(t3, e2.iridescenceThicknessMap), i2.iridescenceThicknessTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, n2[this.name] = true;
    }
  }
  class U_ {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_transmission";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial || 0 === e2.transmission)
        return;
      const r2 = this.writer, n2 = r2.extensionsUsed, i2 = {};
      if (i2.transmissionFactor = e2.transmission, e2.transmissionMap) {
        const t3 = { index: r2.processTexture(e2.transmissionMap) };
        r2.applyTextureTransform(t3, e2.transmissionMap), i2.transmissionTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, n2[this.name] = true;
    }
  }
  class N_ {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_volume";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial || 0 === e2.transmission)
        return;
      const r2 = this.writer, n2 = r2.extensionsUsed, i2 = {};
      if (i2.thicknessFactor = e2.thickness, e2.thicknessMap) {
        const t3 = { index: r2.processTexture(e2.thicknessMap) };
        r2.applyTextureTransform(t3, e2.thicknessMap), i2.thicknessTexture = t3;
      }
      i2.attenuationDistance = e2.attenuationDistance, i2.attenuationColor = e2.attenuationColor.toArray(), t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, n2[this.name] = true;
    }
  }
  class j_ {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_sheen";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial || e2.sheen < 0.01)
        return;
      const r2 = this.writer, n2 = r2.extensionsUsed, i2 = {};
      if (i2.sheenColorFactor = e2.sheenColor.toArray(), e2.sheenColorMap) {
        const t3 = { index: r2.processTexture(e2.sheenColorMap) };
        r2.applyTextureTransform(t3, e2.sheenColorMap), i2.sheenColorTexture = t3;
      }
      if (i2.sheenRoughnessFactor = e2.sheenRoughness, e2.sheenRoughnessMap) {
        const t3 = { index: r2.processTexture(e2.sheenRoughnessMap) };
        r2.applyTextureTransform(t3, e2.sheenRoughnessMap), i2.sheenRoughnessTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, t2.extras = t2.extras || {}, t2.extras.sheenFactor = e2.sheen, n2[this.name] = true;
    }
  }
  class z_ {
    constructor(e2) {
      this.writer = e2, this.name = "KHR_materials_ior";
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshPhysicalMaterial)
        return;
      const r2 = this.writer.extensionsUsed, n2 = {};
      n2.ior = e2.ior, t2.extensions = t2.extensions || {}, t2.extensions[this.name] = n2, r2[this.name] = true;
    }
  }
  w_.Utils = { GLTFWriter: P_, insertKeyframe: function(e2, t2) {
    const r2 = 1e-3, n2 = e2.getValueSize(), i2 = new e2.TimeBufferType(e2.times.length + 1), s2 = new e2.ValueBufferType(e2.values.length + n2), o2 = e2.createInterpolant(new e2.ValueBufferType(n2));
    let a2;
    if (0 === e2.times.length) {
      i2[0] = t2;
      for (let e3 = 0; e3 < n2; e3++)
        s2[e3] = 0;
      a2 = 0;
    } else if (t2 < e2.times[0]) {
      if (Math.abs(e2.times[0] - t2) < r2)
        return 0;
      i2[0] = t2, i2.set(e2.times, 1), s2.set(o2.evaluate(t2), 0), s2.set(e2.values, n2), a2 = 0;
    } else if (t2 > e2.times[e2.times.length - 1]) {
      if (Math.abs(e2.times[e2.times.length - 1] - t2) < r2)
        return e2.times.length - 1;
      i2[i2.length - 1] = t2, i2.set(e2.times, 0), s2.set(e2.values, 0), s2.set(o2.evaluate(t2), e2.values.length), a2 = i2.length - 1;
    } else
      for (let l2 = 0; l2 < e2.times.length; l2++) {
        if (Math.abs(e2.times[l2] - t2) < r2)
          return l2;
        if (e2.times[l2] < t2 && e2.times[l2 + 1] > t2) {
          i2.set(e2.times.slice(0, l2 + 1), 0), i2[l2 + 1] = t2, i2.set(e2.times.slice(l2 + 1), l2 + 2), s2.set(e2.values.slice(0, (l2 + 1) * n2), 0), s2.set(o2.evaluate(t2), (l2 + 1) * n2), s2.set(e2.values.slice((l2 + 1) * n2), (l2 + 2) * n2), a2 = l2 + 1;
          break;
        }
      }
    return e2.times = i2, e2.values = s2, a2;
  }, mergeMorphTargetTracks: function(e2, t2) {
    const r2 = [], i2 = {}, s2 = e2.tracks;
    for (let e3 = 0; e3 < s2.length; ++e3) {
      let o2 = s2[e3];
      const a2 = n.iUV.parseTrackName(o2.name), l2 = n.iUV.findNode(t2, a2.nodeName);
      if ("morphTargetInfluences" !== a2.propertyName || void 0 === a2.propertyIndex) {
        r2.push(o2);
        continue;
      }
      if (o2.createInterpolant !== o2.InterpolantFactoryMethodDiscrete && o2.createInterpolant !== o2.InterpolantFactoryMethodLinear) {
        if (o2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), o2 = o2.clone(), o2.setInterpolation(n.NMF);
      }
      const c2 = l2.morphTargetInfluences.length, u2 = l2.morphTargetDictionary[a2.propertyIndex];
      if (void 0 === u2)
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + a2.propertyIndex);
      let h2;
      if (void 0 === i2[l2.uuid]) {
        h2 = o2.clone();
        const e4 = new h2.ValueBufferType(c2 * h2.times.length);
        for (let t3 = 0; t3 < h2.times.length; t3++)
          e4[t3 * c2 + u2] = h2.values[t3];
        h2.name = (a2.nodeName || "") + ".morphTargetInfluences", h2.values = e4, i2[l2.uuid] = h2, r2.push(h2);
        continue;
      }
      const p2 = o2.createInterpolant(new o2.ValueBufferType(1));
      h2 = i2[l2.uuid];
      for (let e4 = 0; e4 < h2.times.length; e4++)
        h2.values[e4 * c2 + u2] = p2.evaluate(h2.times[e4]);
      for (let e4 = 0; e4 < o2.times.length; e4++) {
        const t3 = this.insertKeyframe(h2, o2.times[e4]);
        h2.values[t3 * c2 + u2] = o2.values[e4];
      }
    }
    return e2.tracks = r2, e2;
  } };
  class G_ extends w_.Utils.GLTFWriter {
    constructor() {
      super(...arguments), this._defaultMaterial = new n.Wid();
    }
    serializeUserData(e2, t2) {
      const r2 = e2.userData, n2 = {};
      r2.__disposed && console.error("Serializing a disposed object", e2), Object.entries(r2).forEach(([e3, t3]) => {
        (!t3 || "function" == typeof t3 || t3.isObject3D || t3.isTexture || t3.isMaterial || null != t3.assetType || e3.startsWith("_") || "uuid" !== e3 && (Ue.includes(e3) || Ne.includes(e3) || ye.includes(e3))) && (n2[e3] = t3, delete r2[e3]);
      }), super.serializeUserData(e2, t2), Object.entries(n2).forEach(([e3, t3]) => {
        r2[e3] = t3, delete n2[e3];
      });
    }
    processObjects(e2) {
      var t2;
      1 === e2.length && (null === (t2 = e2[0]) || void 0 === t2 ? void 0 : t2.userData.rootSceneModelRoot) ? this.processScene(e2[0]) : super.processObjects(e2);
    }
    processMaterial(e2) {
      if (this.cache.materials.has(e2))
        return this.cache.materials.get(e2);
      let t2 = e2;
      t2 && !t2.isShaderMaterial || (t2 = this._defaultMaterial);
      const r2 = super.processMaterial(t2);
      if (!e2 || t2 === e2)
        return r2;
      const n2 = JSON.stringify(this.json.materials[r2]), i2 = JSON.parse(n2);
      this.serializeUserData(e2, i2), this._invokeAll((t3) => {
        t3.writeMaterial && t3.writeMaterial(e2, i2);
      });
      const s2 = this.json.materials.push(i2) - 1;
      return this.cache.materials.set(e2, s2), s2;
    }
    processImageBlob(e2, t2) {
      if (!e2)
        return -1;
      const r2 = this.cache, n2 = this.options, i2 = this.pending, s2 = this.json, o2 = t2.image;
      r2.images.has(o2) || r2.images.set(o2, {});
      const a2 = r2.images.get(o2), l2 = e2.type + ":flipY/" + t2.flipY.toString();
      if (void 0 !== a2[l2])
        return a2[l2];
      s2.images || (s2.images = []);
      const c2 = { mimeType: e2.type };
      true === n2.binary ? i2.push(new Promise((t3) => {
        this.processBufferViewImage(e2).then((e3) => {
          c2.bufferView = e3, t3();
        });
      })) : i2.push(xt(e2).then((e3) => {
        c2.uri = e3;
      }));
      const u2 = s2.images.push(c2) - 1;
      return a2[l2] = u2, u2;
    }
    processSampler(e2) {
      return super.processSampler(e2);
    }
    processTexture(e2) {
      const t2 = this.cache, r2 = this.json;
      if (t2.textures.has(e2))
        return t2.textures.get(e2);
      const n2 = e2.source.data, i2 = e2.userData.mimeType;
      e2.userData.rootPath && !this.options.embedUrlImages && (e2.source.data = null, delete e2.userData.mimeType);
      const s2 = super.processTexture(e2), o2 = r2.textures[s2];
      if (!o2)
        return console.error("No texture def", s2, e2), s2;
      const a2 = r2.images ? r2.images[o2.source] : null;
      if (a2 && (a2.extras || (a2.extras = {}), e2.source && (a2.extras.uuid = e2.source.uuid), a2.extras.t_uuid = e2.uuid), e2.userData.rootPath && !this.options.embedUrlImages) {
        if (e2.source.data = n2, e2.userData.mimeType = i2, !o2)
          return console.error("textureDef is null", s2, e2), s2;
        o2.source >= 0 ? console.warn("textureDef.source is already set", s2, e2) : o2.source = this.processImageUri(e2.image, e2.userData.rootPath, e2.flipY, i2);
      }
      return o2.source < 0 && console.error("textureDef.source cannot be saved", o2, e2), s2;
    }
    processImage(e2, t2, r2, n2 = "image/png") {
      return e2 ? super.processImage(e2, t2, r2, n2) : -1;
    }
    processImageUri(e2, t2, r2, n2 = "image/png") {
      const i2 = this.cache, s2 = this.json;
      i2.images.has(e2) || i2.images.set(e2, {});
      const o2 = i2.images.get(e2), a2 = n2 + ":flipY/" + r2.toString();
      if (void 0 !== o2[a2])
        return o2[a2];
      s2.images || (s2.images = []);
      const l2 = { mimeType: n2, uri: t2, extras: { flipY: r2 } }, c2 = s2.images.push(l2) - 1;
      return o2[a2] = c2, c2;
    }
  }
  class V_ extends w_ {
    register(e2) {
      return super.register(e2);
    }
    async parseAsync(e2, t2) {
      var r2;
      if (!e2)
        throw new Error("No object to export");
      const n2 = e2.__isGLTFOutput || !Array.isArray(e2) && !e2.isObject3D ? e2 : await new Promise((r3, n3) => this.parse(e2, r3, n3, t2));
      if (n2 && "object" == typeof n2 && !n2.byteLength)
        return new Blob([JSON.stringify(n2, (e3, t3) => e3.startsWith("__") ? void 0 : t3, null !== (r2 = t2.jsonSpaces) && void 0 !== r2 ? r2 : 2)], { type: "model/gltf+json" });
      if (n2)
        return new Blob([n2], { type: "model/gltf+binary" });
      throw new Error("GLTFExporter2.parse() failed");
    }
    parse(e2, t2, r2, n2 = {}) {
      var i2;
      const s2 = { binary: false, trs: false, onlyVisible: true, truncateDrawRange: true, externalImagesInExtras: !n2.embedUrlImages && n2.externalImagesInExtras || false, embedUrlImages: null !== (i2 = n2.embedUrlImages) && void 0 !== i2 && i2, maxTextureSize: 1 / 0, animations: [], includeCustomExtensions: true };
      return "glb" === n2.exportExt && (s2.binary = true), false !== n2.preserveUUIDs && (Array.isArray(e2) ? e2 : [e2]).forEach((e3) => e3.traverse((e4) => {
        e4.uuid && (e4.userData.gltfUUID = e4.uuid);
      })), (Array.isArray(e2) ? e2 : [e2]).forEach((e3) => e3.traverse((e4) => {
        if (e4.animations)
          for (const t3 of e4.animations)
            false === t3.__gltfExport || s2.animations.includes(t3) || s2.animations.push(...e4.animations);
      })), super.parse(e2, (r3) => {
        false !== n2.preserveUUIDs && (Array.isArray(e2) ? e2 : [e2]).forEach((e3) => e3.traverse((e4) => {
          delete e4.userData.gltfUUID;
        })), t2(Object.assign(r3, { __isGLTFOutput: true }));
      }, r2, s2, new G_());
    }
  }
  function Q_(e2, t2) {
    const r2 = e2.getPlugin(to).exportViewerConfig();
    t2.json.textures && t2.json.samplers && t2.json.images && r2.resources.textures && Object.entries(r2.resources.textures).forEach(([e3, n2]) => {
      const i3 = t2.json.textures.find((r3) => {
        var n3, i4, s2, o2, a2;
        return (null === (n3 = r3.extras) || void 0 === n3 ? void 0 : n3.uuid) === e3 || (null === (s2 = null === (i4 = t2.json.samplers[r3.sampler]) || void 0 === i4 ? void 0 : i4.extras) || void 0 === s2 ? void 0 : s2.uuid) === e3 || (null === (a2 = null === (o2 = t2.json.images[r3.source]) || void 0 === o2 ? void 0 : o2.extras) || void 0 === a2 ? void 0 : a2.t_uuid) === e3;
      });
      i3 && (n2.image && r2.resources.images && r2.resources.images[n2.image] && delete r2.resources.images[n2.image], r2.resources.textures[e3] = {});
    }), t2.json.materials && r2.resources.materials && Object.entries(r2.resources.materials).forEach(([e3, n2]) => {
      const i3 = t2.json.materials.find((t3) => {
        var r3;
        return (null === (r3 = t3.extras) || void 0 === r3 ? void 0 : r3.uuid) === e3;
      });
      i3 && (r2.resources.materials[e3] = {});
    });
    const i2 = [];
    Object.values(r2.resources).forEach((e3) => {
      Object.values(e3).forEach((e4) => {
        e4.url && ("Uint16Array" === e4.url.type && e4.url.data && (e4.url.data instanceof Uint16Array || (e4.url.data = new Uint16Array(e4.url.data)), i2.push(e4.url)), "Uint8Array" === e4.url.type && e4.url.data && (e4.url.data instanceof Uint8Array || (e4.url.data = new Uint8Array(e4.url.data)), i2.push(e4.url)));
      });
    });
    for (const e3 of i2) {
      let r3 = "application/octet-stream";
      if ("Uint16Array" === e3.type) {
        const t3 = H_(e3.data, 4), i4 = new ImageData(t3, e3.width, e3.height), s3 = n.PpQ.getDataURL(i4, true).split(",")[1];
        r3 = "image/png", e3.data = atob(s3), e3.encoding = "rgbe";
      }
      const i3 = new Blob([e3.data], { type: r3 });
      t2.json.images || (t2.json.images = []);
      const s2 = { mimeType: r3 }, o2 = t2.json.images.push(s2) - 1;
      e3.data = { image: o2 }, t2.pending.push(t2.processBufferViewImage(i3).then((e4) => {
        s2.bufferView = e4;
      }));
    }
    return r2;
  }
  function H_(e2, t2 = 3, r2) {
    let n2, i2, s2, o2, a2;
    const l2 = e2.byteLength / (2 * t2) | 0;
    r2 = r2 || new Uint8ClampedArray(4 * l2);
    for (let c2 = 0; c2 < l2; c2++) {
      n2 = e2[c2 * t2], i2 = e2[c2 * t2 + 1], s2 = e2[c2 * t2 + 2], o2 = Math.max(Math.max(n2, i2), s2);
      const l3 = Math.ceil(Math.log2(o2));
      a2 = Math.pow(2, l3 - 8), r2[4 * c2] = n2 / a2 | 0, r2[4 * c2 + 1] = i2 / a2 | 0, r2[4 * c2 + 2] = s2 / a2 | 0, r2[4 * c2 + 3] = l3 + 128;
    }
    return r2;
  }
  function W_(e2, t2 = V_, r2) {
    var n2;
    if (!e2)
      return;
    const i2 = eg.Exporters.findIndex((e3) => e3.ext.includes("gltf") || e3.ext.includes("glb")), s2 = [];
    i2 >= 0 ? (s2.push(...null !== (n2 = eg.Exporters[i2].extensions) && void 0 !== n2 ? n2 : []), eg.Exporters.splice(i2, 1)) : (s2.push(Y_), s2.push(X_), s2.push(q_), s2.push((e3) => new K_(e3)), s2.push((e3) => new J_(e3)), s2.push((e3) => new Z_(e3)), s2.push((e3) => new $_(e3))), eg.Exporters.push({ ctor: () => {
      const n3 = new t2();
      return s2.forEach((e3) => n3.register(e3)), n3.register((t3) => ({ afterParse: (r3) => {
        var n4, i3;
        if (!(null === (n4 = null == (r3 = Array.isArray(r3) ? r3[0] : r3) ? void 0 : r3.userData) || void 0 === n4 ? void 0 : n4.rootSceneModelRoot) || false === (null === (i3 = null == r3 ? void 0 : r3.userData) || void 0 === i3 ? void 0 : i3.__exportViewerConfig))
          return;
        const s3 = t3.json.scenes[t3.json.scene || 0];
        s3.extensions || (s3.extensions = {}), s3.extensions[on] = Q_(e2, t3), t3.extensionsUsed[on] = true;
      } })), null == r2 || r2(n3), n3;
    }, ext: ["gltf", "glb"], extensions: s2 });
  }
  const q_ = (e2) => ({ writeNode: (t2, r2) => {
    if (!(null == t2 ? void 0 : t2.isLight))
      return;
    r2.extensions || (r2.extensions = {});
    const n2 = {};
    t2.shadow && (n2.shadow = t2.shadow.toJSON()), Object.keys(n2).length > 0 && (r2.extensions[ln] = n2, e2.extensionsUsed[ln] = true);
  } }), X_ = (e2) => ({ writeNode: (t2, r2) => {
    if (!(null == t2 ? void 0 : t2.isObject3D))
      return;
    r2.extensions || (r2.extensions = {});
    const n2 = {};
    void 0 !== t2.castShadow && (n2.castShadow = t2.castShadow), void 0 !== t2.receiveShadow && (n2.receiveShadow = t2.receiveShadow), false === t2.visible && (n2.visible = false), false === t2.frustumCulled && (n2.frustumCulled = false), 0 !== t2.renderOrder && (n2.renderOrder = t2.renderOrder), 1 !== t2.layers.mask && (n2.layers = t2.layers.mask), false === t2.matrixAutoUpdate && (n2.matrixAutoUpdate = false), Object.keys(n2).length > 0 && (r2.extensions[cn] = n2, e2.extensionsUsed[cn] = true);
  } }), Y_ = (e2) => ({ writeMaterial(t2, r2) {
    var i2;
    if (!(null == t2 ? void 0 : t2.isMaterial))
      return;
    r2.extensions || (r2.extensions = {});
    const s2 = {};
    if (void 0 !== t2.emissiveIntensity && (null === (i2 = t2.emissive) || void 0 === i2 ? void 0 : i2.isColor)) {
      const e3 = t2.emissive.clone().multiplyScalar(t2.emissiveIntensity), r3 = Math.max(e3.r, e3.g, e3.b);
      r3 > 1 && (s2.emissiveIntensity = r3);
    }
    void 0 !== t2.fog && (s2.fog = t2.fog), void 0 !== t2.flatShading && (s2.flatShading = t2.flatShading), void 0 !== t2.blending && (s2.blending = t2.blending), void 0 !== t2.side && t2.side !== n.ehD && (s2.side = t2.side), void 0 !== t2.shadowSide && (s2.shadowSide = t2.shadowSide), void 0 !== t2.depthFunc && (s2.depthFunc = t2.depthFunc), void 0 !== t2.depthTest && (s2.depthTest = t2.depthTest), void 0 !== t2.depthWrite && (s2.depthWrite = t2.depthWrite), void 0 !== t2.colorWrite && (s2.colorWrite = t2.colorWrite), void 0 !== t2.wireframe && (s2.wireframe = t2.wireframe), void 0 !== t2.wireframeLinewidth && (s2.wireframeLinewidth = t2.wireframeLinewidth), void 0 !== t2.wireframeLinecap && (s2.wireframeLinecap = t2.wireframeLinecap), void 0 !== t2.wireframeLinejoin && (s2.wireframeLinejoin = t2.wireframeLinejoin), void 0 !== t2.rotation && (s2.rotation = t2.rotation), void 0 !== t2.polygonOffset && (s2.polygonOffset = t2.polygonOffset), void 0 !== t2.polygonOffsetFactor && (s2.polygonOffsetFactor = t2.polygonOffsetFactor), void 0 !== t2.polygonOffsetUnits && (s2.polygonOffsetUnits = t2.polygonOffsetUnits), void 0 !== t2.dithering && (s2.dithering = t2.dithering), void 0 !== t2.alphaToCoverage && (s2.alphaToCoverage = t2.alphaToCoverage), void 0 !== t2.premultipliedAlpha && (s2.premultipliedAlpha = t2.premultipliedAlpha), void 0 !== t2.toneMapped && (s2.toneMapped = t2.toneMapped);
    const o2 = this.materialExternalResources[t2.uuid];
    o2 && Object.entries(o2).forEach(([e3, t3]) => {
      e3.startsWith("_") || (s2[e3] = ke(t3, false, this.serializedMeta));
    }), Object.keys(s2).length > 0 && (r2.extensions[un] = s2, e2.extensionsUsed[un] = true);
  }, materialExternalResources: {}, serializedMeta: { images: {}, textures: {} }, beforeParse(t2) {
    if (this.materialExternalResources = {}, !e2.options.externalImagesInExtras)
      return;
    const r2 = [];
    (Array.isArray(t2) ? t2 : [t2]).forEach((e3) => {
      null == e3 || e3.traverse((e4) => {
        var t3;
        e4 && (null === (t3 = e4.material) || void 0 === t3 ? void 0 : t3.isMaterial) && r2.push(e4.material);
      });
    }), r2.forEach((e3) => {
      e3 && (this.materialExternalResources[e3.uuid] || (this.materialExternalResources[e3.uuid] = {}), this.materialExternalResources[e3.uuid].__materialRef = e3, Object.entries(e3).forEach(([t3, r3]) => {
        t3.startsWith("_") || r3 && r3.isTexture && r3.userData.rootPath && (e3[t3] = null, this.materialExternalResources[e3.uuid][t3] = r3);
      }));
    });
  }, afterParse(t2) {
    const r2 = Object.values(this.materialExternalResources);
    if (r2.length < 1)
      return;
    r2.forEach((e3) => {
      const t3 = e3.__materialRef;
      t3 && (Object.entries(e3).forEach(([e4, r3]) => {
        e4.startsWith("_") || r3 && (t3[e4] = r3);
      }), delete this.materialExternalResources[t3.uuid]);
    });
    const n2 = e2.json.scenes[e2.json.scene || 0];
    n2.extensions || (n2.extensions = {}), n2.extensions[un] = { resources: this.serializedMeta }, e2.extensionsUsed[un] = true;
  } });
  class K_ {
    constructor(e2) {
      this.writer = e2, this.name = mn;
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshStandardMaterial || 0 === e2.bumpScale)
        return;
      const r2 = this.writer, n2 = r2.extensionsUsed, i2 = {};
      if (i2.bumpScale = e2.bumpScale, e2.bumpMap) {
        const t3 = { index: r2.processTexture(e2.bumpMap) };
        r2.applyTextureTransform(t3, e2.bumpMap), i2.bumpTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, n2[this.name] = true;
    }
  }
  class J_ {
    constructor(e2) {
      this.writer = e2, this.name = _n;
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshStandardMaterial || 0 === e2.displacementScale)
        return;
      const r2 = this.writer, n2 = r2.extensionsUsed, i2 = {};
      if (i2.displacementScale = e2.displacementScale, i2.displacementBias = e2.displacementBias, e2.displacementMap) {
        const t3 = { index: r2.processTexture(e2.displacementMap) };
        r2.applyTextureTransform(t3, e2.displacementMap), i2.displacementTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, n2[this.name] = true;
    }
  }
  class Z_ {
    constructor(e2) {
      this.writer = e2, this.name = vn;
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshStandardMaterial || 0 === e2.lightMapIntensity)
        return;
      const r2 = this.writer, n2 = r2.extensionsUsed, i2 = {};
      if (i2.lightMapIntensity = e2.lightMapIntensity, e2.lightMap) {
        const t3 = { index: r2.processTexture(e2.lightMap) };
        r2.applyTextureTransform(t3, e2.lightMap), i2.lightMapTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, n2[this.name] = true;
    }
  }
  class $_ {
    constructor(e2) {
      this.writer = e2, this.name = gn;
    }
    writeMaterial(e2, t2) {
      if (!e2.isMeshStandardMaterial || !e2.alphaMap)
        return;
      const r2 = this.writer, n2 = r2.extensionsUsed, i2 = {};
      if (e2.alphaMap) {
        const t3 = { index: r2.processTexture(e2.alphaMap) };
        r2.applyTextureTransform(t3, e2.alphaMap), i2.alphaTexture = t3;
      }
      t2.extensions = t2.extensions || {}, t2.extensions[this.name] = i2, n2[this.name] = true;
    }
  }
  class eg extends r {
    constructor(e2, t2 = {}) {
      super(), this._processors = new cr(), this._cachedParsers = [], W_(e2);
    }
    get processors() {
      return this._processors;
    }
    getExporter(...e2) {
      return eg.Exporters.find((t2) => t2.ext.some((t3) => e2.includes(t3)));
    }
    async exportObject(e2, t2 = {}) {
      var r2, n2, i2, s2;
      if (!(null == e2 ? void 0 : e2.assetType))
        return void console.error("Object has no asset type");
      (null === (n2 = null === (r2 = e2) || void 0 === r2 ? void 0 : r2.userData) || void 0 === n2 ? void 0 : n2.rootSceneModelRoot) && false === t2.viewerConfig && (e2.userData.__exportViewerConfig = false);
      const o2 = await this._exportFile(e2, t2);
      return (null === (s2 = null === (i2 = e2) || void 0 === i2 ? void 0 : i2.userData) || void 0 === s2 ? void 0 : s2.rootSceneModelRoot) && false === t2.viewerConfig && delete e2.userData.__exportViewerConfig, o2;
    }
    async _exportFile(e2, t2 = {}) {
      var r2, n2, i2;
      let s2;
      this.dispatchEvent({ type: "exportFile", obj: e2, state: "processing" });
      try {
        const o2 = await this.processBeforeExport(e2, t2), a2 = null !== (n2 = null !== (r2 = t2.exportExt) && void 0 !== r2 ? r2 : null == o2 ? void 0 : o2.typeExt) && void 0 !== n2 ? n2 : null == o2 ? void 0 : o2.ext;
        if (!o2 || !a2)
          throw new Error(`Unable to preprocess before export ${a2}`);
        const l2 = this._getParser(a2);
        this.dispatchEvent({ type: "exportFile", obj: e2, state: "exporting" });
        const c2 = await l2.parseAsync(o2.obj, { exportExt: null !== (i2 = o2.ext) && void 0 !== i2 ? i2 : a2, ...t2 });
        c2.ext = o2.ext, s2 = c2;
      } catch (t3) {
        return console.error("AssetExporter: Unable to Export file", e2), console.error(t3), void this.dispatchEvent({ type: "exportFile", obj: e2, state: "error", error: t3 });
      }
      return this.dispatchEvent({ type: "exportFile", obj: e2, state: "done" }), s2;
    }
    _createParser(e2) {
      const t2 = eg.Exporters.find((t3) => t3.ext.includes(e2));
      if (!t2)
        throw new Error(`No exporter found for extension ${e2}`);
      const r2 = null == t2 ? void 0 : t2.ctor(this);
      if (!r2)
        throw new Error(`Unable to create parser for extension ${e2}`);
      return this._cachedParsers.push({ ext: t2.ext, parser: r2 }), this.dispatchEvent({ type: "exporterCreate", exporter: t2, parser: r2 }), r2;
    }
    _getParser(e2) {
      var t2, r2;
      return null !== (r2 = null === (t2 = this._cachedParsers.find((t3) => t3.ext.includes(e2))) || void 0 === t2 ? void 0 : t2.parser) && void 0 !== r2 ? r2 : this._createParser(e2);
    }
    async processBeforeExport(e2, t2 = {}) {
      switch (null != e2.assetType && (e2 = await this._processors.process(e2.assetType, e2, t2)), e2.assetType) {
        case "light":
          return void console.error("AssetExporter: light export not implemented");
        case "model":
          return { obj: e2, ext: "glb" };
        case "material":
          return { obj: e2.toJSON(), ext: e2.typeSlug || "json", typeExt: "json" };
        case "texture":
          return { obj: e2.toJSON(), ext: "json" };
        default:
          console.error("AssetExporter: unknown asset type", e2.assetType);
      }
    }
    dispose() {
      var e2;
      null === (e2 = this._processors) || void 0 === e2 || e2.dispose();
    }
  }
  eg.Exporters = [{ ctor: () => new y_(), ext: ["json"] }, { ctor: () => new x_(), ext: ["txt", "text"] }];
  class tg extends ro {
    constructor(e2) {
      super(), this.enabled = true, this.exportOptions = { compress: false, name: "scene", viewerConfig: true, convertMeshToIndexed: false, embedUrlImages: false }, this.exporter = e2, this.exportScene = this.exportScene.bind(this);
    }
    async onAdded(e2) {
      await super.onAdded(e2), this.exporter || (this.exporter = new eg(e2)), this.exporter.processors.add("model", { forAssetType: "model", processAsync: async (e3, t2) => {
        var r2;
        return t2.convertMeshToIndexed && (null === (r2 = e3.modelObject) || void 0 === r2 || r2.traverse((e4) => {
          var t3;
          e4.geometry && (e4.geometry.attributes.index || null === (t3 = e4.setGeometry) || void 0 === t3 || t3.call(e4, Y(e4.geometry)));
        })), e3;
      } });
    }
    async onRemove(e2) {
      return super.onRemove(e2);
    }
    async exportScene(e2) {
      var t2, r2;
      return null === (t2 = this.exporter) || void 0 === t2 ? void 0 : t2.exportObject(null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.scene.modelRoot, e2 || { ...this.exportOptions });
    }
    get uiConfig() {
      if (this._uiConfig)
        return this._uiConfig;
      const e2 = this._viewer;
      e2.addEventListener("addPlugin", (e3) => {
        var t3;
        "function" == typeof (null === (t3 = e3.plugin) || void 0 === t3 ? void 0 : t3.toJSON) && console.error("Add all plugins before setting up the export UI, or use `toJSON: any = null` in the plugin ");
      });
      const t2 = Object.entries(e2.plugins).filter(([e3, t3]) => "function" == typeof (null == t3 ? void 0 : t3.toJSON)).map(([e3, t3]) => ({ label: e3, type: "checkbox", value: true }));
      return this._uiConfig = { type: "folder", label: "Asset Export", limitedUi: true, children: [{ type: "input", property: [this.exportOptions, "name"], limitedUi: true }, { type: "folder", label: "GLB Export", limitedUi: true, children: [{ type: "checkbox", label: "DRACO Compress", property: [this.exportOptions, "compress"], limitedUi: true }, { type: "checkbox", label: "Scene Settings", property: [this.exportOptions, "viewerConfig"], limitedUi: true }, { type: "checkbox", label: "Indexed meshes only", property: [this.exportOptions, "convertMeshToIndexed"] }, { type: "button", label: "Export GLB", limitedUi: true, value: async () => {
        const e3 = await this.exportScene(this.exportOptions);
        e3 && yt(e3, this.exportOptions.name + "." + e3.ext);
      } }] }, { type: "folder", label: "Preset/Config export", children: [{ type: "folder", label: "Plugins", children: t2 }, { type: "button", label: "Select none", value: () => {
        t2.forEach((e3) => {
          var t3;
          e3.value = false, null === (t3 = e3.uiRefresh) || void 0 === t3 || t3.call(e3);
        });
      } }, { type: "button", label: "Select all", value: () => {
        t2.forEach((e3) => {
          var t3;
          e3.value = true, null === (t3 = e3.uiRefresh) || void 0 === t3 || t3.call(e3);
        });
      } }, { type: "button", label: "Export Plugins", limitedUi: true, value: async () => {
        const r2 = new Blob([JSON.stringify(e2.getPlugin(to).exportPluginPresets(t2.filter((e3) => !!e3.value).map((e3) => A(e3.label) || "")), null, 2)], { type: "application/json" });
        r2 && yt(r2, this.exportOptions.name + "." + to.ViewerTypeSlug);
      } }, { type: "button", label: "Export All Viewer Config", limitedUi: true, value: async () => {
        const t3 = new Blob([JSON.stringify(e2.getPlugin(to).exportViewerConfig(), null, 2)], { type: "application/json" });
        t3 && yt(t3, this.exportOptions.name + "." + to.ViewerTypeSlug);
      } }] }] };
    }
  }
  tg.PluginType = "AssetExporterPlugin";
  class rg {
    constructor() {
      this._listeners = {};
    }
    addEventListener(e2, t2) {
      const r2 = this._listeners;
      return void 0 === r2[e2] && (r2[e2] = []), -1 === r2[e2].indexOf(t2) && r2[e2].push(t2), this;
    }
    removeEventListener(e2, t2) {
      if (void 0 === this._listeners)
        return this;
      const r2 = this._listeners[e2];
      if (void 0 !== r2) {
        const e3 = r2.indexOf(t2);
        -1 !== e3 && r2.splice(e3, 1);
      }
      return this;
    }
    dispatchEvent(e2) {
      if (void 0 === this._listeners)
        return this;
      const t2 = this._listeners[e2.type];
      if (void 0 !== t2) {
        const r2 = t2.slice(0);
        for (let t3 = 0, n2 = r2.length; t3 < n2; t3++)
          r2[t3].call(this, e2);
      }
      return this;
    }
    dispose() {
      for (const e2 in this._listeners)
        delete this._listeners[e2];
    }
  }
  class ng extends rg {
    constructor(e2, t2, r2, n2 = {}) {
      if (super(), this._name = void 0, this._parent = void 0, this._child = void 0, this._attributes = void 0, this._disposed = false, this._name = e2, this._parent = t2, this._child = r2, this._attributes = n2, !t2.isOnGraph(r2))
        throw new Error("Cannot connect disconnected graphs.");
    }
    getName() {
      return this._name;
    }
    getParent() {
      return this._parent;
    }
    getChild() {
      return this._child;
    }
    setChild(e2) {
      return this._child = e2, this;
    }
    getAttributes() {
      return this._attributes;
    }
    dispose() {
      this._disposed || (this._disposed = true, this.dispatchEvent({ type: "dispose", target: this }), super.dispose());
    }
    isDisposed() {
      return this._disposed;
    }
  }
  class ig extends rg {
    constructor(...e2) {
      super(...e2), this._emptySet = /* @__PURE__ */ new Set(), this._edges = /* @__PURE__ */ new Set(), this._parentEdges = /* @__PURE__ */ new Map(), this._childEdges = /* @__PURE__ */ new Map();
    }
    listEdges() {
      return Array.from(this._edges);
    }
    listParentEdges(e2) {
      return Array.from(this._childEdges.get(e2) || this._emptySet);
    }
    listParents(e2) {
      return this.listParentEdges(e2).map((e3) => e3.getParent());
    }
    listChildEdges(e2) {
      return Array.from(this._parentEdges.get(e2) || this._emptySet);
    }
    listChildren(e2) {
      return this.listChildEdges(e2).map((e3) => e3.getChild());
    }
    disconnectParents(e2, t2) {
      let r2 = this.listParentEdges(e2);
      return t2 && (r2 = r2.filter((e3) => t2(e3.getParent()))), r2.forEach((e3) => e3.dispose()), this;
    }
    createEdge(e2, t2, r2, n2) {
      return this._registerEdge(new ng(e2, t2, r2, n2));
    }
    _registerEdge(e2) {
      this._edges.add(e2);
      const t2 = e2.getParent();
      this._parentEdges.has(t2) || this._parentEdges.set(t2, /* @__PURE__ */ new Set()), this._parentEdges.get(t2).add(e2);
      const r2 = e2.getChild();
      return this._childEdges.has(r2) || this._childEdges.set(r2, /* @__PURE__ */ new Set()), this._childEdges.get(r2).add(e2), e2.addEventListener("dispose", () => this._removeEdge(e2)), e2;
    }
    _removeEdge(e2) {
      return this._edges.delete(e2), this._parentEdges.get(e2.getParent()).delete(e2), this._childEdges.get(e2.getChild()).delete(e2), this;
    }
  }
  function sg() {
    return sg = Object.assign || function(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var r2 = arguments[t2];
        for (var n2 in r2)
          Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
      }
      return e2;
    }, sg.apply(this, arguments);
  }
  function og(e2) {
    return e2 instanceof ng;
  }
  function ag(e2) {
    return Array.isArray(e2) && e2[0] instanceof ng;
  }
  function lg(e2) {
    return !!(e2 && "object" == typeof e2 && Object.values(e2)[0] instanceof ng);
  }
  const cg = Symbol("attributes"), ug = Symbol("immutableKeys");
  class hg extends rg {
    constructor(e2) {
      super(), this._disposed = false, this.graph = void 0, this[cg] = void 0, this[ug] = void 0, this.graph = e2, this[ug] = /* @__PURE__ */ new Set(), this[cg] = this._createAttributes();
    }
    getDefaults() {
      return {};
    }
    _createAttributes() {
      const e2 = this.getDefaults(), t2 = {};
      for (const r2 in e2) {
        const n2 = e2[r2];
        if (n2 instanceof hg) {
          const e3 = this.graph.createEdge(r2, this, n2);
          e3.addEventListener("dispose", () => n2.dispose()), this[ug].add(r2), t2[r2] = e3;
        } else
          t2[r2] = n2;
      }
      return t2;
    }
    isOnGraph(e2) {
      return this.graph === e2.graph;
    }
    isDisposed() {
      return this._disposed;
    }
    dispose() {
      this._disposed || (this.graph.listChildEdges(this).forEach((e2) => e2.dispose()), this.graph.disconnectParents(this), this._disposed = true, this.dispatchEvent({ type: "dispose" }));
    }
    detach() {
      return this.graph.disconnectParents(this), this;
    }
    swap(e2, t2) {
      for (const r2 in this[cg]) {
        const n2 = this[cg][r2];
        if (og(n2)) {
          const i2 = n2;
          i2.getChild() === e2 && this.setRef(r2, t2, i2.getAttributes());
        } else if (ag(n2)) {
          const i2 = n2.find((t3) => t3.getChild() === e2);
          if (i2) {
            const n3 = i2.getAttributes();
            this.removeRef(r2, e2).addRef(r2, t2, n3);
          }
        } else if (lg(n2)) {
          const i2 = n2;
          for (const n3 in i2) {
            const s2 = i2[n3];
            s2.getChild() === e2 && this.setRefMap(r2, n3, t2, s2.getAttributes());
          }
        }
      }
      return this;
    }
    get(e2) {
      return this[cg][e2];
    }
    set(e2, t2) {
      return this[cg][e2] = t2, this.dispatchEvent({ type: "change", attribute: e2 });
    }
    getRef(e2) {
      const t2 = this[cg][e2];
      return t2 ? t2.getChild() : null;
    }
    setRef(e2, t2, r2) {
      if (this[ug].has(e2))
        throw new Error(`Cannot overwrite immutable attribute, "${e2}".`);
      const n2 = this[cg][e2];
      if (n2 && n2.dispose(), !t2)
        return this;
      const i2 = this.graph.createEdge(e2, this, t2, r2);
      return i2.addEventListener("dispose", () => {
        delete this[cg][e2], this.dispatchEvent({ type: "change", attribute: e2 });
      }), this[cg][e2] = i2, this.dispatchEvent({ type: "change", attribute: e2 });
    }
    listRefs(e2) {
      return this[cg][e2].map((e3) => e3.getChild());
    }
    addRef(e2, t2, r2) {
      const n2 = this.graph.createEdge(e2, this, t2, r2), i2 = this[cg][e2];
      return i2.push(n2), n2.addEventListener("dispose", () => {
        const t3 = i2.filter((e3) => e3 !== n2);
        i2.length = 0;
        for (const e3 of t3)
          i2.push(e3);
        this.dispatchEvent({ type: "change", attribute: e2 });
      }), this.dispatchEvent({ type: "change", attribute: e2 });
    }
    removeRef(e2, t2) {
      return this[cg][e2].filter((e3) => e3.getChild() === t2).forEach((e3) => e3.dispose()), this;
    }
    listRefMapKeys(e2) {
      return Object.keys(this[cg][e2]);
    }
    listRefMapValues(e2) {
      return Object.values(this[cg][e2]).map((e3) => e3.getChild());
    }
    getRefMap(e2, t2) {
      const r2 = this[cg][e2];
      return r2[t2] ? r2[t2].getChild() : null;
    }
    setRefMap(e2, t2, r2, n2) {
      const i2 = this[cg][e2], s2 = i2[t2];
      if (s2 && s2.dispose(), !r2)
        return this;
      n2 = Object.assign(n2 || {}, { key: t2 });
      const o2 = this.graph.createEdge(e2, this, r2, sg({}, n2, { key: t2 }));
      return o2.addEventListener("dispose", () => {
        delete i2[t2], this.dispatchEvent({ type: "change", attribute: e2, key: t2 });
      }), i2[t2] = o2, this.dispatchEvent({ type: "change", attribute: e2, key: t2 });
    }
    dispatchEvent(e2) {
      return super.dispatchEvent(sg({}, e2, { target: this })), this.graph.dispatchEvent(sg({}, e2, { target: this, type: `node:${e2.type}` })), this;
    }
  }
  var pg, dg, fg, mg, _g, gg, vg = "undefined" != typeof Float32Array ? Float32Array : Array;
  function Ag(e2) {
    var t2 = e2[0], r2 = e2[1], n2 = e2[2];
    return Math.hypot(t2, r2, n2);
  }
  function bg(e2, t2, r2) {
    var n2 = t2[0], i2 = t2[1], s2 = t2[2], o2 = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15];
    return o2 = o2 || 1, e2[0] = (r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12]) / o2, e2[1] = (r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13]) / o2, e2[2] = (r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14]) / o2, e2;
  }
  function yg(e2, t2, r2) {
    var n2 = t2[0], i2 = t2[1], s2 = t2[2], o2 = t2[3], a2 = t2[4], l2 = t2[5], c2 = t2[6], u2 = t2[7], h2 = t2[8], p2 = t2[9], d2 = t2[10], f2 = t2[11], m2 = t2[12], _2 = t2[13], g2 = t2[14], v2 = t2[15], A2 = r2[0], b2 = r2[1], y2 = r2[2], x2 = r2[3];
    return e2[0] = A2 * n2 + b2 * a2 + y2 * h2 + x2 * m2, e2[1] = A2 * i2 + b2 * l2 + y2 * p2 + x2 * _2, e2[2] = A2 * s2 + b2 * c2 + y2 * d2 + x2 * g2, e2[3] = A2 * o2 + b2 * u2 + y2 * f2 + x2 * v2, A2 = r2[4], b2 = r2[5], y2 = r2[6], x2 = r2[7], e2[4] = A2 * n2 + b2 * a2 + y2 * h2 + x2 * m2, e2[5] = A2 * i2 + b2 * l2 + y2 * p2 + x2 * _2, e2[6] = A2 * s2 + b2 * c2 + y2 * d2 + x2 * g2, e2[7] = A2 * o2 + b2 * u2 + y2 * f2 + x2 * v2, A2 = r2[8], b2 = r2[9], y2 = r2[10], x2 = r2[11], e2[8] = A2 * n2 + b2 * a2 + y2 * h2 + x2 * m2, e2[9] = A2 * i2 + b2 * l2 + y2 * p2 + x2 * _2, e2[10] = A2 * s2 + b2 * c2 + y2 * d2 + x2 * g2, e2[11] = A2 * o2 + b2 * u2 + y2 * f2 + x2 * v2, A2 = r2[12], b2 = r2[13], y2 = r2[14], x2 = r2[15], e2[12] = A2 * n2 + b2 * a2 + y2 * h2 + x2 * m2, e2[13] = A2 * i2 + b2 * l2 + y2 * p2 + x2 * _2, e2[14] = A2 * s2 + b2 * c2 + y2 * d2 + x2 * g2, e2[15] = A2 * o2 + b2 * u2 + y2 * f2 + x2 * v2, e2;
  }
  function xg(e2, t2) {
    const r2 = { min: [1 / 0, 1 / 0, 1 / 0], max: [-1 / 0, -1 / 0, -1 / 0] };
    for (const n2 of e2.listPrimitives()) {
      const e3 = n2.getAttribute("POSITION");
      if (!e3)
        continue;
      let i2 = [0, 0, 0], s2 = [0, 0, 0];
      for (let n3 = 0; n3 < e3.getCount(); n3++)
        i2 = e3.getElement(n3, i2), s2 = bg(s2, i2, t2), wg(s2, r2);
    }
    return r2;
  }
  function wg(e2, t2) {
    for (let r2 = 0; r2 < 3; r2++)
      t2.min[r2] = Math.min(e2[r2], t2.min[r2]), t2.max[r2] = Math.max(e2[r2], t2.max[r2]);
  }
  Math.random, Math.PI, Math.hypot || (Math.hypot = function() {
    for (var e2 = 0, t2 = arguments.length; t2--; )
      e2 += arguments[t2] * arguments[t2];
    return Math.sqrt(e2);
  }), pg = new vg(3), vg != Float32Array && (pg[0] = 0, pg[1] = 0, pg[2] = 0), function(e2) {
    e2.ACCESSOR = "Accessor", e2.ANIMATION = "Animation", e2.ANIMATION_CHANNEL = "AnimationChannel", e2.ANIMATION_SAMPLER = "AnimationSampler", e2.BUFFER = "Buffer", e2.CAMERA = "Camera", e2.MATERIAL = "Material", e2.MESH = "Mesh", e2.PRIMITIVE = "Primitive", e2.PRIMITIVE_TARGET = "PrimitiveTarget", e2.NODE = "Node", e2.ROOT = "Root", e2.SCENE = "Scene", e2.SKIN = "Skin", e2.TEXTURE = "Texture", e2.TEXTURE_INFO = "TextureInfo";
  }(dg || (dg = {})), function(e2) {
    e2.INTERLEAVED = "interleaved", e2.SEPARATE = "separate";
  }(fg || (fg = {})), function(e2) {
    e2.ARRAY_BUFFER = "ARRAY_BUFFER", e2.ELEMENT_ARRAY_BUFFER = "ELEMENT_ARRAY_BUFFER", e2.INVERSE_BIND_MATRICES = "INVERSE_BIND_MATRICES", e2.OTHER = "OTHER";
  }(mg || (mg = {})), function(e2) {
    e2[e2.R = 4096] = "R", e2[e2.G = 256] = "G", e2[e2.B = 16] = "B", e2[e2.A = 1] = "A";
  }(_g || (_g = {})), function(e2) {
    e2.GLTF = "GLTF", e2.GLB = "GLB";
  }(gg || (gg = {}));
  class Eg {
    static createBufferFromDataURI(e2) {
      if ("undefined" == typeof Buffer) {
        const t2 = atob(e2.split(",")[1]), r2 = new Uint8Array(t2.length);
        for (let e3 = 0; e3 < t2.length; e3++)
          r2[e3] = t2.charCodeAt(e3);
        return r2;
      }
      {
        const t2 = e2.split(",")[1], r2 = e2.indexOf("base64") >= 0;
        return Buffer.from(t2, r2 ? "base64" : "utf8");
      }
    }
    static encodeText(e2) {
      return "undefined" != typeof TextEncoder ? new TextEncoder().encode(e2) : Buffer.from(e2);
    }
    static decodeText(e2) {
      return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e2) : Buffer.from(e2).toString("utf8");
    }
    static concat(e2) {
      let t2 = 0;
      for (const r3 of e2)
        t2 += r3.byteLength;
      const r2 = new Uint8Array(t2);
      let n2 = 0;
      for (const t3 of e2)
        r2.set(t3, n2), n2 += t3.byteLength;
      return r2;
    }
    static pad(e2, t2 = 0) {
      const r2 = this.padNumber(e2.byteLength);
      if (r2 === e2.byteLength)
        return e2;
      const n2 = new Uint8Array(r2);
      if (n2.set(e2), 0 !== t2)
        for (let i2 = e2.byteLength; i2 < r2; i2++)
          n2[i2] = t2;
      return n2;
    }
    static padNumber(e2) {
      return 4 * Math.ceil(e2 / 4);
    }
    static equals(e2, t2) {
      if (e2 === t2)
        return true;
      if (e2.byteLength !== t2.byteLength)
        return false;
      let r2 = e2.byteLength;
      for (; r2--; )
        if (e2[r2] !== t2[r2])
          return false;
      return true;
    }
    static toView(e2, t2 = 0, r2 = 1 / 0) {
      return new Uint8Array(e2.buffer, e2.byteOffset + t2, Math.min(e2.byteLength, r2));
    }
    static assertView(e2) {
      if (e2 && !ArrayBuffer.isView(e2))
        throw new Error(`Method requires Uint8Array parameter; received "${typeof e2}".`);
      return e2;
    }
  }
  class Sg {
    static hexToFactor(e2, t2) {
      e2 = Math.floor(e2);
      const r2 = t2;
      return r2[0] = (e2 >> 16 & 255) / 255, r2[1] = (e2 >> 8 & 255) / 255, r2[2] = (255 & e2) / 255, this.convertSRGBToLinear(t2, t2);
    }
    static factorToHex(e2) {
      const t2 = [...e2], [r2, n2, i2] = this.convertLinearToSRGB(e2, t2);
      return 255 * r2 << 16 ^ 255 * n2 << 8 ^ 255 * i2 << 0;
    }
    static convertSRGBToLinear(e2, t2) {
      const r2 = e2, n2 = t2;
      for (let e3 = 0; e3 < 3; e3++)
        n2[e3] = r2[e3] < 0.04045 ? 0.0773993808 * r2[e3] : Math.pow(0.9478672986 * r2[e3] + 0.0521327014, 2.4);
      return t2;
    }
    static convertLinearToSRGB(e2, t2) {
      const r2 = e2, n2 = t2;
      for (let e3 = 0; e3 < 3; e3++)
        n2[e3] = r2[e3] < 31308e-7 ? 12.92 * r2[e3] : 1.055 * Math.pow(r2[e3], 0.41666) - 0.055;
      return t2;
    }
  }
  class Cg {
    match(e2) {
      return e2.length >= 8 && 137 === e2[0] && 80 === e2[1] && 78 === e2[2] && 71 === e2[3] && 13 === e2[4] && 10 === e2[5] && 26 === e2[6] && 10 === e2[7];
    }
    getSize(e2) {
      const t2 = new DataView(e2.buffer, e2.byteOffset);
      return Eg.decodeText(e2.slice(12, 16)) === Cg.PNG_FRIED_CHUNK_NAME ? [t2.getUint32(32, false), t2.getUint32(36, false)] : [t2.getUint32(16, false), t2.getUint32(20, false)];
    }
    getChannels(e2) {
      return 4;
    }
  }
  Cg.PNG_FRIED_CHUNK_NAME = "CgBI";
  class Mg {
    static registerFormat(e2, t2) {
      this.impls[e2] = t2;
    }
    static getMimeType(e2) {
      for (const t2 in this.impls)
        if (this.impls[t2].match(e2))
          return t2;
      return null;
    }
    static getSize(e2, t2) {
      return this.impls[t2] ? this.impls[t2].getSize(e2) : null;
    }
    static getChannels(e2, t2) {
      return this.impls[t2] ? this.impls[t2].getChannels(e2) : null;
    }
    static getMemSize(e2, t2) {
      if (!this.impls[t2])
        return null;
      if (this.impls[t2].getGPUByteLength)
        return this.impls[t2].getGPUByteLength(e2);
      let r2 = 0;
      const n2 = this.getSize(e2, t2);
      if (!n2)
        return null;
      for (; n2[0] > 1 || n2[1] > 1; )
        r2 += n2[0] * n2[1] * 4, n2[0] = Math.max(Math.floor(n2[0] / 2), 1), n2[1] = Math.max(Math.floor(n2[1] / 2), 1);
      return r2 += 4, r2;
    }
    static mimeTypeToExtension(e2) {
      return "image/jpeg" === e2 ? "jpg" : e2.split("/").pop();
    }
    static extensionToMimeType(e2) {
      return "jpg" === e2 ? "image/jpeg" : `image/${e2}`;
    }
  }
  function Tg(e2, t2) {
    if (t2 > e2.byteLength)
      throw new TypeError("Corrupt JPG, exceeded buffer limits");
    if (255 !== e2.getUint8(t2))
      throw new TypeError("Invalid JPG, marker table corrupted");
    return e2;
  }
  Mg.impls = { "image/jpeg": new class {
    match(e2) {
      return e2.length >= 3 && 255 === e2[0] && 216 === e2[1] && 255 === e2[2];
    }
    getSize(e2) {
      let t2, r2, n2 = new DataView(e2.buffer, e2.byteOffset + 4);
      for (; n2.byteLength; ) {
        if (t2 = n2.getUint16(0, false), Tg(n2, t2), r2 = n2.getUint8(t2 + 1), 192 === r2 || 193 === r2 || 194 === r2)
          return [n2.getUint16(t2 + 7, false), n2.getUint16(t2 + 5, false)];
        n2 = new DataView(e2.buffer, n2.byteOffset + t2 + 2);
      }
      throw new TypeError("Invalid JPG, no size found");
    }
    getChannels(e2) {
      return 3;
    }
  }(), "image/png": new Cg() };
  class Ig {
    static basename(e2) {
      const t2 = e2.split(/[\\/]/).pop();
      return t2.substring(0, t2.lastIndexOf("."));
    }
    static extension(e2) {
      if (e2.startsWith("data:image/")) {
        const t2 = e2.match(/data:(image\/\w+)/)[1];
        return Mg.mimeTypeToExtension(t2);
      }
      return e2.startsWith("data:model/gltf+json") ? "gltf" : e2.startsWith("data:model/gltf-binary") ? "glb" : e2.startsWith("data:application/") ? "bin" : e2.split(/[\\/]/).pop().split(/[.]/).pop();
    }
  }
  function kg(e2) {
    return "[object Object]" === Object.prototype.toString.call(e2);
  }
  function Dg(e2) {
    if (false === kg(e2))
      return false;
    const t2 = e2.constructor;
    if (void 0 === t2)
      return true;
    const r2 = t2.prototype;
    return false !== kg(r2) && false !== Object.prototype.hasOwnProperty.call(r2, "isPrototypeOf");
  }
  class Pg {
    constructor(e2) {
      this.verbosity = void 0, this.verbosity = e2;
    }
    debug(e2) {
      this.verbosity <= Pg.Verbosity.DEBUG && console.debug(e2);
    }
    info(e2) {
      this.verbosity <= Pg.Verbosity.INFO && console.info(e2);
    }
    warn(e2) {
      this.verbosity <= Pg.Verbosity.WARN && console.warn(e2);
    }
    error(e2) {
      this.verbosity <= Pg.Verbosity.ERROR && console.error(e2);
    }
  }
  Pg.Verbosity = { SILENT: 4, ERROR: 3, WARN: 2, INFO: 1, DEBUG: 0 }, Pg.DEFAULT_INSTANCE = new Pg(Pg.Verbosity.INFO);
  class Bg {
    static identity(e2) {
      return e2;
    }
    static eq(e2, t2) {
      if (e2.length !== t2.length)
        return false;
      for (let r2 = 0; r2 < e2.length; r2++)
        if (Math.abs(e2[r2] - t2[r2]) > 1e-5)
          return false;
      return true;
    }
    static denormalize(e2, t2) {
      switch (t2) {
        case 5126:
          return e2;
        case 5123:
          return e2 / 65535;
        case 5121:
          return e2 / 255;
        case 5122:
          return Math.max(e2 / 32767, -1);
        case 5120:
          return Math.max(e2 / 127, -1);
        default:
          throw new Error("Invalid component type.");
      }
    }
    static normalize(e2, t2) {
      switch (t2) {
        case 5126:
          return e2;
        case 5123:
          return Math.round(65535 * e2);
        case 5121:
          return Math.round(255 * e2);
        case 5122:
          return Math.round(32767 * e2);
        case 5120:
          return Math.round(127 * e2);
        default:
          throw new Error("Invalid component type.");
      }
    }
    static decompose(e2, t2, r2, n2) {
      let i2 = Ag([e2[0], e2[1], e2[2]]);
      const s2 = Ag([e2[4], e2[5], e2[6]]), o2 = Ag([e2[8], e2[9], e2[10]]);
      (function(e3) {
        var t3 = e3[0], r3 = e3[1], n3 = e3[2], i3 = e3[3], s3 = e3[4], o3 = e3[5], a3 = e3[6], l3 = e3[7], c3 = e3[8], u3 = e3[9], h2 = e3[10], p2 = e3[11], d2 = e3[12], f2 = e3[13], m2 = e3[14], _2 = e3[15];
        return (t3 * o3 - r3 * s3) * (h2 * _2 - p2 * m2) - (t3 * a3 - n3 * s3) * (u3 * _2 - p2 * f2) + (t3 * l3 - i3 * s3) * (u3 * m2 - h2 * f2) + (r3 * a3 - n3 * o3) * (c3 * _2 - p2 * d2) - (r3 * l3 - i3 * o3) * (c3 * m2 - h2 * d2) + (n3 * l3 - i3 * a3) * (c3 * f2 - u3 * d2);
      })(e2) < 0 && (i2 = -i2), t2[0] = e2[12], t2[1] = e2[13], t2[2] = e2[14];
      const a2 = e2.slice(), l2 = 1 / i2, c2 = 1 / s2, u2 = 1 / o2;
      a2[0] *= l2, a2[1] *= l2, a2[2] *= l2, a2[4] *= c2, a2[5] *= c2, a2[6] *= c2, a2[8] *= u2, a2[9] *= u2, a2[10] *= u2, function(e3, t3) {
        var r3 = new vg(3);
        !function(e4, t4) {
          var r4 = t4[0], n4 = t4[1], i4 = t4[2], s4 = t4[4], o4 = t4[5], a4 = t4[6], l4 = t4[8], c4 = t4[9], u4 = t4[10];
          e4[0] = Math.hypot(r4, n4, i4), e4[1] = Math.hypot(s4, o4, a4), e4[2] = Math.hypot(l4, c4, u4);
        }(r3, t3);
        var n3 = 1 / r3[0], i3 = 1 / r3[1], s3 = 1 / r3[2], o3 = t3[0] * n3, a3 = t3[1] * i3, l3 = t3[2] * s3, c3 = t3[4] * n3, u3 = t3[5] * i3, h2 = t3[6] * s3, p2 = t3[8] * n3, d2 = t3[9] * i3, f2 = t3[10] * s3, m2 = o3 + u3 + f2, _2 = 0;
        m2 > 0 ? (_2 = 2 * Math.sqrt(m2 + 1), e3[3] = 0.25 * _2, e3[0] = (h2 - d2) / _2, e3[1] = (p2 - l3) / _2, e3[2] = (a3 - c3) / _2) : o3 > u3 && o3 > f2 ? (_2 = 2 * Math.sqrt(1 + o3 - u3 - f2), e3[3] = (h2 - d2) / _2, e3[0] = 0.25 * _2, e3[1] = (a3 + c3) / _2, e3[2] = (p2 + l3) / _2) : u3 > f2 ? (_2 = 2 * Math.sqrt(1 + u3 - o3 - f2), e3[3] = (p2 - l3) / _2, e3[0] = (a3 + c3) / _2, e3[1] = 0.25 * _2, e3[2] = (h2 + d2) / _2) : (_2 = 2 * Math.sqrt(1 + f2 - o3 - u3), e3[3] = (a3 - c3) / _2, e3[0] = (p2 + l3) / _2, e3[1] = (h2 + d2) / _2, e3[2] = 0.25 * _2);
      }(r2, a2), n2[0] = i2, n2[1] = s2, n2[2] = o2;
    }
    static compose(e2, t2, r2, n2) {
      const i2 = n2, s2 = t2[0], o2 = t2[1], a2 = t2[2], l2 = t2[3], c2 = s2 + s2, u2 = o2 + o2, h2 = a2 + a2, p2 = s2 * c2, d2 = s2 * u2, f2 = s2 * h2, m2 = o2 * u2, _2 = o2 * h2, g2 = a2 * h2, v2 = l2 * c2, A2 = l2 * u2, b2 = l2 * h2, y2 = r2[0], x2 = r2[1], w2 = r2[2];
      return i2[0] = (1 - (m2 + g2)) * y2, i2[1] = (d2 + b2) * y2, i2[2] = (f2 - A2) * y2, i2[3] = 0, i2[4] = (d2 - b2) * x2, i2[5] = (1 - (p2 + g2)) * x2, i2[6] = (_2 + v2) * x2, i2[7] = 0, i2[8] = (f2 + A2) * w2, i2[9] = (_2 - v2) * w2, i2[10] = (1 - (p2 + m2)) * w2, i2[11] = 0, i2[12] = e2[0], i2[13] = e2[1], i2[14] = e2[2], i2[15] = 1, i2;
    }
  }
  function Rg(e2, t2) {
    if (!!e2 != !!t2)
      return false;
    const r2 = e2.getChild(), n2 = t2.getChild();
    return r2 === n2 || r2.equals(n2);
  }
  function Lg(e2, t2) {
    if (!!e2 != !!t2)
      return false;
    if (e2.length !== t2.length)
      return false;
    for (let r2 = 0; r2 < e2.length; r2++) {
      const n2 = e2[r2], i2 = t2[r2];
      if (n2.getChild() !== i2.getChild() && !n2.getChild().equals(i2.getChild()))
        return false;
    }
    return true;
  }
  function Og(e2, t2) {
    if (!!e2 != !!t2)
      return false;
    const r2 = Object.keys(e2), n2 = Object.keys(t2);
    if (r2.length !== n2.length)
      return false;
    for (const r3 in e2) {
      const n3 = e2[r3], i2 = t2[r3];
      if (!!n3 != !!i2)
        return false;
      const s2 = n3.getChild(), o2 = i2.getChild();
      if (s2 !== o2 && !s2.equals(o2))
        return false;
    }
    return true;
  }
  function Fg(e2, t2) {
    if (e2 === t2)
      return true;
    if (!!e2 != !!t2 || !e2 || !t2)
      return false;
    if (e2.length !== t2.length)
      return false;
    for (let r2 = 0; r2 < e2.length; r2++)
      if (e2[r2] !== t2[r2])
        return false;
    return true;
  }
  function Ug(e2, t2) {
    if (e2 === t2)
      return true;
    if (!!e2 != !!t2)
      return false;
    if (!Dg(e2) || !Dg(t2))
      return e2 === t2;
    const r2 = e2, n2 = t2;
    let i2, s2 = 0, o2 = 0;
    for (i2 in r2)
      s2++;
    for (i2 in n2)
      o2++;
    if (s2 !== o2)
      return false;
    for (i2 in r2) {
      const e3 = r2[i2], t3 = n2[i2];
      if (Ng(e3) && Ng(t3)) {
        if (!Fg(e3, t3))
          return false;
      } else if (Dg(e3) && Dg(t3)) {
        if (!Ug(e3, t3))
          return false;
      } else if (e3 !== t3)
        return false;
    }
    return true;
  }
  function Ng(e2) {
    return Array.isArray(e2) || ArrayBuffer.isView(e2);
  }
  const jg = "23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ", zg = /* @__PURE__ */ new Set(), Gg = function() {
    let e2 = "";
    for (let t2 = 0; t2 < 6; t2++)
      e2 += jg.charAt(Math.floor(Math.random() * jg.length));
    return e2;
  };
  class Vg {
    static dirname(e2) {
      const t2 = e2.lastIndexOf("/");
      return -1 === t2 ? "./" : e2.substring(0, t2 + 1);
    }
    static basename(e2) {
      return Ig.basename(new URL(e2, "https://null.example").pathname);
    }
    static extension(e2) {
      return Ig.extension(new URL(e2, "https://null.example").pathname);
    }
    static resolve(e2, t2) {
      if (!this.isRelativePath(t2))
        return t2;
      const r2 = e2.split("/"), n2 = t2.split("/");
      r2.pop();
      for (let e3 = 0; e3 < n2.length; e3++)
        "." !== n2[e3] && (".." === n2[e3] ? r2.pop() : r2.push(n2[e3]));
      return r2.join("/");
    }
    static isAbsoluteURL(e2) {
      return this.PROTOCOL_REGEXP.test(e2);
    }
    static isRelativePath(e2) {
      return !/^(?:[a-zA-Z]+:)?\//.test(e2);
    }
  }
  Vg.DEFAULT_INIT = {}, Vg.PROTOCOL_REGEXP = /^[a-zA-Z]+:\/\//;
  const Qg = (e2) => e2, Hg = /* @__PURE__ */ new Set();
  class Wg extends hg {
    constructor(e2, t2 = "") {
      super(e2), this[cg].name = t2, this.init(), this.dispatchEvent({ type: "create" });
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { name: "", extras: {} });
    }
    getName() {
      return this.get("name");
    }
    setName(e2) {
      return this.set("name", e2);
    }
    getExtras() {
      return this.get("extras");
    }
    setExtras(e2) {
      return this.set("extras", e2);
    }
    clone() {
      return new (0, this.constructor)(this.graph).copy(this, Qg);
    }
    copy(e2, t2 = Qg) {
      for (const e3 in this[cg]) {
        const t3 = this[cg][e3];
        if (t3 instanceof ng)
          this[ug].has(e3) || t3.dispose();
        else if (Array.isArray(t3) && t3[0] instanceof ng)
          for (const e4 of t3)
            e4.dispose();
        else if (Dg(t3) && Object.values(t3)[0] instanceof ng)
          for (const e4 in t3)
            t3[e4].dispose();
      }
      for (const r2 in e2[cg]) {
        const n2 = this[cg][r2], i2 = e2[cg][r2];
        if (i2 instanceof ng)
          this[ug].has(r2) ? n2.getChild().copy(t2(i2.getChild()), t2) : this.setRef(r2, t2(i2.getChild()), i2.getAttributes());
        else if (Array.isArray(i2) && i2[0] instanceof ng)
          for (const e3 of i2)
            this.addRef(r2, t2(e3.getChild()), e3.getAttributes());
        else if (Dg(i2) && Object.values(i2)[0] instanceof ng)
          for (const e3 in i2) {
            const n3 = i2[e3];
            this.setRefMap(r2, e3, t2(n3.getChild()), n3.getAttributes());
          }
        else
          this[cg][r2] = Dg(i2) ? JSON.parse(JSON.stringify(i2)) : Array.isArray(i2) || i2 instanceof ArrayBuffer || ArrayBuffer.isView(i2) ? i2.slice() : i2;
      }
      return this;
    }
    equals(e2, t2 = Hg) {
      if (this === e2)
        return true;
      if (this.propertyType !== e2.propertyType)
        return false;
      for (const r2 in this[cg]) {
        if (t2.has(r2))
          continue;
        const n2 = this[cg][r2], i2 = e2[cg][r2];
        if (og(n2) || og(i2)) {
          if (!Rg(n2, i2))
            return false;
        } else if (ag(n2) || ag(i2)) {
          if (!Lg(n2, i2))
            return false;
        } else if (lg(n2) || lg(i2)) {
          if (!Og(n2, i2))
            return false;
        } else if (Dg(n2) || Dg(i2)) {
          if (!Ug(n2, i2))
            return false;
        } else if (Ng(n2) || Ng(i2)) {
          if (!Fg(n2, i2))
            return false;
        } else if (n2 !== i2)
          return false;
      }
      return true;
    }
    detach() {
      return this.graph.disconnectParents(this, (e2) => "Root" !== e2.propertyType), this;
    }
    listParents() {
      return this.graph.listParents(this);
    }
  }
  class qg extends Wg {
    getDefaults() {
      return Object.assign(super.getDefaults(), { extensions: {} });
    }
    getExtension(e2) {
      return this.getRefMap("extensions", e2);
    }
    setExtension(e2, t2) {
      return t2 && t2.t(this), this.setRefMap("extensions", e2, t2);
    }
    listExtensions() {
      return this.listRefMapValues("extensions");
    }
  }
  class Xg extends qg {
    constructor(...e2) {
      super(...e2), this.i = Bg.identity, this.o = Bg.identity;
    }
    init() {
      this.propertyType = dg.ACCESSOR;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { array: null, type: Xg.Type.SCALAR, componentType: Xg.ComponentType.FLOAT, normalized: false, buffer: null });
    }
    copy(e2, t2 = Qg) {
      return super.copy(e2, t2), this.i = e2.i, this.o = e2.o, this;
    }
    static getElementSize(e2) {
      switch (e2) {
        case Xg.Type.SCALAR:
          return 1;
        case Xg.Type.VEC2:
          return 2;
        case Xg.Type.VEC3:
          return 3;
        case Xg.Type.VEC4:
        case Xg.Type.MAT2:
          return 4;
        case Xg.Type.MAT3:
          return 9;
        case Xg.Type.MAT4:
          return 16;
        default:
          throw new Error("Unexpected type: " + e2);
      }
    }
    static getComponentSize(e2) {
      switch (e2) {
        case Xg.ComponentType.BYTE:
        case Xg.ComponentType.UNSIGNED_BYTE:
          return 1;
        case Xg.ComponentType.SHORT:
        case Xg.ComponentType.UNSIGNED_SHORT:
          return 2;
        case Xg.ComponentType.UNSIGNED_INT:
        case Xg.ComponentType.FLOAT:
          return 4;
        default:
          throw new Error("Unexpected component type: " + e2);
      }
    }
    getMinNormalized(e2) {
      const t2 = this.getElementSize();
      this.getMin(e2);
      for (let r2 = 0; r2 < t2; r2++)
        e2[r2] = this.o(e2[r2]);
      return e2;
    }
    getMin(e2) {
      const t2 = this.get("array"), r2 = this.getCount(), n2 = this.getElementSize();
      for (let t3 = 0; t3 < n2; t3++)
        e2[t3] = 1 / 0;
      for (let i2 = 0; i2 < r2 * n2; i2 += n2)
        for (let r3 = 0; r3 < n2; r3++) {
          const n3 = t2[i2 + r3];
          Number.isFinite(n3) && (e2[r3] = Math.min(e2[r3], n3));
        }
      return e2;
    }
    getMaxNormalized(e2) {
      const t2 = this.getElementSize();
      this.getMax(e2);
      for (let r2 = 0; r2 < t2; r2++)
        e2[r2] = this.o(e2[r2]);
      return e2;
    }
    getMax(e2) {
      const t2 = this.get("array"), r2 = this.getCount(), n2 = this.getElementSize();
      for (let t3 = 0; t3 < n2; t3++)
        e2[t3] = -1 / 0;
      for (let i2 = 0; i2 < r2 * n2; i2 += n2)
        for (let r3 = 0; r3 < n2; r3++) {
          const n3 = t2[i2 + r3];
          Number.isFinite(n3) && (e2[r3] = Math.max(e2[r3], n3));
        }
      return e2;
    }
    getCount() {
      const e2 = this.get("array");
      return e2 ? e2.length / this.getElementSize() : 0;
    }
    getType() {
      return this.get("type");
    }
    setType(e2) {
      return this.set("type", e2);
    }
    getElementSize() {
      return Xg.getElementSize(this.get("type"));
    }
    getComponentSize() {
      return this.get("array").BYTES_PER_ELEMENT;
    }
    getComponentType() {
      return this.get("componentType");
    }
    getNormalized() {
      return this.get("normalized");
    }
    setNormalized(e2) {
      return this.set("normalized", e2), e2 ? (this.o = (e3) => Bg.denormalize(e3, this.get("componentType")), this.i = (e3) => Bg.normalize(e3, this.get("componentType"))) : (this.o = Bg.identity, this.i = Bg.identity), this;
    }
    getScalar(e2) {
      const t2 = this.getElementSize();
      return this.o(this.get("array")[e2 * t2]);
    }
    setScalar(e2, t2) {
      return this.get("array")[e2 * this.getElementSize()] = this.i(t2), this;
    }
    getElement(e2, t2) {
      const r2 = this.getElementSize(), n2 = this.get("array");
      for (let i2 = 0; i2 < r2; i2++)
        t2[i2] = this.o(n2[e2 * r2 + i2]);
      return t2;
    }
    setElement(e2, t2) {
      const r2 = this.getElementSize(), n2 = this.get("array");
      for (let i2 = 0; i2 < r2; i2++)
        n2[e2 * r2 + i2] = this.i(t2[i2]);
      return this;
    }
    getBuffer() {
      return this.getRef("buffer");
    }
    setBuffer(e2) {
      return this.setRef("buffer", e2);
    }
    getArray() {
      return this.get("array");
    }
    setArray(e2) {
      return this.set("componentType", e2 ? function(e3) {
        switch (e3.constructor) {
          case Float32Array:
            return Xg.ComponentType.FLOAT;
          case Uint32Array:
            return Xg.ComponentType.UNSIGNED_INT;
          case Uint16Array:
            return Xg.ComponentType.UNSIGNED_SHORT;
          case Uint8Array:
            return Xg.ComponentType.UNSIGNED_BYTE;
          case Int16Array:
            return Xg.ComponentType.SHORT;
          case Int8Array:
            return Xg.ComponentType.BYTE;
          default:
            throw new Error("Unknown accessor componentType.");
        }
      }(e2) : Xg.ComponentType.FLOAT), this.set("array", e2), this;
    }
    getByteLength() {
      const e2 = this.get("array");
      return e2 ? e2.byteLength : 0;
    }
  }
  Xg.Type = { SCALAR: "SCALAR", VEC2: "VEC2", VEC3: "VEC3", VEC4: "VEC4", MAT2: "MAT2", MAT3: "MAT3", MAT4: "MAT4" }, Xg.ComponentType = { BYTE: 5120, UNSIGNED_BYTE: 5121, SHORT: 5122, UNSIGNED_SHORT: 5123, UNSIGNED_INT: 5125, FLOAT: 5126 };
  class Yg extends qg {
    init() {
      this.propertyType = dg.ANIMATION;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { channels: [], samplers: [] });
    }
    addChannel(e2) {
      return this.addRef("channels", e2);
    }
    removeChannel(e2) {
      return this.removeRef("channels", e2);
    }
    listChannels() {
      return this.listRefs("channels");
    }
    addSampler(e2) {
      return this.addRef("samplers", e2);
    }
    removeSampler(e2) {
      return this.removeRef("samplers", e2);
    }
    listSamplers() {
      return this.listRefs("samplers");
    }
  }
  class Kg extends qg {
    init() {
      this.propertyType = dg.ANIMATION_CHANNEL;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { targetPath: null, targetNode: null, sampler: null });
    }
    getTargetPath() {
      return this.get("targetPath");
    }
    setTargetPath(e2) {
      return this.set("targetPath", e2);
    }
    getTargetNode() {
      return this.getRef("targetNode");
    }
    setTargetNode(e2) {
      return this.setRef("targetNode", e2);
    }
    getSampler() {
      return this.getRef("sampler");
    }
    setSampler(e2) {
      return this.setRef("sampler", e2);
    }
  }
  Kg.TargetPath = { TRANSLATION: "translation", ROTATION: "rotation", SCALE: "scale", WEIGHTS: "weights" };
  class Jg extends qg {
    init() {
      this.propertyType = dg.ANIMATION_SAMPLER;
    }
    getDefaultAttributes() {
      return Object.assign(super.getDefaults(), { interpolation: Jg.Interpolation.LINEAR, input: null, output: null });
    }
    getInterpolation() {
      return this.get("interpolation");
    }
    setInterpolation(e2) {
      return this.set("interpolation", e2);
    }
    getInput() {
      return this.getRef("input");
    }
    setInput(e2) {
      return this.setRef("input", e2, { usage: mg.OTHER });
    }
    getOutput() {
      return this.getRef("output");
    }
    setOutput(e2) {
      return this.setRef("output", e2, { usage: mg.OTHER });
    }
  }
  Jg.Interpolation = { LINEAR: "LINEAR", STEP: "STEP", CUBICSPLINE: "CUBICSPLINE" };
  class Zg extends qg {
    init() {
      this.propertyType = dg.BUFFER;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { uri: "" });
    }
    getURI() {
      return this.get("uri");
    }
    setURI(e2) {
      return this.set("uri", e2);
    }
  }
  class $g extends qg {
    init() {
      this.propertyType = dg.CAMERA;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { type: $g.Type.PERSPECTIVE, znear: 0.1, zfar: 100, aspectRatio: null, yfov: 2 * Math.PI * 50 / 360, xmag: 1, ymag: 1 });
    }
    getType() {
      return this.get("type");
    }
    setType(e2) {
      return this.set("type", e2);
    }
    getZNear() {
      return this.get("znear");
    }
    setZNear(e2) {
      return this.set("znear", e2);
    }
    getZFar() {
      return this.get("zfar");
    }
    setZFar(e2) {
      return this.set("zfar", e2);
    }
    getAspectRatio() {
      return this.get("aspectRatio");
    }
    setAspectRatio(e2) {
      return this.set("aspectRatio", e2);
    }
    getYFov() {
      return this.get("yfov");
    }
    setYFov(e2) {
      return this.set("yfov", e2);
    }
    getXMag() {
      return this.get("xmag");
    }
    setXMag(e2) {
      return this.set("xmag", e2);
    }
    getYMag() {
      return this.get("ymag");
    }
    setYMag(e2) {
      return this.set("ymag", e2);
    }
  }
  $g.Type = { PERSPECTIVE: "perspective", ORTHOGRAPHIC: "orthographic" };
  class ev extends Wg {
    t(e2) {
      if (!this.parentTypes.includes(e2.propertyType))
        throw new Error(`Parent "${e2.propertyType}" invalid for child "${this.propertyType}".`);
    }
  }
  ev.EXTENSION_NAME = void 0;
  class tv extends qg {
    init() {
      this.propertyType = dg.TEXTURE_INFO;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { texCoord: 0, magFilter: null, minFilter: null, wrapS: tv.WrapMode.REPEAT, wrapT: tv.WrapMode.REPEAT });
    }
    getTexCoord() {
      return this.get("texCoord");
    }
    setTexCoord(e2) {
      return this.set("texCoord", e2);
    }
    getMagFilter() {
      return this.get("magFilter");
    }
    setMagFilter(e2) {
      return this.set("magFilter", e2);
    }
    getMinFilter() {
      return this.get("minFilter");
    }
    setMinFilter(e2) {
      return this.set("minFilter", e2);
    }
    getWrapS() {
      return this.get("wrapS");
    }
    setWrapS(e2) {
      return this.set("wrapS", e2);
    }
    getWrapT() {
      return this.get("wrapT");
    }
    setWrapT(e2) {
      return this.set("wrapT", e2);
    }
  }
  tv.WrapMode = { CLAMP_TO_EDGE: 33071, MIRRORED_REPEAT: 33648, REPEAT: 10497 }, tv.MagFilter = { NEAREST: 9728, LINEAR: 9729 }, tv.MinFilter = { NEAREST: 9728, LINEAR: 9729, NEAREST_MIPMAP_NEAREST: 9984, LINEAR_MIPMAP_NEAREST: 9985, NEAREST_MIPMAP_LINEAR: 9986, LINEAR_MIPMAP_LINEAR: 9987 };
  const { R: rv, G: nv, B: iv, A: sv } = _g;
  class ov extends qg {
    init() {
      this.propertyType = dg.MATERIAL;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { alphaMode: ov.AlphaMode.OPAQUE, alphaCutoff: 0.5, doubleSided: false, baseColorFactor: [1, 1, 1, 1], baseColorTexture: null, baseColorTextureInfo: new tv(this.graph, "baseColorTextureInfo"), emissiveFactor: [0, 0, 0], emissiveTexture: null, emissiveTextureInfo: new tv(this.graph, "emissiveTextureInfo"), normalScale: 1, normalTexture: null, normalTextureInfo: new tv(this.graph, "normalTextureInfo"), occlusionStrength: 1, occlusionTexture: null, occlusionTextureInfo: new tv(this.graph, "occlusionTextureInfo"), roughnessFactor: 1, metallicFactor: 1, metallicRoughnessTexture: null, metallicRoughnessTextureInfo: new tv(this.graph, "metallicRoughnessTextureInfo") });
    }
    getDoubleSided() {
      return this.get("doubleSided");
    }
    setDoubleSided(e2) {
      return this.set("doubleSided", e2);
    }
    getAlpha() {
      return this.get("baseColorFactor")[3];
    }
    setAlpha(e2) {
      const t2 = this.get("baseColorFactor").slice();
      return t2[3] = e2, this.set("baseColorFactor", t2);
    }
    getAlphaMode() {
      return this.get("alphaMode");
    }
    setAlphaMode(e2) {
      return this.set("alphaMode", e2);
    }
    getAlphaCutoff() {
      return this.get("alphaCutoff");
    }
    setAlphaCutoff(e2) {
      return this.set("alphaCutoff", e2);
    }
    getBaseColorFactor() {
      return this.get("baseColorFactor");
    }
    setBaseColorFactor(e2) {
      return this.set("baseColorFactor", e2);
    }
    getBaseColorHex() {
      return Sg.factorToHex(this.get("baseColorFactor"));
    }
    setBaseColorHex(e2) {
      const t2 = this.get("baseColorFactor").slice();
      return this.set("baseColorFactor", Sg.hexToFactor(e2, t2));
    }
    getBaseColorTexture() {
      return this.getRef("baseColorTexture");
    }
    getBaseColorTextureInfo() {
      return this.getRef("baseColorTexture") ? this.getRef("baseColorTextureInfo") : null;
    }
    setBaseColorTexture(e2) {
      return this.setRef("baseColorTexture", e2, { channels: rv | nv | iv | sv });
    }
    getEmissiveFactor() {
      return this.get("emissiveFactor");
    }
    setEmissiveFactor(e2) {
      return this.set("emissiveFactor", e2);
    }
    getEmissiveHex() {
      return Sg.factorToHex(this.get("emissiveFactor"));
    }
    setEmissiveHex(e2) {
      const t2 = this.get("emissiveFactor").slice();
      return this.set("emissiveFactor", Sg.hexToFactor(e2, t2));
    }
    getEmissiveTexture() {
      return this.getRef("emissiveTexture");
    }
    getEmissiveTextureInfo() {
      return this.getRef("emissiveTexture") ? this.getRef("emissiveTextureInfo") : null;
    }
    setEmissiveTexture(e2) {
      return this.setRef("emissiveTexture", e2, { channels: rv | nv | iv });
    }
    getNormalScale() {
      return this.get("normalScale");
    }
    setNormalScale(e2) {
      return this.set("normalScale", e2);
    }
    getNormalTexture() {
      return this.getRef("normalTexture");
    }
    getNormalTextureInfo() {
      return this.getRef("normalTexture") ? this.getRef("normalTextureInfo") : null;
    }
    setNormalTexture(e2) {
      return this.setRef("normalTexture", e2, { channels: rv | nv | iv });
    }
    getOcclusionStrength() {
      return this.get("occlusionStrength");
    }
    setOcclusionStrength(e2) {
      return this.set("occlusionStrength", e2);
    }
    getOcclusionTexture() {
      return this.getRef("occlusionTexture");
    }
    getOcclusionTextureInfo() {
      return this.getRef("occlusionTexture") ? this.getRef("occlusionTextureInfo") : null;
    }
    setOcclusionTexture(e2) {
      return this.setRef("occlusionTexture", e2, { channels: rv });
    }
    getRoughnessFactor() {
      return this.get("roughnessFactor");
    }
    setRoughnessFactor(e2) {
      return this.set("roughnessFactor", e2);
    }
    getMetallicFactor() {
      return this.get("metallicFactor");
    }
    setMetallicFactor(e2) {
      return this.set("metallicFactor", e2);
    }
    getMetallicRoughnessTexture() {
      return this.getRef("metallicRoughnessTexture");
    }
    getMetallicRoughnessTextureInfo() {
      return this.getRef("metallicRoughnessTexture") ? this.getRef("metallicRoughnessTextureInfo") : null;
    }
    setMetallicRoughnessTexture(e2) {
      return this.setRef("metallicRoughnessTexture", e2, { channels: nv | iv });
    }
  }
  ov.AlphaMode = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
  class av extends qg {
    init() {
      this.propertyType = dg.MESH;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { weights: [], primitives: [] });
    }
    addPrimitive(e2) {
      return this.addRef("primitives", e2);
    }
    removePrimitive(e2) {
      return this.removeRef("primitives", e2);
    }
    listPrimitives() {
      return this.listRefs("primitives");
    }
    getWeights() {
      return this.get("weights");
    }
    setWeights(e2) {
      return this.set("weights", e2);
    }
  }
  class lv extends qg {
    constructor(...e2) {
      super(...e2), this.u = null;
    }
    init() {
      this.propertyType = dg.NODE;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { translation: [0, 0, 0], rotation: [0, 0, 0, 1], scale: [1, 1, 1], weights: [], camera: null, mesh: null, skin: null, children: [] });
    }
    copy(e2, t2 = Qg) {
      if (t2 === Qg)
        throw new Error("Node cannot be copied.");
      return super.copy(e2, t2);
    }
    getTranslation() {
      return this.get("translation");
    }
    getRotation() {
      return this.get("rotation");
    }
    getScale() {
      return this.get("scale");
    }
    setTranslation(e2) {
      return this.set("translation", e2);
    }
    setRotation(e2) {
      return this.set("rotation", e2);
    }
    setScale(e2) {
      return this.set("scale", e2);
    }
    getMatrix() {
      return Bg.compose(this.get("translation"), this.get("rotation"), this.get("scale"), []);
    }
    setMatrix(e2) {
      const t2 = this.get("translation").slice(), r2 = this.get("rotation").slice(), n2 = this.get("scale").slice();
      return Bg.decompose(e2, t2, r2, n2), this.set("translation", t2).set("rotation", r2).set("scale", n2);
    }
    getWorldTranslation() {
      const e2 = [0, 0, 0];
      return Bg.decompose(this.getWorldMatrix(), e2, [0, 0, 0, 1], [1, 1, 1]), e2;
    }
    getWorldRotation() {
      const e2 = [0, 0, 0, 1];
      return Bg.decompose(this.getWorldMatrix(), [0, 0, 0], e2, [1, 1, 1]), e2;
    }
    getWorldScale() {
      const e2 = [1, 1, 1];
      return Bg.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], e2), e2;
    }
    getWorldMatrix() {
      const e2 = [];
      for (let t3 = this; t3 instanceof lv; t3 = t3.u)
        e2.push(t3);
      let t2;
      const r2 = e2.pop().getMatrix();
      for (; t2 = e2.pop(); )
        yg(r2, r2, t2.getMatrix());
      return r2;
    }
    addChild(e2) {
      e2.u && e2.u.removeChild(e2), this.addRef("children", e2), e2.u = this;
      const t2 = this[cg].children;
      return t2[t2.length - 1].addEventListener("dispose", () => e2.u = null), this;
    }
    removeChild(e2) {
      return this.removeRef("children", e2);
    }
    listChildren() {
      return this.listRefs("children");
    }
    getParent() {
      return this.u;
    }
    getMesh() {
      return this.getRef("mesh");
    }
    setMesh(e2) {
      return this.setRef("mesh", e2);
    }
    getCamera() {
      return this.getRef("camera");
    }
    setCamera(e2) {
      return this.setRef("camera", e2);
    }
    getSkin() {
      return this.getRef("skin");
    }
    setSkin(e2) {
      return this.setRef("skin", e2);
    }
    getWeights() {
      return this.get("weights");
    }
    setWeights(e2) {
      return this.set("weights", e2);
    }
    traverse(e2) {
      e2(this);
      for (const t2 of this.listChildren())
        t2.traverse(e2);
      return this;
    }
  }
  class cv extends qg {
    init() {
      this.propertyType = dg.PRIMITIVE;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { mode: cv.Mode.TRIANGLES, material: null, indices: null, attributes: {}, targets: [] });
    }
    getIndices() {
      return this.getRef("indices");
    }
    setIndices(e2) {
      return this.setRef("indices", e2, { usage: mg.ELEMENT_ARRAY_BUFFER });
    }
    getAttribute(e2) {
      return this.getRefMap("attributes", e2);
    }
    setAttribute(e2, t2) {
      return this.setRefMap("attributes", e2, t2, { usage: mg.ARRAY_BUFFER });
    }
    listAttributes() {
      return this.listRefMapValues("attributes");
    }
    listSemantics() {
      return this.listRefMapKeys("attributes");
    }
    getMaterial() {
      return this.getRef("material");
    }
    setMaterial(e2) {
      return this.setRef("material", e2);
    }
    getMode() {
      return this.get("mode");
    }
    setMode(e2) {
      return this.set("mode", e2);
    }
    listTargets() {
      return this.listRefs("targets");
    }
    addTarget(e2) {
      return this.addRef("targets", e2);
    }
    removeTarget(e2) {
      return this.removeRef("targets", e2);
    }
  }
  cv.Mode = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6 };
  class uv extends Wg {
    init() {
      this.propertyType = dg.PRIMITIVE_TARGET;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { attributes: {} });
    }
    getAttribute(e2) {
      return this.getRefMap("attributes", e2);
    }
    setAttribute(e2, t2) {
      return this.setRefMap("attributes", e2, t2, { usage: mg.ARRAY_BUFFER });
    }
    listAttributes() {
      return this.listRefMapValues("attributes");
    }
    listSemantics() {
      return this.listRefMapKeys("attributes");
    }
  }
  function hv() {
    return (hv = Object.assign || function(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var r2 = arguments[t2];
        for (var n2 in r2)
          Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
      }
      return e2;
    }).apply(this, arguments);
  }
  class pv extends qg {
    init() {
      this.propertyType = dg.SCENE;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { children: [] });
    }
    copy(e2, t2 = Qg) {
      if (t2 === Qg)
        throw new Error("Scene cannot be copied.");
      return super.copy(e2, t2);
    }
    addChild(e2) {
      e2.u && e2.u.removeChild(e2), this.addRef("children", e2), e2.u = this;
      const t2 = this[cg].children;
      return t2[t2.length - 1].addEventListener("dispose", () => e2.u = null), this;
    }
    removeChild(e2) {
      return this.removeRef("children", e2);
    }
    listChildren() {
      return this.listRefs("children");
    }
    traverse(e2) {
      for (const t2 of this.listChildren())
        t2.traverse(e2);
      return this;
    }
  }
  class dv extends qg {
    init() {
      this.propertyType = dg.SKIN;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { skeleton: null, inverseBindMatrices: null, joints: [] });
    }
    getSkeleton() {
      return this.getRef("skeleton");
    }
    setSkeleton(e2) {
      return this.setRef("skeleton", e2);
    }
    getInverseBindMatrices() {
      return this.getRef("inverseBindMatrices");
    }
    setInverseBindMatrices(e2) {
      return this.setRef("inverseBindMatrices", e2, { usage: mg.INVERSE_BIND_MATRICES });
    }
    addJoint(e2) {
      return this.addRef("joints", e2);
    }
    removeJoint(e2) {
      return this.removeRef("joints", e2);
    }
    listJoints() {
      return this.listRefs("joints");
    }
  }
  class fv extends qg {
    init() {
      this.propertyType = dg.TEXTURE;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { image: null, mimeType: "", uri: "" });
    }
    getMimeType() {
      return this.get("mimeType") || Mg.extensionToMimeType(Ig.extension(this.get("uri")));
    }
    setMimeType(e2) {
      return this.set("mimeType", e2);
    }
    getURI() {
      return this.get("uri");
    }
    setURI(e2) {
      return this.set("uri", e2), this.set("mimeType", Mg.extensionToMimeType(Ig.extension(e2))), this;
    }
    getImage() {
      return this.get("image");
    }
    setImage(e2) {
      return this.set("image", Eg.assertView(e2));
    }
    getSize() {
      const e2 = this.get("image");
      return e2 ? Mg.getSize(e2, this.getMimeType()) : null;
    }
  }
  class mv extends qg {
    init() {
      this.propertyType = dg.ROOT;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { asset: { generator: "glTF-Transform v2.2.3", version: "2.0" }, defaultScene: null, accessors: [], animations: [], buffers: [], cameras: [], materials: [], meshes: [], nodes: [], scenes: [], skins: [], textures: [] });
    }
    constructor(e2) {
      super(e2), this.h = /* @__PURE__ */ new Set(), e2.addEventListener("node:create", (e3) => {
        this.l(e3.target);
      });
    }
    clone() {
      throw new Error("Root cannot be cloned.");
    }
    copy(e2, t2 = Qg) {
      if (t2 === Qg)
        throw new Error("Root cannot be copied.");
      this.set("asset", hv({}, e2.get("asset"))), this.setName(e2.getName()), this.setExtras(hv({}, e2.getExtras())), this.setDefaultScene(e2.getDefaultScene() ? t2(e2.getDefaultScene()) : null);
      for (const r2 of e2.listRefMapKeys("extensions")) {
        const n2 = e2.getExtension(r2);
        this.setExtension(r2, t2(n2));
      }
      return this;
    }
    l(e2) {
      return e2 instanceof pv ? this.addRef("scenes", e2) : e2 instanceof lv ? this.addRef("nodes", e2) : e2 instanceof $g ? this.addRef("cameras", e2) : e2 instanceof dv ? this.addRef("skins", e2) : e2 instanceof av ? this.addRef("meshes", e2) : e2 instanceof ov ? this.addRef("materials", e2) : e2 instanceof fv ? this.addRef("textures", e2) : e2 instanceof Yg ? this.addRef("animations", e2) : e2 instanceof Xg ? this.addRef("accessors", e2) : e2 instanceof Zg && this.addRef("buffers", e2), this;
    }
    getAsset() {
      return this.get("asset");
    }
    listExtensionsUsed() {
      return Array.from(this.h);
    }
    listExtensionsRequired() {
      return this.listExtensionsUsed().filter((e2) => e2.isRequired());
    }
    g(e2) {
      return this.h.add(e2), this;
    }
    p(e2) {
      return this.h.delete(e2), this;
    }
    listScenes() {
      return this.listRefs("scenes");
    }
    setDefaultScene(e2) {
      return this.setRef("defaultScene", e2);
    }
    getDefaultScene() {
      return this.getRef("defaultScene");
    }
    listNodes() {
      return this.listRefs("nodes");
    }
    listCameras() {
      return this.listRefs("cameras");
    }
    listSkins() {
      return this.listRefs("skins");
    }
    listMeshes() {
      return this.listRefs("meshes");
    }
    listMaterials() {
      return this.listRefs("materials");
    }
    listTextures() {
      return this.listRefs("textures");
    }
    listAnimations() {
      return this.listRefs("animations");
    }
    listAccessors() {
      return this.listRefs("accessors");
    }
    listBuffers() {
      return this.listRefs("buffers");
    }
  }
  class _v {
    constructor() {
      this.m = new ig(), this.T = new mv(this.m), this.v = Pg.DEFAULT_INSTANCE;
    }
    getRoot() {
      return this.T;
    }
    getGraph() {
      return this.m;
    }
    getLogger() {
      return this.v;
    }
    setLogger(e2) {
      return this.v = e2, this;
    }
    clone() {
      return new _v().setLogger(this.v).merge(this);
    }
    merge(e2) {
      for (const t3 of e2.getRoot().listExtensionsUsed()) {
        const e3 = this.createExtension(t3.constructor);
        t3.isRequired() && e3.setRequired(true);
      }
      const t2 = /* @__PURE__ */ new Set(), r2 = /* @__PURE__ */ new Map();
      t2.add(e2.T), r2.set(e2.T, this.T);
      for (const n3 of e2.m.listEdges())
        for (const e3 of [n3.getParent(), n3.getChild()]) {
          if (t2.has(e3))
            continue;
          let n4;
          n4 = e3.propertyType === dg.TEXTURE_INFO ? e3 : new (0, e3.constructor)(this.m), r2.set(e3, n4), t2.add(e3);
        }
      const n2 = (e3) => {
        const t3 = r2.get(e3);
        if (!t3)
          throw new Error("Could resolve property.");
        return t3;
      };
      for (const e3 of t2) {
        const t3 = r2.get(e3);
        if (!t3)
          throw new Error("Could resolve property.");
        t3.propertyType !== dg.TEXTURE_INFO && t3.copy(e3, n2);
      }
      return this;
    }
    async transform(...e2) {
      const t2 = e2.map((e3) => e3.name);
      for (const r2 of e2)
        await r2(this, { stack: t2 });
      return this;
    }
    createExtension(e2) {
      const t2 = e2.EXTENSION_NAME;
      return this.getRoot().listExtensionsUsed().find((e3) => e3.extensionName === t2) || new e2(this);
    }
    createScene(e2 = "") {
      return new pv(this.m, e2);
    }
    createNode(e2 = "") {
      return new lv(this.m, e2);
    }
    createCamera(e2 = "") {
      return new $g(this.m, e2);
    }
    createSkin(e2 = "") {
      return new dv(this.m, e2);
    }
    createMesh(e2 = "") {
      return new av(this.m, e2);
    }
    createPrimitive() {
      return new cv(this.m);
    }
    createPrimitiveTarget(e2 = "") {
      return new uv(this.m, e2);
    }
    createMaterial(e2 = "") {
      return new ov(this.m, e2);
    }
    createTexture(e2 = "") {
      return new fv(this.m, e2);
    }
    createAnimation(e2 = "") {
      return new Yg(this.m, e2);
    }
    createAnimationChannel(e2 = "") {
      return new Kg(this.m, e2);
    }
    createAnimationSampler(e2 = "") {
      return new Jg(this.m, e2);
    }
    createAccessor(e2 = "", t2 = null) {
      return t2 || (t2 = this.getRoot().listBuffers()[0]), new Xg(this.m, e2).setBuffer(t2);
    }
    createBuffer(e2 = "") {
      return new Zg(this.m, e2);
    }
  }
  class gv {
    constructor(e2) {
      this.extensionName = "", this.prereadTypes = [], this.prewriteTypes = [], this.readDependencies = [], this.writeDependencies = [], this.document = void 0, this.required = false, this.properties = /* @__PURE__ */ new Set(), this.S = void 0, this.document = e2, e2.getRoot().g(this), this.S = (e3) => {
        const t3 = e3, r2 = t3.target;
        r2 instanceof ev && r2.extensionName === this.extensionName && ("node:create" === t3.type && this.M(r2), "node:dispose" === t3.type && this.I(r2));
      };
      const t2 = e2.getGraph();
      t2.addEventListener("node:create", this.S), t2.addEventListener("node:dispose", this.S);
    }
    dispose() {
      this.document.getRoot().p(this);
      const e2 = this.document.getGraph();
      e2.removeEventListener("node:create", this.S), e2.removeEventListener("node:dispose", this.S);
      for (const e3 of this.properties)
        e3.dispose();
    }
    static register() {
    }
    isRequired() {
      return this.required;
    }
    setRequired(e2) {
      return this.required = e2, this;
    }
    M(e2) {
      return this.properties.add(e2), this;
    }
    I(e2) {
      return this.properties.delete(e2), this;
    }
    install(e2, t2) {
      return this;
    }
    preread(e2, t2) {
      return this;
    }
    prewrite(e2, t2) {
      return this;
    }
  }
  gv.EXTENSION_NAME = void 0;
  class vv {
    constructor(e2) {
      this.jsonDoc = void 0, this.buffers = [], this.bufferViews = [], this.bufferViewBuffers = [], this.accessors = [], this.textures = [], this.textureInfos = /* @__PURE__ */ new Map(), this.materials = [], this.meshes = [], this.cameras = [], this.nodes = [], this.skins = [], this.animations = [], this.scenes = [], this.jsonDoc = e2;
    }
    setTextureInfo(e2, t2) {
      this.textureInfos.set(e2, t2), void 0 !== t2.texCoord && e2.setTexCoord(t2.texCoord);
      const r2 = this.jsonDoc.json.textures[t2.index];
      if (void 0 === r2.sampler)
        return;
      const n2 = this.jsonDoc.json.samplers[r2.sampler];
      void 0 !== n2.magFilter && e2.setMagFilter(n2.magFilter), void 0 !== n2.minFilter && e2.setMinFilter(n2.minFilter), void 0 !== n2.wrapS && e2.setWrapS(n2.wrapS), void 0 !== n2.wrapT && e2.setWrapT(n2.wrapT);
    }
  }
  const Av = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, bv = { logger: Pg.DEFAULT_INSTANCE, extensions: [], dependencies: {} };
  function yv(e2, t2) {
    const r2 = t2.bufferViews[e2.bufferView], n2 = t2.jsonDoc.json.bufferViews[e2.bufferView], i2 = Av[e2.componentType], s2 = Xg.getElementSize(e2.type), o2 = i2.BYTES_PER_ELEMENT;
    if (void 0 !== n2.byteStride && n2.byteStride !== s2 * o2)
      return function(e3, t3) {
        const r3 = t3.bufferViews[e3.bufferView], n3 = t3.jsonDoc.json.bufferViews[e3.bufferView], i3 = Av[e3.componentType], s3 = Xg.getElementSize(e3.type), o3 = i3.BYTES_PER_ELEMENT, a3 = e3.byteOffset || 0, l2 = new i3(e3.count * s3), c2 = new DataView(r3.buffer, r3.byteOffset, r3.byteLength), u2 = n3.byteStride;
        for (let t4 = 0; t4 < e3.count; t4++)
          for (let r4 = 0; r4 < s3; r4++) {
            const n4 = a3 + t4 * u2 + r4 * o3;
            let i4;
            switch (e3.componentType) {
              case Xg.ComponentType.FLOAT:
                i4 = c2.getFloat32(n4, true);
                break;
              case Xg.ComponentType.UNSIGNED_INT:
                i4 = c2.getUint32(n4, true);
                break;
              case Xg.ComponentType.UNSIGNED_SHORT:
                i4 = c2.getUint16(n4, true);
                break;
              case Xg.ComponentType.UNSIGNED_BYTE:
                i4 = c2.getUint8(n4);
                break;
              case Xg.ComponentType.SHORT:
                i4 = c2.getInt16(n4, true);
                break;
              case Xg.ComponentType.BYTE:
                i4 = c2.getInt8(n4);
                break;
              default:
                throw new Error(`Unexpected componentType "${e3.componentType}".`);
            }
            l2[t4 * s3 + r4] = i4;
          }
        return l2;
      }(e2, t2);
    const a2 = r2.byteOffset + (e2.byteOffset || 0);
    return new i2(r2.buffer.slice(a2, a2 + e2.count * s2 * o2));
  }
  var xv;
  !function(e2) {
    e2[e2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", e2[e2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
  }(xv || (xv = {}));
  class wv {
    constructor(e2, t2, r2) {
      this.N = void 0, this.jsonDoc = void 0, this.options = void 0, this.accessorIndexMap = /* @__PURE__ */ new Map(), this.animationIndexMap = /* @__PURE__ */ new Map(), this.bufferIndexMap = /* @__PURE__ */ new Map(), this.cameraIndexMap = /* @__PURE__ */ new Map(), this.skinIndexMap = /* @__PURE__ */ new Map(), this.materialIndexMap = /* @__PURE__ */ new Map(), this.meshIndexMap = /* @__PURE__ */ new Map(), this.nodeIndexMap = /* @__PURE__ */ new Map(), this.imageIndexMap = /* @__PURE__ */ new Map(), this.textureDefIndexMap = /* @__PURE__ */ new Map(), this.textureInfoDefMap = /* @__PURE__ */ new Map(), this.samplerDefIndexMap = /* @__PURE__ */ new Map(), this.sceneIndexMap = /* @__PURE__ */ new Map(), this.imageBufferViews = [], this.otherBufferViews = /* @__PURE__ */ new Map(), this.otherBufferViewsIndexMap = /* @__PURE__ */ new Map(), this.extensionData = {}, this.bufferURIGenerator = void 0, this.imageURIGenerator = void 0, this.logger = void 0, this.O = /* @__PURE__ */ new Map(), this.accessorUsageGroupedByParent = /* @__PURE__ */ new Set(["ARRAY_BUFFER"]), this.accessorParents = /* @__PURE__ */ new Map(), this.N = e2, this.jsonDoc = t2, this.options = r2;
      const n2 = e2.getRoot(), i2 = n2.listBuffers().length, s2 = n2.listTextures().length;
      this.bufferURIGenerator = new Ev(i2 > 1, r2.basename), this.imageURIGenerator = new Ev(s2 > 1, r2.basename), this.logger = e2.getLogger();
    }
    createTextureInfoDef(e2, t2) {
      const r2 = { magFilter: t2.getMagFilter() || void 0, minFilter: t2.getMinFilter() || void 0, wrapS: t2.getWrapS(), wrapT: t2.getWrapT() }, n2 = JSON.stringify(r2);
      this.samplerDefIndexMap.has(n2) || (this.samplerDefIndexMap.set(n2, this.jsonDoc.json.samplers.length), this.jsonDoc.json.samplers.push(r2));
      const i2 = { source: this.imageIndexMap.get(e2), sampler: this.samplerDefIndexMap.get(n2) }, s2 = JSON.stringify(i2);
      this.textureDefIndexMap.has(s2) || (this.textureDefIndexMap.set(s2, this.jsonDoc.json.textures.length), this.jsonDoc.json.textures.push(i2));
      const o2 = { index: this.textureDefIndexMap.get(s2) };
      return 0 !== t2.getTexCoord() && (o2.texCoord = t2.getTexCoord()), this.textureInfoDefMap.set(t2, o2), o2;
    }
    createPropertyDef(e2) {
      const t2 = {};
      return e2.getName() && (t2.name = e2.getName()), Object.keys(e2.getExtras()).length > 0 && (t2.extras = e2.getExtras()), t2;
    }
    createAccessorDef(e2) {
      const t2 = this.createPropertyDef(e2);
      return t2.type = e2.getType(), t2.componentType = e2.getComponentType(), t2.count = e2.getCount(), this.N.getGraph().listParentEdges(e2).some((e3) => "attributes" === e3.getName() && "POSITION" === e3.getAttributes().key || "input" === e3.getName()) && (t2.max = e2.getMax([]).map(Math.fround), t2.min = e2.getMin([]).map(Math.fround)), e2.getNormalized() && (t2.normalized = e2.getNormalized()), t2;
    }
    createImageData(e2, t2, r2) {
      if (this.options.format === gg.GLB)
        this.imageBufferViews.push(t2), e2.bufferView = this.jsonDoc.json.bufferViews.length, this.jsonDoc.json.bufferViews.push({ buffer: 0, byteOffset: -1, byteLength: t2.byteLength });
      else {
        const n2 = Mg.mimeTypeToExtension(r2.getMimeType());
        e2.uri = this.imageURIGenerator.createURI(r2, n2), this.jsonDoc.resources[e2.uri] = t2;
      }
    }
    getAccessorUsage(e2) {
      const t2 = this.O.get(e2);
      if (t2)
        return t2;
      for (const t3 of this.N.getGraph().listParentEdges(e2)) {
        const { usage: e3 } = t3.getAttributes();
        if (e3)
          return e3;
        t3.getParent().propertyType !== dg.ROOT && this.N.getLogger().warn(`Missing attribute ".usage" on edge, "${t3.getName()}".`);
      }
      return wv.BufferViewUsage.OTHER;
    }
    addAccessorToUsageGroup(e2, t2) {
      const r2 = this.O.get(e2);
      if (r2 && r2 !== t2)
        throw new Error(`Accessor with usage "${r2}" cannot be reused as "${t2}".`);
      return this.O.set(e2, t2), this;
    }
    listAccessorUsageGroups() {
      const e2 = {};
      for (const [t2, r2] of Array.from(this.O.entries()))
        e2[r2] = e2[r2] || [], e2[r2].push(t2);
      return e2;
    }
  }
  wv.BufferViewTarget = xv, wv.BufferViewUsage = mg, wv.USAGE_TO_TARGET = { [mg.ARRAY_BUFFER]: xv.ARRAY_BUFFER, [mg.ELEMENT_ARRAY_BUFFER]: xv.ELEMENT_ARRAY_BUFFER };
  class Ev {
    constructor(e2, t2) {
      this.multiple = void 0, this.basename = void 0, this.counter = 1, this.multiple = e2, this.basename = t2;
    }
    createURI(e2, t2) {
      return e2.getURI() ? e2.getURI() : this.multiple ? `${this.basename}_${this.counter++}.${t2}` : `${this.basename}.${t2}`;
    }
  }
  const { BufferViewUsage: Sv } = wv;
  var Cv;
  !function(e2) {
    e2[e2.JSON = 1313821514] = "JSON", e2[e2.BIN = 5130562] = "BIN";
  }(Cv || (Cv = {}));
  class Mv extends class {
    constructor() {
      this.v = Pg.DEFAULT_INSTANCE, this.h = /* @__PURE__ */ new Set(), this.C = {}, this.F = fg.INTERLEAVED, this.lastReadBytes = 0, this.lastWriteBytes = 0;
    }
    setLogger(e2) {
      return this.v = e2, this;
    }
    registerExtensions(e2) {
      for (const t2 of e2)
        this.h.add(t2), t2.register();
      return this;
    }
    registerDependencies(e2) {
      return Object.assign(this.C, e2), this;
    }
    setVertexLayout(e2) {
      return this.F = e2, this;
    }
    async read(e2) {
      return await this.readJSON(await this.readAsJSON(e2));
    }
    async readAsJSON(e2) {
      return e2.match(/^data:application\/octet-stream;/) || this.detectFormat(e2) === gg.GLB ? this.U(e2) : this.P(e2);
    }
    async readJSON(e2) {
      return e2 = this.j(e2), this.L(e2), class {
        static read(e3, t2 = bv) {
          const r2 = hv({}, bv, t2), { json: n2 } = e3, i2 = new _v();
          this.validate(e3, r2);
          const s2 = new vv(e3), o2 = n2.asset, a2 = i2.getRoot().getAsset();
          o2.copyright && (a2.copyright = o2.copyright), o2.extras && (a2.extras = o2.extras), void 0 !== n2.extras && i2.getRoot().setExtras(hv({}, n2.extras));
          const l2 = n2.extensionsUsed || [], c2 = n2.extensionsRequired || [];
          for (const e4 of r2.extensions)
            if (l2.includes(e4.EXTENSION_NAME)) {
              const t3 = i2.createExtension(e4).setRequired(c2.includes(e4.EXTENSION_NAME));
              for (const e5 of t3.readDependencies)
                t3.install(e5, r2.dependencies[e5]);
            }
          const u2 = n2.buffers || [];
          i2.getRoot().listExtensionsUsed().filter((e4) => e4.prereadTypes.includes(dg.BUFFER)).forEach((e4) => e4.preread(s2, dg.BUFFER)), s2.buffers = u2.map((e4) => {
            const t3 = i2.createBuffer(e4.name);
            return e4.extras && t3.setExtras(e4.extras), e4.uri && 0 !== e4.uri.indexOf("__") && t3.setURI(e4.uri), t3;
          }), s2.bufferViewBuffers = (n2.bufferViews || []).map((t3, r3) => {
            if (!s2.bufferViews[r3]) {
              const n3 = e3.json.buffers[t3.buffer];
              s2.bufferViews[r3] = Eg.toView(n3.uri ? e3.resources[n3.uri] : e3.resources["@glb.bin"], t3.byteOffset || 0, t3.byteLength);
            }
            return s2.buffers[t3.buffer];
          }), s2.accessors = (n2.accessors || []).map((e4) => {
            const t3 = i2.createAccessor(e4.name, s2.bufferViewBuffers[e4.bufferView]).setType(e4.type);
            if (e4.extras && t3.setExtras(e4.extras), void 0 !== e4.normalized && t3.setNormalized(e4.normalized), void 0 === e4.bufferView && !e4.sparse)
              return t3;
            let r3;
            return r3 = void 0 !== e4.sparse ? function(e5, t4) {
              const r4 = Av[e5.componentType], n3 = Xg.getElementSize(e5.type);
              let i3;
              i3 = void 0 !== e5.bufferView ? yv(e5, t4) : new r4(e5.count * n3);
              const s3 = e5.sparse, o3 = s3.count, a3 = hv({}, e5, s3.indices, { count: o3, type: "SCALAR" }), l3 = hv({}, e5, s3.values, { count: o3 }), c3 = yv(a3, t4), u3 = yv(l3, t4);
              for (let e6 = 0; e6 < a3.count; e6++)
                for (let t5 = 0; t5 < n3; t5++)
                  i3[c3[e6] * n3 + t5] = u3[e6 * n3 + t5];
              return i3;
            }(e4, s2) : yv(e4, s2), t3.setArray(r3), t3;
          });
          const h2 = n2.images || [], p2 = n2.textures || [];
          i2.getRoot().listExtensionsUsed().filter((e4) => e4.prereadTypes.includes(dg.TEXTURE)).forEach((e4) => e4.preread(s2, dg.TEXTURE)), s2.textures = h2.map((t3) => {
            const r3 = i2.createTexture(t3.name);
            if (t3.extras && r3.setExtras(t3.extras), void 0 !== t3.bufferView) {
              const i3 = n2.bufferViews[t3.bufferView], s3 = e3.json.buffers[i3.buffer], o3 = i3.byteOffset || 0, a3 = (s3.uri ? e3.resources[s3.uri] : e3.resources["@glb.bin"]).slice(o3, o3 + i3.byteLength);
              r3.setImage(a3);
            } else
              void 0 !== t3.uri && (r3.setImage(e3.resources[t3.uri]), 0 !== t3.uri.indexOf("__") && r3.setURI(t3.uri));
            if (void 0 !== t3.mimeType)
              r3.setMimeType(t3.mimeType);
            else if (t3.uri) {
              const e4 = Ig.extension(t3.uri);
              r3.setMimeType(Mg.extensionToMimeType(e4));
            }
            return r3;
          }), s2.materials = (n2.materials || []).map((e4) => {
            const t3 = i2.createMaterial(e4.name);
            e4.extras && t3.setExtras(e4.extras), void 0 !== e4.alphaMode && t3.setAlphaMode(e4.alphaMode), void 0 !== e4.alphaCutoff && t3.setAlphaCutoff(e4.alphaCutoff), void 0 !== e4.doubleSided && t3.setDoubleSided(e4.doubleSided);
            const r3 = e4.pbrMetallicRoughness || {};
            if (void 0 !== r3.baseColorFactor && t3.setBaseColorFactor(r3.baseColorFactor), void 0 !== e4.emissiveFactor && t3.setEmissiveFactor(e4.emissiveFactor), void 0 !== r3.metallicFactor && t3.setMetallicFactor(r3.metallicFactor), void 0 !== r3.roughnessFactor && t3.setRoughnessFactor(r3.roughnessFactor), void 0 !== r3.baseColorTexture) {
              const e5 = r3.baseColorTexture;
              t3.setBaseColorTexture(s2.textures[p2[e5.index].source]), s2.setTextureInfo(t3.getBaseColorTextureInfo(), e5);
            }
            if (void 0 !== e4.emissiveTexture) {
              const r4 = e4.emissiveTexture;
              t3.setEmissiveTexture(s2.textures[p2[r4.index].source]), s2.setTextureInfo(t3.getEmissiveTextureInfo(), r4);
            }
            if (void 0 !== e4.normalTexture) {
              const r4 = e4.normalTexture;
              t3.setNormalTexture(s2.textures[p2[r4.index].source]), s2.setTextureInfo(t3.getNormalTextureInfo(), r4), void 0 !== e4.normalTexture.scale && t3.setNormalScale(e4.normalTexture.scale);
            }
            if (void 0 !== e4.occlusionTexture) {
              const r4 = e4.occlusionTexture;
              t3.setOcclusionTexture(s2.textures[p2[r4.index].source]), s2.setTextureInfo(t3.getOcclusionTextureInfo(), r4), void 0 !== e4.occlusionTexture.strength && t3.setOcclusionStrength(e4.occlusionTexture.strength);
            }
            if (void 0 !== r3.metallicRoughnessTexture) {
              const e5 = r3.metallicRoughnessTexture;
              t3.setMetallicRoughnessTexture(s2.textures[p2[e5.index].source]), s2.setTextureInfo(t3.getMetallicRoughnessTextureInfo(), e5);
            }
            return t3;
          });
          const d2 = n2.meshes || [];
          i2.getRoot().listExtensionsUsed().filter((e4) => e4.prereadTypes.includes(dg.PRIMITIVE)).forEach((e4) => e4.preread(s2, dg.PRIMITIVE)), s2.meshes = d2.map((e4) => {
            const t3 = i2.createMesh(e4.name);
            return e4.extras && t3.setExtras(e4.extras), void 0 !== e4.weights && t3.setWeights(e4.weights), (e4.primitives || []).forEach((r3) => {
              const n3 = i2.createPrimitive();
              r3.extras && n3.setExtras(r3.extras), void 0 !== r3.material && n3.setMaterial(s2.materials[r3.material]), void 0 !== r3.mode && n3.setMode(r3.mode);
              for (const [e5, t4] of Object.entries(r3.attributes || {}))
                n3.setAttribute(e5, s2.accessors[t4]);
              void 0 !== r3.indices && n3.setIndices(s2.accessors[r3.indices]);
              const o3 = e4.extras && e4.extras.targetNames || [];
              (r3.targets || []).forEach((e5, t4) => {
                const r4 = o3[t4] || t4.toString(), a3 = i2.createPrimitiveTarget(r4);
                for (const [t5, r5] of Object.entries(e5))
                  a3.setAttribute(t5, s2.accessors[r5]);
                n3.addTarget(a3);
              }), t3.addPrimitive(n3);
            }), t3;
          }), s2.cameras = (n2.cameras || []).map((e4) => {
            const t3 = i2.createCamera(e4.name).setType(e4.type);
            if (e4.extras && t3.setExtras(e4.extras), e4.type === $g.Type.PERSPECTIVE) {
              const r3 = e4.perspective;
              t3.setYFov(r3.yfov), t3.setZNear(r3.znear), void 0 !== r3.zfar && t3.setZFar(r3.zfar), void 0 !== r3.aspectRatio && t3.setAspectRatio(r3.aspectRatio);
            } else {
              const r3 = e4.orthographic;
              t3.setZNear(r3.znear).setZFar(r3.zfar).setXMag(r3.xmag).setYMag(r3.ymag);
            }
            return t3;
          });
          const f2 = n2.nodes || [];
          i2.getRoot().listExtensionsUsed().filter((e4) => e4.prereadTypes.includes(dg.NODE)).forEach((e4) => e4.preread(s2, dg.NODE)), s2.nodes = f2.map((e4) => {
            const t3 = i2.createNode(e4.name);
            if (e4.extras && t3.setExtras(e4.extras), void 0 !== e4.translation && t3.setTranslation(e4.translation), void 0 !== e4.rotation && t3.setRotation(e4.rotation), void 0 !== e4.scale && t3.setScale(e4.scale), void 0 !== e4.matrix) {
              const r3 = [0, 0, 0], n3 = [0, 0, 0, 1], i3 = [1, 1, 1];
              Bg.decompose(e4.matrix, r3, n3, i3), t3.setTranslation(r3), t3.setRotation(n3), t3.setScale(i3);
            }
            return void 0 !== e4.weights && t3.setWeights(e4.weights), t3;
          }), s2.skins = (n2.skins || []).map((e4) => {
            const t3 = i2.createSkin(e4.name);
            e4.extras && t3.setExtras(e4.extras), void 0 !== e4.inverseBindMatrices && t3.setInverseBindMatrices(s2.accessors[e4.inverseBindMatrices]), void 0 !== e4.skeleton && t3.setSkeleton(s2.nodes[e4.skeleton]);
            for (const r3 of e4.joints)
              t3.addJoint(s2.nodes[r3]);
            return t3;
          }), f2.map((e4, t3) => {
            const r3 = s2.nodes[t3];
            (e4.children || []).forEach((e5) => r3.addChild(s2.nodes[e5])), void 0 !== e4.mesh && r3.setMesh(s2.meshes[e4.mesh]), void 0 !== e4.camera && r3.setCamera(s2.cameras[e4.camera]), void 0 !== e4.skin && r3.setSkin(s2.skins[e4.skin]);
          }), s2.animations = (n2.animations || []).map((e4) => {
            const t3 = i2.createAnimation(e4.name);
            e4.extras && t3.setExtras(e4.extras);
            const r3 = (e4.samplers || []).map((e5) => {
              const r4 = i2.createAnimationSampler().setInput(s2.accessors[e5.input]).setOutput(s2.accessors[e5.output]).setInterpolation(e5.interpolation || Jg.Interpolation.LINEAR);
              return e5.extras && r4.setExtras(e5.extras), t3.addSampler(r4), r4;
            });
            return (e4.channels || []).forEach((e5) => {
              const n3 = i2.createAnimationChannel().setSampler(r3[e5.sampler]).setTargetPath(e5.target.path);
              void 0 !== e5.target.node && n3.setTargetNode(s2.nodes[e5.target.node]), e5.extras && n3.setExtras(e5.extras), t3.addChannel(n3);
            }), t3;
          });
          const m2 = n2.scenes || [];
          return i2.getRoot().listExtensionsUsed().filter((e4) => e4.prereadTypes.includes(dg.SCENE)).forEach((e4) => e4.preread(s2, dg.SCENE)), s2.scenes = m2.map((e4) => {
            const t3 = i2.createScene(e4.name);
            return e4.extras && t3.setExtras(e4.extras), (e4.nodes || []).map((e5) => s2.nodes[e5]).forEach((e5) => t3.addChild(e5)), t3;
          }), void 0 !== n2.scene && i2.getRoot().setDefaultScene(s2.scenes[n2.scene]), i2.getRoot().listExtensionsUsed().forEach((e4) => e4.read(s2)), i2;
        }
        static validate(e3, t2) {
          const r2 = e3.json;
          if ("2.0" !== r2.asset.version)
            throw new Error(`Unsupported glTF version, "${r2.asset.version}".`);
          if (r2.extensionsRequired) {
            for (const e4 of r2.extensionsRequired)
              if (!t2.extensions.find((t3) => t3.EXTENSION_NAME === e4))
                throw new Error(`Missing required extension, "${e4}".`);
          }
          if (r2.extensionsUsed)
            for (const e4 of r2.extensionsUsed)
              t2.extensions.find((t3) => t3.EXTENSION_NAME === e4) || t2.logger.warn(`Missing optional extension, "${e4}".`);
        }
      }.read(e2, { extensions: Array.from(this.h), dependencies: this.C, logger: this.v });
    }
    async binaryToJSON(e2) {
      const t2 = this._(Eg.assertView(e2));
      this.L(t2);
      const r2 = t2.json;
      if (r2.buffers && r2.buffers.some((e3) => function(e4, t3) {
        return void 0 !== t3.uri && !(t3.uri in e4.resources);
      }(t2, e3)))
        throw new Error("Cannot resolve external buffers with binaryToJSON().");
      if (r2.images && r2.images.some((e3) => function(e4, t3) {
        return void 0 !== t3.uri && !(t3.uri in e4.resources) && void 0 === t3.bufferView;
      }(t2, e3)))
        throw new Error("Cannot resolve external images with binaryToJSON().");
      return t2;
    }
    async readBinary(e2) {
      return this.readJSON(await this.binaryToJSON(Eg.assertView(e2)));
    }
    async writeJSON(e2, t2 = {}) {
      if (t2.format === gg.GLB && e2.getRoot().listBuffers().length > 1)
        throw new Error("GLB must have 0–1 buffers.");
      return class {
        static write(e3, t3) {
          const r2 = e3.getRoot(), n2 = { asset: hv({ generator: "glTF-Transform v2.2.3" }, r2.getAsset()), extras: hv({}, r2.getExtras()) }, i2 = { json: n2, resources: {} }, s2 = new wv(e3, i2, t3), o2 = t3.logger || Pg.DEFAULT_INSTANCE, a2 = new Set(t3.extensions.map((e4) => e4.EXTENSION_NAME)), l2 = e3.getRoot().listExtensionsUsed().filter((e4) => a2.has(e4.extensionName)), c2 = e3.getRoot().listExtensionsRequired().filter((e4) => a2.has(e4.extensionName));
          l2.length < e3.getRoot().listExtensionsUsed().length && o2.debug("Some extensions were not registered for I/O, and will not be written.");
          for (const e4 of l2)
            for (const r3 of e4.writeDependencies)
              e4.install(r3, t3.dependencies[r3]);
          function u2(e4, t4, r3, i3) {
            const o3 = [];
            let a3 = 0;
            for (const t5 of e4) {
              const e5 = s2.createAccessorDef(t5);
              e5.bufferView = n2.bufferViews.length;
              const r4 = t5.getArray(), i4 = Eg.pad(Eg.toView(r4));
              e5.byteOffset = a3, a3 += i4.byteLength, o3.push(i4), s2.accessorIndexMap.set(t5, n2.accessors.length), n2.accessors.push(e5);
            }
            const l3 = { buffer: t4, byteOffset: r3, byteLength: Eg.concat(o3).byteLength };
            return i3 && (l3.target = i3), n2.bufferViews.push(l3), { buffers: o3, byteLength: a3 };
          }
          function h2(e4, t4, r3) {
            const i3 = e4[0].getCount();
            let o3 = 0;
            for (const t5 of e4) {
              const e5 = s2.createAccessorDef(t5);
              e5.bufferView = n2.bufferViews.length, e5.byteOffset = o3;
              const r4 = t5.getElementSize(), i4 = t5.getComponentSize();
              o3 += Eg.padNumber(r4 * i4), s2.accessorIndexMap.set(t5, n2.accessors.length), n2.accessors.push(e5);
            }
            const a3 = i3 * o3, l3 = new ArrayBuffer(a3), c3 = new DataView(l3);
            for (let t5 = 0; t5 < i3; t5++) {
              let r4 = 0;
              for (const n3 of e4) {
                const e5 = n3.getElementSize(), i4 = n3.getComponentSize(), s3 = n3.getComponentType(), a4 = n3.getArray();
                for (let n4 = 0; n4 < e5; n4++) {
                  const l4 = t5 * o3 + r4 + n4 * i4, u3 = a4[t5 * e5 + n4];
                  switch (s3) {
                    case Xg.ComponentType.FLOAT:
                      c3.setFloat32(l4, u3, true);
                      break;
                    case Xg.ComponentType.BYTE:
                      c3.setInt8(l4, u3);
                      break;
                    case Xg.ComponentType.SHORT:
                      c3.setInt16(l4, u3, true);
                      break;
                    case Xg.ComponentType.UNSIGNED_BYTE:
                      c3.setUint8(l4, u3);
                      break;
                    case Xg.ComponentType.UNSIGNED_SHORT:
                      c3.setUint16(l4, u3, true);
                      break;
                    case Xg.ComponentType.UNSIGNED_INT:
                      c3.setUint32(l4, u3, true);
                      break;
                    default:
                      throw new Error("Unexpected component type: " + s3);
                  }
                }
                r4 += Eg.padNumber(e5 * i4);
              }
            }
            return n2.bufferViews.push({ buffer: t4, byteOffset: r3, byteLength: a3, byteStride: o3, target: wv.BufferViewTarget.ARRAY_BUFFER }), { byteLength: a3, buffers: [new Uint8Array(l3)] };
          }
          const p2 = /* @__PURE__ */ new Map();
          for (const t4 of e3.getGraph().listEdges()) {
            if (t4.getParent() === r2)
              continue;
            const e4 = t4.getChild();
            if (e4 instanceof Xg) {
              const r3 = p2.get(e4) || [];
              r3.push(t4), p2.set(e4, r3);
            }
          }
          if (n2.accessors = [], n2.bufferViews = [], n2.samplers = [], n2.textures = [], n2.images = r2.listTextures().map((e4, t4) => {
            const r3 = s2.createPropertyDef(e4);
            e4.getMimeType() && (r3.mimeType = e4.getMimeType());
            const n3 = e4.getImage();
            return n3 && s2.createImageData(r3, n3, e4), s2.imageIndexMap.set(e4, t4), r3;
          }), l2.filter((e4) => e4.prewriteTypes.includes(dg.ACCESSOR)).forEach((e4) => e4.prewrite(s2, dg.ACCESSOR)), r2.listAccessors().forEach((e4) => {
            const t4 = s2.accessorUsageGroupedByParent, r3 = s2.accessorParents;
            if (s2.accessorIndexMap.has(e4))
              return;
            const n3 = p2.get(e4) || [], i3 = s2.getAccessorUsage(e4);
            if (s2.addAccessorToUsageGroup(e4, i3), t4.has(i3)) {
              const t5 = n3[0].getParent(), i4 = r3.get(t5) || /* @__PURE__ */ new Set();
              i4.add(e4), r3.set(t5, i4);
            }
          }), l2.filter((e4) => e4.prewriteTypes.includes(dg.BUFFER)).forEach((e4) => e4.prewrite(s2, dg.BUFFER)), (r2.listAccessors().length > 0 || r2.listTextures().length > 0 || s2.otherBufferViews.size > 0) && 0 === r2.listBuffers().length)
            throw new Error("Buffer required for Document resources, but none was found.");
          n2.buffers = [], r2.listBuffers().forEach((e4, r3) => {
            const o3 = s2.createPropertyDef(e4), a3 = s2.accessorUsageGroupedByParent, l3 = s2.accessorParents, c3 = e4.listParents().filter((e5) => e5 instanceof Xg), p3 = new Set(c3), d3 = [], f2 = n2.buffers.length;
            let m2 = 0;
            const _2 = s2.listAccessorUsageGroups();
            for (const e5 in _2)
              if (a3.has(e5))
                for (const r4 of Array.from(l3.values())) {
                  const n3 = Array.from(r4).filter((e6) => p3.has(e6)).filter((t4) => s2.getAccessorUsage(t4) === e5);
                  if (n3.length)
                    if (e5 !== Sv.ARRAY_BUFFER || t3.vertexLayout === fg.INTERLEAVED) {
                      const t4 = e5 === Sv.ARRAY_BUFFER ? h2(n3, f2, m2) : u2(n3, f2, m2);
                      m2 += t4.byteLength, d3.push(...t4.buffers);
                    } else
                      for (const e6 of n3) {
                        const t4 = h2([e6], f2, m2);
                        m2 += t4.byteLength, d3.push(...t4.buffers);
                      }
                }
              else {
                const t4 = _2[e5].filter((e6) => p3.has(e6));
                if (!t4.length)
                  continue;
                const r4 = u2(t4, f2, m2, e5 === Sv.ELEMENT_ARRAY_BUFFER ? wv.BufferViewTarget.ELEMENT_ARRAY_BUFFER : void 0);
                m2 += r4.byteLength, d3.push(...r4.buffers);
              }
            if (s2.imageBufferViews.length && 0 === r3) {
              for (let e5 = 0; e5 < s2.imageBufferViews.length; e5++)
                if (n2.bufferViews[n2.images[e5].bufferView].byteOffset = m2, m2 += s2.imageBufferViews[e5].byteLength, d3.push(s2.imageBufferViews[e5]), m2 % 8) {
                  const e6 = 8 - m2 % 8;
                  m2 += e6, d3.push(new Uint8Array(e6));
                }
            }
            if (s2.otherBufferViews.has(e4))
              for (const t4 of s2.otherBufferViews.get(e4))
                n2.bufferViews.push({ buffer: f2, byteOffset: m2, byteLength: t4.byteLength }), s2.otherBufferViewsIndexMap.set(t4, n2.bufferViews.length - 1), m2 += t4.byteLength, d3.push(t4);
            if (m2) {
              let r4;
              t3.format === gg.GLB ? r4 = "@glb.bin" : (r4 = s2.bufferURIGenerator.createURI(e4, "bin"), o3.uri = r4), o3.byteLength = m2, i2.resources[r4] = Eg.concat(d3);
            }
            n2.buffers.push(o3), s2.bufferIndexMap.set(e4, r3);
          }), r2.listAccessors().find((e4) => !e4.getBuffer()) && o2.warn("Skipped writing one or more Accessors: no Buffer assigned."), n2.materials = r2.listMaterials().map((e4, t4) => {
            const r3 = s2.createPropertyDef(e4);
            if (e4.getAlphaMode() !== ov.AlphaMode.OPAQUE && (r3.alphaMode = e4.getAlphaMode()), e4.getAlphaMode() === ov.AlphaMode.MASK && (r3.alphaCutoff = e4.getAlphaCutoff()), e4.getDoubleSided() && (r3.doubleSided = true), r3.pbrMetallicRoughness = {}, Bg.eq(e4.getBaseColorFactor(), [1, 1, 1, 1]) || (r3.pbrMetallicRoughness.baseColorFactor = e4.getBaseColorFactor()), Bg.eq(e4.getEmissiveFactor(), [0, 0, 0]) || (r3.emissiveFactor = e4.getEmissiveFactor()), 1 !== e4.getRoughnessFactor() && (r3.pbrMetallicRoughness.roughnessFactor = e4.getRoughnessFactor()), 1 !== e4.getMetallicFactor() && (r3.pbrMetallicRoughness.metallicFactor = e4.getMetallicFactor()), e4.getBaseColorTexture()) {
              const t5 = e4.getBaseColorTexture(), n3 = e4.getBaseColorTextureInfo();
              r3.pbrMetallicRoughness.baseColorTexture = s2.createTextureInfoDef(t5, n3);
            }
            if (e4.getEmissiveTexture()) {
              const t5 = e4.getEmissiveTexture(), n3 = e4.getEmissiveTextureInfo();
              r3.emissiveTexture = s2.createTextureInfoDef(t5, n3);
            }
            if (e4.getNormalTexture()) {
              const t5 = e4.getNormalTexture(), n3 = e4.getNormalTextureInfo(), i3 = s2.createTextureInfoDef(t5, n3);
              1 !== e4.getNormalScale() && (i3.scale = e4.getNormalScale()), r3.normalTexture = i3;
            }
            if (e4.getOcclusionTexture()) {
              const t5 = e4.getOcclusionTexture(), n3 = e4.getOcclusionTextureInfo(), i3 = s2.createTextureInfoDef(t5, n3);
              1 !== e4.getOcclusionStrength() && (i3.strength = e4.getOcclusionStrength()), r3.occlusionTexture = i3;
            }
            if (e4.getMetallicRoughnessTexture()) {
              const t5 = e4.getMetallicRoughnessTexture(), n3 = e4.getMetallicRoughnessTextureInfo();
              r3.pbrMetallicRoughness.metallicRoughnessTexture = s2.createTextureInfoDef(t5, n3);
            }
            return s2.materialIndexMap.set(e4, t4), r3;
          }), n2.meshes = r2.listMeshes().map((e4, t4) => {
            const r3 = s2.createPropertyDef(e4);
            let n3 = null;
            return r3.primitives = e4.listPrimitives().map((e5) => {
              const t5 = { attributes: {} };
              t5.mode = e5.getMode();
              const r4 = e5.getMaterial();
              r4 && (t5.material = s2.materialIndexMap.get(r4)), Object.keys(e5.getExtras()).length && (t5.extras = e5.getExtras());
              const i3 = e5.getIndices();
              i3 && (t5.indices = s2.accessorIndexMap.get(i3));
              for (const r5 of e5.listSemantics())
                t5.attributes[r5] = s2.accessorIndexMap.get(e5.getAttribute(r5));
              for (const r5 of e5.listTargets()) {
                const e6 = {};
                for (const t6 of r5.listSemantics())
                  e6[t6] = s2.accessorIndexMap.get(r5.getAttribute(t6));
                t5.targets = t5.targets || [], t5.targets.push(e6);
              }
              return e5.listTargets().length && !n3 && (n3 = e5.listTargets().map((e6) => e6.getName())), t5;
            }), e4.getWeights().length && (r3.weights = e4.getWeights()), n3 && (r3.extras = r3.extras || {}, r3.extras.targetNames = n3), s2.meshIndexMap.set(e4, t4), r3;
          }), n2.cameras = r2.listCameras().map((e4, t4) => {
            const r3 = s2.createPropertyDef(e4);
            if (r3.type = e4.getType(), r3.type === $g.Type.PERSPECTIVE) {
              r3.perspective = { znear: e4.getZNear(), zfar: e4.getZFar(), yfov: e4.getYFov() };
              const t5 = e4.getAspectRatio();
              null !== t5 && (r3.perspective.aspectRatio = t5);
            } else
              r3.orthographic = { znear: e4.getZNear(), zfar: e4.getZFar(), xmag: e4.getXMag(), ymag: e4.getYMag() };
            return s2.cameraIndexMap.set(e4, t4), r3;
          }), n2.nodes = r2.listNodes().map((e4, t4) => {
            const r3 = s2.createPropertyDef(e4);
            return Bg.eq(e4.getTranslation(), [0, 0, 0]) || (r3.translation = e4.getTranslation()), Bg.eq(e4.getRotation(), [0, 0, 0, 1]) || (r3.rotation = e4.getRotation()), Bg.eq(e4.getScale(), [1, 1, 1]) || (r3.scale = e4.getScale()), e4.getWeights().length && (r3.weights = e4.getWeights()), s2.nodeIndexMap.set(e4, t4), r3;
          }), n2.skins = r2.listSkins().map((e4, t4) => {
            const r3 = s2.createPropertyDef(e4), n3 = e4.getInverseBindMatrices();
            n3 && (r3.inverseBindMatrices = s2.accessorIndexMap.get(n3));
            const i3 = e4.getSkeleton();
            return i3 && (r3.skeleton = s2.nodeIndexMap.get(i3)), r3.joints = e4.listJoints().map((e5) => s2.nodeIndexMap.get(e5)), s2.skinIndexMap.set(e4, t4), r3;
          }), r2.listNodes().forEach((e4, t4) => {
            const r3 = n2.nodes[t4], i3 = e4.getMesh();
            i3 && (r3.mesh = s2.meshIndexMap.get(i3));
            const o3 = e4.getCamera();
            o3 && (r3.camera = s2.cameraIndexMap.get(o3));
            const a3 = e4.getSkin();
            a3 && (r3.skin = s2.skinIndexMap.get(a3)), e4.listChildren().length > 0 && (r3.children = e4.listChildren().map((e5) => s2.nodeIndexMap.get(e5)));
          }), n2.animations = r2.listAnimations().map((e4, t4) => {
            const r3 = s2.createPropertyDef(e4), n3 = /* @__PURE__ */ new Map();
            return r3.samplers = e4.listSamplers().map((e5, t5) => {
              const r4 = s2.createPropertyDef(e5);
              return r4.input = s2.accessorIndexMap.get(e5.getInput()), r4.output = s2.accessorIndexMap.get(e5.getOutput()), r4.interpolation = e5.getInterpolation(), n3.set(e5, t5), r4;
            }), r3.channels = e4.listChannels().map((e5) => {
              const t5 = s2.createPropertyDef(e5);
              return t5.sampler = n3.get(e5.getSampler()), t5.target = { node: s2.nodeIndexMap.get(e5.getTargetNode()), path: e5.getTargetPath() }, t5;
            }), s2.animationIndexMap.set(e4, t4), r3;
          }), n2.scenes = r2.listScenes().map((e4, t4) => {
            const r3 = s2.createPropertyDef(e4);
            return r3.nodes = e4.listChildren().map((e5) => s2.nodeIndexMap.get(e5)), s2.sceneIndexMap.set(e4, t4), r3;
          });
          const d2 = r2.getDefaultScene();
          return d2 && (n2.scene = r2.listScenes().indexOf(d2)), n2.extensionsUsed = l2.map((e4) => e4.extensionName), n2.extensionsRequired = c2.map((e4) => e4.extensionName), l2.forEach((e4) => e4.write(s2)), function(e4) {
            const t4 = [];
            for (const r3 in e4) {
              const n3 = e4[r3];
              (Array.isArray(n3) && 0 === n3.length || null === n3 || "" === n3 || n3 && "object" == typeof n3 && 0 === Object.keys(n3).length) && t4.push(r3);
            }
            for (const r3 of t4)
              delete e4[r3];
          }(n2), i2;
        }
      }.write(e2, { format: t2.format || gg.GLTF, basename: t2.basename || "", logger: this.v, vertexLayout: this.F, dependencies: hv({}, this.C), extensions: Array.from(this.h) });
    }
    async writeBinary(e2) {
      const { json: t2, resources: r2 } = await this.writeJSON(e2, { format: gg.GLB }), n2 = new Uint32Array([1179937895, 2, 12]), i2 = JSON.stringify(t2), s2 = Eg.pad(Eg.encodeText(i2), 32), o2 = Eg.toView(new Uint32Array([s2.byteLength, 1313821514])), a2 = Eg.concat([o2, s2]);
      n2[n2.length - 1] += a2.byteLength;
      const l2 = Object.values(r2)[0];
      if (!l2 || !l2.byteLength)
        return Eg.concat([Eg.toView(n2), a2]);
      const c2 = Eg.pad(l2, 0), u2 = Eg.toView(new Uint32Array([c2.byteLength, 5130562])), h2 = Eg.concat([u2, c2]);
      return n2[n2.length - 1] += h2.byteLength, Eg.concat([Eg.toView(n2), a2, h2]);
    }
    detectFormat(e2) {
      return "glb" === (Vg.isAbsoluteURL(e2) ? Vg.extension(e2) : Ig.extension(e2)) ? gg.GLB : gg.GLTF;
    }
    async P(e2) {
      this.lastReadBytes = 0;
      const t2 = await this.readURI(e2, "text");
      this.lastReadBytes += t2.length;
      const r2 = { json: JSON.parse(t2), resources: {} };
      return await this.D(r2, this.dirname(e2)), this.L(r2), r2;
    }
    async U(e2) {
      const t2 = await this.readURI(e2, "view");
      this.lastReadBytes = t2.byteLength;
      const r2 = this._(t2);
      return await this.D(r2, this.dirname(e2)), this.L(r2), r2;
    }
    async D(e2, t2) {
      var r2 = this;
      const n2 = [...e2.json.images || [], ...e2.json.buffers || []].map(async function(n3) {
        const i2 = n3.uri;
        if (!i2 || i2.match(/data:/))
          return Promise.resolve();
        e2.resources[i2] = await r2.readURI(r2.resolve(t2, i2), "view"), r2.lastReadBytes += e2.resources[i2].byteLength;
      });
      await Promise.all(n2);
    }
    L(e2) {
      function t2(t3) {
        if (t3.uri) {
          if (t3.uri in e2.resources)
            Eg.assertView(e2.resources[t3.uri]);
          else if (t3.uri.match(/data:/)) {
            const r2 = `__${function() {
              for (let e3 = 0; e3 < 999; e3++) {
                const e4 = Gg();
                if (!zg.has(e4))
                  return zg.add(e4), e4;
              }
              return "";
            }()}.${Ig.extension(t3.uri)}`;
            e2.resources[r2] = Eg.createBufferFromDataURI(t3.uri), t3.uri = r2;
          }
        }
      }
      (e2.json.images || []).forEach((e3) => {
        if (void 0 === e3.bufferView && void 0 === e3.uri)
          throw new Error("Missing resource URI or buffer view.");
        t2(e3);
      }), (e2.json.buffers || []).forEach(t2);
    }
    j(e2) {
      const { images: t2, buffers: r2 } = e2.json;
      return e2 = { json: hv({}, e2.json), resources: hv({}, e2.resources) }, t2 && (e2.json.images = t2.map((e3) => hv({}, e3))), r2 && (e2.json.buffers = r2.map((e3) => hv({}, e3))), e2;
    }
    _(e2) {
      const t2 = new Uint32Array(e2.buffer, e2.byteOffset, 3);
      if (1179937895 !== t2[0])
        throw new Error("Invalid glTF asset.");
      if (2 !== t2[1])
        throw new Error(`Unsupported glTF binary version, "${t2[1]}".`);
      const r2 = new Uint32Array(e2.buffer, e2.byteOffset + 12, 2);
      if (r2[1] !== Cv.JSON)
        throw new Error("Missing required GLB JSON chunk.");
      const n2 = r2[0], i2 = Eg.decodeText(Eg.toView(e2, 20, n2)), s2 = JSON.parse(i2), o2 = 20 + n2;
      if (e2.byteLength <= o2)
        return { json: s2, resources: {} };
      const a2 = new Uint32Array(e2.buffer, e2.byteOffset + o2, 2);
      if (a2[1] !== Cv.BIN)
        throw new Error("Expected GLB BIN in second chunk.");
      return { json: s2, resources: { "@glb.bin": Eg.toView(e2, o2 + 8, a2[0]) } };
    }
  } {
    constructor(e2 = Vg.DEFAULT_INIT) {
      super(), this.V = void 0, this.V = e2;
    }
    async readURI(e2, t2) {
      const r2 = await fetch(e2, this.V);
      switch (t2) {
        case "view":
          return new Uint8Array(await r2.arrayBuffer());
        case "text":
          return r2.text();
      }
    }
    resolve(e2, t2) {
      return Vg.resolve(e2, t2);
    }
    dirname(e2) {
      return Vg.dirname(e2);
    }
    detectFormat(e2) {
      return "glb" === Vg.extension(e2) ? gg.GLB : gg.GLTF;
    }
  }
  class Tv {
    constructor() {
      this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
    }
  }
  class Iv {
    constructor(e2, t2, r2, n2) {
      this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e2.buffer, e2.byteOffset + t2, r2), this._littleEndian = n2, this._offset = 0;
    }
    _nextUint8() {
      const e2 = this._dataView.getUint8(this._offset);
      return this._offset += 1, e2;
    }
    _nextUint16() {
      const e2 = this._dataView.getUint16(this._offset, this._littleEndian);
      return this._offset += 2, e2;
    }
    _nextUint32() {
      const e2 = this._dataView.getUint32(this._offset, this._littleEndian);
      return this._offset += 4, e2;
    }
    _nextUint64() {
      const e2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
      return this._offset += 8, e2;
    }
    _nextInt32() {
      const e2 = this._dataView.getInt32(this._offset, this._littleEndian);
      return this._offset += 4, e2;
    }
    _skip(e2) {
      return this._offset += e2, this;
    }
    _scan(e2, t2 = 0) {
      const r2 = this._offset;
      let n2 = 0;
      for (; this._dataView.getUint8(this._offset) !== t2 && n2 < e2; )
        n2++, this._offset++;
      return n2 < e2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + r2, n2);
    }
  }
  new Uint8Array([0]);
  const kv = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
  function Dv(e2) {
    return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e2) : Buffer.from(e2).toString("utf8");
  }
  function Pv(e2) {
    const t2 = new Uint8Array(e2.buffer, e2.byteOffset, kv.length);
    if (t2[0] !== kv[0] || t2[1] !== kv[1] || t2[2] !== kv[2] || t2[3] !== kv[3] || t2[4] !== kv[4] || t2[5] !== kv[5] || t2[6] !== kv[6] || t2[7] !== kv[7] || t2[8] !== kv[8] || t2[9] !== kv[9] || t2[10] !== kv[10] || t2[11] !== kv[11])
      throw new Error("Missing KTX 2.0 identifier.");
    const r2 = new Tv(), n2 = 17 * Uint32Array.BYTES_PER_ELEMENT, i2 = new Iv(e2, kv.length, n2, true);
    r2.vkFormat = i2._nextUint32(), r2.typeSize = i2._nextUint32(), r2.pixelWidth = i2._nextUint32(), r2.pixelHeight = i2._nextUint32(), r2.pixelDepth = i2._nextUint32(), r2.layerCount = i2._nextUint32(), r2.faceCount = i2._nextUint32();
    const s2 = i2._nextUint32();
    r2.supercompressionScheme = i2._nextUint32();
    const o2 = i2._nextUint32(), a2 = i2._nextUint32(), l2 = i2._nextUint32(), c2 = i2._nextUint32(), u2 = i2._nextUint64(), h2 = i2._nextUint64(), p2 = new Iv(e2, kv.length + n2, 3 * s2 * 8, true);
    for (let t3 = 0; t3 < s2; t3++)
      r2.levels.push({ levelData: new Uint8Array(e2.buffer, e2.byteOffset + p2._nextUint64(), p2._nextUint64()), uncompressedByteLength: p2._nextUint64() });
    const d2 = new Iv(e2, o2, a2, true), f2 = { vendorId: d2._skip(4)._nextUint16(), descriptorType: d2._nextUint16(), versionNumber: d2._nextUint16(), descriptorBlockSize: d2._nextUint16(), colorModel: d2._nextUint8(), colorPrimaries: d2._nextUint8(), transferFunction: d2._nextUint8(), flags: d2._nextUint8(), texelBlockDimension: [d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8()], bytesPlane: [d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8()], samples: [] }, m2 = (f2.descriptorBlockSize / 4 - 6) / 4;
    for (let e3 = 0; e3 < m2; e3++) {
      const t3 = { bitOffset: d2._nextUint16(), bitLength: d2._nextUint8(), channelType: d2._nextUint8(), samplePosition: [d2._nextUint8(), d2._nextUint8(), d2._nextUint8(), d2._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 };
      64 & t3.channelType ? (t3.sampleLower = d2._nextInt32(), t3.sampleUpper = d2._nextInt32()) : (t3.sampleLower = d2._nextUint32(), t3.sampleUpper = d2._nextUint32()), f2.samples[e3] = t3;
    }
    r2.dataFormatDescriptor.length = 0, r2.dataFormatDescriptor.push(f2);
    const _2 = new Iv(e2, l2, c2, true);
    for (; _2._offset < c2; ) {
      const e3 = _2._nextUint32(), t3 = _2._scan(e3), n3 = Dv(t3), i3 = _2._scan(e3 - t3.byteLength);
      r2.keyValue[n3] = n3.match(/^ktx/i) ? Dv(i3) : i3, _2._offset % 4 && _2._skip(4 - _2._offset % 4);
    }
    if (h2 <= 0)
      return r2;
    const g2 = new Iv(e2, u2, h2, true), v2 = g2._nextUint16(), A2 = g2._nextUint16(), b2 = g2._nextUint32(), y2 = g2._nextUint32(), x2 = g2._nextUint32(), w2 = g2._nextUint32(), E2 = [];
    for (let e3 = 0; e3 < s2; e3++)
      E2.push({ imageFlags: g2._nextUint32(), rgbSliceByteOffset: g2._nextUint32(), rgbSliceByteLength: g2._nextUint32(), alphaSliceByteOffset: g2._nextUint32(), alphaSliceByteLength: g2._nextUint32() });
    const S2 = u2 + g2._offset, C2 = S2 + b2, M2 = C2 + y2, T2 = M2 + x2, I2 = new Uint8Array(e2.buffer, e2.byteOffset + S2, b2), k2 = new Uint8Array(e2.buffer, e2.byteOffset + C2, y2), D2 = new Uint8Array(e2.buffer, e2.byteOffset + M2, x2), P2 = new Uint8Array(e2.buffer, e2.byteOffset + T2, w2);
    return r2.globalData = { endpointCount: v2, selectorCount: A2, imageDescs: E2, endpointsData: I2, selectorsData: k2, tablesData: D2, extendedData: P2 }, r2;
  }
  class Bv extends ev {
    init() {
      this.extensionName = "EXT_mesh_gpu_instancing", this.propertyType = "InstancedMesh", this.parentTypes = [dg.NODE];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { attributes: {} });
    }
    getAttribute(e2) {
      return this.getRefMap("attributes", e2);
    }
    setAttribute(e2, t2) {
      return this.setRefMap("attributes", e2, t2, { usage: "INSTANCE_ATTRIBUTE" });
    }
    listAttributes() {
      return this.listRefMapValues("attributes");
    }
    listSemantics() {
      return this.listRefMapKeys("attributes");
    }
  }
  Bv.EXTENSION_NAME = "EXT_mesh_gpu_instancing";
  const Rv = "EXT_mesh_gpu_instancing";
  function Lv() {
    return (Lv = Object.assign || function(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var r2 = arguments[t2];
        for (var n2 in r2)
          Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
      }
      return e2;
    }).apply(this, arguments);
  }
  var Ov, Fv, Uv;
  (class extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = Rv, this.provideTypes = [dg.NODE], this.prewriteTypes = [dg.ACCESSOR];
    }
    createInstancedMesh() {
      return new Bv(this.document.getGraph());
    }
    read(e2) {
      return (e2.jsonDoc.json.nodes || []).forEach((t2, r2) => {
        if (!t2.extensions || !t2.extensions[Rv])
          return;
        const n2 = t2.extensions[Rv], i2 = this.createInstancedMesh();
        for (const t3 in n2.attributes)
          i2.setAttribute(t3, e2.accessors[n2.attributes[t3]]);
        e2.nodes[r2].setExtension(Rv, i2);
      }), this;
    }
    prewrite(e2) {
      e2.accessorUsageGroupedByParent.add("INSTANCE_ATTRIBUTE");
      for (const t2 of this.properties)
        for (const r2 of t2.listAttributes())
          e2.addAccessorToUsageGroup(r2, "INSTANCE_ATTRIBUTE");
      return this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listNodes().forEach((r2) => {
        const n2 = r2.getExtension(Rv);
        if (n2) {
          const i2 = e2.nodeIndexMap.get(r2), s2 = t2.json.nodes[i2], o2 = { attributes: {} };
          n2.listSemantics().forEach((t3) => {
            const r3 = n2.getAttribute(t3);
            o2.attributes[t3] = e2.accessorIndexMap.get(r3);
          }), s2.extensions = s2.extensions || {}, s2.extensions[Rv] = o2;
        }
      }), this;
    }
  }).EXTENSION_NAME = Rv, function(e2) {
    e2.QUANTIZE = "quantize", e2.FILTER = "filter";
  }(Ov || (Ov = {})), function(e2) {
    e2.ATTRIBUTES = "ATTRIBUTES", e2.TRIANGLES = "TRIANGLES", e2.INDICES = "INDICES";
  }(Fv || (Fv = {})), function(e2) {
    e2.NONE = "NONE", e2.OCTAHEDRAL = "OCTAHEDRAL", e2.QUATERNION = "QUATERNION", e2.EXPONENTIAL = "EXPONENTIAL";
  }(Uv || (Uv = {}));
  const { BYTE: Nv, SHORT: jv, FLOAT: zv } = Xg.ComponentType, { normalize: Gv, denormalize: Vv } = Bg;
  function Qv(e2, t2, r2, n2) {
    const { filter: i2, bits: s2 } = n2, o2 = { array: e2.getArray(), byteStride: e2.getElementSize() * e2.getComponentSize(), componentType: e2.getComponentType(), normalized: e2.getNormalized() };
    if (r2 !== Fv.ATTRIBUTES)
      return o2;
    if (i2 !== Uv.NONE) {
      let r3 = e2.getNormalized() ? function(e3) {
        const t3 = e3.getComponentType(), r4 = e3.getArray(), n3 = new Float32Array(r4.length);
        for (let e4 = 0; e4 < r4.length; e4++)
          n3[e4] = Vv(r4[e4], t3);
        return n3;
      }(e2) : new Float32Array(o2.array);
      switch (i2) {
        case Uv.EXPONENTIAL:
          o2.byteStride = 4 * e2.getElementSize(), o2.componentType = zv, o2.normalized = false, o2.array = t2.encodeFilterExp(r3, e2.getCount(), o2.byteStride, s2);
          break;
        case Uv.OCTAHEDRAL:
          o2.byteStride = s2 > 8 ? 8 : 4, o2.componentType = s2 > 8 ? jv : Nv, o2.normalized = true, r3 = 3 === e2.getElementSize() ? function(e3) {
            const t3 = new Float32Array(4 * e3.length / 3);
            for (let r4 = 0, n3 = e3.length / 3; r4 < n3; r4++)
              t3[4 * r4] = e3[3 * r4], t3[4 * r4 + 1] = e3[3 * r4 + 1], t3[4 * r4 + 2] = e3[3 * r4 + 2];
            return t3;
          }(r3) : r3, o2.array = t2.encodeFilterOct(r3, e2.getCount(), o2.byteStride, s2);
          break;
        case Uv.QUATERNION:
          o2.byteStride = 8, o2.componentType = jv, o2.normalized = true, o2.array = t2.encodeFilterQuat(r3, e2.getCount(), o2.byteStride, s2);
          break;
        default:
          throw new Error("Invalid filter.");
      }
      o2.min = e2.getMin([]), o2.max = e2.getMax([]), e2.getNormalized() && (o2.min = o2.min.map((t3) => Vv(t3, e2.getComponentType())), o2.max = o2.max.map((t3) => Vv(t3, e2.getComponentType()))), o2.normalized && (o2.min = o2.min.map((e3) => Gv(e3, o2.componentType)), o2.max = o2.max.map((e3) => Gv(e3, o2.componentType)));
    } else
      o2.byteStride % 4 && (o2.array = function(e3, t3) {
        const r3 = Eg.padNumber(e3.BYTES_PER_ELEMENT * t3) / e3.BYTES_PER_ELEMENT, n3 = new e3.constructor(e3.length / t3 * r3);
        for (let i3 = 0; i3 * t3 < e3.length; i3++)
          for (let s3 = 0; s3 < t3; s3++)
            n3[i3 * r3 + s3] = e3[i3 * t3 + s3];
        return n3;
      }(o2.array, e2.getElementSize()), o2.byteStride = o2.array.byteLength / e2.getCount());
    return o2;
  }
  function Hv(e2, t2) {
    return t2 === wv.BufferViewUsage.ELEMENT_ARRAY_BUFFER ? e2.listParents().some((e3) => e3 instanceof cv && e3.getMode() === cv.Mode.TRIANGLES) ? Fv.TRIANGLES : Fv.INDICES : Fv.ATTRIBUTES;
  }
  function Wv(e2, t2) {
    const r2 = t2.getGraph().listParentEdges(e2).filter((e3) => !(e3.getParent() instanceof mv));
    for (const t3 of r2) {
      const r3 = t3.getName(), n2 = t3.getAttributes().key || "";
      if ("indices" === r3)
        return { filter: Uv.NONE };
      if ("attributes" === r3) {
        if ("POSITION" === n2)
          return { filter: Uv.NONE };
        if ("TEXCOORD_0" === n2)
          return { filter: Uv.NONE };
        if ("NORMAL" === n2)
          return { filter: Uv.OCTAHEDRAL, bits: 8 };
        if ("TANGENT" === n2)
          return { filter: Uv.OCTAHEDRAL, bits: 8 };
        if (n2.startsWith("JOINTS_"))
          return { filter: Uv.NONE };
        if (n2.startsWith("WEIGHTS_"))
          return { filter: Uv.NONE };
      }
      if ("output" === r3) {
        const t4 = qv(e2);
        return "rotation" === t4 ? { filter: Uv.QUATERNION, bits: 16 } : "translation" === t4 || "scale" === t4 ? { filter: Uv.EXPONENTIAL, bits: 12 } : { filter: Uv.NONE };
      }
      if ("input" === r3)
        return { filter: Uv.NONE };
      if ("inverseBindMatrices" === r3)
        return { filter: Uv.NONE };
    }
    return { filter: Uv.NONE };
  }
  function qv(e2) {
    for (const t2 of e2.listParents())
      if (t2 instanceof Jg) {
        for (const e3 of t2.listParents())
          if (e3 instanceof Kg)
            return e3.getTargetPath();
      }
    return null;
  }
  const Xv = "EXT_meshopt_compression", Yv = { method: Ov.QUANTIZE };
  class Kv extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = Xv, this.prereadTypes = [dg.BUFFER, dg.PRIMITIVE], this.prewriteTypes = [dg.BUFFER, dg.ACCESSOR], this.readDependencies = ["meshopt.decoder"], this.writeDependencies = ["meshopt.encoder"], this._decoder = null, this._decoderFallbackBufferMap = /* @__PURE__ */ new Map(), this._encoder = null, this._encoderOptions = Yv, this._encoderFallbackBuffer = null, this._encoderBufferViews = {}, this._encoderBufferViewData = {}, this._encoderBufferViewAccessors = {};
    }
    install(e2, t2) {
      return "meshopt.decoder" === e2 && (this._decoder = t2), "meshopt.encoder" === e2 && (this._encoder = t2), this;
    }
    setEncoderOptions(e2) {
      return this._encoderOptions = Lv({}, Yv, e2), this;
    }
    preread(e2, t2) {
      if (!this._decoder) {
        if (!this.isRequired())
          return this;
        throw new Error(`[${Xv}] Please install extension dependency, "meshopt.decoder".`);
      }
      if (!this._decoder.supported) {
        if (!this.isRequired())
          return this;
        throw new Error(`[${Xv}]: Missing WASM support.`);
      }
      return t2 === dg.BUFFER ? this._prereadBuffers(e2) : t2 === dg.PRIMITIVE && this._prereadPrimitives(e2), this;
    }
    _prereadBuffers(e2) {
      const t2 = e2.jsonDoc;
      (t2.json.bufferViews || []).forEach((r2, n2) => {
        if (!r2.extensions || !r2.extensions[Xv])
          return;
        const i2 = r2.extensions[Xv], s2 = i2.byteOffset || 0, o2 = i2.byteLength || 0, a2 = i2.count, l2 = i2.byteStride, c2 = new Uint8Array(a2 * l2), u2 = t2.json.buffers[r2.buffer], h2 = Eg.toView(u2.uri ? t2.resources[u2.uri] : t2.resources["@glb.bin"], s2, o2);
        this._decoder.decodeGltfBuffer(c2, a2, l2, h2, i2.mode, i2.filter), e2.bufferViews[n2] = c2;
      });
    }
    _prereadPrimitives(e2) {
      const t2 = e2.jsonDoc;
      (t2.json.bufferViews || []).forEach((r2) => {
        var n2;
        r2.extensions && r2.extensions[Xv] && (n2 = t2.json.buffers[r2.buffer]).extensions && n2.extensions.EXT_meshopt_compression && n2.extensions.EXT_meshopt_compression.fallback && this._decoderFallbackBufferMap.set(e2.buffers[r2.buffer], e2.buffers[r2.extensions[Xv].buffer]);
      });
    }
    read(e2) {
      if (!this.isRequired())
        return this;
      for (const [e3, t2] of this._decoderFallbackBufferMap) {
        for (const r2 of e3.listParents())
          r2 instanceof Xg && r2.swap(e3, t2);
        e3.dispose();
      }
      return this;
    }
    prewrite(e2, t2) {
      return t2 === dg.ACCESSOR ? this._prewriteAccessors(e2) : t2 === dg.BUFFER && this._prewriteBuffers(e2), this;
    }
    _prewriteAccessors(e2) {
      const t2 = e2.jsonDoc.json, r2 = this._encoder, n2 = this._encoderOptions, i2 = this.document.createBuffer(), s2 = this.document.getRoot().listBuffers().indexOf(i2);
      this._encoderFallbackBuffer = i2, this._encoderBufferViews = {}, this._encoderBufferViewData = {}, this._encoderBufferViewAccessors = {};
      for (const i3 of this.document.getRoot().listAccessors()) {
        if ("weights" === qv(i3))
          continue;
        const o2 = e2.getAccessorUsage(i3), a2 = Hv(i3, o2), l2 = n2.method === Ov.FILTER ? Wv(i3, this.document) : { filter: Uv.NONE }, c2 = Qv(i3, r2, a2, l2), { array: u2, byteStride: h2 } = c2, p2 = i3.getBuffer();
        if (!p2)
          throw new Error(`${Xv}: Missing buffer for accessor.`);
        const d2 = this.document.getRoot().listBuffers().indexOf(p2), f2 = [o2, a2, l2.filter, h2, d2].join(":");
        let m2 = this._encoderBufferViews[f2], _2 = this._encoderBufferViewData[f2], g2 = this._encoderBufferViewAccessors[f2];
        m2 && _2 || (g2 = this._encoderBufferViewAccessors[f2] = [], _2 = this._encoderBufferViewData[f2] = [], m2 = this._encoderBufferViews[f2] = { buffer: s2, target: wv.USAGE_TO_TARGET[o2], byteOffset: 0, byteLength: 0, byteStride: o2 === wv.BufferViewUsage.ARRAY_BUFFER ? h2 : void 0, extensions: { [Xv]: { buffer: d2, byteOffset: 0, byteLength: 0, mode: a2, filter: l2.filter !== Uv.NONE ? l2.filter : void 0, byteStride: h2, count: 0 } } });
        const v2 = e2.createAccessorDef(i3);
        v2.componentType = c2.componentType, v2.normalized = c2.normalized, v2.byteOffset = m2.byteLength, v2.min && c2.min && (v2.min = c2.min), v2.max && c2.max && (v2.max = c2.max), e2.accessorIndexMap.set(i3, t2.accessors.length), t2.accessors.push(v2), g2.push(v2), _2.push(new Uint8Array(u2.buffer, u2.byteOffset, u2.byteLength)), m2.byteLength += u2.byteLength, m2.extensions.EXT_meshopt_compression.count += i3.getCount();
      }
    }
    _prewriteBuffers(e2) {
      const t2 = this._encoder;
      for (const r2 in this._encoderBufferViews) {
        const n2 = this._encoderBufferViews[r2], i2 = this._encoderBufferViewData[r2], s2 = this.document.getRoot().listBuffers()[n2.extensions[Xv].buffer], o2 = e2.otherBufferViews.get(s2) || [], { count: a2, byteStride: l2, mode: c2 } = n2.extensions[Xv], u2 = Eg.concat(i2), h2 = t2.encodeGltfBuffer(u2, a2, l2, c2), p2 = Eg.pad(h2);
        n2.extensions[Xv].byteLength = h2.byteLength, i2.length = 0, i2.push(p2), o2.push(p2), e2.otherBufferViews.set(s2, o2);
      }
    }
    write(e2) {
      let t2 = 0;
      for (const r3 in this._encoderBufferViews) {
        const n3 = this._encoderBufferViews[r3], i3 = e2.otherBufferViewsIndexMap.get(this._encoderBufferViewData[r3][0]), s2 = this._encoderBufferViewAccessors[r3];
        for (const e3 of s2)
          e3.bufferView = i3;
        const o2 = e2.jsonDoc.json.bufferViews[i3], a2 = o2.byteOffset || 0;
        Object.assign(o2, n3), o2.byteOffset = t2, o2.extensions[Xv].byteOffset = a2, t2 += Eg.padNumber(n3.byteLength);
      }
      const r2 = this._encoderFallbackBuffer, n2 = e2.bufferIndexMap.get(r2), i2 = e2.jsonDoc.json.buffers[n2];
      return i2.byteLength = t2, i2.extensions = { [Xv]: { fallback: true } }, r2.dispose(), this;
    }
  }
  Kv.EXTENSION_NAME = Xv, Kv.EncoderMethod = Ov;
  const Jv = "EXT_texture_webp";
  class Zv {
    match(e2) {
      return e2.length >= 12 && 87 === e2[8] && 69 === e2[9] && 66 === e2[10] && 80 === e2[11];
    }
    getSize(e2) {
      const t2 = Eg.decodeText(e2.slice(0, 4)), r2 = Eg.decodeText(e2.slice(8, 12));
      if ("RIFF" !== t2 || "WEBP" !== r2)
        return null;
      const n2 = new DataView(e2.buffer, e2.byteOffset);
      let i2 = 12;
      for (; i2 < n2.byteLength; ) {
        const e3 = Eg.decodeText(new Uint8Array([n2.getUint8(i2), n2.getUint8(i2 + 1), n2.getUint8(i2 + 2), n2.getUint8(i2 + 3)])), t3 = n2.getUint32(i2 + 4, true);
        if ("VP8 " === e3)
          return [16383 & n2.getInt16(i2 + 14, true), 16383 & n2.getInt16(i2 + 16, true)];
        if ("VP8L" === e3) {
          const e4 = n2.getUint8(i2 + 9), t4 = n2.getUint8(i2 + 10), r3 = n2.getUint8(i2 + 11);
          return [1 + ((63 & t4) << 8 | e4), 1 + ((15 & n2.getUint8(i2 + 12)) << 10 | r3 << 2 | (192 & t4) >> 6)];
        }
        i2 += 8 + t3 + t3 % 2;
      }
      return null;
    }
    getChannels(e2) {
      return 4;
    }
  }
  (class extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = Jv, this.prereadTypes = [dg.TEXTURE];
    }
    static register() {
      Mg.registerFormat("image/webp", new Zv());
    }
    preread(e2) {
      return (e2.jsonDoc.json.textures || []).forEach((e3) => {
        e3.extensions && e3.extensions.EXT_texture_webp && (e3.source = e3.extensions.EXT_texture_webp.source);
      }), this;
    }
    read(e2) {
      return this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listTextures().forEach((r2) => {
        if ("image/webp" === r2.getMimeType()) {
          const n2 = e2.imageIndexMap.get(r2);
          (t2.json.textures || []).forEach((e3) => {
            e3.source === n2 && (e3.extensions = e3.extensions || {}, e3.extensions.EXT_texture_webp = { source: e3.source }, delete e3.source);
          });
        }
      }), this;
    }
  }).EXTENSION_NAME = Jv;
  const $v = "KHR_draco_mesh_compression";
  let eA, tA, rA, nA;
  function iA(e2, t2) {
    const r2 = new eA.DecoderBuffer();
    try {
      if (r2.Init(t2, t2.length), e2.GetEncodedGeometryType(r2) !== eA.TRIANGULAR_MESH)
        throw new Error(`[${$v}] Unknown geometry type.`);
      const n2 = new eA.Mesh();
      if (!e2.DecodeBufferToMesh(r2, n2).ok() || 0 === n2.ptr)
        throw new Error(`[${$v}] Decoding failure.`);
      return n2;
    } finally {
      eA.destroy(r2);
    }
  }
  function sA(e2, t2) {
    const r2 = 3 * t2.num_faces();
    let n2, i2;
    if (t2.num_points() <= 65534) {
      const s2 = r2 * Uint16Array.BYTES_PER_ELEMENT;
      n2 = eA._malloc(s2), e2.GetTrianglesUInt16Array(t2, s2, n2), i2 = new Uint16Array(eA.HEAPU16.buffer, n2, r2).slice();
    } else {
      const s2 = r2 * Uint32Array.BYTES_PER_ELEMENT;
      n2 = eA._malloc(s2), e2.GetTrianglesUInt32Array(t2, s2, n2), i2 = new Uint32Array(eA.HEAPU32.buffer, n2, r2).slice();
    }
    return eA._free(n2), i2;
  }
  function oA(e2, t2, r2, n2) {
    const i2 = rA[n2.componentType], s2 = tA[n2.componentType], o2 = r2.num_components(), a2 = t2.num_points() * o2, l2 = a2 * s2.BYTES_PER_ELEMENT, c2 = eA._malloc(l2);
    e2.GetAttributeDataArrayForAllPoints(t2, r2, i2, l2, c2);
    const u2 = new s2(eA.HEAPF32.buffer, c2, a2).slice();
    return eA._free(c2), u2;
  }
  var aA, lA;
  !function(e2) {
    e2[e2.EDGEBREAKER = 1] = "EDGEBREAKER", e2[e2.SEQUENTIAL = 0] = "SEQUENTIAL";
  }(aA || (aA = {})), function(e2) {
    e2.POSITION = "POSITION", e2.NORMAL = "NORMAL", e2.COLOR = "COLOR", e2.TEX_COORD = "TEX_COORD", e2.GENERIC = "GENERIC";
  }(lA || (lA = {}));
  const cA = { [lA.POSITION]: 14, [lA.NORMAL]: 10, [lA.COLOR]: 8, [lA.TEX_COORD]: 12, [lA.GENERIC]: 12 }, uA = { decodeSpeed: 5, encodeSpeed: 5, method: aA.EDGEBREAKER, quantizationBits: cA, quantizationVolume: "mesh" };
  function hA(e2, t2 = uA) {
    const r2 = Lv({}, uA, t2);
    r2.quantizationBits = Lv({}, cA, t2.quantizationBits);
    const n2 = new nA.Encoder(), i2 = new nA.MeshBuilder(), s2 = new nA.Mesh(), o2 = {}, a2 = new nA.DracoInt8Array();
    for (const t3 of e2.listSemantics()) {
      const a3 = e2.getAttribute(t3), l3 = pA(t3), c3 = dA(i2, a3.getComponentType(), s2, nA[l3], a3.getCount(), a3.getElementSize(), a3.getArray());
      if (-1 === c3)
        throw new Error(`Error compressing "${t3}" attribute.`);
      if (o2[t3] = c3, "mesh" === r2.quantizationVolume || "POSITION" !== t3)
        n2.SetAttributeQuantization(nA[l3], r2.quantizationBits[l3]);
      else {
        if ("object" != typeof r2.quantizationVolume)
          throw new Error("Invalid quantization volume state.");
        {
          const { quantizationVolume: e3 } = r2, t4 = Math.max(e3.max[0] - e3.min[0], e3.max[1] - e3.min[1], e3.max[2] - e3.min[2]);
          n2.SetAttributeExplicitQuantization(nA[l3], r2.quantizationBits[l3], a3.getElementSize(), e3.min, t4);
        }
      }
    }
    const l2 = e2.getIndices();
    if (!l2)
      throw new Error("Primitive must have indices.");
    i2.AddFacesToMesh(s2, l2.getCount() / 3, l2.getArray()), n2.SetSpeedOptions(r2.encodeSpeed, r2.decodeSpeed), n2.SetTrackEncodedProperties(true), r2.method === aA.SEQUENTIAL || e2.listTargets().length > 0 ? n2.SetEncodingMethod(nA.MESH_SEQUENTIAL_ENCODING) : n2.SetEncodingMethod(nA.MESH_EDGEBREAKER_ENCODING);
    const c2 = n2.EncodeMeshToDracoBuffer(s2, a2);
    if (c2 <= 0)
      throw new Error("Error applying Draco compression.");
    const u2 = new Uint8Array(c2);
    for (let e3 = 0; e3 < c2; ++e3)
      u2[e3] = a2.GetValue(e3);
    const h2 = e2.getAttribute("POSITION").getCount(), p2 = n2.GetNumberOfEncodedPoints(), d2 = 3 * n2.GetNumberOfEncodedFaces();
    if (e2.listTargets().length > 0 && p2 !== h2)
      throw new Error('Compression reduced vertex count unexpectedly, corrupting morph targets. Applying the "weld" function before compression may resolve the issue.');
    return nA.destroy(a2), nA.destroy(s2), nA.destroy(i2), nA.destroy(n2), { numVertices: p2, numIndices: d2, data: u2, attributeIDs: o2 };
  }
  function pA(e2) {
    return "POSITION" === e2 ? lA.POSITION : "NORMAL" === e2 ? lA.NORMAL : e2.startsWith("COLOR_") ? lA.COLOR : e2.startsWith("TEXCOORD_") ? lA.TEX_COORD : lA.GENERIC;
  }
  function dA(e2, t2, r2, n2, i2, s2, o2) {
    switch (t2) {
      case Xg.ComponentType.UNSIGNED_BYTE:
        return e2.AddUInt8Attribute(r2, n2, i2, s2, o2);
      case Xg.ComponentType.BYTE:
        return e2.AddInt8Attribute(r2, n2, i2, s2, o2);
      case Xg.ComponentType.UNSIGNED_SHORT:
        return e2.AddUInt16Attribute(r2, n2, i2, s2, o2);
      case Xg.ComponentType.SHORT:
        return e2.AddInt16Attribute(r2, n2, i2, s2, o2);
      case Xg.ComponentType.UNSIGNED_INT:
        return e2.AddUInt32Attribute(r2, n2, i2, s2, o2);
      case Xg.ComponentType.FLOAT:
        return e2.AddFloatAttribute(r2, n2, i2, s2, o2);
      default:
        throw new Error(`Unexpected component type, "${t2}".`);
    }
  }
  const fA = "KHR_draco_mesh_compression";
  class mA extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = fA, this.prereadTypes = [dg.PRIMITIVE], this.prewriteTypes = [dg.ACCESSOR], this.readDependencies = ["draco3d.decoder"], this.writeDependencies = ["draco3d.encoder"], this._decoderModule = null, this._encoderModule = null, this._encoderOptions = {};
    }
    install(e2, t2) {
      return "draco3d.decoder" === e2 && (this._decoderModule = t2, eA = this._decoderModule, tA = { [Xg.ComponentType.FLOAT]: Float32Array, [Xg.ComponentType.UNSIGNED_INT]: Uint32Array, [Xg.ComponentType.UNSIGNED_SHORT]: Uint16Array, [Xg.ComponentType.UNSIGNED_BYTE]: Uint8Array, [Xg.ComponentType.SHORT]: Int16Array, [Xg.ComponentType.BYTE]: Int8Array }, rA = { [Xg.ComponentType.FLOAT]: eA.DT_FLOAT32, [Xg.ComponentType.UNSIGNED_INT]: eA.DT_UINT32, [Xg.ComponentType.UNSIGNED_SHORT]: eA.DT_UINT16, [Xg.ComponentType.UNSIGNED_BYTE]: eA.DT_UINT8, [Xg.ComponentType.SHORT]: eA.DT_INT16, [Xg.ComponentType.BYTE]: eA.DT_INT8 }), "draco3d.encoder" === e2 && (this._encoderModule = t2, nA = this._encoderModule), this;
    }
    setEncoderOptions(e2) {
      return this._encoderOptions = e2, this;
    }
    preread(e2) {
      if (!this._decoderModule)
        throw new Error(`[${fA}] Please install extension dependency, "draco3d.decoder".`);
      const t2 = this.document.getLogger(), r2 = e2.jsonDoc, n2 = /* @__PURE__ */ new Map();
      try {
        const i2 = r2.json.meshes || [];
        for (const s2 of i2)
          for (const i3 of s2.primitives) {
            if (!i3.extensions || !i3.extensions[fA])
              continue;
            const s3 = i3.extensions[fA];
            let [o2, a2] = n2.get(s3.bufferView) || [];
            if (!a2 || !o2) {
              const e3 = r2.json.bufferViews[s3.bufferView], i4 = r2.json.buffers[e3.buffer], l2 = Eg.toView(i4.uri ? r2.resources[i4.uri] : r2.resources["@glb.bin"], e3.byteOffset || 0, e3.byteLength);
              o2 = new this._decoderModule.Decoder(), a2 = iA(o2, l2), n2.set(s3.bufferView, [o2, a2]), t2.debug(`[${fA}] Decompressed ${l2.byteLength} bytes.`);
            }
            for (const t3 in i3.attributes) {
              const r3 = e2.jsonDoc.json.accessors[i3.attributes[t3]], n3 = o2.GetAttributeByUniqueId(a2, s3.attributes[t3]), l2 = oA(o2, a2, n3, r3);
              e2.accessors[i3.attributes[t3]].setArray(l2);
            }
            void 0 !== i3.indices && e2.accessors[i3.indices].setArray(sA(o2, a2));
          }
      } finally {
        for (const [e3, t3] of Array.from(n2.values()))
          this._decoderModule.destroy(e3), this._decoderModule.destroy(t3);
      }
      return this;
    }
    read(e2) {
      return this;
    }
    prewrite(e2, t2) {
      if (!this._encoderModule)
        throw new Error(`[${fA}] Please install extension dependency, "draco3d.encoder".`);
      const r2 = this.document.getLogger();
      r2.debug(`[${fA}] Compression options: ${JSON.stringify(this._encoderOptions)}`);
      const n2 = function(e3) {
        const t3 = e3.getLogger(), r3 = /* @__PURE__ */ new Set(), n3 = /* @__PURE__ */ new Set();
        for (const i4 of e3.getRoot().listMeshes())
          for (const e4 of i4.listPrimitives())
            e4.getIndices() ? e4.getMode() !== cv.Mode.TRIANGLES ? (n3.add(e4), t3.warn(`[${fA}] Skipping Draco compression on non-TRIANGLES primitive.`)) : r3.add(e4) : (n3.add(e4), t3.warn(`[${fA}] Skipping Draco compression on non-indexed primitive.`));
        const i3 = e3.getRoot().listAccessors(), s3 = /* @__PURE__ */ new Map();
        for (let e4 = 0; e4 < i3.length; e4++)
          s3.set(i3[e4], e4);
        const o2 = /* @__PURE__ */ new Map(), a2 = /* @__PURE__ */ new Set(), l2 = /* @__PURE__ */ new Map();
        for (const t4 of Array.from(r3)) {
          let r4 = _A(t4, s3);
          if (a2.has(r4))
            l2.set(t4, r4);
          else {
            if (o2.has(t4.getIndices())) {
              const r5 = t4.getIndices(), n4 = r5.clone();
              s3.set(n4, e3.getRoot().listAccessors().length - 1), t4.swap(r5, n4);
            }
            for (const r5 of t4.listAttributes())
              if (o2.has(r5)) {
                const n4 = r5.clone();
                s3.set(n4, e3.getRoot().listAccessors().length - 1), t4.swap(r5, n4);
              }
            r4 = _A(t4, s3), a2.add(r4), l2.set(t4, r4), o2.set(t4.getIndices(), r4);
            for (const e4 of t4.listAttributes())
              o2.set(e4, r4);
          }
        }
        for (const e4 of Array.from(o2.keys())) {
          const t4 = new Set(e4.listParents().map((e5) => e5.propertyType));
          if (2 !== t4.size || !t4.has(dg.PRIMITIVE) || !t4.has(dg.ROOT))
            throw new Error(`[${fA}] Compressed accessors must only be used as indices or vertex attributes.`);
        }
        for (const e4 of Array.from(r3)) {
          const t4 = l2.get(e4), r4 = e4.getIndices();
          if (o2.get(r4) !== t4 || e4.listAttributes().some((e5) => o2.get(e5) !== t4))
            throw new Error(`[${fA}] Draco primitives must share all, or no, accessors.`);
        }
        for (const e4 of Array.from(n3)) {
          const t4 = e4.getIndices();
          if (o2.has(t4) || e4.listAttributes().some((e5) => o2.has(e5)))
            throw new Error(`[${fA}] Accessor cannot be shared by compressed and uncompressed primitives.`);
        }
        return l2;
      }(this.document), i2 = /* @__PURE__ */ new Map();
      let s2 = "mesh";
      "scene" === this._encoderOptions.quantizationVolume && (1 !== this.document.getRoot().listScenes().length ? r2.warn(`[${fA}]: quantizationVolume=scene requires exactly 1 scene.`) : s2 = function(e3) {
        const t3 = { min: [1 / 0, 1 / 0, 1 / 0], max: [-1 / 0, -1 / 0, -1 / 0] }, r3 = e3.propertyType === dg.NODE ? [e3] : e3.listChildren();
        for (const e4 of r3)
          e4.traverse((e5) => {
            const r4 = e5.getMesh();
            if (!r4)
              return;
            const n3 = xg(r4, e5.getWorldMatrix());
            wg(n3.min, t3), wg(n3.max, t3);
          });
        return t3;
      }(this.document.getRoot().listScenes().pop()));
      for (const t3 of Array.from(n2.keys())) {
        const r3 = n2.get(t3);
        if (!r3)
          throw new Error("Unexpected primitive.");
        if (i2.has(r3)) {
          i2.set(r3, i2.get(r3));
          continue;
        }
        const o2 = t3.getIndices(), a2 = e2.jsonDoc.json.accessors, l2 = hA(t3, Lv({}, this._encoderOptions, { quantizationVolume: s2 }));
        i2.set(r3, l2);
        const c2 = e2.createAccessorDef(o2);
        c2.count = l2.numIndices, e2.accessorIndexMap.set(o2, a2.length), a2.push(c2);
        for (const r4 of t3.listSemantics()) {
          const n3 = t3.getAttribute(r4), i3 = e2.createAccessorDef(n3);
          i3.count = l2.numVertices, e2.accessorIndexMap.set(n3, a2.length), a2.push(i3);
        }
        const u2 = t3.getAttribute("POSITION").getBuffer() || this.document.getRoot().listBuffers()[0];
        e2.otherBufferViews.has(u2) || e2.otherBufferViews.set(u2, []), e2.otherBufferViews.get(u2).push(l2.data);
      }
      return r2.debug(`[${fA}] Compressed ${n2.size} primitives.`), e2.extensionData[fA] = { primitiveHashMap: n2, primitiveEncodingMap: i2 }, this;
    }
    write(e2) {
      const t2 = e2.extensionData[fA];
      for (const r2 of this.document.getRoot().listMeshes()) {
        const n2 = e2.jsonDoc.json.meshes[e2.meshIndexMap.get(r2)];
        for (let i2 = 0; i2 < r2.listPrimitives().length; i2++) {
          const s2 = r2.listPrimitives()[i2], o2 = n2.primitives[i2], a2 = t2.primitiveHashMap.get(s2);
          if (!a2)
            continue;
          const l2 = t2.primitiveEncodingMap.get(a2);
          o2.extensions = o2.extensions || {}, o2.extensions[fA] = { bufferView: e2.otherBufferViewsIndexMap.get(l2.data), attributes: l2.attributeIDs };
        }
      }
      if (!t2.primitiveHashMap.size) {
        const t3 = e2.jsonDoc.json;
        t3.extensionsUsed = (t3.extensionsUsed || []).filter((e3) => e3 !== fA), t3.extensionsRequired = (t3.extensionsRequired || []).filter((e3) => e3 !== fA);
      }
      return this;
    }
  }
  function _A(e2, t2) {
    const r2 = [], n2 = e2.getIndices();
    r2.push(t2.get(n2));
    for (const n3 of e2.listAttributes())
      r2.push(t2.get(n3));
    return r2.sort().join("|");
  }
  mA.EXTENSION_NAME = fA, mA.EncoderMethod = aA;
  class gA extends ev {
    init() {
      this.extensionName = "KHR_lights_punctual", this.propertyType = "Light", this.parentTypes = [dg.NODE];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { color: [1, 1, 1], intensity: 1, type: gA.Type.POINT, range: null, innerConeAngle: 0, outerConeAngle: Math.PI / 4 });
    }
    getColor() {
      return this.get("color");
    }
    setColor(e2) {
      return this.set("color", e2);
    }
    getColorHex() {
      return Sg.factorToHex(this.getColor());
    }
    setColorHex(e2) {
      const t2 = this.getColor().slice();
      return Sg.hexToFactor(e2, t2), this.setColor(t2);
    }
    getIntensity() {
      return this.get("intensity");
    }
    setIntensity(e2) {
      return this.set("intensity", e2);
    }
    getType() {
      return this.get("type");
    }
    setType(e2) {
      return this.set("type", e2);
    }
    getRange() {
      return this.get("range");
    }
    setRange(e2) {
      return this.set("range", e2);
    }
    getInnerConeAngle() {
      return this.get("innerConeAngle");
    }
    setInnerConeAngle(e2) {
      return this.set("innerConeAngle", e2);
    }
    getOuterConeAngle() {
      return this.get("outerConeAngle");
    }
    setOuterConeAngle(e2) {
      return this.set("outerConeAngle", e2);
    }
  }
  gA.EXTENSION_NAME = "KHR_lights_punctual", gA.Type = { POINT: "point", SPOT: "spot", DIRECTIONAL: "directional" };
  const vA = "KHR_lights_punctual";
  class AA extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = vA;
    }
    createLight(e2 = "") {
      return new gA(this.document.getGraph(), e2);
    }
    read(e2) {
      const t2 = e2.jsonDoc;
      if (!t2.json.extensions || !t2.json.extensions.KHR_lights_punctual)
        return this;
      const r2 = (t2.json.extensions.KHR_lights_punctual.lights || []).map((e3) => {
        var t3, r3;
        const n2 = this.createLight().setName(e3.name || "").setType(e3.type);
        return void 0 !== e3.color && n2.setColor(e3.color), void 0 !== e3.intensity && n2.setIntensity(e3.intensity), void 0 !== e3.range && n2.setRange(e3.range), void 0 !== (null == (t3 = e3.spot) ? void 0 : t3.innerConeAngle) && n2.setInnerConeAngle(e3.spot.innerConeAngle), void 0 !== (null == (r3 = e3.spot) ? void 0 : r3.outerConeAngle) && n2.setOuterConeAngle(e3.spot.outerConeAngle), n2;
      });
      return t2.json.nodes.forEach((t3, n2) => {
        t3.extensions && t3.extensions.KHR_lights_punctual && e2.nodes[n2].setExtension(vA, r2[t3.extensions.KHR_lights_punctual.light]);
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      if (0 === this.properties.size)
        return this;
      const r2 = [], n2 = /* @__PURE__ */ new Map();
      for (const e3 of this.properties) {
        const t3 = e3, i2 = { type: t3.getType() };
        Bg.eq(t3.getColor(), [1, 1, 1]) || (i2.color = t3.getColor()), 1 !== t3.getIntensity() && (i2.intensity = t3.getIntensity()), null != t3.getRange() && (i2.range = t3.getRange()), t3.getName() && (i2.name = t3.getName()), t3.getType() === gA.Type.SPOT && (i2.spot = { innerConeAngle: t3.getInnerConeAngle(), outerConeAngle: t3.getOuterConeAngle() }), r2.push(i2), n2.set(t3, r2.length - 1);
      }
      return this.document.getRoot().listNodes().forEach((r3) => {
        const i2 = r3.getExtension(vA);
        if (i2) {
          const s2 = e2.nodeIndexMap.get(r3), o2 = t2.json.nodes[s2];
          o2.extensions = o2.extensions || {}, o2.extensions.KHR_lights_punctual = { light: n2.get(i2) };
        }
      }), t2.json.extensions = t2.json.extensions || {}, t2.json.extensions.KHR_lights_punctual = { lights: r2 }, this;
    }
  }
  AA.EXTENSION_NAME = vA;
  const { R: bA, G: yA, B: xA } = _g;
  class wA extends ev {
    init() {
      this.extensionName = "KHR_materials_clearcoat", this.propertyType = "Clearcoat", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { clearcoatFactor: 0, clearcoatTexture: null, clearcoatTextureInfo: new tv(this.graph, "clearcoatTextureInfo"), clearcoatRoughnessFactor: 0, clearcoatRoughnessTexture: null, clearcoatRoughnessTextureInfo: new tv(this.graph, "clearcoatRoughnessTextureInfo"), clearcoatNormalScale: 1, clearcoatNormalTexture: null, clearcoatNormalTextureInfo: new tv(this.graph, "clearcoatNormalTextureInfo") });
    }
    getClearcoatFactor() {
      return this.get("clearcoatFactor");
    }
    setClearcoatFactor(e2) {
      return this.set("clearcoatFactor", e2);
    }
    getClearcoatTexture() {
      return this.getRef("clearcoatTexture");
    }
    getClearcoatTextureInfo() {
      return this.getRef("clearcoatTexture") ? this.getRef("clearcoatTextureInfo") : null;
    }
    setClearcoatTexture(e2) {
      return this.setRef("clearcoatTexture", e2, { channels: bA });
    }
    getClearcoatRoughnessFactor() {
      return this.get("clearcoatRoughnessFactor");
    }
    setClearcoatRoughnessFactor(e2) {
      return this.set("clearcoatRoughnessFactor", e2);
    }
    getClearcoatRoughnessTexture() {
      return this.getRef("clearcoatRoughnessTexture");
    }
    getClearcoatRoughnessTextureInfo() {
      return this.getRef("clearcoatRoughnessTexture") ? this.getRef("clearcoatRoughnessTextureInfo") : null;
    }
    setClearcoatRoughnessTexture(e2) {
      return this.setRef("clearcoatRoughnessTexture", e2, { channels: yA });
    }
    getClearcoatNormalScale() {
      return this.get("clearcoatNormalScale");
    }
    setClearcoatNormalScale(e2) {
      return this.set("clearcoatNormalScale", e2);
    }
    getClearcoatNormalTexture() {
      return this.getRef("clearcoatNormalTexture");
    }
    getClearcoatNormalTextureInfo() {
      return this.getRef("clearcoatNormalTexture") ? this.getRef("clearcoatNormalTextureInfo") : null;
    }
    setClearcoatNormalTexture(e2) {
      return this.setRef("clearcoatNormalTexture", e2, { channels: bA | yA | xA });
    }
  }
  wA.EXTENSION_NAME = "KHR_materials_clearcoat";
  const EA = "KHR_materials_clearcoat";
  class SA extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = EA;
    }
    createClearcoat() {
      return new wA(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, r2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, n2) => {
        if (t3.extensions && t3.extensions[EA]) {
          const i2 = this.createClearcoat();
          e2.materials[n2].setExtension(EA, i2);
          const s2 = t3.extensions[EA];
          if (void 0 !== s2.clearcoatFactor && i2.setClearcoatFactor(s2.clearcoatFactor), void 0 !== s2.clearcoatRoughnessFactor && i2.setClearcoatRoughnessFactor(s2.clearcoatRoughnessFactor), void 0 !== s2.clearcoatTexture) {
            const t4 = s2.clearcoatTexture;
            i2.setClearcoatTexture(e2.textures[r2[t4.index].source]), e2.setTextureInfo(i2.getClearcoatTextureInfo(), t4);
          }
          if (void 0 !== s2.clearcoatRoughnessTexture) {
            const t4 = s2.clearcoatRoughnessTexture;
            i2.setClearcoatRoughnessTexture(e2.textures[r2[t4.index].source]), e2.setTextureInfo(i2.getClearcoatRoughnessTextureInfo(), t4);
          }
          if (void 0 !== s2.clearcoatNormalTexture) {
            const t4 = s2.clearcoatNormalTexture;
            i2.setClearcoatNormalTexture(e2.textures[r2[t4.index].source]), e2.setTextureInfo(i2.getClearcoatNormalTextureInfo(), t4), void 0 !== t4.scale && i2.setClearcoatNormalScale(t4.scale);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((r2) => {
        const n2 = r2.getExtension(EA);
        if (n2) {
          const i2 = e2.materialIndexMap.get(r2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions[EA] = { clearcoatFactor: n2.getClearcoatFactor(), clearcoatRoughnessFactor: n2.getClearcoatRoughnessFactor() };
          if (n2.getClearcoatTexture()) {
            const t3 = n2.getClearcoatTexture(), r3 = n2.getClearcoatTextureInfo();
            o2.clearcoatTexture = e2.createTextureInfoDef(t3, r3);
          }
          if (n2.getClearcoatRoughnessTexture()) {
            const t3 = n2.getClearcoatRoughnessTexture(), r3 = n2.getClearcoatRoughnessTextureInfo();
            o2.clearcoatRoughnessTexture = e2.createTextureInfoDef(t3, r3);
          }
          if (n2.getClearcoatNormalTexture()) {
            const t3 = n2.getClearcoatNormalTexture(), r3 = n2.getClearcoatNormalTextureInfo();
            o2.clearcoatNormalTexture = e2.createTextureInfoDef(t3, r3), 1 !== n2.getClearcoatNormalScale() && (o2.clearcoatNormalTexture.scale = n2.getClearcoatNormalScale());
          }
        }
      }), this;
    }
  }
  SA.EXTENSION_NAME = EA;
  class CA extends ev {
    init() {
      this.extensionName = "KHR_materials_emissive_strength", this.propertyType = "EmissiveStrength", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { emissiveStrength: 1 });
    }
    getEmissiveStrength() {
      return this.get("emissiveStrength");
    }
    setEmissiveStrength(e2) {
      return this.set("emissiveStrength", e2);
    }
  }
  CA.EXTENSION_NAME = "KHR_materials_emissive_strength";
  const MA = "KHR_materials_emissive_strength";
  class TA extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = MA;
    }
    createEmissiveStrength() {
      return new CA(this.document.getGraph());
    }
    read(e2) {
      return (e2.jsonDoc.json.materials || []).forEach((t2, r2) => {
        if (t2.extensions && t2.extensions[MA]) {
          const n2 = this.createEmissiveStrength();
          e2.materials[r2].setExtension(MA, n2);
          const i2 = t2.extensions[MA];
          void 0 !== i2.emissiveStrength && n2.setEmissiveStrength(i2.emissiveStrength);
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((r2) => {
        const n2 = r2.getExtension(MA);
        if (n2) {
          const i2 = e2.materialIndexMap.get(r2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {}, s2.extensions[MA] = { emissiveStrength: n2.getEmissiveStrength() };
        }
      }), this;
    }
  }
  TA.EXTENSION_NAME = MA;
  class IA extends ev {
    init() {
      this.extensionName = "KHR_materials_ior", this.propertyType = "IOR", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { ior: 0 });
    }
    getIOR() {
      return this.get("ior");
    }
    setIOR(e2) {
      return this.set("ior", e2);
    }
  }
  IA.EXTENSION_NAME = "KHR_materials_ior";
  const kA = "KHR_materials_ior";
  class DA extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = kA;
    }
    createIOR() {
      return new IA(this.document.getGraph());
    }
    read(e2) {
      return (e2.jsonDoc.json.materials || []).forEach((t2, r2) => {
        if (t2.extensions && t2.extensions.KHR_materials_ior) {
          const n2 = this.createIOR();
          e2.materials[r2].setExtension(kA, n2);
          const i2 = t2.extensions.KHR_materials_ior;
          void 0 !== i2.ior && n2.setIOR(i2.ior);
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((r2) => {
        const n2 = r2.getExtension(kA);
        if (n2) {
          const i2 = e2.materialIndexMap.get(r2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {}, s2.extensions.KHR_materials_ior = { ior: n2.getIOR() };
        }
      }), this;
    }
  }
  DA.EXTENSION_NAME = kA;
  const { R: PA, G: BA } = _g;
  class RA extends ev {
    init() {
      this.extensionName = "KHR_materials_iridescence", this.propertyType = "Iridescence", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { iridescenceFactor: 0, iridescenceTexture: null, iridescenceTextureInfo: new tv(this.graph, "iridescenceTextureInfo"), iridescenceIOR: 1.3, iridescenceThicknessMinimum: 100, iridescenceThicknessMaximum: 400, iridescenceThicknessTexture: null, iridescenceThicknessTextureInfo: new tv(this.graph, "iridescenceThicknessTextureInfo") });
    }
    getIridescenceFactor() {
      return this.get("iridescenceFactor");
    }
    setIridescenceFactor(e2) {
      return this.set("iridescenceFactor", e2);
    }
    getIridescenceTexture() {
      return this.getRef("iridescenceTexture");
    }
    getIridescenceTextureInfo() {
      return this.getRef("iridescenceTexture") ? this.getRef("iridescenceTextureInfo") : null;
    }
    setIridescenceTexture(e2) {
      return this.setRef("iridescenceTexture", e2, { channels: PA });
    }
    getIridescenceIOR() {
      return this.get("iridescenceIOR");
    }
    setIridescenceIOR(e2) {
      return this.set("iridescenceIOR", e2);
    }
    getIridescenceThicknessMinimum() {
      return this.get("iridescenceThicknessMinimum");
    }
    setIridescenceThicknessMinimum(e2) {
      return this.set("iridescenceThicknessMinimum", e2);
    }
    getIridescenceThicknessMaximum() {
      return this.get("iridescenceThicknessMaximum");
    }
    setIridescenceThicknessMaximum(e2) {
      return this.set("iridescenceThicknessMaximum", e2);
    }
    getIridescenceThicknessTexture() {
      return this.getRef("iridescenceThicknessTexture");
    }
    getIridescenceThicknessTextureInfo() {
      return this.getRef("iridescenceThicknessTexture") ? this.getRef("iridescenceThicknessTextureInfo") : null;
    }
    setIridescenceThicknessTexture(e2) {
      return this.setRef("iridescenceThicknessTexture", e2, { channels: BA });
    }
  }
  RA.EXTENSION_NAME = "KHR_materials_iridescence";
  const LA = "KHR_materials_iridescence";
  class OA extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = LA;
    }
    createIridescence() {
      return new RA(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, r2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, n2) => {
        if (t3.extensions && t3.extensions[LA]) {
          const i2 = this.createIridescence();
          e2.materials[n2].setExtension(LA, i2);
          const s2 = t3.extensions[LA];
          if (void 0 !== s2.iridescenceFactor && i2.setIridescenceFactor(s2.iridescenceFactor), void 0 !== s2.iridescenceIor && i2.setIridescenceIOR(s2.iridescenceIor), void 0 !== s2.iridescenceThicknessMinimum && i2.setIridescenceThicknessMinimum(s2.iridescenceThicknessMinimum), void 0 !== s2.iridescenceThicknessMaximum && i2.setIridescenceThicknessMaximum(s2.iridescenceThicknessMaximum), void 0 !== s2.iridescenceTexture) {
            const t4 = s2.iridescenceTexture;
            i2.setIridescenceTexture(e2.textures[r2[t4.index].source]), e2.setTextureInfo(i2.getIridescenceTextureInfo(), t4);
          }
          if (void 0 !== s2.iridescenceThicknessTexture) {
            const t4 = s2.iridescenceThicknessTexture;
            i2.setIridescenceThicknessTexture(e2.textures[r2[t4.index].source]), e2.setTextureInfo(i2.getIridescenceThicknessTextureInfo(), t4);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((r2) => {
        const n2 = r2.getExtension(LA);
        if (n2) {
          const i2 = e2.materialIndexMap.get(r2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions[LA] = {};
          if (n2.getIridescenceFactor() > 0 && (o2.iridescenceFactor = n2.getIridescenceFactor()), 1.3 !== n2.getIridescenceIOR() && (o2.iridescenceIor = n2.getIridescenceIOR()), 100 !== n2.getIridescenceThicknessMinimum() && (o2.iridescenceThicknessMinimum = n2.getIridescenceThicknessMinimum()), 400 !== n2.getIridescenceThicknessMaximum() && (o2.iridescenceThicknessMaximum = n2.getIridescenceThicknessMaximum()), n2.getIridescenceTexture()) {
            const t3 = n2.getIridescenceTexture(), r3 = n2.getIridescenceTextureInfo();
            o2.iridescenceTexture = e2.createTextureInfoDef(t3, r3);
          }
          if (n2.getIridescenceThicknessTexture()) {
            const t3 = n2.getIridescenceThicknessTexture(), r3 = n2.getIridescenceThicknessTextureInfo();
            o2.iridescenceThicknessTexture = e2.createTextureInfoDef(t3, r3);
          }
        }
      }), this;
    }
  }
  OA.EXTENSION_NAME = LA;
  const { R: FA, G: UA, B: NA, A: jA } = _g;
  class zA extends ev {
    init() {
      this.extensionName = "KHR_materials_pbrSpecularGlossiness", this.propertyType = "PBRSpecularGlossiness", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { diffuseFactor: [1, 1, 1, 1], diffuseTexture: null, diffuseTextureInfo: new tv(this.graph, "diffuseTextureInfo"), specularFactor: [1, 1, 1], glossinessFactor: 1, specularGlossinessTexture: null, specularGlossinessTextureInfo: new tv(this.graph, "specularGlossinessTextureInfo") });
    }
    getDiffuseFactor() {
      return this.get("diffuseFactor");
    }
    setDiffuseFactor(e2) {
      return this.set("diffuseFactor", e2);
    }
    getDiffuseHex() {
      return Sg.factorToHex(this.getDiffuseFactor());
    }
    setDiffuseHex(e2) {
      const t2 = this.getDiffuseFactor().slice();
      return this.setDiffuseFactor(Sg.hexToFactor(e2, t2));
    }
    getDiffuseTexture() {
      return this.getRef("diffuseTexture");
    }
    getDiffuseTextureInfo() {
      return this.getRef("diffuseTexture") ? this.getRef("diffuseTextureInfo") : null;
    }
    setDiffuseTexture(e2) {
      return this.setRef("diffuseTexture", e2, { channels: FA | UA | NA | jA });
    }
    getSpecularFactor() {
      return this.get("specularFactor");
    }
    setSpecularFactor(e2) {
      return this.set("specularFactor", e2);
    }
    getGlossinessFactor() {
      return this.get("glossinessFactor");
    }
    setGlossinessFactor(e2) {
      return this.set("glossinessFactor", e2);
    }
    getSpecularGlossinessTexture() {
      return this.getRef("specularGlossinessTexture");
    }
    getSpecularGlossinessTextureInfo() {
      return this.getRef("specularGlossinessTexture") ? this.getRef("specularGlossinessTextureInfo") : null;
    }
    setSpecularGlossinessTexture(e2) {
      return this.setRef("specularGlossinessTexture", e2, { channels: FA | UA | NA | jA });
    }
  }
  zA.EXTENSION_NAME = "KHR_materials_pbrSpecularGlossiness";
  const GA = "KHR_materials_pbrSpecularGlossiness";
  class VA extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = GA;
    }
    createPBRSpecularGlossiness() {
      return new zA(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, r2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, n2) => {
        if (t3.extensions && t3.extensions[GA]) {
          const i2 = this.createPBRSpecularGlossiness();
          e2.materials[n2].setExtension(GA, i2);
          const s2 = t3.extensions[GA];
          if (void 0 !== s2.diffuseFactor && i2.setDiffuseFactor(s2.diffuseFactor), void 0 !== s2.specularFactor && i2.setSpecularFactor(s2.specularFactor), void 0 !== s2.glossinessFactor && i2.setGlossinessFactor(s2.glossinessFactor), void 0 !== s2.diffuseTexture) {
            const t4 = s2.diffuseTexture;
            i2.setDiffuseTexture(e2.textures[r2[t4.index].source]), e2.setTextureInfo(i2.getDiffuseTextureInfo(), t4);
          }
          if (void 0 !== s2.specularGlossinessTexture) {
            const t4 = s2.specularGlossinessTexture;
            i2.setSpecularGlossinessTexture(e2.textures[r2[t4.index].source]), e2.setTextureInfo(i2.getSpecularGlossinessTextureInfo(), t4);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((r2) => {
        const n2 = r2.getExtension(GA);
        if (n2) {
          const i2 = e2.materialIndexMap.get(r2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions[GA] = { diffuseFactor: n2.getDiffuseFactor(), specularFactor: n2.getSpecularFactor(), glossinessFactor: n2.getGlossinessFactor() };
          if (n2.getDiffuseTexture()) {
            const t3 = n2.getDiffuseTexture(), r3 = n2.getDiffuseTextureInfo();
            o2.diffuseTexture = e2.createTextureInfoDef(t3, r3);
          }
          if (n2.getSpecularGlossinessTexture()) {
            const t3 = n2.getSpecularGlossinessTexture(), r3 = n2.getSpecularGlossinessTextureInfo();
            o2.specularGlossinessTexture = e2.createTextureInfoDef(t3, r3);
          }
        }
      }), this;
    }
  }
  VA.EXTENSION_NAME = GA;
  const { R: QA, G: HA, B: WA, A: qA } = _g;
  class XA extends ev {
    init() {
      this.extensionName = "KHR_materials_sheen", this.propertyType = "Sheen", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { sheenColorFactor: [0, 0, 0], sheenColorTexture: null, sheenColorTextureInfo: new tv(this.graph, "sheenColorTextureInfo"), sheenRoughnessFactor: 0, sheenRoughnessTexture: null, sheenRoughnessTextureInfo: new tv(this.graph, "sheenRoughnessTextureInfo") });
    }
    getSheenColorFactor() {
      return this.get("sheenColorFactor");
    }
    getSheenColorHex() {
      return Sg.factorToHex(this.getSheenColorFactor());
    }
    setSheenColorFactor(e2) {
      return this.set("sheenColorFactor", e2);
    }
    setSheenColorHex(e2) {
      const t2 = this.getSheenColorFactor().slice();
      return this.set("sheenColorFactor", Sg.hexToFactor(e2, t2));
    }
    getSheenColorTexture() {
      return this.getRef("sheenColorTexture");
    }
    getSheenColorTextureInfo() {
      return this.getRef("sheenColorTexture") ? this.getRef("sheenColorTextureInfo") : null;
    }
    setSheenColorTexture(e2) {
      return this.setRef("sheenColorTexture", e2, { channels: QA | HA | WA });
    }
    getSheenRoughnessFactor() {
      return this.get("sheenRoughnessFactor");
    }
    setSheenRoughnessFactor(e2) {
      return this.set("sheenRoughnessFactor", e2);
    }
    getSheenRoughnessTexture() {
      return this.getRef("sheenRoughnessTexture");
    }
    getSheenRoughnessTextureInfo() {
      return this.getRef("sheenRoughnessTexture") ? this.getRef("sheenRoughnessTextureInfo") : null;
    }
    setSheenRoughnessTexture(e2) {
      return this.setRef("sheenRoughnessTexture", e2, { channels: qA });
    }
  }
  XA.EXTENSION_NAME = "KHR_materials_sheen";
  const YA = "KHR_materials_sheen";
  class KA extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = YA;
    }
    createSheen() {
      return new XA(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, r2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, n2) => {
        if (t3.extensions && t3.extensions.KHR_materials_sheen) {
          const i2 = this.createSheen();
          e2.materials[n2].setExtension(YA, i2);
          const s2 = t3.extensions.KHR_materials_sheen;
          if (void 0 !== s2.sheenColorFactor && i2.setSheenColorFactor(s2.sheenColorFactor), void 0 !== s2.sheenRoughnessFactor && i2.setSheenRoughnessFactor(s2.sheenRoughnessFactor), void 0 !== s2.sheenColorTexture) {
            const t4 = s2.sheenColorTexture;
            i2.setSheenColorTexture(e2.textures[r2[t4.index].source]), e2.setTextureInfo(i2.getSheenColorTextureInfo(), t4);
          }
          if (void 0 !== s2.sheenRoughnessTexture) {
            const t4 = s2.sheenRoughnessTexture;
            i2.setSheenRoughnessTexture(e2.textures[r2[t4.index].source]), e2.setTextureInfo(i2.getSheenRoughnessTextureInfo(), t4);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((r2) => {
        const n2 = r2.getExtension(YA);
        if (n2) {
          const i2 = e2.materialIndexMap.get(r2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions.KHR_materials_sheen = { sheenColorFactor: n2.getSheenColorFactor(), sheenRoughnessFactor: n2.getSheenRoughnessFactor() };
          if (n2.getSheenColorTexture()) {
            const t3 = n2.getSheenColorTexture(), r3 = n2.getSheenColorTextureInfo();
            o2.sheenColorTexture = e2.createTextureInfoDef(t3, r3);
          }
          if (n2.getSheenRoughnessTexture()) {
            const t3 = n2.getSheenRoughnessTexture(), r3 = n2.getSheenRoughnessTextureInfo();
            o2.sheenRoughnessTexture = e2.createTextureInfoDef(t3, r3);
          }
        }
      }), this;
    }
  }
  KA.EXTENSION_NAME = YA;
  const { R: JA, G: ZA, B: $A, A: eb } = _g;
  class tb extends ev {
    init() {
      this.extensionName = "KHR_materials_specular", this.propertyType = "Specular", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { specularFactor: 1, specularTexture: null, specularTextureInfo: new tv(this.graph, "specularTextureInfo"), specularColorFactor: [1, 1, 1], specularColorTexture: null, specularColorTextureInfo: new tv(this.graph, "specularColorTextureInfo") });
    }
    getSpecularFactor() {
      return this.get("specularFactor");
    }
    setSpecularFactor(e2) {
      return this.set("specularFactor", e2);
    }
    getSpecularColorFactor() {
      return this.get("specularColorFactor");
    }
    setSpecularColorFactor(e2) {
      return this.set("specularColorFactor", e2);
    }
    getSpecularColorHex() {
      return Sg.factorToHex(this.getSpecularColorFactor());
    }
    setSpecularColorHex(e2) {
      const t2 = this.getSpecularColorFactor().slice();
      return this.set("specularColorFactor", Sg.hexToFactor(e2, t2));
    }
    getSpecularTexture() {
      return this.getRef("specularTexture");
    }
    getSpecularTextureInfo() {
      return this.getRef("specularTexture") ? this.getRef("specularTextureInfo") : null;
    }
    setSpecularTexture(e2) {
      return this.setRef("specularTexture", e2, { channels: eb });
    }
    getSpecularColorTexture() {
      return this.getRef("specularColorTexture");
    }
    getSpecularColorTextureInfo() {
      return this.getRef("specularColorTexture") ? this.getRef("specularColorTextureInfo") : null;
    }
    setSpecularColorTexture(e2) {
      return this.setRef("specularColorTexture", e2, { channels: JA | ZA | $A });
    }
  }
  tb.EXTENSION_NAME = "KHR_materials_specular";
  const rb = "KHR_materials_specular";
  class nb extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = rb;
    }
    createSpecular() {
      return new tb(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, r2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, n2) => {
        if (t3.extensions && t3.extensions[rb]) {
          const i2 = this.createSpecular();
          e2.materials[n2].setExtension(rb, i2);
          const s2 = t3.extensions[rb];
          if (void 0 !== s2.specularFactor && i2.setSpecularFactor(s2.specularFactor), void 0 !== s2.specularColorFactor && i2.setSpecularColorFactor(s2.specularColorFactor), void 0 !== s2.specularTexture) {
            const t4 = s2.specularTexture;
            i2.setSpecularTexture(e2.textures[r2[t4.index].source]), e2.setTextureInfo(i2.getSpecularTextureInfo(), t4);
          }
          if (void 0 !== s2.specularColorTexture) {
            const t4 = s2.specularColorTexture;
            i2.setSpecularColorTexture(e2.textures[r2[t4.index].source]), e2.setTextureInfo(i2.getSpecularColorTextureInfo(), t4);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((r2) => {
        const n2 = r2.getExtension(rb);
        if (n2) {
          const i2 = e2.materialIndexMap.get(r2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions[rb] = {};
          if (1 !== n2.getSpecularFactor() && (o2.specularFactor = n2.getSpecularFactor()), Bg.eq(n2.getSpecularColorFactor(), [1, 1, 1]) || (o2.specularColorFactor = n2.getSpecularColorFactor()), n2.getSpecularTexture()) {
            const t3 = n2.getSpecularTexture(), r3 = n2.getSpecularTextureInfo();
            o2.specularTexture = e2.createTextureInfoDef(t3, r3);
          }
          if (n2.getSpecularColorTexture()) {
            const t3 = n2.getSpecularColorTexture(), r3 = n2.getSpecularColorTextureInfo();
            o2.specularColorTexture = e2.createTextureInfoDef(t3, r3);
          }
        }
      }), this;
    }
  }
  nb.EXTENSION_NAME = rb;
  const { R: ib } = _g;
  class sb extends ev {
    init() {
      this.extensionName = "KHR_materials_transmission", this.propertyType = "Transmission", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { transmissionFactor: 0, transmissionTexture: null, transmissionTextureInfo: new tv(this.graph, "transmissionTextureInfo") });
    }
    getTransmissionFactor() {
      return this.get("transmissionFactor");
    }
    setTransmissionFactor(e2) {
      return this.set("transmissionFactor", e2);
    }
    getTransmissionTexture() {
      return this.getRef("transmissionTexture");
    }
    getTransmissionTextureInfo() {
      return this.getRef("transmissionTexture") ? this.getRef("transmissionTextureInfo") : null;
    }
    setTransmissionTexture(e2) {
      return this.setRef("transmissionTexture", e2, { channels: ib });
    }
  }
  sb.EXTENSION_NAME = "KHR_materials_transmission";
  const ob = "KHR_materials_transmission";
  class ab extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = ob;
    }
    createTransmission() {
      return new sb(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, r2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, n2) => {
        if (t3.extensions && t3.extensions[ob]) {
          const i2 = this.createTransmission();
          e2.materials[n2].setExtension(ob, i2);
          const s2 = t3.extensions[ob];
          if (void 0 !== s2.transmissionFactor && i2.setTransmissionFactor(s2.transmissionFactor), void 0 !== s2.transmissionTexture) {
            const t4 = s2.transmissionTexture;
            i2.setTransmissionTexture(e2.textures[r2[t4.index].source]), e2.setTextureInfo(i2.getTransmissionTextureInfo(), t4);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((r2) => {
        const n2 = r2.getExtension(ob);
        if (n2) {
          const i2 = e2.materialIndexMap.get(r2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions[ob] = { transmissionFactor: n2.getTransmissionFactor() };
          if (n2.getTransmissionTexture()) {
            const t3 = n2.getTransmissionTexture(), r3 = n2.getTransmissionTextureInfo();
            o2.transmissionTexture = e2.createTextureInfoDef(t3, r3);
          }
        }
      }), this;
    }
  }
  ab.EXTENSION_NAME = ob;
  class lb extends ev {
    init() {
      this.extensionName = "KHR_materials_unlit", this.propertyType = "Unlit", this.parentTypes = [dg.MATERIAL];
    }
  }
  lb.EXTENSION_NAME = "KHR_materials_unlit";
  const cb = "KHR_materials_unlit";
  class ub extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = cb;
    }
    createUnlit() {
      return new lb(this.document.getGraph());
    }
    read(e2) {
      return (e2.jsonDoc.json.materials || []).forEach((t2, r2) => {
        t2.extensions && t2.extensions.KHR_materials_unlit && e2.materials[r2].setExtension(cb, this.createUnlit());
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((r2) => {
        if (r2.getExtension(cb)) {
          const n2 = e2.materialIndexMap.get(r2), i2 = t2.json.materials[n2];
          i2.extensions = i2.extensions || {}, i2.extensions.KHR_materials_unlit = {};
        }
      }), this;
    }
  }
  ub.EXTENSION_NAME = cb;
  class hb extends ev {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "Mapping", this.parentTypes = ["MappingList"];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { material: null, variants: [] });
    }
    getMaterial() {
      return this.getRef("material");
    }
    setMaterial(e2) {
      return this.setRef("material", e2);
    }
    addVariant(e2) {
      return this.addRef("variants", e2);
    }
    removeVariant(e2) {
      return this.removeRef("variants", e2);
    }
    listVariants() {
      return this.listRefs("variants");
    }
  }
  hb.EXTENSION_NAME = "KHR_materials_variants";
  class pb extends ev {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "MappingList", this.parentTypes = [dg.PRIMITIVE];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { mappings: [] });
    }
    addMapping(e2) {
      return this.addRef("mappings", e2);
    }
    removeMapping(e2) {
      return this.removeRef("mappings", e2);
    }
    listMappings() {
      return this.listRefs("mappings");
    }
  }
  pb.EXTENSION_NAME = "KHR_materials_variants";
  class db extends ev {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "Variant", this.parentTypes = ["MappingList"];
    }
  }
  db.EXTENSION_NAME = "KHR_materials_variants";
  const fb = "KHR_materials_variants";
  class mb extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = fb;
    }
    createMappingList() {
      return new pb(this.document.getGraph());
    }
    createVariant(e2 = "") {
      return new db(this.document.getGraph(), e2);
    }
    createMapping() {
      return new hb(this.document.getGraph());
    }
    listVariants() {
      return Array.from(this.properties).filter((e2) => e2 instanceof db);
    }
    read(e2) {
      const t2 = e2.jsonDoc;
      if (!t2.json.extensions || !t2.json.extensions[fb])
        return this;
      const r2 = (t2.json.extensions[fb].variants || []).map((e3) => this.createVariant().setName(e3.name || ""));
      return (t2.json.meshes || []).forEach((t3, n2) => {
        const i2 = e2.meshes[n2];
        (t3.primitives || []).forEach((t4, n3) => {
          if (!t4.extensions || !t4.extensions[fb])
            return;
          const s2 = this.createMappingList(), o2 = t4.extensions[fb];
          for (const t5 of o2.mappings) {
            const n4 = this.createMapping();
            void 0 !== t5.material && n4.setMaterial(e2.materials[t5.material]);
            for (const e3 of t5.variants || [])
              n4.addVariant(r2[e3]);
            s2.addMapping(n4);
          }
          i2.listPrimitives()[n3].setExtension(fb, s2);
        });
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc, r2 = this.listVariants();
      if (!r2.length)
        return this;
      const n2 = [], i2 = /* @__PURE__ */ new Map();
      for (const t3 of r2)
        i2.set(t3, n2.length), n2.push(e2.createPropertyDef(t3));
      for (const t3 of this.document.getRoot().listMeshes()) {
        const r3 = e2.meshIndexMap.get(t3);
        t3.listPrimitives().forEach((t4, n3) => {
          const s2 = t4.getExtension(fb);
          if (!s2)
            return;
          const o2 = e2.jsonDoc.json.meshes[r3].primitives[n3], a2 = s2.listMappings().map((t5) => {
            const r4 = e2.createPropertyDef(t5), n4 = t5.getMaterial();
            return n4 && (r4.material = e2.materialIndexMap.get(n4)), r4.variants = t5.listVariants().map((e3) => i2.get(e3)), r4;
          });
          o2.extensions = o2.extensions || {}, o2.extensions[fb] = { mappings: a2 };
        });
      }
      return t2.json.extensions = t2.json.extensions || {}, t2.json.extensions[fb] = { variants: n2 }, this;
    }
  }
  mb.EXTENSION_NAME = fb;
  const { G: _b } = _g;
  class gb extends ev {
    init() {
      this.extensionName = "KHR_materials_volume", this.propertyType = "Volume", this.parentTypes = [dg.MATERIAL];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { thicknessFactor: 0, thicknessTexture: null, thicknessTextureInfo: new tv(this.graph, "thicknessTexture"), attenuationDistance: 1 / 0, attenuationColor: [1, 1, 1] });
    }
    getThicknessFactor() {
      return this.get("thicknessFactor");
    }
    setThicknessFactor(e2) {
      return this.set("thicknessFactor", e2);
    }
    getThicknessTexture() {
      return this.getRef("thicknessTexture");
    }
    getThicknessTextureInfo() {
      return this.getRef("thicknessTexture") ? this.getRef("thicknessTextureInfo") : null;
    }
    setThicknessTexture(e2) {
      return this.setRef("thicknessTexture", e2, { channels: _b });
    }
    getAttenuationDistance() {
      return this.get("attenuationDistance");
    }
    setAttenuationDistance(e2) {
      return this.set("attenuationDistance", e2);
    }
    getAttenuationColor() {
      return this.get("attenuationColor");
    }
    setAttenuationColor(e2) {
      return this.set("attenuationColor", e2);
    }
    getAttenuationColorHex() {
      return Sg.factorToHex(this.getAttenuationColor());
    }
    setAttenuationColorHex(e2) {
      const t2 = this.getAttenuationColor().slice();
      return this.set("attenuationColor", Sg.hexToFactor(e2, t2));
    }
  }
  gb.EXTENSION_NAME = "KHR_materials_volume";
  const vb = "KHR_materials_volume";
  class Ab extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = vb;
    }
    createVolume() {
      return new gb(this.document.getGraph());
    }
    read(e2) {
      const t2 = e2.jsonDoc, r2 = t2.json.textures || [];
      return (t2.json.materials || []).forEach((t3, n2) => {
        if (t3.extensions && t3.extensions.KHR_materials_volume) {
          const i2 = this.createVolume();
          e2.materials[n2].setExtension(vb, i2);
          const s2 = t3.extensions.KHR_materials_volume;
          if (void 0 !== s2.thicknessFactor && i2.setThicknessFactor(s2.thicknessFactor), void 0 !== s2.attenuationDistance && i2.setAttenuationDistance(s2.attenuationDistance), void 0 !== s2.attenuationColor && i2.setAttenuationColor(s2.attenuationColor), void 0 !== s2.thicknessTexture) {
            const t4 = s2.thicknessTexture;
            i2.setThicknessTexture(e2.textures[r2[t4.index].source]), e2.setTextureInfo(i2.getThicknessTextureInfo(), t4);
          }
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((r2) => {
        const n2 = r2.getExtension(vb);
        if (n2) {
          const i2 = e2.materialIndexMap.get(r2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = s2.extensions.KHR_materials_volume = {};
          if (n2.getThicknessFactor() > 0 && (o2.thicknessFactor = n2.getThicknessFactor()), Number.isFinite(n2.getAttenuationDistance()) && (o2.attenuationDistance = n2.getAttenuationDistance()), Bg.eq(n2.getAttenuationColor(), [1, 1, 1]) || (o2.attenuationColor = n2.getAttenuationColor()), n2.getThicknessTexture()) {
            const t3 = n2.getThicknessTexture(), r3 = n2.getThicknessTextureInfo();
            o2.thicknessTexture = e2.createTextureInfoDef(t3, r3);
          }
        }
      }), this;
    }
  }
  Ab.EXTENSION_NAME = vb;
  const bb = "KHR_mesh_quantization";
  class yb extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = bb;
    }
    read(e2) {
      return this;
    }
    write(e2) {
      return this;
    }
  }
  yb.EXTENSION_NAME = bb;
  const xb = "KHR_texture_basisu";
  class wb {
    match(e2) {
      return 171 === e2[0] && 75 === e2[1] && 84 === e2[2] && 88 === e2[3] && 32 === e2[4] && 50 === e2[5] && 48 === e2[6] && 187 === e2[7] && 13 === e2[8] && 10 === e2[9] && 26 === e2[10] && 10 === e2[11];
    }
    getSize(e2) {
      const t2 = Pv(e2);
      return [t2.pixelWidth, t2.pixelHeight];
    }
    getChannels(e2) {
      const t2 = Pv(e2).dataFormatDescriptor[0];
      if (163 === t2.colorModel)
        return 2 === t2.samples.length && 15 == (15 & t2.samples[1].channelType) ? 4 : 3;
      if (166 === t2.colorModel)
        return 3 == (15 & t2.samples[0].channelType) ? 4 : 3;
      throw new Error(`Unexpected KTX2 colorModel, "${t2.colorModel}".`);
    }
    getGPUByteLength(e2) {
      const t2 = Pv(e2), r2 = this.getChannels(e2) > 3;
      let n2 = 0;
      for (let e3 = 0; e3 < t2.levels.length; e3++) {
        const i2 = t2.levels[e3];
        n2 += i2.uncompressedByteLength ? i2.uncompressedByteLength : Math.max(1, Math.floor(t2.pixelWidth / Math.pow(2, e3))) / 4 * (Math.max(1, Math.floor(t2.pixelHeight / Math.pow(2, e3))) / 4) * (r2 ? 16 : 8);
      }
      return n2;
    }
  }
  class Eb extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = xb, this.prereadTypes = [dg.TEXTURE];
    }
    static register() {
      Mg.registerFormat("image/ktx2", new wb());
    }
    preread(e2) {
      return e2.jsonDoc.json.textures.forEach((e3) => {
        e3.extensions && e3.extensions.KHR_texture_basisu && (e3.source = e3.extensions.KHR_texture_basisu.source);
      }), this;
    }
    read(e2) {
      return this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listTextures().forEach((r2) => {
        if ("image/ktx2" === r2.getMimeType()) {
          const n2 = e2.imageIndexMap.get(r2);
          t2.json.textures.forEach((e3) => {
            e3.source === n2 && (e3.extensions = e3.extensions || {}, e3.extensions.KHR_texture_basisu = { source: e3.source }, delete e3.source);
          });
        }
      }), this;
    }
  }
  Eb.EXTENSION_NAME = xb;
  class Sb extends ev {
    init() {
      this.extensionName = "KHR_texture_transform", this.propertyType = "Transform", this.parentTypes = [dg.TEXTURE_INFO];
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { offset: [0, 0], rotation: 0, scale: [1, 1], texCoord: null });
    }
    getOffset() {
      return this.get("offset");
    }
    setOffset(e2) {
      return this.set("offset", e2);
    }
    getRotation() {
      return this.get("rotation");
    }
    setRotation(e2) {
      return this.set("rotation", e2);
    }
    getScale() {
      return this.get("scale");
    }
    setScale(e2) {
      return this.set("scale", e2);
    }
    getTexCoord() {
      return this.get("texCoord");
    }
    setTexCoord(e2) {
      return this.set("texCoord", e2);
    }
  }
  Sb.EXTENSION_NAME = "KHR_texture_transform";
  const Cb = "KHR_texture_transform";
  class Mb extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = Cb;
    }
    createTransform() {
      return new Sb(this.document.getGraph());
    }
    read(e2) {
      for (const [t2, r2] of Array.from(e2.textureInfos.entries())) {
        if (!r2.extensions || !r2.extensions.KHR_texture_transform)
          continue;
        const e3 = this.createTransform(), n2 = r2.extensions.KHR_texture_transform;
        void 0 !== n2.offset && e3.setOffset(n2.offset), void 0 !== n2.rotation && e3.setRotation(n2.rotation), void 0 !== n2.scale && e3.setScale(n2.scale), void 0 !== n2.texCoord && e3.setTexCoord(n2.texCoord), t2.setExtension(Cb, e3);
      }
      return this;
    }
    write(e2) {
      const t2 = Array.from(e2.textureInfoDefMap.entries());
      for (const [e3, r2] of t2) {
        const t3 = e3.getExtension(Cb);
        if (!t3)
          continue;
        r2.extensions = r2.extensions || {};
        const n2 = {}, i2 = Bg.eq;
        i2(t3.getOffset(), [0, 0]) || (n2.offset = t3.getOffset()), 0 !== t3.getRotation() && (n2.rotation = t3.getRotation()), i2(t3.getScale(), [1, 1]) || (n2.scale = t3.getScale()), null != t3.getTexCoord() && (n2.texCoord = t3.getTexCoord()), r2.extensions.KHR_texture_transform = n2;
      }
      return this;
    }
  }
  Mb.EXTENSION_NAME = Cb;
  const Tb = [dg.ROOT, dg.SCENE, dg.NODE, dg.MESH, dg.MATERIAL, dg.TEXTURE, dg.ANIMATION];
  class Ib extends ev {
    init() {
      this.extensionName = "KHR_xmp_json_ld", this.propertyType = "Packet", this.parentTypes = Tb;
    }
    getDefaults() {
      return Object.assign(super.getDefaults(), { context: {}, properties: {} });
    }
    getContext() {
      return this.get("context");
    }
    setContext(e2) {
      return this.set("context", Lv({}, e2));
    }
    listProperties() {
      return Object.keys(this.get("properties"));
    }
    getProperty(e2) {
      const t2 = this.get("properties");
      return e2 in t2 ? t2[e2] : null;
    }
    setProperty(e2, t2) {
      this._assertContext(e2);
      const r2 = Lv({}, this.get("properties"));
      return t2 ? r2[e2] = t2 : delete r2[e2], this.set("properties", r2);
    }
    toJSONLD() {
      return Lv({ "@context": kb(this.get("context")) }, kb(this.get("properties")));
    }
    fromJSONLD(e2) {
      const t2 = (e2 = kb(e2))["@context"];
      return t2 && this.set("context", t2), delete e2["@context"], this.set("properties", e2);
    }
    _assertContext(e2) {
      if (!(e2.split(":")[0] in this.get("context")))
        throw new Error(`KHR_xmp_json_ld: Missing context for term, "${e2}".`);
    }
  }
  function kb(e2) {
    return JSON.parse(JSON.stringify(e2));
  }
  Ib.EXTENSION_NAME = "KHR_xmp_json_ld";
  const Db = "KHR_xmp_json_ld";
  class Pb extends gv {
    constructor(...e2) {
      super(...e2), this.extensionName = Db;
    }
    createPacket() {
      return new Ib(this.document.getGraph());
    }
    listPackets() {
      return Array.from(this.properties);
    }
    read(e2) {
      var t2;
      const r2 = null == (t2 = e2.jsonDoc.json.extensions) ? void 0 : t2.KHR_xmp_json_ld;
      if (!r2 || !r2.packets)
        return this;
      const n2 = e2.jsonDoc.json, i2 = this.document.getRoot(), s2 = r2.packets.map((e3) => this.createPacket().fromJSONLD(e3)), o2 = [[n2.asset], n2.scenes, n2.nodes, n2.meshes, n2.materials, n2.images, n2.animations], a2 = [[i2], i2.listScenes(), i2.listNodes(), i2.listMeshes(), i2.listMaterials(), i2.listTextures(), i2.listAnimations()];
      for (let e3 = 0; e3 < o2.length; e3++) {
        const t3 = o2[e3] || [];
        for (let r3 = 0; r3 < t3.length; r3++) {
          const n3 = t3[r3];
          n3.extensions && n3.extensions.KHR_xmp_json_ld && a2[e3][r3].setExtension(Db, s2[n3.extensions.KHR_xmp_json_ld.packet]);
        }
      }
      return this;
    }
    write(e2) {
      const { json: t2 } = e2.jsonDoc, r2 = [];
      for (const n2 of this.properties) {
        r2.push(n2.toJSONLD());
        for (const i2 of n2.listParents()) {
          let n3;
          switch (i2.propertyType) {
            case dg.ROOT:
              n3 = t2.asset;
              break;
            case dg.SCENE:
              n3 = t2.scenes[e2.sceneIndexMap.get(i2)];
              break;
            case dg.NODE:
              n3 = t2.nodes[e2.nodeIndexMap.get(i2)];
              break;
            case dg.MESH:
              n3 = t2.meshes[e2.meshIndexMap.get(i2)];
              break;
            case dg.MATERIAL:
              n3 = t2.materials[e2.materialIndexMap.get(i2)];
              break;
            case dg.TEXTURE:
              n3 = t2.images[e2.imageIndexMap.get(i2)];
              break;
            case dg.ANIMATION:
              n3 = t2.animations[e2.animationIndexMap.get(i2)];
              break;
            default:
              n3 = null, this.document.getLogger().warn(`[KHR_xmp_json_ld]: Unsupported parent property, "${i2.propertyType}"`);
          }
          n3 && (n3.extensions = n3.extensions || {}, n3.extensions.KHR_xmp_json_ld = { packet: r2.length - 1 });
        }
      }
      return r2.length > 0 && (t2.extensions = t2.extensions || {}, t2.extensions.KHR_xmp_json_ld = { packets: r2 }), this;
    }
  }
  Pb.EXTENSION_NAME = Db;
  const Bb = [mA, AA, SA, TA, DA, OA, VA, nb, KA, ab, ub, mb, Ab, yb, Eb, Mb, Pb];
  let Rb = class extends Gt {
    constructor(e2, t2, r2) {
      super(e2, t2, null != r2 ? r2 : new Lb(), new Ae(0, 0, 0), 1), this.enabled = true, this._firstCall = true;
    }
    render(e2, t2, r2, n2, i2) {
      this.enabled && super.render(e2, t2, r2, n2, i2);
    }
  };
  Rb = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  }([lt("High precision Normal Buffer")], Rb);
  class Lb extends n.RSm {
    constructor() {
      super();
    }
    onBeforeRender(e2, t2, r2, i2, s2) {
      var o2, a2;
      let l2 = s2.material;
      Array.isArray(l2) && (l2 = l2[0]), this.normalMap = null !== (o2 = null == l2 ? void 0 : l2.normalMap) && void 0 !== o2 ? o2 : null, this.needsUpdate = true, this.side = null !== (a2 = l2.side) && void 0 !== a2 ? a2 : n.ehD;
    }
  }
  class Ob extends io {
    constructor(e2 = true) {
      super(), this.passId = "normalBuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this.enabled = e2;
    }
    passCtor(e2) {
      this._normalTarget = e2.renderer.createTarget({ depthBuffer: true, type: n.cLu, minFilter: n.TyD, magFilter: n.TyD, generateMipmaps: false }), this._normalTarget.texture.name = "normalBuffer", this._normalTarget.texture.generateMipmaps = false;
      const t2 = this._normalTarget, r2 = /* @__PURE__ */ new Set(), i2 = /* @__PURE__ */ new Set();
      return new class extends Rb {
        render(e3, n2, s2, o2, a2) {
          const l2 = e3.getRenderTarget(), c2 = e3.getActiveCubeFace(), u2 = e3.getActiveMipmapLevel();
          this.scene && (this.scene.traverse(({ material: e4 }) => {
            e4 && ((e4.transparent && e4.userData.renderToDepth || !e4.transparent && 0 === e4.transmission && false === e4.userData.renderToDepth) && (r2.add(e4), e4.transparent = !e4.transparent), Math.abs(e4.transmission || 0) > 0 && e4.userData.renderToDepth && (i2.add([e4, e4.transmission]), e4.transmission = 0));
          }), W(e3, { shadowMapRender: false, backgroundRender: false, opaqueRender: true, transparentRender: false, transmissionRender: false, mainRenderPass: false }, () => super.render(e3, n2, t2, o2, a2)), r2.forEach((e4) => e4.transparent = !e4.transparent), r2.clear(), i2.forEach(([e4, t3]) => e4.transmission = t3), i2.clear(), e3.setRenderTarget(l2, c2, u2));
        }
      }();
    }
    _update(e2) {
      if (!super._update(e2))
        return false;
      const t2 = this.pass.passObject;
      return t2.scene = e2.scene.modelObject, t2.camera = e2.scene.activeCamera.cameraObject, true;
    }
    getNormalBuffer() {
      return this._normalTarget;
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      var t2, r2;
      return e2.renderer.disposeTarget(null === (r2 = null === (t2 = this._normalTarget) || void 0 === t2 ? void 0 : t2.dispose) || void 0 === r2 ? void 0 : r2.call(t2)), super.onRemove(e2);
    }
    updateShaderProperties(e2) {
      var t2, r2;
      return e2.uniforms.tNormalBuffer ? e2.uniforms.tNormalBuffer.value = this.enabled && null !== (r2 = null === (t2 = this.getNormalBuffer()) || void 0 === t2 ? void 0 : t2.texture) && void 0 !== r2 ? r2 : null : console.warn("BaseRenderer: no uniform: tNormalBuffer"), this;
    }
    get uiConfig() {
      var e2;
      return null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject.uiConfig;
    }
  }
  Ob.PluginType = "NormalBufferPlugin";
  function Fb(e2) {
    const t2 = null == e2 ? void 0 : e2.userData;
    if (!t2)
      return false;
    t2._ssBevel || (t2._ssBevel = {});
    const r2 = t2._ssBevel;
    return r2.hasSSBevel = true, void 0 === r2.radius && (r2.radius = 0), e2.isMaterial && (e2.needsUpdate = true), true;
  }
  let Ub = class extends zt {
    constructor(e2, t2, r2, i2) {
      super({ defines: { NUM_SAMPLES: 16 }, uniforms: { tNormalDepth: { value: null }, tNormalBuffer: { value: null }, tGBufferFlags: { value: null }, edgeMaskBuffer: { value: null }, screenSize: { value: new n.FM8() }, radius: { value: 1 }, samples: { value: null }, frameCount: { value: 0 }, cameraPositionWorld: { value: new n.Pa4(1, 1, 1) } }, vertexShader: Io, fragmentShader: `

            ${r2}

            ${Po}

            uniform sampler2D tNormalBuffer;uniform sampler2D edgeMaskBuffer;uniform vec2 screenSize;const float depthStep=0.02;uniform vec2 samples[NUM_SAMPLES];uniform vec3 cameraPositionWorld;varying vec2 vUv;
#include <common>
vec3 smoothNormal(){vec2 uv=gl_FragCoord.xy/screenSize;vec4 texel=texture2D(tNormalDepth,uv);vec4 edgeMask=texture2D(edgeMaskBuffer,uv);vec3 avgNormal=2.*texture2D(tNormalBuffer,uv).rgb-1.;float depth=pow(unpack16(texel.xy),2.);vec2 invScreenSize=vec2(1.)/screenSize;vec4 mask=texture2D(tGBufferFlags,uv);float weightSum=0.;float radius=mask.g*255.*2.;float randomAngle=6.2*random(frameCount*0.1);float theta=randomAngle;float snTheta=sin(theta);float csTheta=cos(theta);mat2 randomRotationMatrix=mat2(csTheta,snTheta,-snTheta,csTheta);float d_=dot(cameraPositionWorld,cameraPositionWorld);float radiusModifier=clamp(1./(1.+pow(d_,0.5)),0.,1.);for(int i=0;i<5;i++){float x=float(i)-2.;for(int j=0;j<5;j++){float y=float(j)-2.;vec2 offset=randomRotationMatrix*vec2(x,y)*radius*radiusModifier*invScreenSize;vec4 texel=texture2D(tNormalDepth,uv+offset);float offsetDepth=pow(unpack16(texel.xy),2.);float depthWeight=abs(offsetDepth-depth);depthWeight=(1.-step(depthStep,depthWeight));vec3 offsetNormal=2.*texture2D(tNormalBuffer,uv+offset).rgb-1.;if(dot(offsetNormal,offsetNormal)>0.){avgNormal+=offsetNormal*depthWeight;}}}return normalize(avgNormal);}void main(){vec2 uv=gl_FragCoord.xy/screenSize;vec4 edgeMask=texture2D(edgeMaskBuffer,uv);vec3 normal=vec3(0.);if(edgeMask.x>0.){normal=smoothNormal();}else{normal=2.*texture2D(tNormalBuffer,uv).rgb-1.;}gl_FragColor=vec4(vec3(0.5*normal+0.5),1.);}
            
            ` }, "tDiffuse"), this.uiConfig = void 0, this.materialExtension = { shaderExtender: (e3, t3, r3) => {
        var n2, i3;
        this.enabled && (null === (i3 = null === (n2 = t3.materialObject.userData) || void 0 === n2 ? void 0 : n2._ssBevel) || void 0 === i3 ? void 0 : i3.hasSSBevel) && (e3.fragmentShader = qt(e3.fragmentShader, "#include <normal_fragment_maps>", " \n                normal = 2. * texture2D(tSSBevelMap, viewToScreen(vViewPosition.xyz).xy).rgb - 1.;\n                normal = normalize(normal);\n                //geometryNormal = normal;\n            "));
      }, onObjectRender: (e3, t3, r3) => {
        var n2, i3;
        if (!this.enabled || !(null === (i3 = null === (n2 = t3.materialObject.userData) || void 0 === n2 ? void 0 : n2._ssBevel) || void 0 === i3 ? void 0 : i3.hasSSBevel))
          return;
        const s2 = t3.materialObject, o2 = this._target.texture;
        this.materialExtension.extraUniforms.tSSBevelMap.value !== o2 && (this.materialExtension.extraUniforms.tSSBevelMap.value = o2, s2.needsUpdate = true);
      }, getUiConfig: (e3) => {
        const t3 = { type: "folder", label: "SSBevel (Dev)", children: [{ type: "checkbox", label: "Enabled", get value() {
          var t4;
          return (null === (t4 = e3.materialObject.userData._ssBevel) || void 0 === t4 ? void 0 : t4.hasSSBevel) || false;
        }, set value(r3) {
          var n2, i3;
          r3 !== (null === (n2 = e3.materialObject.userData._ssBevel) || void 0 === n2 ? void 0 : n2.hasSSBevel) && (r3 ? Fb(e3.materialObject) || alert("Cannot add screen space bevel.") : (e3.materialObject.userData._ssBevel.hasSSBevel = false, e3.materialObject.needsUpdate = true), null === (i3 = t3.uiRefresh) || void 0 === i3 || i3.call(t3, "postFrame", true));
        }, onChange: this.setDirty }, () => ({ type: "slider", bounds: [0, 8], label: "radius", hidden: () => {
          var t4;
          return !(null === (t4 = e3.materialObject.userData._ssBevel) || void 0 === t4 ? void 0 : t4.hasSSBevel);
        }, property: [e3.materialObject.userData._ssBevel, "radius"], onChange: this.setDirty })] };
        return t3;
      }, parsFragmentSnippet: (e3, t3) => {
        var r3, n2;
        return this.enabled && (null === (n2 = null === (r3 = null == t3 ? void 0 : t3.materialObject.userData) || void 0 === r3 ? void 0 : r3._ssBevel) || void 0 === n2 ? void 0 : n2.hasSSBevel) ? w`
            uniform sampler2D tSSBevelMap;
            ${Oo}
            ` : "";
      }, extraUniforms: { tSSBevelMap: { value: null } }, computeCacheKey: (e3) => {
        var t3, r3;
        return (this.enabled ? "1" : "0") + ((null === (r3 = null === (t3 = e3.materialObject.userData) || void 0 === t3 ? void 0 : t3._ssBevel) || void 0 === r3 ? void 0 : r3.hasSSBevel) ? "1" : "0");
      }, isCompatible: (e3) => e3.isMeshStandardMaterial2 }, this._target = t2, this.needsSwap = false, this.clear = true, this._viewerApp = i2, this._edgeMaterial = new Ut({ uniforms: { tNormalDepth: { value: null }, tNormalBuffer: { value: null }, tGBufferFlags: { value: null }, screenSize: { value: null }, radius: { value: 10 }, cameraNearFar: { value: new n.FM8(1, 1) }, cameraPositionWorld: { value: new n.Pa4(1, 1, 1) } }, vertexShader: Io, fragmentShader: "uniform vec2 screenSize;uniform sampler2D tNormalDepth;uniform sampler2D tNormalBuffer;uniform sampler2D tGBufferFlags;uniform float radius;uniform vec2 cameraNearFar;uniform vec3 cameraPositionWorld;const float depthStep=0.2;const float normalThreshold=0.9;float unpack16(vec2 value){return(value.x*0.996108949416342426275150501169264316558837890625+value.y*0.00389105058365758760263730664519243873655796051025390625);}vec3 unpackNormal(vec2 enc){vec2 fenc=enc*4.-2.;float f=dot(fenc,fenc);float g=sqrt(1.-f/4.);return vec3(fenc*g,1.-f/2.);}void lookupNormalDepth(out float depth,out vec3 normal,vec2 off){vec2 uv=(gl_FragCoord.st+off)/screenSize;vec4 texel=texture2D(tNormalDepth,uv);depth=mix(cameraNearFar.x,cameraNearFar.y,pow(unpack16(texel.xy),2.));normal=2.*texture2D(tNormalBuffer,uv).rgb-1.;}float getBorderWeight(){float depth1,depth2,depth3,depth4;vec3 normal1,normal2,normal3,normal4;float d_=dot(cameraPositionWorld,cameraPositionWorld);float radiusModifier=clamp(3./(1.+pow(d_,0.5)),0.,1.);float modRad=radius;lookupNormalDepth(depth1,normal1,vec2(0.,modRad));lookupNormalDepth(depth2,normal2,vec2(0.,-modRad));lookupNormalDepth(depth3,normal3,vec2(modRad,0.));lookupNormalDepth(depth4,normal4,vec2(-modRad,0.));vec2 uv=(gl_FragCoord.st)/screenSize;float mask=step(0.0001,texture2D(tGBufferFlags,uv).g);float mask1=texture2D(tGBufferFlags,uv+vec2(0.,modRad)/screenSize).b*255.;float mask2=texture2D(tGBufferFlags,uv+vec2(0.,-modRad)/screenSize).b*255.;float mask3=texture2D(tGBufferFlags,uv+vec2(modRad,0.)/screenSize).b*255.;float mask4=texture2D(tGBufferFlags,uv+vec2(-modRad,0.)/screenSize).b*255.;float maskWeight=max(abs(mask1-mask2),abs(mask3-mask4))*255.;maskWeight=(step(maskWeight,0.01));float a1=dot(normal1,normal2);float a2=dot(normal3,normal4);float normalWeight=min(abs(a1),abs(a2));normalWeight=1.-step(normalThreshold,normalWeight);float depthWeight=max(abs(depth1-depth2),abs(depth3-depth4));depthWeight=(step(depthWeight,depthStep));return normalWeight*depthWeight*maskWeight*mask;}void main(){float weight=getBorderWeight();vec2 uv=gl_FragCoord.st/screenSize;vec4 texel=texture2D(tNormalDepth,uv);float depth=pow(unpack16(texel.xy),2.);vec3 outColor=vec3(0.);if(depth>0.999){weight=0.;}else{outColor=vec3(weight);}gl_FragColor=vec4(outColor,1.);}" }), this._separableBlurMaterial = new Ut({ defines: { KERNEL_RADIUS: 3, SIGMA: 3 }, uniforms: { colorTexture: { value: null }, maskTexture: { value: null }, texSize: { value: new n.FM8(0.5, 0.5) }, direction: { value: new n.FM8(0.5, 0.5) } }, vertexShader: Io, fragmentShader: "varying vec2 vUv;uniform sampler2D colorTexture;uniform sampler2D maskTexture;uniform vec2 texSize;uniform vec2 direction;float gaussianPdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}void main(){vec2 invSize=1./texSize;float fSigma=float(SIGMA);float weightSum=gaussianPdf(0.,fSigma);vec4 mask=texture2D(maskTexture,vUv);vec3 diffuseSum=texture2D(colorTexture,vUv).rgb*weightSum;for(int i=1;i<KERNEL_RADIUS;i++){float x=float(i);float w=gaussianPdf(x,fSigma);vec2 uvOffset=direction*invSize*x;vec3 sample1=texture2D(colorTexture,vUv+uvOffset).rgb;vec3 sample2=texture2D(colorTexture,vUv-uvOffset).rgb;diffuseSum+=(sample1+sample2)*w;weightSum+=2.*w;}gl_FragColor=vec4(diffuseSum/weightSum,1.);}" });
    }
    render(e2, t2, r2, i2, s2) {
      var o2, a2;
      if (!this.enabled)
        return;
      const l2 = e2.baseRenderer, c2 = { minFilter: n.wem, magFilter: n.wem, isAntialiased: false, format: n.wk1, depthBuffer: false, generateMipmaps: false }, u2 = l2.getTempTarget(c2);
      this._renderEdges(l2, u2), this._blurEdges(l2, u2), this._viewerApp.scene.activeCamera.updateShaderProperties(this.material), null === (o2 = this._viewerApp.getPlugin(lo)) || void 0 === o2 || o2.updateShaderProperties(this.material), null === (a2 = this._viewerApp.getPlugin(Ob)) || void 0 === a2 || a2.updateShaderProperties(this.material), this._viewerApp.renderer.updateShaderProperties(this.material), this.uniforms.edgeMaskBuffer.value = u2.texture, super.render(e2, this._target, u2, i2, s2), l2.releaseTempTarget(u2);
    }
    _initsamples() {
      const e2 = [], t2 = 1 / 8;
      return e2.push(new n.FM8(-8, 0).multiplyScalar(t2)), e2.push(new n.FM8(-6, -4).multiplyScalar(t2)), e2.push(new n.FM8(-3, -2).multiplyScalar(t2)), e2.push(new n.FM8(-2, -6).multiplyScalar(t2)), e2.push(new n.FM8(1, -1).multiplyScalar(t2)), e2.push(new n.FM8(2, -5).multiplyScalar(t2)), e2.push(new n.FM8(6, -7).multiplyScalar(t2)), e2.push(new n.FM8(5, -3).multiplyScalar(t2)), e2.push(new n.FM8(4, 1).multiplyScalar(t2)), e2.push(new n.FM8(7, 4).multiplyScalar(t2)), e2.push(new n.FM8(3, 5).multiplyScalar(t2)), e2.push(new n.FM8(0, 7).multiplyScalar(t2)), e2.push(new n.FM8(-1, 3).multiplyScalar(t2)), e2.push(new n.FM8(-4, 6).multiplyScalar(t2)), e2.push(new n.FM8(-7, 8).multiplyScalar(t2)), e2.push(new n.FM8(-5, 2).multiplyScalar(t2)), e2;
    }
    _blurEdges(e2, t2) {
      var r2, i2;
      const s2 = { minFilter: n.wem, magFilter: n.wem, isAntialiased: false, format: n.wk1, depthBuffer: false, generateMipmaps: false, sizeMultiplier: 0.5 }, o2 = e2.getTempTarget(s2), a2 = (null === (r2 = t2.texture.image) || void 0 === r2 ? void 0 : r2.width) || 1, l2 = (null === (i2 = t2.texture.image) || void 0 === i2 ? void 0 : i2.height) || 1;
      this._separableBlurMaterial.uniforms.texSize.value = new n.FM8(a2, l2), this._separableBlurMaterial.uniforms.colorTexture.value = t2.texture, this._separableBlurMaterial.uniforms.direction.value = new n.FM8(1, 0), e2.blit(void 0, o2, { material: this._separableBlurMaterial }), this._separableBlurMaterial.uniforms.texSize.value = new n.FM8(a2 / 2, l2 / 2), this._separableBlurMaterial.uniforms.colorTexture.value = o2.texture, this._separableBlurMaterial.uniforms.direction.value = new n.FM8(0, 1), e2.blit(void 0, t2, { material: this._separableBlurMaterial }), e2.releaseTempTarget(o2);
    }
    _renderEdges(e2, t2) {
      var r2, i2, s2, o2;
      const a2 = (null === (r2 = t2.texture.image) || void 0 === r2 ? void 0 : r2.width) || 1, l2 = (null === (i2 = t2.texture.image) || void 0 === i2 ? void 0 : i2.height) || 1;
      this._edgeMaterial.uniforms.screenSize.value = new n.FM8(a2, l2), this._viewerApp.scene.activeCamera.updateShaderProperties(this._edgeMaterial), null === (s2 = this._viewerApp.getPlugin(lo)) || void 0 === s2 || s2.updateShaderProperties(this._edgeMaterial), null === (o2 = this._viewerApp.getPlugin(Ob)) || void 0 === o2 || o2.updateShaderProperties(this._edgeMaterial), e2.blit(void 0, t2, { material: this._edgeMaterial });
    }
  };
  Ub = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  }([lt("SSBevel")], Ub);
  class Nb extends io {
    constructor(e2 = true) {
      super(), this.passId = "ssBevel", this._beforeFilters = ["render"], this._afterFilters = ["gbuffer", "normalBuffer"], this._requiredFilters = ["render", "gbuffer", "normalBuffer"], this._lastEnabled = false, this.dependencies = [to, lo, Ob], this.enabled = e2, this.setDirty = this.setDirty.bind(this), this._loaderCreate = this._loaderCreate.bind(this);
    }
    get bevelTarget() {
      return this._bevelTarget;
    }
    _loaderCreate({ loader: e2 }) {
      e2.isGLTFLoader2 && e2.register((e3) => new jb(e3));
    }
    passCtor(e2) {
      var t2, r2;
      this._bevelTarget = e2.renderer.createTarget({ depthBuffer: true, type: n.cLu, minFilter: n.TyD, magFilter: n.TyD, generateMipmaps: false }), this._bevelTarget.texture.name = "bevelBuffer", this._bevelTarget.texture.generateMipmaps = false;
      const i2 = e2.getPluginByType("debug");
      return i2 && i2.addTexture("tempBuffer", () => this._bevelTarget.texture, [440, 50, 400, 200]), new Ub(e2.renderer, this._bevelTarget, null !== (r2 = null === (t2 = e2.getPlugin(lo)) || void 0 === t2 ? void 0 : t2.getUnpackSnippet()) && void 0 !== r2 ? r2 : "", e2);
    }
    async onAdded(e2) {
      var t2, r2, n2, i2, s2, o2, a2;
      await super.onAdded(e2);
      const l2 = e2.getPlugin(to);
      return (null === (t2 = this.pass) || void 0 === t2 ? void 0 : t2.passObject.materialExtension) && (null === (r2 = null == l2 ? void 0 : l2.materials) || void 0 === r2 || r2.registerMaterialExtension(null === (n2 = this.pass) || void 0 === n2 ? void 0 : n2.passObject.materialExtension)), null === (i2 = null == l2 ? void 0 : l2.importer) || void 0 === i2 || i2.addEventListener("loaderCreate", this._loaderCreate), null === (a2 = null === (o2 = null === (s2 = null == l2 ? void 0 : l2.exporter) || void 0 === s2 ? void 0 : s2.getExporter("gltf", "glb")) || void 0 === o2 ? void 0 : o2.extensions) || void 0 === a2 || a2.push(zb), super.onAdded(e2);
    }
    async onRemove(e2) {
      return e2.renderer.disposeTarget(this._bevelTarget), super.onRemove(e2);
    }
    setDirty() {
      var e2, t2, r2, n2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty(), null === (n2 = null === (t2 = this.pass) || void 0 === t2 ? void 0 : (r2 = t2.passObject.materialExtension).setDirty) || void 0 === n2 || n2.call(r2);
    }
    _update(e2) {
      var t2;
      let r2 = this.enabled;
      if (r2 && !this._lastEnabled) {
        const e3 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("NormalBufferPlugin");
        confirm("SS Bevel Plugin needs to enable NormalBufferPlugin. Enable now?") ? e3.enabled = true : (this.enabled = false, e3.enabled = false, r2 = false);
      }
      return this._lastEnabled = r2, r2;
    }
    get uiConfig() {
      var e2, t2, r2, n2, i2;
      const s2 = null !== (r2 = null === (t2 = null === (e2 = this.pass) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.uiConfig) && void 0 !== r2 ? r2 : {};
      return null === (i2 = null === (n2 = s2.children) || void 0 === n2 ? void 0 : n2.map((e3) => A(e3))) || void 0 === i2 || i2.flat(2).forEach((e3) => e3 && (e3.onChange = this.setDirty)), s2;
    }
  }
  Nb.PluginType = "SSBevelPlugin", Nb.SSBEVEL_GLTF_EXTENSION = "WEBGI_materials_ssbevel";
  class jb {
    constructor(e2) {
      this.parser = e2, this.name = Nb.SSBEVEL_GLTF_EXTENSION;
    }
    async extendMaterialParams(e2, t2) {
      const r2 = this.parser.json.materials[e2];
      if (!r2.extensions || !r2.extensions[this.name])
        return Promise.resolve();
      const n2 = r2.extensions[this.name];
      return t2.userData || (t2.userData = {}), Fb(t2), t2.userData._ssBevel = De(n2, t2.userData._ssBevel, false, {}), Promise.resolve();
    }
  }
  const zb = (e2) => ({ writeMaterial: (t2, r2) => {
    if (!t2.isMeshStandardMaterial || !t2.userData._ssBevel)
      return;
    if (!t2.userData._ssBevel.hasSSBevel)
      return;
    r2.extensions = r2.extensions || {};
    const n2 = ke(t2.userData._ssBevel, false);
    r2.extensions[Nb.SSBEVEL_GLTF_EXTENSION] = n2, e2.extensionsUsed[Nb.SSBEVEL_GLTF_EXTENSION] = true;
  } });
  class Gb extends V_ {
    constructor(e2) {
      super(), this._loadedLibs = false, e2 = e2 || { method: mA.EncoderMethod.EDGEBREAKER, encodeSpeed: 5 }, this._io = new Mv().registerExtensions(Bb).registerExtensions([Hb, Jb, Xb, Yb, Kb, Zb, $b, ey, ty, ry, ny, iy, sy, oy, ay]), this._encoderOptions = e2;
    }
    preload() {
      return this._loadLibs(), this;
    }
    async _loadLibs() {
      if (this._loadedLibs || !this.loader)
        return;
      const e2 = await Promise.all([this.loader.initEncoder(), this.loader.initDecoder()]);
      this._io.registerDependencies({ "draco3d.encoder": e2[0], "draco3d.decoder": e2[1] }), this._loadedLibs = true;
    }
    async parseAsync(e2, { compress: t2 = false, ...r2 }) {
      if (!this.loader)
        return console.error("GLTFDracoExporter: No DRACOLoader2 instance provided"), super.parseAsync(e2, r2);
      await this._loadLibs();
      const n2 = { ...r2 };
      t2 && (n2.externalImagesInExtras = true);
      const i2 = await new Promise((t3, r3) => this.parse(e2, t3, r3, n2)), s2 = await super.parseAsync(i2, n2);
      if (!t2)
        return s2;
      if (!i2)
        throw new Error("GLTFDracoExporter: gltf is null");
      let o2 = i2;
      const a2 = o2.byteLength || 1 / 0, l2 = await ("object" != typeof o2 || o2.byteLength ? this._io.readBinary(new Uint8Array(o2)) : this._io.readJSON({ json: o2, resources: {} }));
      if (l2.createExtension(mA).setRequired(true).setEncoderOptions(this._encoderOptions), "glb" === n2.exportExt)
        o2 = await this._io.writeBinary(l2), isFinite(a2) && console.log("DRACO Compression ratio: " + (o2.byteLength / a2).toFixed(5));
      else {
        const e3 = await this._io.writeJSON(l2);
        o2 = e3.json, Object.values(e3.resources).filter((e4) => e4).length > 0 && (console.warn("DRACOExporter: extra resources in resources not supported properly"), o2.resources = e3.resources);
      }
      o2.__isGLTFOutput = true;
      const c2 = await super.parseAsync(o2, n2);
      return c2.__uncompressed = s2, c2;
    }
  }
  class Vb extends ro {
    constructor() {
      super(...arguments), this.enabled = true, this.dependencies = [to, tg];
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const t2 = e2.getManager().importer;
      if (!t2)
        throw new Error("GLTFDracoExportPlugin: AssetImporter not found");
      !function(e3, t3) {
        W_(e3, Gb, (e4) => {
          const r2 = Xe() + ".drc", n2 = e4;
          n2.loader = t3.registerFile(r2), n2.loader.setDecoderConfig({ type: "js" }), n2.loader.preload(true, true);
        });
      }(e2, t2);
    }
  }
  Vb.PluginType = "GLTFDracoExportPlugin";
  class Qb extends ev {
    constructor() {
      super(...arguments), this.extensionName = on, this.parentTypes = [dg.SCENE], this.propertyType = "ViewerJSON";
    }
    init() {
    }
  }
  class Hb extends gv {
    constructor() {
      super(...arguments), this.extensionName = on, this._viewerConfig = {}, this._texturesRef = [], this.required = true;
    }
    read(e2) {
      var t2;
      return this._viewerConfig = {}, null === (t2 = e2.jsonDoc.json.scenes) || void 0 === t2 || t2.forEach((t3, r2) => {
        if (t3.extensions && t3.extensions[on]) {
          const n2 = new Qb(this.document.getGraph());
          e2.scenes[r2].setExtension(on, n2);
          const i2 = t3.extensions[on];
          this._viewerConfig = i2;
        }
      }), this;
    }
    write(e2) {
      return this.document.getRoot().listScenes().forEach((t2) => {
        var r2;
        if (t2.getExtension(on)) {
          const t3 = null === (r2 = e2.jsonDoc.json.scenes) || void 0 === r2 ? void 0 : r2[e2.jsonDoc.json.scene || 0];
          t3 && this._viewerConfig !== {} && (t3.extensions = t3.extensions || {}, t3.extensions[on] = this._viewerConfig, this._texturesRef = [], this._viewerConfig = {});
        }
      }), this;
    }
  }
  Hb.EXTENSION_NAME = on;
  class Wb extends ev {
    constructor(e2, t2, r2) {
      super(e2, t2), this.parentTypes = [dg.MATERIAL, dg.MESH, dg.NODE, dg.SCENE], this.propertyType = "GenericExtension", this.textures = {}, this.extensionName = r2;
    }
    addTexture(e2, t2, r2, n2 = 4369) {
      this.setRef(e2, r2, { channels: n2 }), this.textures[e2] = [t2, r2];
    }
    copy(e2, t2 = Qg) {
      return super.copy(e2, t2), this;
    }
    dispose() {
      Object.values(this.textures).forEach(([e2, t2]) => {
        null == e2 || e2.dispose();
      }), super.dispose();
    }
    init() {
    }
  }
  class qb extends gv {
    constructor() {
      super(...arguments), this.textureChannels = {};
    }
    read(e2) {
      const t2 = e2.jsonDoc, r2 = t2.json.materials || [], n2 = t2.json.textures || [];
      return r2.forEach((t3, r3) => {
        var i2, s2;
        if (t3.extensions && t3.extensions[this.extensionName]) {
          const o2 = new Wb(this.document.getGraph(), "", this.extensionName);
          e2.materials[r3].setExtension(this.extensionName, o2);
          const a2 = { ...t3.extensions[this.extensionName] };
          for (const [t4, r4] of Object.entries(a2))
            if ("number" == typeof (null == r4 ? void 0 : r4.index)) {
              const l2 = r4, c2 = null === (i2 = n2[l2.index]) || void 0 === i2 ? void 0 : i2.source;
              if ("number" != typeof c2) {
                console.warn("GLTF Pipeline: source texture not found for texture info", l2);
                continue;
              }
              const u2 = e2.textures[c2], h2 = new tv(this.document.getGraph()), p2 = null !== (s2 = this.textureChannels[t4]) && void 0 !== s2 ? s2 : 4369;
              o2.addTexture(t4, h2, u2, p2), e2.setTextureInfo(h2, l2), delete a2[t4];
            }
          o2.setExtras(a2);
        }
      }), (t2.json.meshes || []).forEach((t3, r3) => {
        if (t3.extensions && t3.extensions[this.extensionName]) {
          const n3 = new Wb(this.document.getGraph(), "", this.extensionName);
          e2.meshes[r3].setExtension(this.extensionName, n3);
          const i2 = t3.extensions[this.extensionName];
          n3.setExtras(i2);
        }
      }), (t2.json.nodes || []).forEach((t3, r3) => {
        if (t3.extensions && t3.extensions[this.extensionName]) {
          const n3 = new Wb(this.document.getGraph(), "", this.extensionName);
          e2.nodes[r3].setExtension(this.extensionName, n3);
          const i2 = t3.extensions[this.extensionName];
          n3.setExtras(i2);
        }
      }), (t2.json.scenes || []).forEach((t3, r3) => {
        if (t3.extensions && t3.extensions[this.extensionName]) {
          const n3 = new Wb(this.document.getGraph(), "", this.extensionName);
          e2.scenes[r3].setExtension(this.extensionName, n3);
          const i2 = t3.extensions[this.extensionName];
          n3.setExtras(i2);
        }
      }), this;
    }
    write(e2) {
      const t2 = e2.jsonDoc;
      return this.document.getRoot().listMaterials().forEach((r2) => {
        const n2 = r2.getExtension(this.extensionName);
        if (n2) {
          const i2 = e2.materialIndexMap.get(r2), s2 = t2.json.materials[i2];
          s2.extensions = s2.extensions || {};
          const o2 = { ...n2.getExtras() };
          for (const [t3, r3] of Object.entries(n2.textures)) {
            const n3 = r3[0], i3 = r3[1];
            i3 && (o2[t3] = e2.createTextureInfoDef(i3, n3));
          }
          s2.extensions[this.extensionName] = o2;
        }
      }), this.document.getRoot().listMeshes().forEach((r2) => {
        const n2 = r2.getExtension(this.extensionName);
        if (n2) {
          const i2 = e2.meshIndexMap.get(r2), s2 = t2.json.meshes[i2];
          s2.extensions = s2.extensions || {}, s2.extensions[this.extensionName] = n2.getExtras();
        }
      }), this.document.getRoot().listNodes().forEach((r2) => {
        const n2 = r2.getExtension(this.extensionName);
        if (n2) {
          const i2 = e2.nodeIndexMap.get(r2), s2 = t2.json.nodes[i2];
          s2.extensions = s2.extensions || {}, s2.extensions[this.extensionName] = n2.getExtras();
        }
      }), this.document.getRoot().listScenes().forEach((r2) => {
        const n2 = r2.getExtension(this.extensionName);
        if (n2) {
          const r3 = e2.jsonDoc.json.scene || 0, i2 = t2.json.scenes[r3];
          if (!i2)
            return;
          i2.extensions = i2.extensions || {}, i2.extensions[this.extensionName] = n2.getExtras();
        }
      }), this;
    }
  }
  class Xb extends qb {
    constructor() {
      super(...arguments), this.extensionName = Xb.EXTENSION_NAME, this.textureChannels = { bumpTexture: _g.R };
    }
  }
  Xb.EXTENSION_NAME = mn;
  class Yb extends qb {
    constructor() {
      super(...arguments), this.extensionName = Yb.EXTENSION_NAME, this.textureChannels = { lightMapTexture: _g.R | _g.G | _g.B };
    }
  }
  Yb.EXTENSION_NAME = vn;
  class Kb extends qb {
    constructor() {
      super(...arguments), this.extensionName = Kb.EXTENSION_NAME, this.textureChannels = { alphaTexture: _g.G };
    }
  }
  Kb.EXTENSION_NAME = gn;
  class Jb extends qb {
    constructor() {
      super(...arguments), this.extensionName = Jb.EXTENSION_NAME;
    }
  }
  Jb.EXTENSION_NAME = Gc.DIAMOND_GLTF_EXTENSION;
  class Zb extends qb {
    constructor() {
      super(...arguments), this.extensionName = Zb.EXTENSION_NAME;
    }
  }
  Zb.EXTENSION_NAME = Wc.AnimationMarkersExtension;
  class $b extends qb {
    constructor() {
      super(...arguments), this.extensionName = $b.EXTENSION_NAME, this.textureChannels = { anisotropyDirection: _g.R | _g.G | _g.B };
    }
  }
  $b.EXTENSION_NAME = xu.ANISOTROPY_GLTF_EXTENSION;
  class ey extends qb {
    constructor() {
      super(...arguments), this.extensionName = ey.EXTENSION_NAME, this.textureChannels = { anisotropyDirection: _g.R | _g.G | _g.B };
    }
  }
  ey.EXTENSION_NAME = Fu.CUSTOM_BUMP_MAP_GLTF_EXTENSION;
  class ty extends qb {
    constructor() {
      super(...arguments), this.extensionName = ty.EXTENSION_NAME;
    }
  }
  ty.EXTENSION_NAME = ln;
  class ry extends qb {
    constructor() {
      super(...arguments), this.extensionName = ry.EXTENSION_NAME;
    }
  }
  ry.EXTENSION_NAME = cn;
  class ny extends qb {
    constructor() {
      super(...arguments), this.extensionName = ny.EXTENSION_NAME;
    }
  }
  ny.EXTENSION_NAME = un;
  class iy extends qb {
    constructor() {
      super(...arguments), this.extensionName = iy.EXTENSION_NAME;
    }
  }
  iy.EXTENSION_NAME = zu.CLEARCOAT_TINT_GLTF_EXTENSION;
  class sy extends qb {
    constructor() {
      super(...arguments), this.extensionName = sy.EXTENSION_NAME;
    }
  }
  sy.EXTENSION_NAME = Cu.THIN_FILM_LAYER_GLTF_EXTENSION;
  class oy extends qb {
    constructor() {
      super(...arguments), this.extensionName = oy.EXTENSION_NAME;
    }
  }
  oy.EXTENSION_NAME = Nb.SSBEVEL_GLTF_EXTENSION;
  class ay extends qb {
    constructor() {
      super(...arguments), this.extensionName = ay.EXTENSION_NAME;
    }
  }
  ay.EXTENSION_NAME = Du.NOISE_BUMP_MATERIAL_GLTF_EXTENSION;
  class ly extends r {
    constructor() {
      super(...arguments), this.processor = { forAssetType: "texture", process: (e2, t2) => e2 };
    }
    async onAdded(e2) {
    }
    async onDispose(e2) {
    }
    async onRemove(e2) {
      this._pmrem = void 0;
    }
  }
  ly.PluginType = "PMREMGenerator";
  const cy = new n.Pa4(), uy = new n._fP(), hy = new n.Pa4();
  class py extends n.Tme {
    constructor(e2 = document.createElement("div")) {
      super(), this.isCSS3DObject = true, this.element = e2, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.element.style.userSelect = "none", this.element.setAttribute("draggable", false), this.addEventListener("removed", function() {
        this.traverse(function(e3) {
          e3.element instanceof Element && null !== e3.element.parentNode && e3.element.parentNode.removeChild(e3.element);
        });
      });
    }
    copy(e2, t2) {
      return super.copy(e2, t2), this.element = e2.element.cloneNode(true), this;
    }
  }
  const dy = new n.yGw(), fy = new n.yGw();
  class my {
    constructor(e2 = {}) {
      const t2 = this;
      let r2, n2, i2, s2;
      const o2 = { camera: { fov: 0, style: "" }, objects: /* @__PURE__ */ new WeakMap() }, a2 = void 0 !== e2.element ? e2.element : document.createElement("div");
      a2.style.overflow = "hidden", this.domElement = a2;
      const l2 = document.createElement("div");
      function c2(e3) {
        return Math.abs(e3) < 1e-10 ? 0 : e3;
      }
      function u2(e3) {
        const t3 = e3.elements;
        return "matrix3d(" + c2(t3[0]) + "," + c2(-t3[1]) + "," + c2(t3[2]) + "," + c2(t3[3]) + "," + c2(t3[4]) + "," + c2(-t3[5]) + "," + c2(t3[6]) + "," + c2(t3[7]) + "," + c2(t3[8]) + "," + c2(-t3[9]) + "," + c2(t3[10]) + "," + c2(t3[11]) + "," + c2(t3[12]) + "," + c2(-t3[13]) + "," + c2(t3[14]) + "," + c2(t3[15]) + ")";
      }
      function h2(e3) {
        const t3 = e3.elements;
        return "translate(-50%,-50%)matrix3d(" + c2(t3[0]) + "," + c2(t3[1]) + "," + c2(t3[2]) + "," + c2(t3[3]) + "," + c2(-t3[4]) + "," + c2(-t3[5]) + "," + c2(-t3[6]) + "," + c2(-t3[7]) + "," + c2(t3[8]) + "," + c2(t3[9]) + "," + c2(t3[10]) + "," + c2(t3[11]) + "," + c2(t3[12]) + "," + c2(t3[13]) + "," + c2(t3[14]) + "," + c2(t3[15]) + ")";
      }
      function p2(e3, r3, n3, i3) {
        if (e3.isCSS3DObject) {
          const i4 = true === e3.visible && true === e3.layers.test(n3.layers);
          if (e3.element.style.display = true === i4 ? "" : "none", true === i4) {
            let i5;
            e3.onBeforeRender(t2, r3, n3), e3.isCSS3DSprite ? (dy.copy(n3.matrixWorldInverse), dy.transpose(), 0 !== e3.rotation2D && dy.multiply(fy.makeRotationZ(e3.rotation2D)), e3.matrixWorld.decompose(cy, uy, hy), dy.setPosition(cy), dy.scale(hy), dy.elements[3] = 0, dy.elements[7] = 0, dy.elements[11] = 0, dy.elements[15] = 1, i5 = h2(dy)) : i5 = h2(e3.matrixWorld);
            const s3 = e3.element, a3 = o2.objects.get(e3);
            if (void 0 === a3 || a3.style !== i5) {
              s3.style.transform = i5;
              const t3 = { style: i5 };
              o2.objects.set(e3, t3);
            }
            s3.parentNode !== l2 && l2.appendChild(s3), e3.onAfterRender(t2, r3, n3);
          }
        }
        for (let t3 = 0, s3 = e3.children.length; t3 < s3; t3++)
          p2(e3.children[t3], r3, n3, i3);
      }
      l2.style.transformStyle = "preserve-3d", l2.style.pointerEvents = "none", a2.appendChild(l2), this.getSize = function() {
        return { width: r2, height: n2 };
      }, this.render = function(e3, t3) {
        const r3 = t3.projectionMatrix.elements[5] * s2;
        let n3, h3;
        o2.camera.fov !== r3 && (a2.style.perspective = t3.isPerspectiveCamera ? r3 + "px" : "", o2.camera.fov = r3), true === e3.matrixWorldAutoUpdate && e3.updateMatrixWorld(), null === t3.parent && true === t3.matrixWorldAutoUpdate && t3.updateMatrixWorld(), t3.isOrthographicCamera && (n3 = -(t3.right + t3.left) / 2, h3 = (t3.top + t3.bottom) / 2);
        const d2 = t3.isOrthographicCamera ? "scale(" + r3 + ")translate(" + c2(n3) + "px," + c2(h3) + "px)" + u2(t3.matrixWorldInverse) : "translateZ(" + r3 + "px)" + u2(t3.matrixWorldInverse), f2 = d2 + "translate(" + i2 + "px," + s2 + "px)";
        o2.camera.style !== f2 && (l2.style.transform = f2, o2.camera.style = f2), p2(e3, e3, t3, d2);
      }, this.setSize = function(e3, t3) {
        r2 = e3, n2 = t3, i2 = r2 / 2, s2 = n2 / 2, a2.style.width = e3 + "px", a2.style.height = t3 + "px", l2.style.width = e3 + "px", l2.style.height = t3 + "px";
      };
    }
  }
  var _y, gy = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let vy = _y = class extends ro {
    constructor(e2 = true) {
      super(), this._scene = new n.xsS(), this.overCanvas = true, this._trackers = [], this.attachIFrameToSelected = async () => {
        var e3, t2, r2, n2, i2;
        const s2 = null === (t2 = null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.getPlugin(Nc)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
        if (!(null == s2 ? void 0 : s2.geometry))
          return void await (null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.alert("No Geometry: Selected object must have a geometry to apply the iframe to"));
        const o2 = await (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.prompt("URL: Enter the url for the webpage. (Make sure its allowed to be embedded in an iframe.)", "https://webgi.xyz/", false)) || "https://webgi.pixotronics.com/";
        if (!o2)
          return;
        const a2 = await (null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.prompt("Width: Enter the width for the object.", "512", false)) || "512";
        a2 && this.attachIFrame(s2, o2, parseInt(a2));
      }, this._resizeObserver = new ResizeObserver(() => {
        var e3;
        this.enabled && (null === (e3 = this._viewer) || void 0 === e3 || e3.scene.setDirty({ sceneUpdate: true }));
      }), this.enabled = e2, this._refreshCanvasInDOM = this._refreshCanvasInDOM.bind(this), this._refreshEnabled = this._refreshEnabled.bind(this);
    }
    _refreshEnabled() {
    }
    _refreshCanvasInDOM() {
      const e2 = this._viewer;
      e2 && this._renderer && (e2.canvas.remove(), this.overCanvas ? this._renderer.domElement.insertAdjacentElement("afterbegin", e2.canvas) : this._renderer.domElement.appendChild(e2.canvas));
    }
    _initialize() {
      if (this._renderer)
        return;
      if (!this._viewer)
        return;
      this._renderer = new my();
      const e2 = this._viewer.renderer.rendererObject.getSize(new n.FM8());
      this._renderer.setSize(e2.width, e2.height);
      const t2 = document.createElement("div");
      t2.style.position = "absolute", t2.style.top = "0", t2.style.zIndex = "0", t2.appendChild(this._renderer.domElement), this._viewer.canvas.style.position = "absolute", this._viewer.canvas.style.top = "0", this._viewer.canvas.style.left = "0", this._viewer.canvas.style.zIndex = "0", this._viewer.container.appendChild(t2), this._refreshCanvasInDOM(), this._viewer.renderer.addEventListener("resize", () => {
        if (!this._viewer || !this._renderer)
          return;
        const e3 = this._viewer.renderer.rendererObject.getSize(new n.FM8());
        this._renderer.setSize(e3.width, e3.height);
      });
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      let t2 = true, r2 = true;
      e2.addEventListener("postFrame", (i3) => {
        var s3, o2;
        t2 && this.enabled && (this._renderer || this._initialize(), this._renderer && (r2 && this._trackers.forEach((e3) => {
          var t3, r3;
          let i4 = true;
          const s4 = e3.modelObj.material.side;
          if (s4 !== n.ehD) {
            const o3 = new n.Pa4(0, 0, 1).applyQuaternion(e3.cssObj.quaternion), a2 = null === (r3 = null === (t3 = this._viewer) || void 0 === t3 ? void 0 : t3.scene.activeCamera) || void 0 === r3 ? void 0 : r3.cameraObject, l2 = o3.dot(a2.getWorldDirection(new n.Pa4()));
            i4 = s4 === n._Li ? l2 > 0 : l2 < 0;
          }
          e3.cssObj.element.style.visibility = i4 ? "visible" : "hidden";
        }), this._trackers.filter((e3) => e3.dirty).forEach((e3) => this._syncProperties(e3)), null === (s3 = this._renderer) || void 0 === s3 || s3.render(this._scene, null === (o2 = e2.scene.activeCamera) || void 0 === o2 ? void 0 : o2.cameraObject), t2 = false));
      }), e2.addEventListener("update", (e3) => {
        this.enabled && (t2 = this._trackers.length > 0);
      }), e2.scene.addEventListener("sceneUpdate", (e3) => {
        this.enabled && (this._trackers.forEach((e4) => e4.dirty = true), t2 = this._trackers.length > 0);
      }), e2.scene.addEventListener("activeCameraUpdate", (e3) => {
        this.enabled && (t2 = this._trackers.length > 0, r2 = true);
      });
      let i2 = false;
      const s2 = new n.iMs();
      e2.container.addEventListener("mousemove", (e3) => {
        if (!this.enabled || !this._viewer || this.overCanvas)
          return;
        const t3 = this._viewer.canvas.getBoundingClientRect(), r3 = (e3.clientX - t3.x) / t3.width * 2 - 1, n2 = -(e3.clientY - t3.y) / t3.height * 2 + 1;
        s2.setFromCamera({ x: r3, y: n2 }, this._viewer.scene.activeCamera.cameraObject);
        const o2 = this._trackers.map((e4) => e4.modelObj), a2 = s2.intersectObjects(o2, false);
        if (console.log(a2), a2.length)
          return this._viewer.canvas.style.pointerEvents = "none", i2 = true, void console.log(this._viewer.canvas.style.pointerEvents);
        i2 && (this._viewer.canvas.style.pointerEvents = "auto", i2 = false);
      });
    }
    attachIFrame(e2, t2, r2) {
      const n2 = xy(e2.modelObject), i2 = Ay(t2, r2, r2 * n2.y / n2.x, () => {
        var t3;
        return null === (t3 = e2.setDirty) || void 0 === t3 ? void 0 : t3.call(e2);
      });
      return this.attachCSS3DObject(i2, e2), i2;
    }
    attachCSS3DObject(e2, t2) {
      var r2, i2, s2, o2, a2;
      if (this._trackers.push({ cssObj: e2, modelObj: t2.modelObject, dirty: true }), e2.element && (this._resizeObserver.observe(e2.element), e2.element.__isCSS3DObjectElement = true, console.log(e2.element, e2.element.__isCSS3DObjectElement)), t2.userData.__oldMaterial = t2.material, !t2.setMaterial)
        throw "model not processed?";
      const l2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.createMaterial("basic", { opacity: 0, color: new n.Ilk("black"), blending: n.jFi, side: n.Wl3 });
      if (!l2)
        throw "cannot create mat";
      l2.userData.forcedLinearDepth = 0, null === (i2 = t2.setMaterial) || void 0 === i2 || i2.call(t2, l2), by(t2.modelObject), yy(t2.modelObject), xy(t2.modelObject), this._scene.add(e2), null === (o2 = null === (s2 = this.uiConfig) || void 0 === s2 ? void 0 : s2.uiRefresh) || void 0 === o2 || o2.call(s2), null === (a2 = t2.setDirty) || void 0 === a2 || a2.call(t2);
    }
    _syncProperties(e2) {
      const t2 = e2.modelObj, r2 = e2.cssObj;
      t2.updateMatrixWorld();
      const i2 = e2.cssObj.element.clientWidth < 1.5 ? 0 : (e2.cssObj.element.clientWidth - 1.5) / xy(t2).x, s2 = by(t2);
      r2.quaternion.setFromUnitVectors(new n.Pa4(0, 0, 1), s2), r2.position.copy(yy(t2)), r2.scale.set(1, 1, 1).multiplyScalar(1 / i2), r2.updateMatrixWorld(), r2.applyMatrix4(t2.matrixWorld), e2.dirty = false;
    }
    async onDispose(e2) {
      return this._resizeObserver.disconnect(), super.onDispose(e2);
    }
  };
  function Ay(e2, t2, r2, n2) {
    const i2 = document.createElement("div");
    i2.style.width = t2.toString() + "px", i2.style.height = r2.toString() + "px", i2.style.backgroundColor = "transparent";
    const s2 = document.createElement("iframe", { is: "x-frame-bypass" });
    s2.style.width = "100%", s2.style.height = "100%", s2.style.border = "0px";
    const o2 = () => {
      var e3, t3;
      try {
        s2.contentWindow.name;
      } catch (r3) {
        ("string" == typeof r3 ? r3 : null !== (t3 = null === (e3 = null == r3 ? void 0 : r3.toString) || void 0 === e3 ? void 0 : e3.call(r3)) && void 0 !== t3 ? t3 : "").includes("cross-origin") ? console.warn("Trying to load cross-origin scripts, Install chrome extension if not able to load: https://chrome.google.com/webstore/detail/ignore-x-frame-headers/gleekbfjekiniecknbkamfmkohkpodhe") : console.error(r3);
      }
      n2(), s2.removeEventListener("load", o2);
    };
    return s2.addEventListener("load", o2), s2.src = e2, i2.appendChild(s2), new py(i2);
  }
  function by(e2) {
    if (e2.geometry.userData.geometryNormal)
      return e2.geometry.userData.geometryNormal;
    const t2 = e2.geometry.attributes.normal, r2 = new n.Pa4(), i2 = new n.Pa4();
    for (let e3 = 0, n2 = t2.count; e3 < n2; e3++)
      r2.fromBufferAttribute(t2, e3), i2.add(r2);
    return i2.normalize(), e2.geometry.userData.geometryNormal = i2, i2;
  }
  function yy(e2) {
    if (e2.geometry.userData.geometryCenter)
      return e2.geometry.userData.geometryCenter;
    const t2 = e2.geometry;
    if (!t2)
      return new n.Pa4(0, 0, 0);
    t2.boundingBox || t2.computeBoundingBox();
    const r2 = t2.boundingBox.getCenter(new n.Pa4());
    return e2.geometry.userData.geometryCenter = r2, r2;
  }
  function xy(e2, t2 = new n.Pa4(0, 0, 1)) {
    if (e2.geometry.userData.geometrySize)
      return e2.geometry.userData.geometrySize;
    const r2 = e2.geometry;
    if (!r2)
      return new n.Pa4(0, 0, 0);
    const i2 = r2.clone();
    i2.applyMatrix4(new n.yGw().makeRotationFromQuaternion(new n._fP().setFromUnitVectors(t2, by(e2)).invert())), i2.computeBoundingBox();
    const s2 = i2.boundingBox.getSize(new n.Pa4());
    return e2.geometry.userData.geometrySize = s2, i2.dispose(), s2;
  }
  vy.PluginType = "CSS3DRenderer", gy([Je("Enabled"), M(_y.prototype._refreshEnabled), Ce()], vy.prototype, "enabled", void 0), gy([Je("Over canvas"), M(_y.prototype._refreshCanvasInDOM), Ce()], vy.prototype, "overCanvas", void 0), gy([rt("Attach iframe")], vy.prototype, "attachIFrameToSelected", void 0), vy = _y = gy([lt("CSS3D Renderer")], vy);
  const wy = 1e4, Ey = 50;
  class Sy {
    constructor(e2 = Ey) {
      this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(e2);
    }
    setDecayTime(e2) {
      this.naturalFrequency = 1 / Math.max(1e-3, e2);
    }
    update(e2, t2, r2, n2) {
      const i2 = 2e-4 * this.naturalFrequency;
      if (null == e2 || 0 === n2)
        return t2;
      if (e2 === t2 && 0 === this.velocity)
        return t2;
      if (r2 < 0)
        return e2;
      const s2 = e2 - t2, o2 = this.velocity + this.naturalFrequency * s2, a2 = s2 + r2 * o2, l2 = Math.exp(-this.naturalFrequency * r2), c2 = (o2 - this.naturalFrequency * a2) * l2, u2 = -this.naturalFrequency * (c2 + o2 * l2);
      return Math.abs(c2) < i2 * Math.abs(n2) && u2 * s2 >= 0 ? (this.velocity = 0, t2) : (this.velocity = c2, t2 + a2 * l2);
    }
  }
  const Cy = new n.Pa4();
  class My {
    constructor() {
      this.inputSource = null, this.isTranslating = false, this.isRotating = false, this.isTwoFingering = false, this.lastDragPosition = new n.Pa4(), this.firstRatio = 0, this.lastAngle = 0, this.goalPosition = new n.Pa4(), this.goalYaw = 0, this.goalScale = 1, this.presentedScene = null, this.placementBox = null, this.placeOnWall = false, this.placementComplete = false, this.xr = null, this.session = null, this._hitPosition = new n.Pa4(), this._hitMatrix = new n.yGw(), this.xDamper = new Sy(), this.yDamper = new Sy(), this.zDamper = new Sy(), this.yawDamper = new Sy(), this.scaleDamper = new Sy(), this.onSelectStart = (e2) => {
        const t2 = this.transientHitTestSource;
        if (null == t2)
          return;
        const r2 = this.frame.getHitTestResultsForTransientInput(t2), n2 = this.presentedScene, i2 = this.placementBox;
        if (1 === r2.length) {
          this.inputSource = e2.inputSource;
          const { axes: t3 } = this.inputSource.gamepad || { axes: [0, 0] }, r3 = i2.getHit(n2, t3[0], t3[1]);
          i2.show = true, null != r3 ? (this.isTranslating = true, this.lastDragPosition.copy(r3)) : this.placeOnWall || (this.isRotating = true, this.lastAngle = 1.5 * t3[0]);
        } else if (2 === r2.length) {
          i2.show = true, this.isTwoFingering = true;
          const { separation: e3 } = this.fingerPolar(r2);
          this.firstRatio = e3 / n2.scale.x;
        }
      }, this.onSelectEnd = () => {
        this.isTranslating = false, this.isRotating = false, this.isTwoFingering = false, this.inputSource = null, this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x, this.placementBox.show = false;
      };
    }
    async setSession(e2, t2, r2, n2) {
      var i2;
      this.transientHitTestSource = await (null === (i2 = e2.requestHitTestSourceForTransientInput) || void 0 === i2 ? void 0 : i2.call(e2, { profile: "generic-touchscreen" })), this.presentedScene = t2, this.placementBox = n2, this.xr = r2, this.session = e2, this.placementComplete = false, this.goalPosition.copy(t2.position), this.goalYaw = t2.rotation.y, this.goalScale = t2.scale.x, e2.addEventListener("selectstart", this.onSelectStart), e2.addEventListener("selectend", this.onSelectEnd);
    }
    cancel() {
      this.transientHitTestSource && (this.transientHitTestSource.cancel(), this.transientHitTestSource = void 0), this.presentedScene = null, this.placeOnWall = false, this.frame = void 0, this.xr = null, this.placementBox && (this.placementBox.show = false, this.placementBox = null), this.session && (this.session.removeEventListener("selectstart", this.onSelectStart), this.session.removeEventListener("selectend", this.onSelectEnd), this.session = null);
    }
    getHitPoint(e2) {
      var t2;
      const r2 = null === (t2 = this.xr) || void 0 === t2 ? void 0 : t2.getReferenceSpace(), n2 = r2 ? e2.getPose(r2) : null;
      return n2 ? (this._hitMatrix.fromArray(n2.transform.matrix), this.placeOnWall && (this.goalYaw = Math.atan2(this._hitMatrix.elements[4], this._hitMatrix.elements[6])), this._hitMatrix.elements[5] > 0.75 !== this.placeOnWall ? this._hitPosition.setFromMatrixPosition(this._hitMatrix) : null) : null;
    }
    moveScene(e2) {
      if (!this.session)
        return;
      const t2 = this.presentedScene, r2 = t2.position, n2 = t2.rotation.y, i2 = this.placementBox, s2 = Math.max(i2.boundingSize.x, i2.boundingSize.y, i2.boundingSize.z) / 2, o2 = this.goalPosition, a2 = t2.scale.x;
      if (!o2.equals(r2) || this.goalScale !== a2) {
        let { x: n3, y: l2, z: c2 } = r2;
        n3 = this.xDamper.update(n3, o2.x, e2, s2), l2 = this.yDamper.update(l2, o2.y, e2, s2), c2 = this.zDamper.update(c2, o2.z, e2, s2), r2.set(n3, l2, c2);
        const u2 = this.scaleDamper.update(a2, this.goalScale, e2, 1);
        if (t2.scale.set(u2, u2, u2), !this.isTranslating) {
          const e3 = o2.y - l2;
          this.placementComplete && !this.placeOnWall ? i2.offsetHeight = e3 / u2 : 0 === e3 && (this.placementComplete = true, i2.show = false);
        }
      }
      i2.updateOpacity(e2), t2.rotation.y = this.yawDamper.update(n2, this.goalYaw, e2, Math.PI);
    }
    processInput(e2) {
      var t2;
      this.frame = e2;
      const r2 = this.transientHitTestSource;
      if (!r2)
        return;
      if (!this.isTranslating && !this.isTwoFingering && !this.isRotating)
        return;
      const n2 = e2.getHitTestResultsForTransientInput(r2), i2 = this.presentedScene, s2 = i2.scale.x;
      if (this.isTwoFingering)
        if (n2.length < 2)
          this.isTwoFingering = false;
        else {
          const { separation: e3, deltaYaw: t3 } = this.fingerPolar(n2);
          if (this.placeOnWall || (this.goalYaw += t3), !i2.userData.__scaleDisabled) {
            const t4 = e3 / this.firstRatio;
            this.goalScale = t4 < 1.3 && t4 > 0.7692307692307692 ? 1 : t4;
          }
        }
      else if (2 !== n2.length)
        if (this.isRotating && (null === (t2 = this.inputSource) || void 0 === t2 ? void 0 : t2.gamepad)) {
          const e3 = 1.5 * this.inputSource.gamepad.axes[0];
          this.goalYaw += e3 - this.lastAngle, this.lastAngle = e3;
        } else
          this.isTranslating && (console.log("translating"), n2.forEach((e3) => {
            if (e3.inputSource !== this.inputSource)
              return;
            let t3 = null;
            if (e3.results.length > 0 && (t3 = this.getHitPoint(e3.results[0])), null == t3 && (t3 = this.getTouchLocation()), null != t3) {
              if (this.goalPosition.sub(this.lastDragPosition), !this.placeOnWall) {
                const e4 = t3.y - this.lastDragPosition.y;
                if (e4 < 0) {
                  this.placementBox.offsetHeight = e4 / s2;
                  const r3 = Cy.copy(this.xr.getCamera().position), n3 = -e4 / (r3.y - t3.y);
                  r3.multiplyScalar(n3), t3.multiplyScalar(1 - n3).add(r3);
                }
              }
              this.goalPosition.add(t3), this.lastDragPosition.copy(t3);
            }
          }));
      else {
        this.isTranslating = false, this.isRotating = false, this.isTwoFingering = true;
        const { separation: e3 } = this.fingerPolar(n2);
        this.firstRatio = e3 / s2;
      }
    }
    getTouchLocation() {
      var e2, t2;
      const { axes: r2 } = null !== (e2 = this.inputSource.gamepad) && void 0 !== e2 ? e2 : { axes: [0, 0] }, n2 = this.placementBox.getExpandedHit(this.presentedScene, r2[0], r2[1]);
      return null != n2 && (Cy.copy(n2).sub(null === (t2 = this.xr) || void 0 === t2 ? void 0 : t2.getCamera().position), Cy.length() > 10) ? null : n2;
    }
    fingerPolar(e2) {
      var t2, r2, n2, i2, s2, o2;
      const a2 = null !== (n2 = null === (r2 = null === (t2 = e2[0].inputSource) || void 0 === t2 ? void 0 : t2.gamepad) || void 0 === r2 ? void 0 : r2.axes) && void 0 !== n2 ? n2 : [0, 0], l2 = null !== (o2 = null === (s2 = null === (i2 = e2[1].inputSource) || void 0 === i2 ? void 0 : i2.gamepad) || void 0 === s2 ? void 0 : s2.axes) && void 0 !== o2 ? o2 : [0, 0], c2 = l2[0] - a2[0], u2 = l2[1] - a2[1], h2 = Math.atan2(u2, c2);
      let p2 = this.lastAngle - h2;
      return p2 > Math.PI ? p2 -= 2 * Math.PI : p2 < -Math.PI && (p2 += 2 * Math.PI), this.lastAngle = h2, { separation: Math.sqrt(c2 * c2 + u2 * u2), deltaYaw: p2 };
    }
  }
  const Ty = 0.2, Iy = Math.PI / 24, ky = new n.FM8(), Dy = (e2, t2, r2) => {
    let n2 = t2 > 0 ? r2 > 0 ? 0 : -Math.PI / 2 : r2 > 0 ? Math.PI / 2 : Math.PI;
    for (let i2 = 0; i2 <= 12; ++i2)
      e2.push(t2 + 0.17 * Math.cos(n2), r2 + 0.17 * Math.sin(n2), 0, t2 + Ty * Math.cos(n2), r2 + Ty * Math.sin(n2), 0), n2 += Iy;
  };
  class Py extends n.Kj0 {
    constructor(e2, t2, r2 = false) {
      super(((e3, t3) => {
        const r3 = new n.u9r(), i3 = [], s3 = [], o3 = e3.getSize(new n.Pa4()), a3 = o3.x / 2, l2 = (t3 ? o3.y : o3.z) / 2;
        Dy(s3, a3, l2), Dy(s3, -a3, l2), Dy(s3, -a3, -l2), Dy(s3, a3, -l2);
        const c2 = s3.length / 3;
        for (let e4 = 0; e4 < c2 - 2; e4 += 2)
          i3.push(e4, e4 + 1, e4 + 3, e4, e4 + 3, e4 + 2);
        const u2 = c2 - 2;
        return i3.push(u2, u2 + 1, 1, u2, 1, 0), r3.setAttribute("position", new n.a$l(s3, 3)), r3.setIndex(i3), r3;
      })(e2, r2)), this.boundingSize = new n.Pa4(), this._raycaster = new n.iMs(), this._camera = t2, this._placeOnWall = r2;
      const i2 = this.material;
      i2.side = n.Wl3, i2.color = new Ae(16711935), i2.opacity = 0, this.userData.bboxVisible = false;
      const s2 = e2.getSize(this.boundingSize);
      console.log(e2, r2, s2, this);
      const o2 = s2.x / 2, a2 = (r2 ? s2.y : s2.z) / 2;
      this.hitPlane = new n.Kj0(new n._12(2 * (o2 + Ty), 2 * (a2 + Ty))), this.hitPlane.visible = false, this.add(this.hitPlane), e2.getCenter(this.position), r2 ? (this.shadowHeight = e2.min.z, this.position.z = this.shadowHeight) : (this.rotateX(-Math.PI / 2), this.shadowHeight = e2.min.y, this.position.y = this.shadowHeight), this.offsetHeight = 0;
    }
    getHit(e2, t2, r2) {
      ky.set(t2, -r2), this.hitPlane.visible = true;
      const n2 = this._positionAndNormalFromPoint(ky, this.hitPlane);
      return this.hitPlane.visible = false, null == n2 ? null : n2.position;
    }
    getExpandedHit(e2, t2, r2) {
      this.hitPlane.scale.set(1e3, 1e3, 1e3);
      const n2 = this.getHit(e2, t2, r2);
      return this.hitPlane.scale.set(1, 1, 1), n2;
    }
    set offsetHeight(e2) {
      e2 -= 1e-3, this._placeOnWall ? this.position.z = this.shadowHeight + e2 : this.position.y = this.shadowHeight + e2;
    }
    get offsetHeight() {
      return this._placeOnWall ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight;
    }
    set show(e2) {
      this.material.opacity = e2 ? 0.75 : 0;
    }
    get show() {
      return this.material.opacity > 0.01;
    }
    updateOpacity(e2) {
      const t2 = this.material;
      this.visible = t2.opacity > 0;
    }
    dispose() {
      var e2;
      const { geometry: t2, material: r2 } = this.hitPlane;
      t2.dispose(), r2.dispose(), this.geometry.dispose(), this.material.dispose(), null === (e2 = this.parent) || void 0 === e2 || e2.remove(this);
    }
    _positionAndNormalFromPoint(e2, t2) {
      if (!this._camera)
        return null;
      this._raycaster.setFromCamera(e2, this._camera);
      const r2 = this._raycaster.intersectObject(t2, true);
      if (0 === r2.length)
        return null;
      const i2 = r2[0];
      return null == i2.face ? null : null == i2.uv ? { position: i2.point, normal: i2.face.normal, uv: null } : (i2.face.normal.applyNormalMatrix(new n.Vkp().getNormalMatrix(i2.object.matrixWorld)), { position: i2.point, normal: i2.face.normal, uv: i2.uv });
    }
  }
  class By extends ro {
    constructor() {
      super(...arguments), this.enabled = true, this._touchInputHelper = new My(), this._preRender = () => {
        if (!(this._dirty && this._viewer && this._xrManager && this._xrSession))
          return;
        this._viewer.renderer.composer.renderToScreen = false, this._xrManager.enabled = false;
        const e2 = this._xrManager.getCamera(), t2 = e2.cameras[0] || e2, r2 = this._viewer.scene.activeCamera;
        r2.cameraObject.projectionMatrix.copy(t2.projectionMatrix), r2.cameraObject.projectionMatrixInverse.copy(r2.cameraObject.projectionMatrix).invert();
      }, this._postRender = () => {
        var e2, t2;
        if (!this._dirty || !this._viewer || !this._xrSession)
          return;
        this._viewer.scene.activeCamera.cameraObject.updateProjectionMatrix();
        const r2 = this._viewer.renderer, n2 = null === (t2 = null === (e2 = this._xrManager) || void 0 === e2 ? void 0 : e2.getCamera()) || void 0 === t2 ? void 0 : t2.cameras[0].viewport;
        n2 ? r2.rendererObject.setViewport(n2) : console.warn("no viewport for ar camera"), W(r2.rendererObject, { sceneRender: true, opaqueRender: true, shadowMapRender: false, backgroundRender: false, transparentRender: false, transmissionRender: false, screenSpaceRendering: false }, () => {
          Ry.render(r2.rendererObject, null, r2.composer.readBuffer, 0, false);
        }), this._xrManager.enabled = true, this._viewer.renderer.composer.renderToScreen = true;
      }, this._frameCount = 0, this._lastTime = 0, this._preFrame = ({ xrFrame: e2, deltaTime: t2 }) => {
        var r2, n2;
        if (this.dirty = !!e2 && (null === (r2 = this._xrManager) || void 0 === r2 ? void 0 : r2.isPresenting) || false, this._viewer.scene.activeCamera.interactionsEnabled = !this._dirty, this._viewer.scene.activeCamera.autoLookAtTarget = !this._dirty, !this._dirty || !e2)
          return void (this._xrSession && this._xrSessionEnd());
        if (!this._xrSession && !this._xrManager.getSession())
          return console.error("no xr session found, shouldn't happen"), void (this.dirty = false);
        this._xrSession || console.log("webxr: AR session init"), this._frameCount++;
        const i2 = this._xrManager.getReferenceSpace(), s2 = e2.getViewerPose(i2);
        if (null == s2 && this._frameCount, null == s2 || 0 === (null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.scene.modelRoot.children.length))
          return this.dirty = false, void console.log("no pose or no model");
        if (!this._xrSession) {
          if (this._xrSession = this._xrManager.getSession() || void 0, !this._xrSession)
            return;
          this._frameCount = 0, this._cancelHitSources(), this._savePreXRState(), this._preSetupModel(), this._xrSessionStart();
        }
        const o2 = this._viewer.scene.activeCamera;
        this._xrManager.updateCamera(o2.cameraObject), o2.setDirty(), this.moveToFloor(e2), this._touchInputHelper.processInput(e2), this._touchInputHelper.moveScene(t2), this._updateShadow();
      }, this.placeOnWall = false, this._preXRState = { viewerBg: null, modelScale: new n.Pa4(1, 1, 1), modelPosition: new n.Pa4(), modelRotation: new n._fP(), cameraPosition: new n.Pa4(0, 0, 5), cameraTarget: new n.Pa4(), cameraUp: new n.Pa4(0, 1, 0), cameraAspect: 1, cameraFov: 50, cameraZoom: 1, cameraNear: 0.01, cameraFar: 100, groundOffset: new n.Pa4(), groundScale: 1 }, this._savePreXRState = () => {
        if (!this._viewer)
          return;
        this._preXRState.viewerBg = this._viewer.getBackground(true);
        const e2 = this._viewer.scene.modelRoot, t2 = this._viewer.scene.activeCamera;
        e2.updateMatrix(), e2.updateMatrixWorld(true), this._preXRState.modelScale.copy(e2.scale), this._preXRState.modelPosition.copy(e2.position), this._preXRState.modelRotation.copy(e2.quaternion), this._preXRState.cameraPosition.copy(t2.position), this._preXRState.cameraTarget.copy(t2.target), this._preXRState.cameraUp.copy(t2.cameraObject.up), t2.cameraObject.isPerspectiveCamera && (this._preXRState.cameraFov = t2.cameraObject.fov, this._preXRState.cameraAspect = t2.cameraObject.aspect), this._preXRState.cameraZoom = t2.cameraObject.zoom, this._preXRState.cameraNear = t2.cameraObject.near, this._preXRState.cameraFar = t2.cameraObject.far;
        const r2 = this._viewer.getPluginByType("Ground");
        (null == r2 ? void 0 : r2.mesh) && (this._preXRState.groundOffset.subVectors(e2.position, r2.mesh.modelObject.position), this._preXRState.groundScale = r2.mesh.modelObject.scale.x, console.log("ground offset", this._preXRState.groundOffset, this._preXRState.groundScale), r2.shadowBaker.enabled = false);
      }, this._xrSessionStart = () => {
        if (!this._xrSession || !this._viewer)
          return;
        console.log("webxr: AR session start");
        const e2 = 20 * Math.PI / 180, t2 = this.placeOnWall ? void 0 : new window.XRRay(new DOMPoint(0, 0, 0), { x: 0, y: -Math.sin(e2), z: -Math.cos(e2) });
        this._touchInputHelper.placeOnWall = this.placeOnWall, this._viewer.resize(), (async () => {
          var e3, r2;
          if (this._xrSession) {
            const n2 = await this._xrSession.requestReferenceSpace("viewer");
            this._hitTestSource = await (null === (r2 = (e3 = this._xrSession).requestHitTestSource) || void 0 === r2 ? void 0 : r2.call(e3, { space: n2, offsetRay: t2 }));
          }
          this._xrSession && await this._touchInputHelper.setSession(this._xrSession, this._viewer.scene.modelRoot, this._xrManager, this._placementBox);
        })();
      }, this._xrSessionEnd = () => {
        var e2;
        console.log("webxr: AR session end"), this._frameCount = 0, null === (e2 = this._xrSession) || void 0 === e2 || e2.removeEventListener("end", this._xrSessionEnd), this._xrSession = void 0, this._cancelHitSources(), this._viewer && (this._restorePreXRState(), this._viewer.resize());
      };
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const t2 = e2.renderer.rendererObject.xr;
      t2.enabled = true, t2.cameraAutoUpdate = false, this._xrManager = t2;
      const r2 = document.getElementById("tweakpaneUiContainer"), n2 = r2 ? { root: r2 } : void 0;
      document.body.appendChild(class {
        static createButton(e3, t3 = {}) {
          const r3 = document.createElement("button");
          function n3() {
            r3.style.display = "", r3.style.cursor = "auto", r3.style.left = "calc(50% - 75px)", r3.style.width = "150px", r3.onmouseenter = null, r3.onmouseleave = null, r3.onclick = null;
          }
          function i2(e4) {
            e4.style.position = "absolute", e4.style.bottom = "20px", e4.style.padding = "12px 6px", e4.style.border = "1px solid #fff", e4.style.borderRadius = "4px", e4.style.background = "rgba(0,0,0,0.1)", e4.style.color = "#fff", e4.style.font = "normal 13px sans-serif", e4.style.textAlign = "center", e4.style.opacity = "0.5", e4.style.outline = "none", e4.style.zIndex = "999";
          }
          if ("xr" in navigator)
            return r3.id = "ARButton", r3.style.display = "none", i2(r3), navigator.xr.isSessionSupported("immersive-ar").then(function(i3) {
              i3 ? function() {
                if (void 0 === t3.domOverlay) {
                  const e4 = document.createElement("div");
                  e4.style.display = "none", document.body.appendChild(e4);
                  const r4 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                  r4.setAttribute("width", 38), r4.setAttribute("height", 38), r4.style.position = "absolute", r4.style.right = "20px", r4.style.top = "20px", r4.addEventListener("click", function() {
                    n4.end();
                  }), e4.appendChild(r4);
                  const i5 = document.createElementNS("http://www.w3.org/2000/svg", "path");
                  i5.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), i5.setAttribute("stroke", "#fff"), i5.setAttribute("stroke-width", 2), r4.appendChild(i5), void 0 === t3.optionalFeatures && (t3.optionalFeatures = []), t3.optionalFeatures.push("dom-overlay"), t3.domOverlay = { root: e4 };
                }
                let n4 = null;
                async function i4(i5) {
                  i5.addEventListener("end", s2), e3.xr.setReferenceSpaceType("local"), await e3.xr.setSession(i5), r3.textContent = "STOP AR", t3.domOverlay.root.style.display = "", n4 = i5;
                }
                function s2() {
                  n4.removeEventListener("end", s2), r3.textContent = "START AR", t3.domOverlay.root.style.display = "none", n4 = null;
                }
                r3.style.display = "", r3.style.cursor = "pointer", r3.style.left = "calc(50% - 50px)", r3.style.width = "100px", r3.textContent = "START AR", r3.onmouseenter = function() {
                  r3.style.opacity = "1.0";
                }, r3.onmouseleave = function() {
                  r3.style.opacity = "0.5";
                }, r3.onclick = function() {
                  null === n4 ? navigator.xr.requestSession("immersive-ar", t3).then(i4) : n4.end();
                };
              }() : (n3(), r3.textContent = "AR NOT SUPPORTED");
            }).catch(function(e4) {
              n3(), console.warn("Exception when trying to call xr.isSessionSupported", e4), r3.textContent = "AR NOT ALLOWED";
            }), r3;
          {
            const e4 = document.createElement("a");
            return false === window.isSecureContext ? (e4.href = document.location.href.replace(/^http:/, "https:"), e4.innerHTML = "WEBXR NEEDS HTTPS") : (e4.href = "https://immersiveweb.dev/", e4.innerHTML = "WEBXR NOT AVAILABLE"), e4.style.left = "calc(50% - 90px)", e4.style.width = "180px", e4.style.textDecoration = "none", i2(e4), e4;
          }
        }
      }.createButton(e2.renderer.rendererObject, { requiredFeatures: ["hit-test"], optionalFeatures: ["dom-overlay"], domOverlay: n2 })), e2.addEventListener("preRender", this._preRender), e2.addEventListener("postRender", this._postRender), e2.addEventListener("preFrame", this._preFrame);
    }
    _updateShadow() {
      if (!this._viewer)
        return;
      const e2 = this._viewer.scene.modelRoot, t2 = this._viewer.getPluginByType("Ground");
      t2 && (t2.groundReflection = false, t2.mesh.modelObject.position.copy(this._preXRState.groundOffset).multiplyScalar(e2.modelObject.scale.x).sub(e2.modelObject.position).negate(), t2.mesh.modelObject.scale.setScalar(e2.modelObject.scale.x * this._preXRState.groundScale));
    }
    moveToFloor(e2) {
      if (!this._dirty || !this._hitTestSource || !this._xrManager)
        return;
      const t2 = e2.getHitTestResults(this._hitTestSource);
      if (!t2.length)
        return;
      const r2 = t2[0], n2 = this._touchInputHelper.getHitPoint(r2);
      n2 && (this._placementBox.show = true, this._viewer.scene.modelRoot, this.placeOnWall ? this._touchInputHelper.goalPosition.copy(n2) : this._touchInputHelper.goalPosition.y = n2.y, this._hitTestSource.cancel(), this._hitTestSource = void 0, console.log("move to initial hit point", n2));
    }
    _removePlacementBox() {
      this._placementBox && (this._placementBox.dispose(), this._placementBox = void 0);
    }
    _preSetupModel() {
      var e2;
      const t2 = this._viewer.scene.modelRoot, r2 = this._viewer.scene.activeCamera, i2 = null === (e2 = this._xrManager) || void 0 === e2 ? void 0 : e2.getCamera(), s2 = i2.cameras[0] || i2;
      this._removePlacementBox();
      const o2 = this._viewer.scene.getBounds(true, true);
      o2.getSize(new n.Pa4()).length() > 0.01 && (this._placementBox = new Py(o2, i2, this.placeOnWall), t2.add(this._placementBox), this._placementBox.show = false);
      const a2 = i2.getWorldDirection(new n.Pa4());
      t2.rotation.y = Math.atan2(-a2.x, -a2.z) - 0, r2.cameraObject.zoom = s2.zoom, r2.cameraObject.near = s2.near, r2.cameraObject.far = s2.far, r2.cameraObject.isPerspectiveCamera ? (r2.cameraObject.fov = s2.fov, r2.cameraObject.aspect = s2.viewport.width / s2.viewport.height) : console.warn("Perspective camera required."), r2.cameraObject.updateProjectionMatrix(), t2.position.set(0, 0, 0);
      const l2 = t2.userData.arScale || 1;
      t2.scale.set(l2, l2, l2), t2.position.copy(i2.position).add(a2.multiplyScalar(5)), t2.visible = true, this._viewer.setBackground(null);
    }
    _restorePreXRState() {
      if (!this._viewer)
        return;
      this._viewer.setBackground(this._preXRState.viewerBg), this._preXRState.viewerBg = null;
      const e2 = this._viewer.scene.modelRoot;
      e2.scale.copy(this._preXRState.modelScale), e2.position.copy(this._preXRState.modelPosition), e2.quaternion.copy(this._preXRState.modelRotation), e2.updateMatrix(), e2.updateMatrixWorld(true), e2.visible = true;
      const t2 = this._viewer.scene.activeCamera;
      t2.position.copy(this._preXRState.cameraPosition), t2.target.copy(this._preXRState.cameraTarget), t2.cameraObject.up.copy(this._preXRState.cameraUp), t2.cameraObject.near = this._preXRState.cameraNear, t2.cameraObject.far = this._preXRState.cameraFar, t2.cameraObject.isPerspectiveCamera && (void 0 !== this._preXRState.cameraFov && (t2.cameraObject.fov = this._preXRState.cameraFov), void 0 !== this._preXRState.cameraAspect && (t2.cameraObject.aspect = this._preXRState.cameraAspect)), t2.positionUpdated(false), t2.targetUpdated(true), t2.cameraObject.updateMatrixWorld(true), t2.cameraObject.updateProjectionMatrix();
    }
    _cancelHitSources() {
      this._hitTestSource && (this._hitTestSource.cancel(), this._hitTestSource = void 0), this._touchInputHelper.cancel();
    }
  }
  By.PluginType = "WEBXR_ARPlugin";
  const Ry = new c({ vertexShader: i.vertexShader, fragmentShader: "\n    uniform float opacity;\n\n		uniform sampler2D tDiffuse;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vec4 texel = texture2D( tDiffuse, vUv );\n			// gl_FragColor = vec4(1,0,1,1);\n			gl_FragColor = texel;\n\n		}\n		", uniforms: i.uniforms });
  async function Ly(e2, t2) {
    if (e2.createWriter) {
      const r3 = await e2.createWriter();
      return await r3.write(0, t2), void await r3.close();
    }
    const r2 = await e2.createWritable();
    await r2.write(t2), await r2.close();
  }
  async function Oy(e2, t2) {
    const r2 = {};
    return t2 && (r2.writable = true, r2.mode = "readwrite"), "granted" === await e2.queryPermission(r2) || "granted" === await e2.requestPermission(r2);
  }
  Ry.renderToScreen = false, Ry.useExistingRenderTarget = true, Ry.clear = false;
  class Fy extends r {
    constructor(e2, t2) {
      super(), this._state = "stopped", this._console = console, this._currentRecording = [], this._currentImages = [], this.stepMode = false, this._resumeSyncTime = 0, this._frameCount = 0, this._onstop = (e3) => {
        var t3;
        if (this._state = "stopped", this._recorder && this._currentRecording.length > 0) {
          const e4 = new Blob(this._currentRecording, { type: this._options.mimeType });
          null === (t3 = this._recordingCallback) || void 0 === t3 || t3.call(this, e4);
        } else
          this._currentImages.length > 0 && (this._writeImages([...this._currentImages]), this._currentImages = []);
        this._recorder = void 0, this.dispatchEvent({ type: "stop" });
      }, this._onstart = (e3) => {
        var t3;
        this._state = "recording", this._frameCount = 0, this.dispatchEvent({ type: "start" }), this.stepMode && (null === (t3 = this._recorder) || void 0 === t3 || t3.pause());
      }, this._onresume = (e3) => {
        if (!this.stepMode)
          return;
        const t3 = () => {
          var e4;
          "recording" === this._state && (null === (e4 = this._recorder) || void 0 === e4 || e4.pause());
        }, r3 = Math.min(this._resumeSyncTime - Dt(), 0) + 1e3 / this._options.frameRate;
        r3 > 0 ? Dc(r3).then(t3) : t3();
      }, this._onpause = (e3) => {
      }, this._ondataavailable = (e3) => {
        e3.data && e3.data.size > 0 && this._currentRecording.push(e3.data);
      }, this._onerror = (e3) => {
        this._state = "error", this._console.error(e3), this.dispatchEvent({ type: "error", error: e3 }), this._recorder = void 0;
      }, this._canvas = e2;
      const r2 = null == t2 ? void 0 : t2.mimeType;
      this._options = { mimeType: r2 || "auto", frameRate: 30 }, this._setOptions(t2 || this._options);
    }
    _setOptions(e2) {
      var t2, r2;
      Object.assign(this._options, e2), this._options.mimeType && "auto" !== this._options.mimeType || (this._options.mimeType = null !== (t2 = Fy.GetSupportedMimeTypes([], ["h264"], true)) && void 0 !== t2 ? t2 : Fy.GetSupportedMimeTypes(void 0, void 0, true)), this._options.mimeType && !(null === (r2 = this._options.mimeType) || void 0 === r2 ? void 0 : r2.startsWith("video/")) || window.MediaRecorder || (this._console.warn("MediaRecorder is not supported, switching to png"), this._options.mimeType = "image/png"), this._options.mimeType || console.warn(new Error("No supported mimetype found"));
    }
    setOptions(e2) {
      this._setOptions(e2);
    }
    isRecording() {
      return "recording" === this._state;
    }
    start() {
      var e2, t2, r2;
      if ("recording" === this._state)
        return void this._console.log("Already recording canvas");
      if ("error" === this._state && (this._recorder = void 0, this._console.warn("Resetting from error state.")), this._recorder)
        return "paused" === this._state ? (this.dispatchEvent({ type: "starting" }), void this._recorder.resume()) : void this._console.warn("Canvas recorder unknown state", this._state);
      if ("paused" === this._state)
        return this.dispatchEvent({ type: "starting" }), void (this._state = "recording");
      const n2 = { mimeType: this._options.mimeType, videoBitsPerSecond: this._options.videoBitsPerSecond };
      if (this._currentRecording = [], this._currentImages = [], this._frameCount = 0, null === (e2 = n2.mimeType) || void 0 === e2 ? void 0 : e2.startsWith("video")) {
        if (!window.MediaRecorder)
          return this._console.error("MediaRecorder not supported, use image sequence"), void (this._state = "error");
        {
          const e3 = this._canvas.captureStream(this.stepMode ? 0 : this._options.frameRate), r3 = null === (t2 = e3.getVideoTracks()) || void 0 === t2 ? void 0 : t2[0];
          this._track = r3, this._recorder = new window.MediaRecorder(e3, n2), this._recorder.onstop = this._onstop, this._recorder.ondataavailable = this._ondataavailable, this._recorder.onerror = this._onerror, this._recorder.onresume = this._onresume, this._recorder.onstart = this._onstart;
        }
      }
      this.dispatchEvent({ type: "starting" }), this._recorder ? (this._state = "recording", null === (r2 = this._recorder) || void 0 === r2 || r2.start()) : window.showDirectoryPicker && window.showDirectoryPicker().then(async (e3) => {
        const t3 = await (null == e3 ? void 0 : e3.getDirectoryHandle("i-" + Math.floor(Date.now()), { create: true }));
        this._imgDirectory = t3, this._state = "recording", this._onstart({});
      }).catch((e3) => {
        this._onerror({ detail: e3 });
      });
    }
    async requestFrame() {
      if ("recording" !== this._state)
        return;
      this._frameCount++;
      const e2 = this._options.mimeType;
      if (!this._recorder && e2.startsWith("image/")) {
        const t2 = this._canvas.toDataURL(e2, 90);
        this._currentImages.push(["frame_" + String(this._frameCount).padStart(5, "0") + (e2.includes("png") ? ".png" : ".jpg"), t2]), this._currentImages.length > 60 && (this._writeImages([...this._currentImages]), this._currentImages = []);
      }
      this._recorder && this._track && this.stepMode && (this._resumeSyncTime = Dt(), this._track.requestFrame(), this._recorder.resume());
    }
    pause() {
      "paused" !== this._state && "stopped" !== this._state && (this._recorder ? this._recorder.pause() : this._state = "paused");
    }
    stop(e2) {
      "stopped" !== this._state && ("error" !== this._state ? (this._recordingCallback = e2, this.dispatchEvent({ type: "stopping" }), this._recorder ? this._recorder.stop() : this._onstop({})) : this._console.error("Recorder in error state, cannot stop, call start again."));
    }
    get state() {
      return this._state;
    }
    dispose() {
      this._recorder && "error" !== this._state ? this.stop((e2) => {
        this._console.warn("disposed with blob", e2), this.dispose();
      }) : this._recorder = void 0;
    }
    async _writeImages(e2) {
      if (!this._imgDirectory)
        return;
      const t2 = await Promise.all(e2.map(async ([e3, t3]) => await (await fetch(t3)).blob())), r2 = [];
      for (let n2 = 0; n2 < e2.length; n2++) {
        const i2 = await this._imgDirectory.getFileHandle(e2[n2][0], { create: true });
        r2.push(Ly(i2, t2[n2]));
      }
      await Promise.all(r2);
    }
    static GetSupportedMimeTypes(e2, t2, r2 = false) {
      if (!window.MediaRecorder)
        return r2 ? void 0 : [];
      const n2 = ["webm", "ogg", "mp4", "x-matroska"].filter((t3) => !e2 || e2.length < 1 || e2.includes(t3)), i2 = ["vp9", "vp9.0", "vp8", "vp8.0", "avc1", "av1", "h265", "h.265", "h264", "h.264", "opus"].filter((e3) => !t2 || t2.length < 1 || t2.includes(e3)), s2 = [];
      return n2.forEach((e3) => {
        const t3 = `video/${e3}`;
        i2.forEach((e4) => {
          [`${t3};codecs=${e4}`, `${t3};codecs:${e4}`, `${t3};codecs=${e4.toUpperCase()}`, `${t3};codecs:${e4.toUpperCase()}`, `${t3}`].forEach((e5) => {
            MediaRecorder.isTypeSupported(e5) && s2.push(e5);
          });
        });
      }), r2 ? s2.length > 0 ? s2[0] : void 0 : s2;
    }
  }
  var Uy = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class Ny extends ro {
    constructor() {
      super(...arguments), this.enabled = true, this.convergeMode = false, this.mimeType = "auto", this.videoFrameRate = 30, this._renderToScreenDisabled = false, this._preRender = () => {
        var e2, t2, r2;
        if (this.convergeMode && (null === (e2 = this._recorder) || void 0 === e2 ? void 0 : e2.isRecording())) {
          const e3 = this._viewer.renderer.composer.renderToScreen;
          this._viewer.renderer.composer.renderToScreen = (null === (r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Progressive")) || void 0 === r2 ? void 0 : r2.isConverged()) || false, e3 && !this._viewer.renderer.composer.renderToScreen && (this._renderToScreenDisabled = true);
        }
      }, this._postRender = () => {
        var e2, t2, r2;
        if ((null === (e2 = this._recorder) || void 0 === e2 ? void 0 : e2.isRecording()) && (!this.convergeMode || (null === (r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Progressive")) || void 0 === r2 ? void 0 : r2.isConverged(true)))) {
          const e3 = () => {
            var e4;
            return null === (e4 = this._recorder) || void 0 === e4 ? void 0 : e4.requestFrame();
          };
          this.convergeMode ? Dc(1).then(e3) : e3();
        }
        this._renderToScreenDisabled && (this._viewer.renderer.composer.renderToScreen = true);
      };
    }
    get recorder() {
      return this._recorder;
    }
    isRecording() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._recorder) || void 0 === e2 ? void 0 : e2.isRecording()) && void 0 !== t2 && t2;
    }
    refreshRecorderOptions() {
      this._recorder && (this._recorder.setOptions({ frameRate: this.videoFrameRate, mimeType: this.mimeType }), this._recorder.stepMode = this.convergeMode);
    }
    async onAdded(e2) {
      await super.onAdded(e2), this._recorder = new Fy(e2.canvas, { frameRate: this.videoFrameRate, mimeType: this.mimeType }), e2.addEventListener("preRender", this._preRender), e2.addEventListener("postRender", this._postRender), this._recorder.addEventListener("starting", () => this._stateChange(false)), this._recorder.addEventListener("start", () => {
        this.dispatchEvent({ type: "start" }), this._stateChange(!this.convergeMode);
      }), this._recorder.addEventListener("error", () => {
        this.dispatchEvent({ type: "error" });
      }), this._recorder.addEventListener("pause", () => this._stateChange(false)), this._recorder.addEventListener("resume", () => this._stateChange(!this.convergeMode)), this._recorder.addEventListener("stop", () => {
        this.dispatchEvent({ type: "stop" }), this._stateChange(false);
      });
    }
    _stateChange(e2) {
      var t2, r2, n2;
      this.dirty = e2, null === (t2 = this._viewer) || void 0 === t2 || t2.setDirty(), null === (n2 = null === (r2 = this._uiConfig) || void 0 === r2 ? void 0 : r2.children) || void 0 === n2 || n2.map((e3) => A(e3)).flat(2).forEach((e3) => {
        var t3;
        return null === (t3 = null == e3 ? void 0 : e3.uiRefresh) || void 0 === t3 ? void 0 : t3.call(e3);
      });
    }
    async onRemove(e2) {
      var t2;
      return e2.removeEventListener("preRender", this._preRender), e2.removeEventListener("preRender", this._postRender), null === (t2 = this._recorder) || void 0 === t2 || t2.dispose(), super.onRemove(e2);
    }
    startRecording() {
      var e2;
      return !!this.enabled && false === (null === (e2 = this.recorder) || void 0 === e2 ? void 0 : e2.isRecording()) && (this.recorder.stepMode = this.convergeMode, this.recorder.start(), true);
    }
    async stopRecording() {
      var e2;
      if (null === (e2 = this.recorder) || void 0 === e2 ? void 0 : e2.isRecording())
        return new Promise((e3, t2) => {
          var r2;
          return null === (r2 = this.recorder) || void 0 === r2 ? void 0 : r2.stop(e3);
        });
    }
    get uiConfig() {
      if (this._uiConfig)
        return this._uiConfig;
      const e2 = this;
      return this._uiConfig = { type: "folder", label: "Video Export", children: [{ type: "slider", label: "Frame Rate", bounds: [1, 60], stepSize: 1, property: [this, "videoFrameRate"] }, { type: "checkbox", limitedUi: true, property: [this, "convergeMode"] }, { type: "dropdown", label: "Mime type", limitedUi: true, property: [this, "mimeType"], children: [["Auto Video (x264)", "auto"], ["PNG sequence", "image/png"], ["JPEG sequence", "image/jpeg"]].map((e3) => ({ label: e3[0], value: e3[1] })) }, { type: "input", disabled: true, label: "State", limitedUi: true, get value() {
        var t2, r2;
        return null !== (r2 = null === (t2 = e2.recorder) || void 0 === t2 ? void 0 : t2.state) && void 0 !== r2 ? r2 : "not initialized";
      }, set value(e3) {
      } }, { type: "button", get label() {
        var t2;
        return (null === (t2 = e2.recorder) || void 0 === t2 ? void 0 : t2.isRecording()) ? "Stop" : "Start";
      }, value: () => {
        var t2;
        (null === (t2 = e2.recorder) || void 0 === t2 ? void 0 : t2.isRecording()) ? this.stopRecording().then((e3) => {
          if (e3) {
            console.log(e3);
            const t3 = e3.type.split(";")[0].split("/").pop() || "mp4";
            yt(e3, "test." + t3);
          }
        }) : this.startRecording();
      } }, { type: "button", limitedUi: true, label: "Record Camera Views", hidden: () => {
        var t2, r2;
        return !!(null === (t2 = e2.recorder) || void 0 === t2 ? void 0 : t2.isRecording()) || !(null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.getPluginByType("CameraViews"));
      }, value: () => {
        var e3, t2;
        null === (t2 = null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.getPluginByType("CameraViews")) || void 0 === t2 || t2.recordAllViews();
      } }, { type: "button", limitedUi: true, label: "Record Camera Views + GLTF Anim", hidden: () => {
        var t2, r2, n2, i2;
        return !!(null === (t2 = e2.recorder) || void 0 === t2 ? void 0 : t2.isRecording()) || !(null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.getPluginByType("CameraViews")) || !(null === (i2 = null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.getPluginByType("GLTFAnimation")) || void 0 === i2 ? void 0 : i2.animations.length);
      }, value: () => {
        var e3, t2, r2, n2;
        const i2 = "playing" === (null === (t2 = null === (e3 = this._viewer) || void 0 === e3 ? void 0 : e3.getPluginByType("GLTFAnimation")) || void 0 === t2 ? void 0 : t2.animationState);
        null === (n2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.getPluginByType("CameraViews")) || void 0 === n2 || n2.recordAllViews(() => {
          var e4, t3;
          null === (t3 = null === (e4 = this._viewer) || void 0 === e4 ? void 0 : e4.getPluginByType("GLTFAnimation")) || void 0 === t3 || t3.playAnimation();
        }).then(() => {
          var e4, t3;
          i2 || null === (t3 = null === (e4 = this._viewer) || void 0 === e4 ? void 0 : e4.getPluginByType("GLTFAnimation")) || void 0 === t3 || t3.stopAnimation();
        });
      } }] };
    }
  }
  Ny.PluginType = "CanvasRecorder", Uy([M(Ny.prototype.refreshRecorderOptions), Ce()], Ny.prototype, "convergeMode", void 0), Uy([M(Ny.prototype.refreshRecorderOptions), Ce()], Ny.prototype, "mimeType", void 0), Uy([M(Ny.prototype.refreshRecorderOptions), Ce()], Ny.prototype, "videoFrameRate", void 0);
  var jy = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  const zy = new n.jyz({ uniforms: { tDiffuse: { value: null }, h: { value: 1 / 512 } }, vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}", fragmentShader: "\n\n		uniform sampler2D tDiffuse;\n		uniform float h;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vec4 sum = vec4( 0.0 );\n\n			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n			gl_FragColor = sum;\n\n		}" });
  zy.depthTest = false;
  const Gy = new n.jyz({ uniforms: { tDiffuse: { value: null }, v: { value: 1 / 512 } }, vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}", fragmentShader: "\n\n		uniform sampler2D tDiffuse;\n		uniform float v;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vec4 sum = vec4( 0.0 );\n\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n			gl_FragColor = sum;\n\n		}" });
  Gy.depthTest = false;
  class Vy extends fu {
    constructor(e2 = {}, t2 = false) {
      super(e2), this.contactShadows = true, this.blurAmount = 1, this.shadowScale = 1, this.shadowHeight = 5, this.shadowCamera = new n.iKG(-1, 1, 1, -1, 1e-3, this.shadowHeight), this._refreshShadowCameraFrustum = this._refreshShadowCameraFrustum.bind(this), this.refreshOptions = this.refreshOptions.bind(this), this._showDebug = t2, t2 && this.dependencies.push(Yc);
    }
    async onAdded(e2) {
      const t2 = e2.renderer.createTarget({ type: n.ywz, format: n.wk1, encoding: n.rnI, size: { width: 512, height: 512 }, generateMipmaps: false, depthBuffer: true, minFilter: n.wem, magFilter: n.wem });
      t2.texture.name = "groundContactDepthTexture";
      const r2 = new n.lRF({ depthPacking: n.z81 });
      r2.onBeforeCompile = function(e3) {
        e3.uniforms.opacity.value = 1, e3.fragmentShader = `
						${e3.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), 1.0 );")}
					`;
      };
      const i2 = new ao(t2, r2);
      this._depthPass = i2, await super.onAdded(e2);
    }
    _postFrame() {
      super._postFrame(), this._viewer;
    }
    _preRender() {
      if (super._preRender(), !this._viewer)
        return;
      if (!this._depthPass)
        return;
      this._depthPass.scene = this._viewer.scene.modelObject, this._depthPass.camera = this.shadowCamera, this._depthPass.render(this._viewer.renderer.rendererObject);
      const e2 = this._viewer.renderer.getTempTarget({ type: n.ywz, format: n.wk1, encoding: n.rnI, size: { width: 1024, height: 1024 }, generateMipmaps: false, depthBuffer: false, minFilter: n.wem, magFilter: n.wem });
      this._blurShadow(e2), this._blurShadow(e2, 0.4), this._viewer.renderer.releaseTempTarget(e2);
    }
    _blurShadow(e2, t2 = 1) {
      this._viewer && this._depthPass && (zy.uniforms.h.value = t2 * this.blurAmount / 256, Gy.uniforms.v.value = t2 * this.blurAmount / 256, this._viewer.renderer.blit(this._depthPass.target.texture, e2, { material: zy, clear: true }), this._viewer.renderer.blit(e2.texture, this._depthPass.target, { material: Gy, clear: true }));
    }
    async onDispose(e2) {
      return super.onDispose(e2);
    }
    async onRemove(e2) {
      return super.onRemove(e2);
    }
    _refreshTransform() {
      super._refreshTransform(), this._mesh && this._viewer && (this.shadowCamera.position.copy(this._mesh.getWorldPosition(new n.Pa4())), this.shadowCamera.setRotationFromEuler(new n.USm(Math.PI / 2, 0, 0)), this.shadowCamera.updateMatrixWorld(), this._refreshShadowCameraFrustum(), this._mesh.scale.y = -this.size);
    }
    _refreshShadowCameraFrustum() {
      this.shadowCamera && (this.shadowCamera.left = -this.size / (2 * this.shadowScale), this.shadowCamera.right = this.size / (2 * this.shadowScale), this.shadowCamera.top = this.size / (2 * this.shadowScale), this.shadowCamera.bottom = -this.size / (2 * this.shadowScale), this.shadowCamera.far = this.shadowHeight, this.shadowCamera.updateProjectionMatrix(), this._setDirty());
    }
    _setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    _removeMaterial() {
      this._material && super._removeMaterial();
    }
    refreshOptions() {
      this._viewer && super.refreshOptions();
    }
    _refreshMaterial() {
      var e2;
      if (!this._viewer)
        return false;
      const t2 = super._refreshMaterial();
      return this._material ? (this._material.alphaMap = (null === (e2 = this._depthPass) || void 0 === e2 ? void 0 : e2.target.texture) || null, t2 && (this._material.roughness = 1, this._material.metalness = 0, this._material.color.set(1118481), this._material.transparent = true, this._material.materialObject.userData.ssreflDisabled = true, this._material.materialObject.userData.ssreflNonPhysical = false), t2) : t2;
    }
    _extraUiConfig() {
      return [{ label: "Contact Shadows", type: "checkbox", property: [this, "contactShadows"] }, { label: "Shadow Scale", type: "slider", bounds: [0, 2], property: [this, "shadowScale"] }, { label: "Shadow Height", type: "slider", bounds: [0, 20], property: [this, "shadowHeight"] }, { label: "Blur Amount", type: "slider", bounds: [0, 10], property: [this, "blurAmount"] }, ...super._extraUiConfig()];
    }
  }
  Vy.PluginType = "ContactShadowGroundPlugin", jy([M(Vy.prototype.refreshOptions), Ce()], Vy.prototype, "contactShadows", void 0), jy([Ce(), M(Vy.prototype._setDirty)], Vy.prototype, "blurAmount", void 0), jy([Ce(), M(Vy.prototype._refreshShadowCameraFrustum)], Vy.prototype, "shadowScale", void 0), jy([Ce(), M(Vy.prototype._refreshShadowCameraFrustum)], Vy.prototype, "shadowHeight", void 0);
  const Qy = new n.cPb(45, 1, 0.1, 1e3);
  function Hy(e2, t2, r2, i2 = 7, s2 = new n.Pa4(0, 0, 1.5)) {
    r2 = null != r2 ? r2 : e2.scene.modelObject;
    const o2 = new k().expandByObject(null != r2 ? r2 : t2, true, true), a2 = o2.getCenter(new n.Pa4()), l2 = o2.getSize(new n.Pa4());
    Qy.position.copy(a2).add(s2.clone().multiplyScalar(Math.max(l2.x, l2.y, l2.z))), Qy.lookAt(a2), t2 && t2.traverseVisible((e3) => {
      e3.layers.enable(i2);
    }), i2 > 0 ? Qy.layers.set(i2) : Qy.layers.enableAll();
    const c2 = null == t2 ? void 0 : t2.visible;
    t2 && (t2.visible = true), e2.renderer.rendererObject.setRenderTarget(null), e2.renderer.rendererObject.render(r2, Qy);
    const u2 = e2.renderer.rendererObject.domElement.toDataURL("image/png");
    return t2 && (t2.visible = c2, t2.traverseVisible((e3) => {
      e3.layers.disable(i2);
    }), Qy.layers.enableAll()), e2.setDirty(), u2;
  }
  class Wy {
    constructor(e2) {
      this.viewer = e2, this._lights = [], this.shapes = { sphere: new n.Kj0(new n.xo$(1)), cube: new n.Kj0(new n.DvJ(1, 1, 1)), cylinder: new n.Kj0(new n.fHI(0.5, 0.5, 1)) };
      const t2 = new n.xsS();
      this._channel = 7;
      const r2 = new n.vmT(16777215, 4473924, 1);
      r2.position.set(0, 10, 0), r2.layers.set(this._channel), t2.add(r2), this._lights.push(r2), this._scene = t2;
    }
    dispose() {
      [...this._lights].forEach((e2) => e2.dispose()), Object.values(this.shapes).forEach((e2) => {
        e2.geometry && e2.geometry.dispose();
      });
    }
    generate(e2, t2 = "sphere") {
      const r2 = this.shapes[t2] || new n.Kj0(new n.xo$(1));
      r2.material = e2.materialObject, r2.geometry.attributes.tangent || r2.geometry.computeTangents(), this._scene.add(r2), this._scene.environment = this.viewer.scene.getEnvironment();
      const i2 = r2.material.envMapIntensity;
      "number" == typeof i2 && (r2.material.envMapIntensity = Math.max(i2, 2));
      const s2 = Hy(this.viewer, r2, this._scene, this._channel, new n.Pa4(0, 0, 1.5));
      return "number" == typeof i2 && (r2.material.envMapIntensity = i2), this._scene.remove(r2), r2.material = void 0, s2;
    }
  }
  class qy extends ro {
    constructor() {
      super(...arguments), this.enabled = true, this._uiNeedRefresh = false, this._refreshUiConfig = () => {
        var e2, t2;
        this.enabled && (null === (t2 = (e2 = this.uiConfig).uiRefresh) || void 0 === t2 || t2.call(e2));
      }, this.dependencies = [to], this.variations = [], this._selectedMaterial = () => {
        var e2, t2;
        return (null === (t2 = null === (e2 = this._picking) || void 0 === e2 ? void 0 : e2.getSelectedObject()) || void 0 === t2 ? void 0 : t2.material) || void 0;
      }, this.uiConfig = { label: "Material Configurator", type: "folder", children: [() => {
        var e2;
        return [{ type: "input", label: "uuid", property: [this._selectedMaterial(), "uuid"], hidden: () => !this._selectedMaterial(), disabled: true }, { type: "input", label: "title", hidden: () => !this._selectedMaterial(), property: () => [this.getSelectedVariation(), "title"], onChange: async () => this.refreshUi() }, { type: "dropdown", label: "Preview Type", hidden: () => !this._selectedMaterial(), property: () => [this.getSelectedVariation(), "preview"], onChange: async () => this.refreshUi(), children: ["generate:sphere", "generate:cube", "color", "map", "emissive", ...Object.keys(Xt).filter((e3) => e3.endsWith("Map"))].map((e3) => ({ label: e3, value: e3 })) }, ...(null === (e2 = this.getSelectedVariation()) || void 0 === e2 ? void 0 : e2.materials.map((e3) => e3.uiConfig ? Object.assign(e3.uiConfig, { expanded: false }) : {})) || [], { type: "button", label: "Remove All", hidden: () => !this._selectedMaterial(), value: async () => {
          const e3 = this.getSelectedVariation();
          e3 && await this._viewer.confirm("Material configurator: Remove all variations for this material?") && (e3.materials = []), this.refreshUi();
        } }, { type: "button", label: "Remove Variation", hidden: () => !this._selectedMaterial(), value: async () => {
          const e3 = this.getSelectedVariation();
          e3 && await this._viewer.confirm("Material configurator: Remove this variation?") && this.removeVariation(e3);
        } }, { type: "button", label: "Add Variation", hidden: () => !this._selectedMaterial(), value: () => this.addVariation(this._selectedMaterial()) }, { type: "button", label: "Refresh Ui", value: () => this.refreshUi() }];
      }] };
    }
    async onAdded(e2) {
      var t2, r2;
      await super.onAdded(e2), this.refreshUi = this.refreshUi.bind(this), this._refreshUi = this._refreshUi.bind(this), this._picking = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Picking"), this._previewGenerator = new Wy(this._viewer), null === (r2 = this._picking) || void 0 === r2 || r2.addEventListener("selectedObjectChanged", this._refreshUiConfig), e2.addEventListener("preFrame", this._refreshUi), this.addEventListener("deserialize", this.refreshUi);
    }
    fromJSON(e2, t2) {
      return this.variations = [], super.fromJSON(e2, t2);
    }
    async onRemove(e2) {
      var t2, r2;
      return null === (t2 = this._previewGenerator) || void 0 === t2 || t2.dispose(), this._previewGenerator = void 0, null === (r2 = this._picking) || void 0 === r2 || r2.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this.removeEventListener("deserialize", this.refreshUi), e2.removeEventListener("preFrame", this._refreshUi), this._picking = void 0, super.onRemove(e2);
    }
    findVariation(e2) {
      return e2 ? this.variations.find((t2) => t2.uuid === e2) : void 0;
    }
    getSelectedVariation() {
      var e2, t2;
      return this.findVariation(null === (e2 = this._selectedMaterial()) || void 0 === e2 ? void 0 : e2.uuid) || this.findVariation(null === (t2 = this._selectedMaterial()) || void 0 === t2 ? void 0 : t2.name);
    }
    applyVariation(e2, t2) {
      var r2, n2;
      const i2 = e2.materials.find((e3) => e3.uuid === t2);
      if (i2) {
        const t3 = null === (n2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.getManager()) || void 0 === n2 ? void 0 : n2.materials;
        let s2 = null == t3 ? void 0 : t3.findMaterialsByName(e2.uuid);
        (!s2 || s2.length < 1) && (s2 = [null == t3 ? void 0 : t3.findMaterial(e2.uuid)]), s2.forEach((e3) => {
          if (!e3)
            return;
          const t4 = e3.name;
          e3.copyProps(i2), e3.name = t4;
        });
      }
    }
    refreshUi() {
      this.enabled && (this._uiNeedRefresh = true);
    }
    async _refreshUi() {
      return !(!this.enabled || !this._viewer || !this._uiNeedRefresh || (this._uiNeedRefresh = false, this._refreshUiConfig(), 0));
    }
    removeVariationForMaterial(e2) {
      let t2 = this.findVariation(e2.uuid);
      !t2 && e2.name.length > 0 && (t2 = this.findVariation(e2.name)), t2 && this.removeVariation(t2);
    }
    removeVariation(e2) {
      e2 && (this.variations.splice(this.variations.indexOf(e2), 1), this.refreshUi());
    }
    addVariation(e2) {
      var t2;
      const r2 = null === (t2 = null == e2 ? void 0 : e2.clone) || void 0 === t2 ? void 0 : t2.call(e2);
      if (e2 && r2) {
        let t3 = this.findVariation(e2.uuid);
        !t3 && e2.name.length > 0 && (t3 = this.findVariation(e2.name)), t3 || this.variations.push(t3 = { uuid: e2.name.length > 0 ? e2.name : e2.uuid, title: "Name", preview: "generate:sphere", materials: [] }), t3.materials.push(r2), this.refreshUi();
      }
    }
  }
  qy.PluginType = "MaterialConfiguratorBasePlugin", function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, r2, o2);
  }([Ce()], qy.prototype, "variations", void 0);
  const Xy = (e2, t2 = true) => {
    const r2 = new Ae().set(e2);
    return t2 && r2.convertLinearToSRGB(), `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='16' height='16' fill='%23${r2.getHexString()}'/%3E%3C/svg%3E%0A`;
  }, Yy = (e2, t2 = true) => {
    const r2 = new Ae().set(e2);
    return t2 && r2.convertLinearToSRGB(), `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='8' cy='8' r='7' fill='%23${r2.getHexString()}'/%3E%3C/svg%3E%0A`;
  }, Ky = (e2) => `data:image/svg+xml,%3Csvg viewBox='0 0 80 14' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext style='font: 8px "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace; fill: white;' x='9' y='9'%3E${e2}%3C/text%3E%3C/svg%3E%0A`, Jy = async (e2, t2) => Ot(await Ct(e2), t2), Zy = async (e2, t2) => await Jy(e2, t2).then((e3) => e3.toDataURL("image/png"));
  class $y {
    static _initialize() {
      this._inited = true, Mt(E`
  .customContextGrid {
    background: #28223C;
    //backdrop-filter: blur(8px);
    border: 0.5px solid rgba(220, 220, 220, 0.3);
    width: auto;
    height: auto;
    position: absolute;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    z-index: 200;
    padding: 0.35rem 0.35rem;
    border-radius: 0.375rem;
    min-width: 5rem;
    pointer-events: auto;
    box-shadow: 0px 2px 10px rgba(12, 12, 12, 0.2);

    color: white;
    font-size: 0.65rem;
    font-family: Inter, "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
  }
  .customContextGridItems {
    background-color: transparent;
    cursor: pointer;
    border-radius: 0.25rem;
    line-height: 1rem;
    font-weight: 500;
    overflow: hidden;
    margin: 0.12rem;
  }
  .customContextGridItems:hover {
    color: white;
    background-color: #017AFF;
  }
  .customContextGridItemImage{
    width: 100%;
    height: 100%;
  }
  .customContextGridHeading{
    width: 100%;
    padding: 0.12rem;
    font-size: 0.85rem;
  }

        `);
    }
    static Create(e2, t2, r2, n2, i2, s2, o2) {
      var a2;
      this._inited || this._initialize();
      const l2 = Pt(), c2 = l2 ? 0.15 : 0.25, u2 = l2 ? 1.5 : 2.5, h2 = St({ classList: ["customContextGrid"], addToBody: false, innerHTML: `
            <div class="customContextGridHeading"> ${t2} </div>
            ` });
      h2.style.top = i2 + "px", h2.style.left = n2 + "px", h2.style.gap = c2 + "rem", h2.style.width = (u2 + c2) * r2 - c2 + "rem", h2.dataset.tag = e2;
      for (const e3 of s2) {
        const t3 = St({ classList: ["customContextGridItems"], addToBody: false, innerHTML: `
            <img src="${e3.image}" class="customContextGridItemImage">
            ` });
        t3.style.width = u2 + "rem", t3.style.height = u2 + "rem", h2.appendChild(t3), t3.onclick = () => {
          var t4;
          return null === (t4 = e3.onClick) || void 0 === t4 ? void 0 : t4.call(e3, e3.id);
        }, o2(t3, e3);
      }
      return null === (a2 = this.Elements) || void 0 === a2 || a2.push(h2), h2;
    }
    static RemoveAll(e2) {
      if (e2) {
        const t2 = this.Elements.filter((t3) => t3.dataset.tag === e2);
        for (const e3 of t2)
          e3.remove();
        this.Elements = this.Elements.filter((t3) => t3.dataset.tag !== e2);
      } else {
        for (const e3 of this.Elements)
          e3.remove();
        this.Elements = [];
      }
    }
    static RebuildUi(e2) {
      if (0 === this.Elements.length)
        return;
      e2 || (e2 = document.body);
      for (const e3 of this.Elements)
        e3.remove();
      let t2 = 20;
      for (const r2 of this.Elements)
        r2.style.top = t2 + "px", e2.appendChild(r2), t2 += r2.clientHeight + 20;
    }
  }
  function ex(e2) {
    if (null == e2)
      return window;
    if ("[object Window]" !== e2.toString()) {
      var t2 = e2.ownerDocument;
      return t2 && t2.defaultView || window;
    }
    return e2;
  }
  function tx(e2) {
    return e2 instanceof ex(e2).Element || e2 instanceof Element;
  }
  function rx(e2) {
    return e2 instanceof ex(e2).HTMLElement || e2 instanceof HTMLElement;
  }
  function nx(e2) {
    return "undefined" != typeof ShadowRoot && (e2 instanceof ex(e2).ShadowRoot || e2 instanceof ShadowRoot);
  }
  $y.Elements = [], $y._inited = false;
  var ix = Math.max, sx = Math.min, ox = Math.round;
  function ax(e2, t2) {
    void 0 === t2 && (t2 = false);
    var r2 = e2.getBoundingClientRect(), n2 = 1, i2 = 1;
    if (rx(e2) && t2) {
      var s2 = e2.offsetHeight, o2 = e2.offsetWidth;
      o2 > 0 && (n2 = ox(r2.width) / o2 || 1), s2 > 0 && (i2 = ox(r2.height) / s2 || 1);
    }
    return { width: r2.width / n2, height: r2.height / i2, top: r2.top / i2, right: r2.right / n2, bottom: r2.bottom / i2, left: r2.left / n2, x: r2.left / n2, y: r2.top / i2 };
  }
  function lx(e2) {
    var t2 = ex(e2);
    return { scrollLeft: t2.pageXOffset, scrollTop: t2.pageYOffset };
  }
  function cx(e2) {
    return e2 ? (e2.nodeName || "").toLowerCase() : null;
  }
  function ux(e2) {
    return ((tx(e2) ? e2.ownerDocument : e2.document) || window.document).documentElement;
  }
  function hx(e2) {
    return ax(ux(e2)).left + lx(e2).scrollLeft;
  }
  function px(e2) {
    return ex(e2).getComputedStyle(e2);
  }
  function dx(e2) {
    var t2 = px(e2), r2 = t2.overflow, n2 = t2.overflowX, i2 = t2.overflowY;
    return /auto|scroll|overlay|hidden/.test(r2 + i2 + n2);
  }
  function fx(e2, t2, r2) {
    void 0 === r2 && (r2 = false);
    var n2, i2, s2 = rx(t2), o2 = rx(t2) && function(e3) {
      var t3 = e3.getBoundingClientRect(), r3 = ox(t3.width) / e3.offsetWidth || 1, n3 = ox(t3.height) / e3.offsetHeight || 1;
      return 1 !== r3 || 1 !== n3;
    }(t2), a2 = ux(t2), l2 = ax(e2, o2), c2 = { scrollLeft: 0, scrollTop: 0 }, u2 = { x: 0, y: 0 };
    return (s2 || !s2 && !r2) && (("body" !== cx(t2) || dx(a2)) && (c2 = (n2 = t2) !== ex(n2) && rx(n2) ? { scrollLeft: (i2 = n2).scrollLeft, scrollTop: i2.scrollTop } : lx(n2)), rx(t2) ? ((u2 = ax(t2, true)).x += t2.clientLeft, u2.y += t2.clientTop) : a2 && (u2.x = hx(a2))), { x: l2.left + c2.scrollLeft - u2.x, y: l2.top + c2.scrollTop - u2.y, width: l2.width, height: l2.height };
  }
  function mx(e2) {
    var t2 = ax(e2), r2 = e2.offsetWidth, n2 = e2.offsetHeight;
    return Math.abs(t2.width - r2) <= 1 && (r2 = t2.width), Math.abs(t2.height - n2) <= 1 && (n2 = t2.height), { x: e2.offsetLeft, y: e2.offsetTop, width: r2, height: n2 };
  }
  function _x(e2) {
    return "html" === cx(e2) ? e2 : e2.assignedSlot || e2.parentNode || (nx(e2) ? e2.host : null) || ux(e2);
  }
  function gx(e2) {
    return ["html", "body", "#document"].indexOf(cx(e2)) >= 0 ? e2.ownerDocument.body : rx(e2) && dx(e2) ? e2 : gx(_x(e2));
  }
  function vx(e2, t2) {
    var r2;
    void 0 === t2 && (t2 = []);
    var n2 = gx(e2), i2 = n2 === (null == (r2 = e2.ownerDocument) ? void 0 : r2.body), s2 = ex(n2), o2 = i2 ? [s2].concat(s2.visualViewport || [], dx(n2) ? n2 : []) : n2, a2 = t2.concat(o2);
    return i2 ? a2 : a2.concat(vx(_x(o2)));
  }
  function Ax(e2) {
    return ["table", "td", "th"].indexOf(cx(e2)) >= 0;
  }
  function bx(e2) {
    return rx(e2) && "fixed" !== px(e2).position ? e2.offsetParent : null;
  }
  function yx(e2) {
    for (var t2 = ex(e2), r2 = bx(e2); r2 && Ax(r2) && "static" === px(r2).position; )
      r2 = bx(r2);
    return r2 && ("html" === cx(r2) || "body" === cx(r2) && "static" === px(r2).position) ? t2 : r2 || function(e3) {
      var t3 = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
      if (-1 !== navigator.userAgent.indexOf("Trident") && rx(e3) && "fixed" === px(e3).position)
        return null;
      var r3 = _x(e3);
      for (nx(r3) && (r3 = r3.host); rx(r3) && ["html", "body"].indexOf(cx(r3)) < 0; ) {
        var n2 = px(r3);
        if ("none" !== n2.transform || "none" !== n2.perspective || "paint" === n2.contain || -1 !== ["transform", "perspective"].indexOf(n2.willChange) || t3 && "filter" === n2.willChange || t3 && n2.filter && "none" !== n2.filter)
          return r3;
        r3 = r3.parentNode;
      }
      return null;
    }(e2) || t2;
  }
  var xx = "top", wx = "bottom", Ex = "right", Sx = "left", Cx = "auto", Mx = [xx, wx, Ex, Sx], Tx = "start", Ix = "end", kx = "clippingParents", Dx = "viewport", Px = "popper", Bx = "reference", Rx = Mx.reduce(function(e2, t2) {
    return e2.concat([t2 + "-" + Tx, t2 + "-" + Ix]);
  }, []), Lx = [].concat(Mx, [Cx]).reduce(function(e2, t2) {
    return e2.concat([t2, t2 + "-" + Tx, t2 + "-" + Ix]);
  }, []), Ox = "beforeRead", Fx = "read", Ux = "afterRead", Nx = "beforeMain", jx = "main", zx = "afterMain", Gx = "beforeWrite", Vx = "write", Qx = "afterWrite", Hx = [Ox, Fx, Ux, Nx, jx, zx, Gx, Vx, Qx];
  function Wx(e2) {
    var t2 = /* @__PURE__ */ new Map(), r2 = /* @__PURE__ */ new Set(), n2 = [];
    function i2(e3) {
      r2.add(e3.name), [].concat(e3.requires || [], e3.requiresIfExists || []).forEach(function(e4) {
        if (!r2.has(e4)) {
          var n3 = t2.get(e4);
          n3 && i2(n3);
        }
      }), n2.push(e3);
    }
    return e2.forEach(function(e3) {
      t2.set(e3.name, e3);
    }), e2.forEach(function(e3) {
      r2.has(e3.name) || i2(e3);
    }), n2;
  }
  var qx = { placement: "bottom", modifiers: [], strategy: "absolute" };
  function Xx() {
    for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
      t2[r2] = arguments[r2];
    return !t2.some(function(e3) {
      return !(e3 && "function" == typeof e3.getBoundingClientRect);
    });
  }
  function Yx(e2) {
    void 0 === e2 && (e2 = {});
    var t2 = e2, r2 = t2.defaultModifiers, n2 = void 0 === r2 ? [] : r2, i2 = t2.defaultOptions, s2 = void 0 === i2 ? qx : i2;
    return function(e3, t3, r3) {
      void 0 === r3 && (r3 = s2);
      var i3, o2, a2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, qx, s2), modifiersData: {}, elements: { reference: e3, popper: t3 }, attributes: {}, styles: {} }, l2 = [], c2 = false, u2 = { state: a2, setOptions: function(r4) {
        var i4 = "function" == typeof r4 ? r4(a2.options) : r4;
        h2(), a2.options = Object.assign({}, s2, a2.options, i4), a2.scrollParents = { reference: tx(e3) ? vx(e3) : e3.contextElement ? vx(e3.contextElement) : [], popper: vx(t3) };
        var o3, c3, p2 = function(e4) {
          var t4 = Wx(e4);
          return Hx.reduce(function(e5, r5) {
            return e5.concat(t4.filter(function(e6) {
              return e6.phase === r5;
            }));
          }, []);
        }((o3 = [].concat(n2, a2.options.modifiers), c3 = o3.reduce(function(e4, t4) {
          var r5 = e4[t4.name];
          return e4[t4.name] = r5 ? Object.assign({}, r5, t4, { options: Object.assign({}, r5.options, t4.options), data: Object.assign({}, r5.data, t4.data) }) : t4, e4;
        }, {}), Object.keys(c3).map(function(e4) {
          return c3[e4];
        })));
        return a2.orderedModifiers = p2.filter(function(e4) {
          return e4.enabled;
        }), a2.orderedModifiers.forEach(function(e4) {
          var t4 = e4.name, r5 = e4.options, n3 = void 0 === r5 ? {} : r5, i5 = e4.effect;
          if ("function" == typeof i5) {
            var s3 = i5({ state: a2, name: t4, instance: u2, options: n3 });
            l2.push(s3 || function() {
            });
          }
        }), u2.update();
      }, forceUpdate: function() {
        if (!c2) {
          var e4 = a2.elements, t4 = e4.reference, r4 = e4.popper;
          if (Xx(t4, r4)) {
            a2.rects = { reference: fx(t4, yx(r4), "fixed" === a2.options.strategy), popper: mx(r4) }, a2.reset = false, a2.placement = a2.options.placement, a2.orderedModifiers.forEach(function(e5) {
              return a2.modifiersData[e5.name] = Object.assign({}, e5.data);
            });
            for (var n3 = 0; n3 < a2.orderedModifiers.length; n3++)
              if (true !== a2.reset) {
                var i4 = a2.orderedModifiers[n3], s3 = i4.fn, o3 = i4.options, l3 = void 0 === o3 ? {} : o3, h3 = i4.name;
                "function" == typeof s3 && (a2 = s3({ state: a2, options: l3, name: h3, instance: u2 }) || a2);
              } else
                a2.reset = false, n3 = -1;
          }
        }
      }, update: (i3 = function() {
        return new Promise(function(e4) {
          u2.forceUpdate(), e4(a2);
        });
      }, function() {
        return o2 || (o2 = new Promise(function(e4) {
          Promise.resolve().then(function() {
            o2 = void 0, e4(i3());
          });
        })), o2;
      }), destroy: function() {
        h2(), c2 = true;
      } };
      if (!Xx(e3, t3))
        return u2;
      function h2() {
        l2.forEach(function(e4) {
          return e4();
        }), l2 = [];
      }
      return u2.setOptions(r3).then(function(e4) {
        !c2 && r3.onFirstUpdate && r3.onFirstUpdate(e4);
      }), u2;
    };
  }
  var Kx = Yx(), Jx = { passive: true }, Zx = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
  }, effect: function(e2) {
    var t2 = e2.state, r2 = e2.instance, n2 = e2.options, i2 = n2.scroll, s2 = void 0 === i2 || i2, o2 = n2.resize, a2 = void 0 === o2 || o2, l2 = ex(t2.elements.popper), c2 = [].concat(t2.scrollParents.reference, t2.scrollParents.popper);
    return s2 && c2.forEach(function(e3) {
      e3.addEventListener("scroll", r2.update, Jx);
    }), a2 && l2.addEventListener("resize", r2.update, Jx), function() {
      s2 && c2.forEach(function(e3) {
        e3.removeEventListener("scroll", r2.update, Jx);
      }), a2 && l2.removeEventListener("resize", r2.update, Jx);
    };
  }, data: {} };
  function $x(e2) {
    return e2.split("-")[0];
  }
  function ew(e2) {
    return e2.split("-")[1];
  }
  function tw(e2) {
    return ["top", "bottom"].indexOf(e2) >= 0 ? "x" : "y";
  }
  function rw(e2) {
    var t2, r2 = e2.reference, n2 = e2.element, i2 = e2.placement, s2 = i2 ? $x(i2) : null, o2 = i2 ? ew(i2) : null, a2 = r2.x + r2.width / 2 - n2.width / 2, l2 = r2.y + r2.height / 2 - n2.height / 2;
    switch (s2) {
      case xx:
        t2 = { x: a2, y: r2.y - n2.height };
        break;
      case wx:
        t2 = { x: a2, y: r2.y + r2.height };
        break;
      case Ex:
        t2 = { x: r2.x + r2.width, y: l2 };
        break;
      case Sx:
        t2 = { x: r2.x - n2.width, y: l2 };
        break;
      default:
        t2 = { x: r2.x, y: r2.y };
    }
    var c2 = s2 ? tw(s2) : null;
    if (null != c2) {
      var u2 = "y" === c2 ? "height" : "width";
      switch (o2) {
        case Tx:
          t2[c2] = t2[c2] - (r2[u2] / 2 - n2[u2] / 2);
          break;
        case Ix:
          t2[c2] = t2[c2] + (r2[u2] / 2 - n2[u2] / 2);
      }
    }
    return t2;
  }
  var nw = { name: "popperOffsets", enabled: true, phase: "read", fn: function(e2) {
    var t2 = e2.state, r2 = e2.name;
    t2.modifiersData[r2] = rw({ reference: t2.rects.reference, element: t2.rects.popper, strategy: "absolute", placement: t2.placement });
  }, data: {} }, iw = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
  function sw(e2) {
    var t2, r2 = e2.popper, n2 = e2.popperRect, i2 = e2.placement, s2 = e2.variation, o2 = e2.offsets, a2 = e2.position, l2 = e2.gpuAcceleration, c2 = e2.adaptive, u2 = e2.roundOffsets, h2 = e2.isFixed, p2 = o2.x, d2 = void 0 === p2 ? 0 : p2, f2 = o2.y, m2 = void 0 === f2 ? 0 : f2, _2 = "function" == typeof u2 ? u2({ x: d2, y: m2 }) : { x: d2, y: m2 };
    d2 = _2.x, m2 = _2.y;
    var g2 = o2.hasOwnProperty("x"), v2 = o2.hasOwnProperty("y"), A2 = Sx, b2 = xx, y2 = window;
    if (c2) {
      var x2 = yx(r2), w2 = "clientHeight", E2 = "clientWidth";
      x2 === ex(r2) && "static" !== px(x2 = ux(r2)).position && "absolute" === a2 && (w2 = "scrollHeight", E2 = "scrollWidth"), (i2 === xx || (i2 === Sx || i2 === Ex) && s2 === Ix) && (b2 = wx, m2 -= (h2 && x2 === y2 && y2.visualViewport ? y2.visualViewport.height : x2[w2]) - n2.height, m2 *= l2 ? 1 : -1), i2 !== Sx && (i2 !== xx && i2 !== wx || s2 !== Ix) || (A2 = Ex, d2 -= (h2 && x2 === y2 && y2.visualViewport ? y2.visualViewport.width : x2[E2]) - n2.width, d2 *= l2 ? 1 : -1);
    }
    var S2, C2 = Object.assign({ position: a2 }, c2 && iw), M2 = true === u2 ? function(e3) {
      var t3 = e3.x, r3 = e3.y, n3 = window.devicePixelRatio || 1;
      return { x: ox(t3 * n3) / n3 || 0, y: ox(r3 * n3) / n3 || 0 };
    }({ x: d2, y: m2 }) : { x: d2, y: m2 };
    return d2 = M2.x, m2 = M2.y, l2 ? Object.assign({}, C2, ((S2 = {})[b2] = v2 ? "0" : "", S2[A2] = g2 ? "0" : "", S2.transform = (y2.devicePixelRatio || 1) <= 1 ? "translate(" + d2 + "px, " + m2 + "px)" : "translate3d(" + d2 + "px, " + m2 + "px, 0)", S2)) : Object.assign({}, C2, ((t2 = {})[b2] = v2 ? m2 + "px" : "", t2[A2] = g2 ? d2 + "px" : "", t2.transform = "", t2));
  }
  var ow = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: function(e2) {
    var t2 = e2.state, r2 = e2.options, n2 = r2.gpuAcceleration, i2 = void 0 === n2 || n2, s2 = r2.adaptive, o2 = void 0 === s2 || s2, a2 = r2.roundOffsets, l2 = void 0 === a2 || a2, c2 = { placement: $x(t2.placement), variation: ew(t2.placement), popper: t2.elements.popper, popperRect: t2.rects.popper, gpuAcceleration: i2, isFixed: "fixed" === t2.options.strategy };
    null != t2.modifiersData.popperOffsets && (t2.styles.popper = Object.assign({}, t2.styles.popper, sw(Object.assign({}, c2, { offsets: t2.modifiersData.popperOffsets, position: t2.options.strategy, adaptive: o2, roundOffsets: l2 })))), null != t2.modifiersData.arrow && (t2.styles.arrow = Object.assign({}, t2.styles.arrow, sw(Object.assign({}, c2, { offsets: t2.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: l2 })))), t2.attributes.popper = Object.assign({}, t2.attributes.popper, { "data-popper-placement": t2.placement });
  }, data: {} }, aw = { name: "applyStyles", enabled: true, phase: "write", fn: function(e2) {
    var t2 = e2.state;
    Object.keys(t2.elements).forEach(function(e3) {
      var r2 = t2.styles[e3] || {}, n2 = t2.attributes[e3] || {}, i2 = t2.elements[e3];
      rx(i2) && cx(i2) && (Object.assign(i2.style, r2), Object.keys(n2).forEach(function(e4) {
        var t3 = n2[e4];
        false === t3 ? i2.removeAttribute(e4) : i2.setAttribute(e4, true === t3 ? "" : t3);
      }));
    });
  }, effect: function(e2) {
    var t2 = e2.state, r2 = { popper: { position: t2.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
    return Object.assign(t2.elements.popper.style, r2.popper), t2.styles = r2, t2.elements.arrow && Object.assign(t2.elements.arrow.style, r2.arrow), function() {
      Object.keys(t2.elements).forEach(function(e3) {
        var n2 = t2.elements[e3], i2 = t2.attributes[e3] || {}, s2 = Object.keys(t2.styles.hasOwnProperty(e3) ? t2.styles[e3] : r2[e3]).reduce(function(e4, t3) {
          return e4[t3] = "", e4;
        }, {});
        rx(n2) && cx(n2) && (Object.assign(n2.style, s2), Object.keys(i2).forEach(function(e4) {
          n2.removeAttribute(e4);
        }));
      });
    };
  }, requires: ["computeStyles"] }, lw = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: function(e2) {
    var t2 = e2.state, r2 = e2.options, n2 = e2.name, i2 = r2.offset, s2 = void 0 === i2 ? [0, 0] : i2, o2 = Lx.reduce(function(e3, r3) {
      return e3[r3] = function(e4, t3, r4) {
        var n3 = $x(e4), i3 = [Sx, xx].indexOf(n3) >= 0 ? -1 : 1, s3 = "function" == typeof r4 ? r4(Object.assign({}, t3, { placement: e4 })) : r4, o3 = s3[0], a3 = s3[1];
        return o3 = o3 || 0, a3 = (a3 || 0) * i3, [Sx, Ex].indexOf(n3) >= 0 ? { x: a3, y: o3 } : { x: o3, y: a3 };
      }(r3, t2.rects, s2), e3;
    }, {}), a2 = o2[t2.placement], l2 = a2.x, c2 = a2.y;
    null != t2.modifiersData.popperOffsets && (t2.modifiersData.popperOffsets.x += l2, t2.modifiersData.popperOffsets.y += c2), t2.modifiersData[n2] = o2;
  } }, cw = { left: "right", right: "left", bottom: "top", top: "bottom" };
  function uw(e2) {
    return e2.replace(/left|right|bottom|top/g, function(e3) {
      return cw[e3];
    });
  }
  var hw = { start: "end", end: "start" };
  function pw(e2) {
    return e2.replace(/start|end/g, function(e3) {
      return hw[e3];
    });
  }
  function dw(e2, t2) {
    var r2 = t2.getRootNode && t2.getRootNode();
    if (e2.contains(t2))
      return true;
    if (r2 && nx(r2)) {
      var n2 = t2;
      do {
        if (n2 && e2.isSameNode(n2))
          return true;
        n2 = n2.parentNode || n2.host;
      } while (n2);
    }
    return false;
  }
  function fw(e2) {
    return Object.assign({}, e2, { left: e2.x, top: e2.y, right: e2.x + e2.width, bottom: e2.y + e2.height });
  }
  function mw(e2, t2) {
    return t2 === Dx ? fw(function(e3) {
      var t3 = ex(e3), r2 = ux(e3), n2 = t3.visualViewport, i2 = r2.clientWidth, s2 = r2.clientHeight, o2 = 0, a2 = 0;
      return n2 && (i2 = n2.width, s2 = n2.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o2 = n2.offsetLeft, a2 = n2.offsetTop)), { width: i2, height: s2, x: o2 + hx(e3), y: a2 };
    }(e2)) : tx(t2) ? function(e3) {
      var t3 = ax(e3);
      return t3.top = t3.top + e3.clientTop, t3.left = t3.left + e3.clientLeft, t3.bottom = t3.top + e3.clientHeight, t3.right = t3.left + e3.clientWidth, t3.width = e3.clientWidth, t3.height = e3.clientHeight, t3.x = t3.left, t3.y = t3.top, t3;
    }(t2) : fw(function(e3) {
      var t3, r2 = ux(e3), n2 = lx(e3), i2 = null == (t3 = e3.ownerDocument) ? void 0 : t3.body, s2 = ix(r2.scrollWidth, r2.clientWidth, i2 ? i2.scrollWidth : 0, i2 ? i2.clientWidth : 0), o2 = ix(r2.scrollHeight, r2.clientHeight, i2 ? i2.scrollHeight : 0, i2 ? i2.clientHeight : 0), a2 = -n2.scrollLeft + hx(e3), l2 = -n2.scrollTop;
      return "rtl" === px(i2 || r2).direction && (a2 += ix(r2.clientWidth, i2 ? i2.clientWidth : 0) - s2), { width: s2, height: o2, x: a2, y: l2 };
    }(ux(e2)));
  }
  function _w(e2) {
    return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e2);
  }
  function gw(e2, t2) {
    return t2.reduce(function(t3, r2) {
      return t3[r2] = e2, t3;
    }, {});
  }
  function vw(e2, t2) {
    void 0 === t2 && (t2 = {});
    var r2 = t2, n2 = r2.placement, i2 = void 0 === n2 ? e2.placement : n2, s2 = r2.boundary, o2 = void 0 === s2 ? kx : s2, a2 = r2.rootBoundary, l2 = void 0 === a2 ? Dx : a2, c2 = r2.elementContext, u2 = void 0 === c2 ? Px : c2, h2 = r2.altBoundary, p2 = void 0 !== h2 && h2, d2 = r2.padding, f2 = void 0 === d2 ? 0 : d2, m2 = _w("number" != typeof f2 ? f2 : gw(f2, Mx)), _2 = u2 === Px ? Bx : Px, g2 = e2.rects.popper, v2 = e2.elements[p2 ? _2 : u2], A2 = function(e3, t3, r3) {
      var n3 = "clippingParents" === t3 ? function(e4) {
        var t4 = vx(_x(e4)), r4 = ["absolute", "fixed"].indexOf(px(e4).position) >= 0 && rx(e4) ? yx(e4) : e4;
        return tx(r4) ? t4.filter(function(e5) {
          return tx(e5) && dw(e5, r4) && "body" !== cx(e5);
        }) : [];
      }(e3) : [].concat(t3), i3 = [].concat(n3, [r3]), s3 = i3[0], o3 = i3.reduce(function(t4, r4) {
        var n4 = mw(e3, r4);
        return t4.top = ix(n4.top, t4.top), t4.right = sx(n4.right, t4.right), t4.bottom = sx(n4.bottom, t4.bottom), t4.left = ix(n4.left, t4.left), t4;
      }, mw(e3, s3));
      return o3.width = o3.right - o3.left, o3.height = o3.bottom - o3.top, o3.x = o3.left, o3.y = o3.top, o3;
    }(tx(v2) ? v2 : v2.contextElement || ux(e2.elements.popper), o2, l2), b2 = ax(e2.elements.reference), y2 = rw({ reference: b2, element: g2, strategy: "absolute", placement: i2 }), x2 = fw(Object.assign({}, g2, y2)), w2 = u2 === Px ? x2 : b2, E2 = { top: A2.top - w2.top + m2.top, bottom: w2.bottom - A2.bottom + m2.bottom, left: A2.left - w2.left + m2.left, right: w2.right - A2.right + m2.right }, S2 = e2.modifiersData.offset;
    if (u2 === Px && S2) {
      var C2 = S2[i2];
      Object.keys(E2).forEach(function(e3) {
        var t3 = [Ex, wx].indexOf(e3) >= 0 ? 1 : -1, r3 = [xx, wx].indexOf(e3) >= 0 ? "y" : "x";
        E2[e3] += C2[r3] * t3;
      });
    }
    return E2;
  }
  var Aw = { name: "flip", enabled: true, phase: "main", fn: function(e2) {
    var t2 = e2.state, r2 = e2.options, n2 = e2.name;
    if (!t2.modifiersData[n2]._skip) {
      for (var i2 = r2.mainAxis, s2 = void 0 === i2 || i2, o2 = r2.altAxis, a2 = void 0 === o2 || o2, l2 = r2.fallbackPlacements, c2 = r2.padding, u2 = r2.boundary, h2 = r2.rootBoundary, p2 = r2.altBoundary, d2 = r2.flipVariations, f2 = void 0 === d2 || d2, m2 = r2.allowedAutoPlacements, _2 = t2.options.placement, g2 = $x(_2), v2 = l2 || (g2 !== _2 && f2 ? function(e3) {
        if ($x(e3) === Cx)
          return [];
        var t3 = uw(e3);
        return [pw(e3), t3, pw(t3)];
      }(_2) : [uw(_2)]), A2 = [_2].concat(v2).reduce(function(e3, r3) {
        return e3.concat($x(r3) === Cx ? function(e4, t3) {
          void 0 === t3 && (t3 = {});
          var r4 = t3, n3 = r4.placement, i3 = r4.boundary, s3 = r4.rootBoundary, o3 = r4.padding, a3 = r4.flipVariations, l3 = r4.allowedAutoPlacements, c3 = void 0 === l3 ? Lx : l3, u3 = ew(n3), h3 = u3 ? a3 ? Rx : Rx.filter(function(e5) {
            return ew(e5) === u3;
          }) : Mx, p3 = h3.filter(function(e5) {
            return c3.indexOf(e5) >= 0;
          });
          0 === p3.length && (p3 = h3);
          var d3 = p3.reduce(function(t4, r5) {
            return t4[r5] = vw(e4, { placement: r5, boundary: i3, rootBoundary: s3, padding: o3 })[$x(r5)], t4;
          }, {});
          return Object.keys(d3).sort(function(e5, t4) {
            return d3[e5] - d3[t4];
          });
        }(t2, { placement: r3, boundary: u2, rootBoundary: h2, padding: c2, flipVariations: f2, allowedAutoPlacements: m2 }) : r3);
      }, []), b2 = t2.rects.reference, y2 = t2.rects.popper, x2 = /* @__PURE__ */ new Map(), w2 = true, E2 = A2[0], S2 = 0; S2 < A2.length; S2++) {
        var C2 = A2[S2], M2 = $x(C2), T2 = ew(C2) === Tx, I2 = [xx, wx].indexOf(M2) >= 0, k2 = I2 ? "width" : "height", D2 = vw(t2, { placement: C2, boundary: u2, rootBoundary: h2, altBoundary: p2, padding: c2 }), P2 = I2 ? T2 ? Ex : Sx : T2 ? wx : xx;
        b2[k2] > y2[k2] && (P2 = uw(P2));
        var B2 = uw(P2), R2 = [];
        if (s2 && R2.push(D2[M2] <= 0), a2 && R2.push(D2[P2] <= 0, D2[B2] <= 0), R2.every(function(e3) {
          return e3;
        })) {
          E2 = C2, w2 = false;
          break;
        }
        x2.set(C2, R2);
      }
      if (w2)
        for (var L2 = function(e3) {
          var t3 = A2.find(function(t4) {
            var r3 = x2.get(t4);
            if (r3)
              return r3.slice(0, e3).every(function(e4) {
                return e4;
              });
          });
          if (t3)
            return E2 = t3, "break";
        }, O2 = f2 ? 3 : 1; O2 > 0 && "break" !== L2(O2); O2--)
          ;
      t2.placement !== E2 && (t2.modifiersData[n2]._skip = true, t2.placement = E2, t2.reset = true);
    }
  }, requiresIfExists: ["offset"], data: { _skip: false } };
  function bw(e2, t2, r2) {
    return ix(e2, sx(t2, r2));
  }
  var yw = { name: "preventOverflow", enabled: true, phase: "main", fn: function(e2) {
    var t2 = e2.state, r2 = e2.options, n2 = e2.name, i2 = r2.mainAxis, s2 = void 0 === i2 || i2, o2 = r2.altAxis, a2 = void 0 !== o2 && o2, l2 = r2.boundary, c2 = r2.rootBoundary, u2 = r2.altBoundary, h2 = r2.padding, p2 = r2.tether, d2 = void 0 === p2 || p2, f2 = r2.tetherOffset, m2 = void 0 === f2 ? 0 : f2, _2 = vw(t2, { boundary: l2, rootBoundary: c2, padding: h2, altBoundary: u2 }), g2 = $x(t2.placement), v2 = ew(t2.placement), A2 = !v2, b2 = tw(g2), y2 = "x" === b2 ? "y" : "x", x2 = t2.modifiersData.popperOffsets, w2 = t2.rects.reference, E2 = t2.rects.popper, S2 = "function" == typeof m2 ? m2(Object.assign({}, t2.rects, { placement: t2.placement })) : m2, C2 = "number" == typeof S2 ? { mainAxis: S2, altAxis: S2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, S2), M2 = t2.modifiersData.offset ? t2.modifiersData.offset[t2.placement] : null, T2 = { x: 0, y: 0 };
    if (x2) {
      if (s2) {
        var I2, k2 = "y" === b2 ? xx : Sx, D2 = "y" === b2 ? wx : Ex, P2 = "y" === b2 ? "height" : "width", B2 = x2[b2], R2 = B2 + _2[k2], L2 = B2 - _2[D2], O2 = d2 ? -E2[P2] / 2 : 0, F2 = v2 === Tx ? w2[P2] : E2[P2], U2 = v2 === Tx ? -E2[P2] : -w2[P2], N2 = t2.elements.arrow, j2 = d2 && N2 ? mx(N2) : { width: 0, height: 0 }, z2 = t2.modifiersData["arrow#persistent"] ? t2.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, G2 = z2[k2], V2 = z2[D2], Q2 = bw(0, w2[P2], j2[P2]), H2 = A2 ? w2[P2] / 2 - O2 - Q2 - G2 - C2.mainAxis : F2 - Q2 - G2 - C2.mainAxis, W2 = A2 ? -w2[P2] / 2 + O2 + Q2 + V2 + C2.mainAxis : U2 + Q2 + V2 + C2.mainAxis, q2 = t2.elements.arrow && yx(t2.elements.arrow), X2 = q2 ? "y" === b2 ? q2.clientTop || 0 : q2.clientLeft || 0 : 0, Y2 = null != (I2 = null == M2 ? void 0 : M2[b2]) ? I2 : 0, K2 = B2 + W2 - Y2, J2 = bw(d2 ? sx(R2, B2 + H2 - Y2 - X2) : R2, B2, d2 ? ix(L2, K2) : L2);
        x2[b2] = J2, T2[b2] = J2 - B2;
      }
      if (a2) {
        var Z2, $2 = "x" === b2 ? xx : Sx, ee2 = "x" === b2 ? wx : Ex, te2 = x2[y2], re2 = "y" === y2 ? "height" : "width", ne2 = te2 + _2[$2], ie2 = te2 - _2[ee2], se2 = -1 !== [xx, Sx].indexOf(g2), oe2 = null != (Z2 = null == M2 ? void 0 : M2[y2]) ? Z2 : 0, ae2 = se2 ? ne2 : te2 - w2[re2] - E2[re2] - oe2 + C2.altAxis, le2 = se2 ? te2 + w2[re2] + E2[re2] - oe2 - C2.altAxis : ie2, ce2 = d2 && se2 ? function(e3, t3, r3) {
          var n3 = bw(e3, t3, r3);
          return n3 > r3 ? r3 : n3;
        }(ae2, te2, le2) : bw(d2 ? ae2 : ne2, te2, d2 ? le2 : ie2);
        x2[y2] = ce2, T2[y2] = ce2 - te2;
      }
      t2.modifiersData[n2] = T2;
    }
  }, requiresIfExists: ["offset"] }, xw = { name: "arrow", enabled: true, phase: "main", fn: function(e2) {
    var t2, r2 = e2.state, n2 = e2.name, i2 = e2.options, s2 = r2.elements.arrow, o2 = r2.modifiersData.popperOffsets, a2 = $x(r2.placement), l2 = tw(a2), c2 = [Sx, Ex].indexOf(a2) >= 0 ? "height" : "width";
    if (s2 && o2) {
      var u2 = function(e3, t3) {
        return _w("number" != typeof (e3 = "function" == typeof e3 ? e3(Object.assign({}, t3.rects, { placement: t3.placement })) : e3) ? e3 : gw(e3, Mx));
      }(i2.padding, r2), h2 = mx(s2), p2 = "y" === l2 ? xx : Sx, d2 = "y" === l2 ? wx : Ex, f2 = r2.rects.reference[c2] + r2.rects.reference[l2] - o2[l2] - r2.rects.popper[c2], m2 = o2[l2] - r2.rects.reference[l2], _2 = yx(s2), g2 = _2 ? "y" === l2 ? _2.clientHeight || 0 : _2.clientWidth || 0 : 0, v2 = f2 / 2 - m2 / 2, A2 = u2[p2], b2 = g2 - h2[c2] - u2[d2], y2 = g2 / 2 - h2[c2] / 2 + v2, x2 = bw(A2, y2, b2), w2 = l2;
      r2.modifiersData[n2] = ((t2 = {})[w2] = x2, t2.centerOffset = x2 - y2, t2);
    }
  }, effect: function(e2) {
    var t2 = e2.state, r2 = e2.options.element, n2 = void 0 === r2 ? "[data-popper-arrow]" : r2;
    null != n2 && ("string" != typeof n2 || (n2 = t2.elements.popper.querySelector(n2))) && dw(t2.elements.popper, n2) && (t2.elements.arrow = n2);
  }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
  function ww(e2, t2, r2) {
    return void 0 === r2 && (r2 = { x: 0, y: 0 }), { top: e2.top - t2.height - r2.y, right: e2.right - t2.width + r2.x, bottom: e2.bottom - t2.height + r2.y, left: e2.left - t2.width - r2.x };
  }
  function Ew(e2) {
    return [xx, Ex, wx, Sx].some(function(t2) {
      return e2[t2] >= 0;
    });
  }
  var Sw = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: function(e2) {
    var t2 = e2.state, r2 = e2.name, n2 = t2.rects.reference, i2 = t2.rects.popper, s2 = t2.modifiersData.preventOverflow, o2 = vw(t2, { elementContext: "reference" }), a2 = vw(t2, { altBoundary: true }), l2 = ww(o2, n2), c2 = ww(a2, i2, s2), u2 = Ew(l2), h2 = Ew(c2);
    t2.modifiersData[r2] = { referenceClippingOffsets: l2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: h2 }, t2.attributes.popper = Object.assign({}, t2.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": h2 });
  } }, Cw = Yx({ defaultModifiers: [Zx, nw, ow, aw, lw, Aw, yw, xw, Sw] }), Mw = "tippy-content", Tw = "tippy-arrow", Iw = "tippy-svg-arrow", kw = { passive: true, capture: true }, Dw = function() {
    return document.body;
  };
  function Pw(e2, t2, r2) {
    if (Array.isArray(e2)) {
      var n2 = e2[t2];
      return null == n2 ? Array.isArray(r2) ? r2[t2] : r2 : n2;
    }
    return e2;
  }
  function Bw(e2, t2) {
    var r2 = {}.toString.call(e2);
    return 0 === r2.indexOf("[object") && r2.indexOf(t2 + "]") > -1;
  }
  function Rw(e2, t2) {
    return "function" == typeof e2 ? e2.apply(void 0, t2) : e2;
  }
  function Lw(e2, t2) {
    return 0 === t2 ? e2 : function(n2) {
      clearTimeout(r2), r2 = setTimeout(function() {
        e2(n2);
      }, t2);
    };
    var r2;
  }
  function Ow(e2) {
    return [].concat(e2);
  }
  function Fw(e2, t2) {
    -1 === e2.indexOf(t2) && e2.push(t2);
  }
  function Uw(e2) {
    return [].slice.call(e2);
  }
  function Nw(e2) {
    return Object.keys(e2).reduce(function(t2, r2) {
      return void 0 !== e2[r2] && (t2[r2] = e2[r2]), t2;
    }, {});
  }
  function jw() {
    return document.createElement("div");
  }
  function zw(e2) {
    return ["Element", "Fragment"].some(function(t2) {
      return Bw(e2, t2);
    });
  }
  function Gw(e2, t2) {
    e2.forEach(function(e3) {
      e3 && (e3.style.transitionDuration = t2 + "ms");
    });
  }
  function Vw(e2, t2) {
    e2.forEach(function(e3) {
      e3 && e3.setAttribute("data-state", t2);
    });
  }
  function Qw(e2, t2, r2) {
    var n2 = t2 + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(t3) {
      e2[n2](t3, r2);
    });
  }
  function Hw(e2, t2) {
    for (var r2 = t2; r2; ) {
      var n2;
      if (e2.contains(r2))
        return true;
      r2 = null == r2.getRootNode || null == (n2 = r2.getRootNode()) ? void 0 : n2.host;
    }
    return false;
  }
  var Ww = { isTouch: false }, qw = 0;
  function Xw() {
    Ww.isTouch || (Ww.isTouch = true, window.performance && document.addEventListener("mousemove", Yw));
  }
  function Yw() {
    var e2 = performance.now();
    e2 - qw < 20 && (Ww.isTouch = false, document.removeEventListener("mousemove", Yw)), qw = e2;
  }
  function Kw() {
    var e2, t2 = document.activeElement;
    if ((e2 = t2) && e2._tippy && e2._tippy.reference === e2) {
      var r2 = t2._tippy;
      t2.blur && !r2.state.isVisible && t2.blur();
    }
  }
  var Jw = !("undefined" == typeof window || "undefined" == typeof document || !window.msCrypto), Zw = Object.assign({ appendTo: Dw, aria: { content: "auto", expanded: "auto" }, delay: 0, duration: [300, 250], getReferenceClientRect: null, hideOnClick: true, ignoreAttributes: false, interactive: false, interactiveBorder: 2, interactiveDebounce: 0, moveTransition: "", offset: [0, 10], onAfterUpdate: function() {
  }, onBeforeUpdate: function() {
  }, onCreate: function() {
  }, onDestroy: function() {
  }, onHidden: function() {
  }, onHide: function() {
  }, onMount: function() {
  }, onShow: function() {
  }, onShown: function() {
  }, onTrigger: function() {
  }, onUntrigger: function() {
  }, onClickOutside: function() {
  }, placement: "top", plugins: [], popperOptions: {}, render: null, showOnCreate: false, touch: true, trigger: "mouseenter focus", triggerTarget: null }, { animateFill: false, followCursor: false, inlinePositioning: false, sticky: false }, { allowHTML: false, animation: "fade", arrow: true, content: "", inertia: false, maxWidth: 350, role: "tooltip", theme: "", zIndex: 9999 }), $w = Object.keys(Zw);
  function eE(e2) {
    var t2 = (e2.plugins || []).reduce(function(t3, r2) {
      var n2, i2 = r2.name, s2 = r2.defaultValue;
      return i2 && (t3[i2] = void 0 !== e2[i2] ? e2[i2] : null != (n2 = Zw[i2]) ? n2 : s2), t3;
    }, {});
    return Object.assign({}, e2, t2);
  }
  function tE(e2, t2) {
    var r2 = Object.assign({}, t2, { content: Rw(t2.content, [e2]) }, t2.ignoreAttributes ? {} : function(e3, t3) {
      return (t3 ? Object.keys(eE(Object.assign({}, Zw, { plugins: t3 }))) : $w).reduce(function(t4, r3) {
        var n2 = (e3.getAttribute("data-tippy-" + r3) || "").trim();
        if (!n2)
          return t4;
        if ("content" === r3)
          t4[r3] = n2;
        else
          try {
            t4[r3] = JSON.parse(n2);
          } catch (e4) {
            t4[r3] = n2;
          }
        return t4;
      }, {});
    }(e2, t2.plugins));
    return r2.aria = Object.assign({}, Zw.aria, r2.aria), r2.aria = { expanded: "auto" === r2.aria.expanded ? t2.interactive : r2.aria.expanded, content: "auto" === r2.aria.content ? t2.interactive ? null : "describedby" : r2.aria.content }, r2;
  }
  function rE(e2, t2) {
    e2.innerHTML = t2;
  }
  function nE(e2) {
    var t2 = jw();
    return true === e2 ? t2.className = Tw : (t2.className = Iw, zw(e2) ? t2.appendChild(e2) : rE(t2, e2)), t2;
  }
  function iE(e2, t2) {
    zw(t2.content) ? (rE(e2, ""), e2.appendChild(t2.content)) : "function" != typeof t2.content && (t2.allowHTML ? rE(e2, t2.content) : e2.textContent = t2.content);
  }
  function sE(e2) {
    var t2 = e2.firstElementChild, r2 = Uw(t2.children);
    return { box: t2, content: r2.find(function(e3) {
      return e3.classList.contains(Mw);
    }), arrow: r2.find(function(e3) {
      return e3.classList.contains(Tw) || e3.classList.contains(Iw);
    }), backdrop: r2.find(function(e3) {
      return e3.classList.contains("tippy-backdrop");
    }) };
  }
  function oE(e2) {
    var t2 = jw(), r2 = jw();
    r2.className = "tippy-box", r2.setAttribute("data-state", "hidden"), r2.setAttribute("tabindex", "-1");
    var n2 = jw();
    function i2(r3, n3) {
      var i3 = sE(t2), s2 = i3.box, o2 = i3.content, a2 = i3.arrow;
      n3.theme ? s2.setAttribute("data-theme", n3.theme) : s2.removeAttribute("data-theme"), "string" == typeof n3.animation ? s2.setAttribute("data-animation", n3.animation) : s2.removeAttribute("data-animation"), n3.inertia ? s2.setAttribute("data-inertia", "") : s2.removeAttribute("data-inertia"), s2.style.maxWidth = "number" == typeof n3.maxWidth ? n3.maxWidth + "px" : n3.maxWidth, n3.role ? s2.setAttribute("role", n3.role) : s2.removeAttribute("role"), r3.content === n3.content && r3.allowHTML === n3.allowHTML || iE(o2, e2.props), n3.arrow ? a2 ? r3.arrow !== n3.arrow && (s2.removeChild(a2), s2.appendChild(nE(n3.arrow))) : s2.appendChild(nE(n3.arrow)) : a2 && s2.removeChild(a2);
    }
    return n2.className = Mw, n2.setAttribute("data-state", "hidden"), iE(n2, e2.props), t2.appendChild(r2), r2.appendChild(n2), i2(e2.props, e2.props), { popper: t2, onUpdate: i2 };
  }
  oE.$$tippy = true;
  var aE = 1, lE = [], cE = [];
  function uE(e2, t2) {
    var r2, n2, i2, s2, o2, a2, l2, c2, u2 = tE(e2, Object.assign({}, Zw, eE(Nw(t2)))), h2 = false, p2 = false, d2 = false, f2 = false, m2 = [], _2 = Lw(q2, u2.interactiveDebounce), g2 = aE++, v2 = (c2 = u2.plugins).filter(function(e3, t3) {
      return c2.indexOf(e3) === t3;
    }), A2 = { id: g2, reference: e2, popper: jw(), popperInstance: null, props: u2, state: { isEnabled: true, isVisible: false, isDestroyed: false, isMounted: false, isShown: false }, plugins: v2, clearDelayTimeouts: function() {
      clearTimeout(r2), clearTimeout(n2), cancelAnimationFrame(i2);
    }, setProps: function(t3) {
      if (!A2.state.isDestroyed) {
        B2("onBeforeUpdate", [A2, t3]), H2();
        var r3 = A2.props, n3 = tE(e2, Object.assign({}, r3, Nw(t3), { ignoreAttributes: true }));
        A2.props = n3, Q2(), r3.interactiveDebounce !== n3.interactiveDebounce && (O2(), _2 = Lw(q2, n3.interactiveDebounce)), r3.triggerTarget && !n3.triggerTarget ? Ow(r3.triggerTarget).forEach(function(e3) {
          e3.removeAttribute("aria-expanded");
        }) : n3.triggerTarget && e2.removeAttribute("aria-expanded"), L2(), P2(), x2 && x2(r3, n3), A2.popperInstance && (J2(), $2().forEach(function(e3) {
          requestAnimationFrame(e3._tippy.popperInstance.forceUpdate);
        })), B2("onAfterUpdate", [A2, t3]);
      }
    }, setContent: function(e3) {
      A2.setProps({ content: e3 });
    }, show: function() {
      var e3 = A2.state.isVisible, t3 = A2.state.isDestroyed, r3 = !A2.state.isEnabled, n3 = Ww.isTouch && !A2.props.touch, i3 = Pw(A2.props.duration, 0, Zw.duration);
      if (!(e3 || t3 || r3 || n3 || T2().hasAttribute("disabled") || (B2("onShow", [A2], false), false === A2.props.onShow(A2)))) {
        if (A2.state.isVisible = true, M2() && (y2.style.visibility = "visible"), P2(), j2(), A2.state.isMounted || (y2.style.transition = "none"), M2()) {
          var s3 = k2();
          Gw([s3.box, s3.content], 0);
        }
        var o3, l3, c3;
        a2 = function() {
          var e4;
          if (A2.state.isVisible && !f2) {
            if (f2 = true, y2.offsetHeight, y2.style.transition = A2.props.moveTransition, M2() && A2.props.animation) {
              var t4 = k2(), r4 = t4.box, n4 = t4.content;
              Gw([r4, n4], i3), Vw([r4, n4], "visible");
            }
            R2(), L2(), Fw(cE, A2), null == (e4 = A2.popperInstance) || e4.forceUpdate(), B2("onMount", [A2]), A2.props.animation && M2() && function(e5, t5) {
              G2(e5, function() {
                A2.state.isShown = true, B2("onShown", [A2]);
              });
            }(i3);
          }
        }, l3 = A2.props.appendTo, c3 = T2(), (o3 = A2.props.interactive && l3 === Dw || "parent" === l3 ? c3.parentNode : Rw(l3, [c3])).contains(y2) || o3.appendChild(y2), A2.state.isMounted = true, J2();
      }
    }, hide: function() {
      var e3 = !A2.state.isVisible, t3 = A2.state.isDestroyed, r3 = !A2.state.isEnabled, n3 = Pw(A2.props.duration, 1, Zw.duration);
      if (!(e3 || t3 || r3) && (B2("onHide", [A2], false), false !== A2.props.onHide(A2))) {
        if (A2.state.isVisible = false, A2.state.isShown = false, f2 = false, h2 = false, M2() && (y2.style.visibility = "hidden"), O2(), z2(), P2(true), M2()) {
          var i3 = k2(), s3 = i3.box, o3 = i3.content;
          A2.props.animation && (Gw([s3, o3], n3), Vw([s3, o3], "hidden"));
        }
        R2(), L2(), A2.props.animation ? M2() && function(e4, t4) {
          G2(e4, function() {
            !A2.state.isVisible && y2.parentNode && y2.parentNode.contains(y2) && t4();
          });
        }(n3, A2.unmount) : A2.unmount();
      }
    }, hideWithInteractivity: function(e3) {
      I2().addEventListener("mousemove", _2), Fw(lE, _2), _2(e3);
    }, enable: function() {
      A2.state.isEnabled = true;
    }, disable: function() {
      A2.hide(), A2.state.isEnabled = false;
    }, unmount: function() {
      A2.state.isVisible && A2.hide(), A2.state.isMounted && (Z2(), $2().forEach(function(e3) {
        e3._tippy.unmount();
      }), y2.parentNode && y2.parentNode.removeChild(y2), cE = cE.filter(function(e3) {
        return e3 !== A2;
      }), A2.state.isMounted = false, B2("onHidden", [A2]));
    }, destroy: function() {
      A2.state.isDestroyed || (A2.clearDelayTimeouts(), A2.unmount(), H2(), delete e2._tippy, A2.state.isDestroyed = true, B2("onDestroy", [A2]));
    } };
    if (!u2.render)
      return A2;
    var b2 = u2.render(A2), y2 = b2.popper, x2 = b2.onUpdate;
    y2.setAttribute("data-tippy-root", ""), y2.id = "tippy-" + A2.id, A2.popper = y2, e2._tippy = A2, y2._tippy = A2;
    var w2 = v2.map(function(e3) {
      return e3.fn(A2);
    }), E2 = e2.hasAttribute("aria-expanded");
    return Q2(), L2(), P2(), B2("onCreate", [A2]), u2.showOnCreate && ee2(), y2.addEventListener("mouseenter", function() {
      A2.props.interactive && A2.state.isVisible && A2.clearDelayTimeouts();
    }), y2.addEventListener("mouseleave", function() {
      A2.props.interactive && A2.props.trigger.indexOf("mouseenter") >= 0 && I2().addEventListener("mousemove", _2);
    }), A2;
    function S2() {
      var e3 = A2.props.touch;
      return Array.isArray(e3) ? e3 : [e3, 0];
    }
    function C2() {
      return "hold" === S2()[0];
    }
    function M2() {
      var e3;
      return !(null == (e3 = A2.props.render) || !e3.$$tippy);
    }
    function T2() {
      return l2 || e2;
    }
    function I2() {
      var e3, t3, r3 = T2().parentNode;
      return r3 ? null != (t3 = Ow(r3)[0]) && null != (e3 = t3.ownerDocument) && e3.body ? t3.ownerDocument : document : document;
    }
    function k2() {
      return sE(y2);
    }
    function D2(e3) {
      return A2.state.isMounted && !A2.state.isVisible || Ww.isTouch || s2 && "focus" === s2.type ? 0 : Pw(A2.props.delay, e3 ? 0 : 1, Zw.delay);
    }
    function P2(e3) {
      void 0 === e3 && (e3 = false), y2.style.pointerEvents = A2.props.interactive && !e3 ? "" : "none", y2.style.zIndex = "" + A2.props.zIndex;
    }
    function B2(e3, t3, r3) {
      var n3;
      void 0 === r3 && (r3 = true), w2.forEach(function(r4) {
        r4[e3] && r4[e3].apply(r4, t3);
      }), r3 && (n3 = A2.props)[e3].apply(n3, t3);
    }
    function R2() {
      var t3 = A2.props.aria;
      if (t3.content) {
        var r3 = "aria-" + t3.content, n3 = y2.id;
        Ow(A2.props.triggerTarget || e2).forEach(function(e3) {
          var t4 = e3.getAttribute(r3);
          if (A2.state.isVisible)
            e3.setAttribute(r3, t4 ? t4 + " " + n3 : n3);
          else {
            var i3 = t4 && t4.replace(n3, "").trim();
            i3 ? e3.setAttribute(r3, i3) : e3.removeAttribute(r3);
          }
        });
      }
    }
    function L2() {
      !E2 && A2.props.aria.expanded && Ow(A2.props.triggerTarget || e2).forEach(function(e3) {
        A2.props.interactive ? e3.setAttribute("aria-expanded", A2.state.isVisible && e3 === T2() ? "true" : "false") : e3.removeAttribute("aria-expanded");
      });
    }
    function O2() {
      I2().removeEventListener("mousemove", _2), lE = lE.filter(function(e3) {
        return e3 !== _2;
      });
    }
    function F2(t3) {
      if (!Ww.isTouch || !d2 && "mousedown" !== t3.type) {
        var r3 = t3.composedPath && t3.composedPath()[0] || t3.target;
        if (!A2.props.interactive || !Hw(y2, r3)) {
          if (Ow(A2.props.triggerTarget || e2).some(function(e3) {
            return Hw(e3, r3);
          })) {
            if (Ww.isTouch)
              return;
            if (A2.state.isVisible && A2.props.trigger.indexOf("click") >= 0)
              return;
          } else
            B2("onClickOutside", [A2, t3]);
          true === A2.props.hideOnClick && (A2.clearDelayTimeouts(), A2.hide(), p2 = true, setTimeout(function() {
            p2 = false;
          }), A2.state.isMounted || z2());
        }
      }
    }
    function U2() {
      d2 = true;
    }
    function N2() {
      d2 = false;
    }
    function j2() {
      var e3 = I2();
      e3.addEventListener("mousedown", F2, true), e3.addEventListener("touchend", F2, kw), e3.addEventListener("touchstart", N2, kw), e3.addEventListener("touchmove", U2, kw);
    }
    function z2() {
      var e3 = I2();
      e3.removeEventListener("mousedown", F2, true), e3.removeEventListener("touchend", F2, kw), e3.removeEventListener("touchstart", N2, kw), e3.removeEventListener("touchmove", U2, kw);
    }
    function G2(e3, t3) {
      var r3 = k2().box;
      function n3(e4) {
        e4.target === r3 && (Qw(r3, "remove", n3), t3());
      }
      if (0 === e3)
        return t3();
      Qw(r3, "remove", o2), Qw(r3, "add", n3), o2 = n3;
    }
    function V2(t3, r3, n3) {
      void 0 === n3 && (n3 = false), Ow(A2.props.triggerTarget || e2).forEach(function(e3) {
        e3.addEventListener(t3, r3, n3), m2.push({ node: e3, eventType: t3, handler: r3, options: n3 });
      });
    }
    function Q2() {
      var e3;
      C2() && (V2("touchstart", W2, { passive: true }), V2("touchend", X2, { passive: true })), (e3 = A2.props.trigger, e3.split(/\s+/).filter(Boolean)).forEach(function(e4) {
        if ("manual" !== e4)
          switch (V2(e4, W2), e4) {
            case "mouseenter":
              V2("mouseleave", X2);
              break;
            case "focus":
              V2(Jw ? "focusout" : "blur", Y2);
              break;
            case "focusin":
              V2("focusout", Y2);
          }
      });
    }
    function H2() {
      m2.forEach(function(e3) {
        var t3 = e3.node, r3 = e3.eventType, n3 = e3.handler, i3 = e3.options;
        t3.removeEventListener(r3, n3, i3);
      }), m2 = [];
    }
    function W2(e3) {
      var t3, r3 = false;
      if (A2.state.isEnabled && !K2(e3) && !p2) {
        var n3 = "focus" === (null == (t3 = s2) ? void 0 : t3.type);
        s2 = e3, l2 = e3.currentTarget, L2(), !A2.state.isVisible && Bw(e3, "MouseEvent") && lE.forEach(function(t4) {
          return t4(e3);
        }), "click" === e3.type && (A2.props.trigger.indexOf("mouseenter") < 0 || h2) && false !== A2.props.hideOnClick && A2.state.isVisible ? r3 = true : ee2(e3), "click" === e3.type && (h2 = !r3), r3 && !n3 && te2(e3);
      }
    }
    function q2(e3) {
      var t3 = e3.target, r3 = T2().contains(t3) || y2.contains(t3);
      if ("mousemove" !== e3.type || !r3) {
        var n3 = $2().concat(y2).map(function(e4) {
          var t4, r4 = null == (t4 = e4._tippy.popperInstance) ? void 0 : t4.state;
          return r4 ? { popperRect: e4.getBoundingClientRect(), popperState: r4, props: u2 } : null;
        }).filter(Boolean);
        (function(e4, t4) {
          var r4 = t4.clientX, n4 = t4.clientY;
          return e4.every(function(e5) {
            var t5 = e5.popperRect, i3 = e5.popperState, s3 = e5.props.interactiveBorder, o3 = i3.placement.split("-")[0], a3 = i3.modifiersData.offset;
            if (!a3)
              return true;
            var l3 = "bottom" === o3 ? a3.top.y : 0, c3 = "top" === o3 ? a3.bottom.y : 0, u3 = "right" === o3 ? a3.left.x : 0, h3 = "left" === o3 ? a3.right.x : 0, p3 = t5.top - n4 + l3 > s3, d3 = n4 - t5.bottom - c3 > s3, f3 = t5.left - r4 + u3 > s3, m3 = r4 - t5.right - h3 > s3;
            return p3 || d3 || f3 || m3;
          });
        })(n3, e3) && (O2(), te2(e3));
      }
    }
    function X2(e3) {
      K2(e3) || A2.props.trigger.indexOf("click") >= 0 && h2 || (A2.props.interactive ? A2.hideWithInteractivity(e3) : te2(e3));
    }
    function Y2(e3) {
      A2.props.trigger.indexOf("focusin") < 0 && e3.target !== T2() || A2.props.interactive && e3.relatedTarget && y2.contains(e3.relatedTarget) || te2(e3);
    }
    function K2(e3) {
      return !!Ww.isTouch && C2() !== e3.type.indexOf("touch") >= 0;
    }
    function J2() {
      Z2();
      var t3 = A2.props, r3 = t3.popperOptions, n3 = t3.placement, i3 = t3.offset, s3 = t3.getReferenceClientRect, o3 = t3.moveTransition, l3 = M2() ? sE(y2).arrow : null, c3 = s3 ? { getBoundingClientRect: s3, contextElement: s3.contextElement || T2() } : e2, u3 = [{ name: "offset", options: { offset: i3 } }, { name: "preventOverflow", options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } } }, { name: "flip", options: { padding: 5 } }, { name: "computeStyles", options: { adaptive: !o3 } }, { name: "$$tippy", enabled: true, phase: "beforeWrite", requires: ["computeStyles"], fn: function(e3) {
        var t4 = e3.state;
        if (M2()) {
          var r4 = k2().box;
          ["placement", "reference-hidden", "escaped"].forEach(function(e4) {
            "placement" === e4 ? r4.setAttribute("data-placement", t4.placement) : t4.attributes.popper["data-popper-" + e4] ? r4.setAttribute("data-" + e4, "") : r4.removeAttribute("data-" + e4);
          }), t4.attributes.popper = {};
        }
      } }];
      M2() && l3 && u3.push({ name: "arrow", options: { element: l3, padding: 3 } }), u3.push.apply(u3, (null == r3 ? void 0 : r3.modifiers) || []), A2.popperInstance = Cw(c3, y2, Object.assign({}, r3, { placement: n3, onFirstUpdate: a2, modifiers: u3 }));
    }
    function Z2() {
      A2.popperInstance && (A2.popperInstance.destroy(), A2.popperInstance = null);
    }
    function $2() {
      return Uw(y2.querySelectorAll("[data-tippy-root]"));
    }
    function ee2(e3) {
      A2.clearDelayTimeouts(), e3 && B2("onTrigger", [A2, e3]), j2();
      var t3 = D2(true), n3 = S2(), i3 = n3[0], s3 = n3[1];
      Ww.isTouch && "hold" === i3 && s3 && (t3 = s3), t3 ? r2 = setTimeout(function() {
        A2.show();
      }, t3) : A2.show();
    }
    function te2(e3) {
      if (A2.clearDelayTimeouts(), B2("onUntrigger", [A2, e3]), A2.state.isVisible) {
        if (!(A2.props.trigger.indexOf("mouseenter") >= 0 && A2.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(e3.type) >= 0 && h2)) {
          var t3 = D2(false);
          t3 ? n2 = setTimeout(function() {
            A2.state.isVisible && A2.hide();
          }, t3) : i2 = requestAnimationFrame(function() {
            A2.hide();
          });
        }
      } else
        z2();
    }
  }
  function hE(e2, t2) {
    void 0 === t2 && (t2 = {});
    var r2 = Zw.plugins.concat(t2.plugins || []);
    document.addEventListener("touchstart", Xw, kw), window.addEventListener("blur", Kw);
    var n2, i2 = Object.assign({}, t2, { plugins: r2 }), s2 = (n2 = e2, zw(n2) ? [n2] : function(e3) {
      return Bw(e3, "NodeList");
    }(n2) ? Uw(n2) : Array.isArray(n2) ? n2 : Uw(document.querySelectorAll(n2))).reduce(function(e3, t3) {
      var r3 = t3 && uE(t3, i2);
      return r3 && e3.push(r3), e3;
    }, []);
    return zw(e2) ? s2[0] : s2;
  }
  hE.defaultProps = Zw, hE.setDefaultProps = function(e2) {
    Object.keys(e2).forEach(function(t2) {
      Zw[t2] = e2[t2];
    });
  }, hE.currentInput = Ww, Object.assign({}, aw, { effect: function(e2) {
    var t2 = e2.state, r2 = { popper: { position: t2.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
    Object.assign(t2.elements.popper.style, r2.popper), t2.styles = r2, t2.elements.arrow && Object.assign(t2.elements.arrow.style, r2.arrow);
  } }), hE.setDefaultProps({ render: oE });
  var pE = hE;
  class dE extends qy {
    async _refreshUi() {
      var e2;
      if (!await super._refreshUi())
        return false;
      $y.RemoveAll(dE.PluginType);
      for (const e3 of this.variations)
        $y.Create(dE.PluginType, e3.title, 5, 20, 0, e3.materials.map((t2) => {
          let r2;
          if (e3.preview.startsWith("generate:"))
            r2 = this._previewGenerator.generate(t2, e3.preview.split(":")[1]);
          else {
            const n2 = t2[e3.preview] || "#ff00ff";
            r2 = n2.image ? It(n2.image, 100) : void 0, r2 || (r2 = Yy(n2, true));
          }
          return { id: t2.uuid, image: r2, onClick: (t3) => this.applyVariation(e3, t3), tooltip: t2.name || t2.uuid };
        }), (e4, t2) => pE(e4, { placement: "bottom", content: t2.tooltip }));
      return $y.RebuildUi(null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.container), true;
    }
  }
  dE.PluginType = "MaterialConfiguratorPlugin";
  class fE extends ro {
    constructor() {
      super(...arguments), this.enabled = true, this._uiNeedRefresh = false, this._refreshUiConfig = () => {
        var e2, t2;
        this.enabled && (null === (t2 = null === (e2 = this.uiConfig) || void 0 === e2 ? void 0 : e2.uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true));
      }, this.dependencies = [to], this._selectedObject = () => {
        var e2;
        return (null === (e2 = this._picking) || void 0 === e2 ? void 0 : e2.getSelectedObject()) || void 0;
      }, this._selectedMaterial = () => {
        var e2;
        return (null === (e2 = this._selectedObject()) || void 0 === e2 ? void 0 : e2.material) || void 0;
      };
    }
    async onAdded(e2) {
      var t2, r2;
      await super.onAdded(e2), this.refreshUi = this.refreshUi.bind(this), this._refreshUi = this._refreshUi.bind(this), this._picking = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Picking"), this._previewGenerator = new Wy(this._viewer), null === (r2 = this._picking) || void 0 === r2 || r2.addEventListener("selectedObjectChanged", this._refreshUiConfig), e2.addEventListener("preFrame", this._refreshUi), this.addEventListener("deserialize", this.refreshUi);
    }
    async onRemove(e2) {
      var t2, r2;
      return null === (t2 = this._previewGenerator) || void 0 === t2 || t2.dispose(), this._previewGenerator = void 0, null === (r2 = this._picking) || void 0 === r2 || r2.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this.removeEventListener("deserialize", this.refreshUi), e2.removeEventListener("preFrame", this._refreshUi), this._picking = void 0, super.onRemove(e2);
    }
    refreshUi() {
      this.enabled && (this._uiNeedRefresh = true);
    }
    async _refreshUi() {
      return this._uiNeedRefresh && this.enabled && this._refreshUiConfig(), this._uiNeedRefresh = false, false;
    }
  }
  fE.PluginType = "MaterialLibraryBasePlugin", function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, r2, o2);
  }([Je("Enabled")], fE.prototype, "enabled", void 0);
  class mE extends fE {
    constructor() {
      super(...arguments), this.replaceMaterial = false, this.uiConfig = { type: "folder", label: "Material Library", uuid: Xe(), children: [...ot(this), () => {
        var e2;
        return { type: "dropdown", label: "Apply Material", limitedUi: true, hidden: () => !this._selectedObject(), children: [{ label: "select one", value: "" }, [...this._viewer.getPlugin(to).materials.getMaterialsOfType(null === (e2 = this._selectedMaterial()) || void 0 === e2 ? void 0 : e2.typeSlug).map((e3) => ({ label: e3.name || e3.uuid, value: e3.uuid })) || []]], getValue: () => {
          var e3;
          return null === (e3 = this._selectedMaterial()) || void 0 === e3 ? void 0 : e3.uuid;
        }, setValue: (e3) => {
          var t2, r2, n2, i2, s2;
          const o2 = null === (n2 = null === (r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(to)) || void 0 === r2 ? void 0 : r2.materials) || void 0 === n2 ? void 0 : n2.findMaterial(e3);
          if (o2)
            if (this.replaceMaterial)
              null === (s2 = null === (i2 = this._selectedObject()) || void 0 === i2 ? void 0 : i2.setMaterial) || void 0 === s2 || s2.call(i2, o2);
            else {
              const e4 = this._selectedMaterial();
              if (e4) {
                const t3 = e4.name, r3 = e4.uuid;
                e4.copyProps(o2), e4.name = t3, e4.uuid = r3, e4.userData.uuid && (e4.userData.uuid = r3);
              }
            }
          this._refreshUi();
        } };
      }] };
    }
    async _refreshUi() {
      var e2, t2, r2, n2;
      if (!await super._refreshUi())
        return false;
      const i2 = [Kt.TypeSlug, Zo.TypeSlug], s2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(to)) || void 0 === t2 ? void 0 : t2.materials, o2 = i2.map((e3) => [e3, null == s2 ? void 0 : s2.getMaterialsOfType(e3)]);
      $y.RemoveAll(mE.PluginType);
      for (const [e3, t3] of o2)
        $y.Create(mE.PluginType, e3, 5, 20, 0, null === (r2 = t3) || void 0 === r2 ? void 0 : r2.filter((e4) => !e4.userData.__runtimeMaterial).map((e4) => {
          let t4;
          const r3 = "generate:sphere";
          if (r3.startsWith("generate:"))
            t4 = this._previewGenerator.generate(e4, r3.split(":")[1]);
          else {
            const n3 = e4[r3] || "#ff00ff";
            t4 = n3.image ? It(n3.image, 100) : void 0, t4 || (t4 = Xy(n3, true));
          }
          return { id: e4.uuid, image: t4, onClick: (e5) => {
            const t5 = null == s2 ? void 0 : s2.findMaterial(e5);
            if (console.log(null == t5 ? void 0 : t5.name), t5) {
              const e6 = t5.userData.__appliedMeshes;
              if (null == e6 ? void 0 : e6.size) {
                const t6 = e6.keys().next().value;
                t6.dispatchEvent({ type: "select", value: t6 });
              }
            }
          }, tooltip: e4.name || e4.uuid };
        }), (e4, t4) => pE(e4, { placement: "bottom", content: t4.tooltip }));
      return $y.RebuildUi(null === (n2 = this._viewer) || void 0 === n2 ? void 0 : n2.container), true;
    }
  }
  function _E(e2, t2, r2, i2) {
    e2.traverse((e3) => {
      e3 && (e3.userData.cloneRotI = t2, e3.userData.rotationCount = r2, e3.userData.rotationAxis = i2, e3.addEventListener("beforeRender", (t3) => function(e4, t4) {
        var r3;
        t4 && (null === (r3 = t4.map) || void 0 === r3 ? void 0 : r3.isTexture) && (t4.extraUniformsToUpload || (t4.extraUniformsToUpload = {}), t4.extraUniformsToUpload.uvTransform || (t4.extraUniformsToUpload.uvTransform = { value: new n.Vkp() }), t4.extraUniformsToUpload.uvTransform.value.setUvTransform(t4.map.offset.x * t4.map.repeat.x * e4.userData.cloneRotI / (e4.userData.rotationCount || 1), t4.map.offset.y * t4.map.repeat.y * e4.userData.cloneRotI / (e4.userData.rotationCount || 1), t4.map.repeat.x, t4.map.repeat.y, t4.map.rotation, t4.map.center.x, t4.map.center.y));
      }(e3, t3.material)));
    });
  }
  function gE(e2, t2, r2, n2 = "x") {
    var i2;
    if (e2.userData.rotationCount > 1 && !e2.userData.rotationRoot)
      return e2;
    const s2 = e2.parent;
    if (!s2)
      throw new Error("No parent");
    if (e2.userData.cloneParent) {
      const t3 = e2.userData.cloneParent;
      if (!(e2 = s2.children.find((e3) => t3 === e3.uuid)))
        return console.error("Couldn't find clone root, cannot rotate. maybe a serialization issue?", t3, s2), e2;
    }
    let o2 = s2.children.filter((t3) => {
      var r3;
      return (null === (r3 = t3.userData) || void 0 === r3 ? void 0 : r3.cloneParent) === e2.uuid;
    }).sort((e3, t3) => e3.userData.cloneRotI - t3.userData.cloneRotI);
    if (e2.userData.rotationCount === t2 && t2 === o2.length && void 0 === r2 && e2.userData.rotationAxis === n2)
      return e2;
    if (null == r2 && (r2 = null !== (i2 = e2.userData.rotationSkips) && void 0 !== i2 ? i2 : []), r2 !== e2.userData.rotationSkips && (e2.userData.rotationSkips = [...r2]), _E(e2, 0, t2, n2), e2.userData.rotationRoot = true, e2.visible = true, t2 <= o2.length) {
      for (let e3 = t2 - 1; e3 < o2.length; e3++)
        s2.remove(o2[e3]), o2[e3].traverse((e4) => e4.userData = { __disposed: true });
      o2 = o2.slice(0, t2);
    }
    for (let i3 = 1; i3 < t2; i3++) {
      const a2 = i3 <= o2.length ? o2[i3 - 1] : e2.clone();
      a2.rotation.copy(e2.rotation), a2.rotation[n2] += i3 / t2 * Math.PI * 2, _E(a2, i3, t2, n2), i3 > o2.length && s2.add(a2), a2.visible = !r2.includes(i3);
    }
    return e2.visible = !r2.includes(0), e2;
  }
  mE.PluginType = "MaterialLibraryPlugin", function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, r2, o2);
  }([Je("Replace Material")], mE.prototype, "replaceMaterial", void 0);
  var vE, AE = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let bE = vE = class extends ro {
    constructor() {
      super(), this.enabled = true, this.rotations = 1, this.axis = "x", this.skips = "", this._selectedObjectChanged = this._selectedObjectChanged.bind(this);
    }
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2), null === (t2 = e2.getPluginByType("Picking")) || void 0 === t2 || t2.addEventListener("selectedObjectChanged", this._selectedObjectChanged);
    }
    _selectedObjectChanged() {
      var e2, t2, r2, n2, i2, s2, o2, a2, l2;
      if (!this.enabled)
        return;
      const c2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("Picking")) || void 0 === t2 ? void 0 : t2.getSelectedObject();
      if (!c2)
        return void (null === (n2 = (r2 = this.uiConfig).uiRefresh) || void 0 === n2 || n2.call(r2, "postFrame", true));
      const u2 = c2.userData.rotationRoot && null !== (i2 = c2.userData.rotationCount) && void 0 !== i2 ? i2 : 1;
      this.rotations = u2, this.skips = null !== (o2 = null === (s2 = c2.userData.rotationSkips) || void 0 === s2 ? void 0 : s2.join(",")) && void 0 !== o2 ? o2 : "", this.axis = c2.userData.rotationAxis || "x", null === (l2 = (a2 = this.uiConfig).uiRefresh) || void 0 === l2 || l2.call(a2, "postFrame", true);
    }
    _paramsChanged() {
      var e2, t2, r2, i2, s2, o2;
      if (!this.enabled)
        return;
      const a2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("Picking")) || void 0 === t2 ? void 0 : t2.getSelectedObject();
      if (a2) {
        if (this.rotations > 1 || a2.userData.rotationCount) {
          const e3 = a2.userData.rotationCount, t3 = gE(a2, this.rotations, this.skips.split(",").map((e4) => parseInt(e4)).filter((e4) => isFinite(e4)), this.axis), o3 = null == t3 ? void 0 : t3.userData.rotationCount;
          if (o3 && o3 !== e3) {
            const e4 = [];
            null == t3 || t3.traverseAncestors((t4) => {
              e4.push(t4);
            });
            for (const t4 of e4)
              if (t4.userData.autoScaled) {
                X(t4), null === (r2 = this._viewer) || void 0 === r2 || r2.resetCamera({ rootObject: t4, centerOffset: new n.Pa4(4, 4, 4) });
                break;
              }
          }
          a2.parent && !a2.userData.__disposed || null === (s2 = null === (i2 = this._viewer) || void 0 === i2 ? void 0 : i2.getPluginByType("Picking")) || void 0 === s2 || s2.setSelectedObject(t3, true);
        }
        null === (o2 = this._viewer) || void 0 === o2 || o2.scene.setDirty({ frameFade: false, sceneUpdate: true });
      }
    }
  };
  bE.PluginType = "ObjectRotationPlugin", AE([Ce(), Je("Enabled"), M(vE.prototype._paramsChanged)], bE.prototype, "enabled", void 0), AE([$e("Rotation Count", [1, 100], 1, (e2) => ({ hidden: () => {
    var t2, r2;
    return !(null === (r2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Picking")) || void 0 === r2 ? void 0 : r2.getSelectedObject()) || !e2.rotations;
  } })), M(vE.prototype._paramsChanged)], bE.prototype, "rotations", void 0), AE([tt("Axis", ["x", "y", "z"].map((e2) => ({ label: e2 })), (e2) => ({ hidden: () => {
    var t2, r2;
    return !(null === (r2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Picking")) || void 0 === r2 ? void 0 : r2.getSelectedObject()) || !e2.rotations;
  } })), M(vE.prototype._paramsChanged)], bE.prototype, "axis", void 0), AE([nt("Rotation Skips", (e2) => ({ hidden: () => {
    var t2, r2;
    return !(null === (r2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Picking")) || void 0 === r2 ? void 0 : r2.getSelectedObject()) || !e2.rotations;
  } })), M(vE.prototype._paramsChanged)], bE.prototype, "skips", void 0), bE = vE = AE([lt("Object Rotations")], bE);
  var yE, xE = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let wE = yE = class extends ro {
    constructor(e2 = true) {
      super(), this.enabled = true, this.debugNormals = false, this.debugHitHeight = false, this._defines = { PARALLAX_NORMAL_MAP_QUALITY: 0 }, this.stepCount = 12, this.binaryStepCount = 3, this._bumpMapExtension = { shaderExtender: (e3, t2, r2) => {
        if (t2.materialObject.bumpMap && this.enabled) {
          e3.fragmentShader = e3.fragmentShader.replace("#include <normal_fragment_begin>", ""), e3.fragmentShader = e3.fragmentShader.replace("#include <normal_fragment_maps>", ""), e3.fragmentShader = e3.fragmentShader.replace("#include <map_fragment>", "#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <map_fragment>");
          for (const t3 of ["map_fragment", "alphamap_fragment", "roughnessmap_fragment", "metalnessmap_fragment", "emissivemap_fragment", "transmission_fragment"])
            e3.fragmentShader = e3.fragmentShader.replace(`#include <${t3}>`, n.WdD[t3].replace("vUv", "parallaxUv.xy"));
          (this.debugNormals || this.debugHitHeight) && (e3.fragmentShader = e3.fragmentShader.replace("texture2D( map, parallaxUv.xy )", this.debugNormals ? "vec4(normal, 1.); normal = geometryNormal" : "vec4(parallaxUv.z,0., 0., 1.)")), e3.fragmentShader = e3.fragmentShader.replace("#include <normal_fragment_maps>", n.WdD.normal_fragment_maps.replace("#elif defined( TANGENTSPACE_NORMALMAP )", "#elif defined( TANGENTSPACE_NORMALMAP ) && !defined( USE_BUMPMAP )").replace("normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );", "vec3 parallaxUv = reliefParallaxPerturbNormal(faceDirection, normal);"));
        }
      }, parsFragmentSnippet: () => this.enabled ? "#ifdef USE_BUMPMAP\nmat3 mat3_inverse(mat3 A){mat3 M_t=mat3(vec3(A[0][0],A[1][0],A[2][0]),vec3(A[0][1],A[1][1],A[2][1]),vec3(A[0][2],A[1][2],A[2][2]));float det=dot(cross(M_t[0],M_t[1]),M_t[2]);mat3 adjugate=mat3(cross(M_t[1],M_t[2]),cross(M_t[2],M_t[0]),cross(M_t[0],M_t[1]));return adjugate/det;}float CalculateHeight(in vec2 texCoords){float height=texture2D(bumpMap,texCoords).x;return clamp(height,0.,1.);}const vec2 bumpMapSize=vec2(512,512);vec3 CalculateNormal(in vec2 texCoords){\n#if defined( TANGENTSPACE_NORMALMAP ) && 0 \nvec3 mapN=texture2D(normalMap,texCoords).xyz;mapN.xy*=normalScale;return normalize(mapN);\n#else\nvec2 texOffs=1./bumpMapSize;\n#if PARALLAX_NORMAL_MAP_QUALITY > 0\nfloat hx[9];hx[0]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,-1.)).r;hx[1]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;hx[2]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,-1.)).r;hx[3]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;hx[4]=texture2D(bumpMap,texCoords.st).r;hx[5]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;hx[6]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,1.)).r;hx[7]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;hx[8]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,1.)).r;vec2 deltaH=vec2(hx[0]-hx[2]+2.*(hx[3]-hx[5])+hx[6]-hx[8],hx[0]-hx[6]+2.*(hx[1]-hx[7])+hx[2]-hx[8]);\n#else\nfloat h_xa=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;float h_xb=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;float h_ya=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;float h_yb=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;vec2 deltaH=vec2(h_xa-h_xb,h_ya-h_yb);\n#endif\nreturn normalize(vec3(deltaH/texOffs,1.));\n#endif\n}vec3 ReliefParallax(in float frontFace,in vec3 texDir3D,in vec2 texCoord){float surf_sign=frontFace;float back_face=step(0.,-surf_sign);vec2 texStep=surf_sign*texDir3D.xy/abs(texDir3D.z);vec2 texC=texCoord.st+surf_sign*texStep+back_face*texStep.xy;float mapHeight=1.;float bumpHeightStep=1./float(PARALLAX_MAP_STEPS);float bestBumpHeight=mapHeight+bumpHeightStep;\n#pragma unroll_loop_start\nfor(int i=0;i<PARALLAX_MAP_STEPS;i++){if(mapHeight<bestBumpHeight){bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);}}\n#pragma unroll_loop_end\nbestBumpHeight+=bumpHeightStep;\n#pragma unroll_loop_start\nfor(int i=0;i<PARALLAX_MAP_B_STEPS;i++){bumpHeightStep*=0.5;bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);bestBumpHeight+=(bestBumpHeight<mapHeight)?bumpHeightStep:0.;}\n#pragma unroll_loop_end\nbestBumpHeight-=bumpHeightStep*clamp((bestBumpHeight-mapHeight)/bumpHeightStep,0.,1.);mapHeight=bestBumpHeight;texC-=mapHeight*texStep;return vec3(texC.xy,mapHeight);}vec3 reliefParallaxPerturbNormal(in float faceDirection,inout vec3 normal){if(abs(bumpScale)<0.001)return vec3(vUv,0.);float parallaxHeight;vec2 texCoords=vUv;float face_sign=sign(dot(normal,vViewPosition));vec3 N=normalize(normal);vec3 dp1=dFdx(-vViewPosition);vec3 dp2=dFdy(-vViewPosition);vec2 duv1=dFdx(vUv);vec2 duv2=dFdy(vUv);vec3 dp2perp=cross(dp2,N);vec3 dp1perp=cross(N,dp1);vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(T,T),dot(B,B)));mat3 tbnMat=mat3(T*invmax,B*invmax,N*bumpScale);vec3 tangentPos=normalize(mat3_inverse(tbnMat)*-vViewPosition);vec3 parallaxUv=ReliefParallax(face_sign,tangentPos,vUv);tbnMat[2]=face_sign*N/bumpScale;normal=normalize(tbnMat*CalculateNormal(parallaxUv.xy).xyz);\n#ifdef FLIP_SIDED\nnormal=-normal;\n#endif\nreturn parallaxUv;}\n#endif \n\n".replaceAll("PARALLAX_MAP_STEPS", this._defines.PARALLAX_MAP_STEPS).replaceAll("PARALLAX_MAP_B_STEPS", this._defines.PARALLAX_MAP_B_STEPS) : "", isCompatible: (e3) => e3.isMeshStandardMaterial2, computeCacheKey: (e3) => {
        var t2;
        return this.enabled + " " + (null === (t2 = e3.materialObject.bumpMap) || void 0 === t2 ? void 0 : t2.uuid) + " " + this.debugNormals + " " + this.debugHitHeight + "  ";
      }, onObjectRender: (e3, { materialObject: t2 }, r2) => {
        for (const [e4, r3] of Object.entries(this._defines)) {
          const n2 = "number" == typeof r3 ? r3 : r3 ? 1 : 0;
          t2.defines[e4] !== n2 && (t2.defines[e4] = n2, t2.needsUpdate = true);
        }
      } }, this.dependencies = [to], this.enabled = e2, this._updateExtension = this._updateExtension.bind(this);
    }
    _updateExtension() {
      var e2, t2, r2;
      null === (t2 = null === (e2 = this._bumpMapExtension) || void 0 === e2 ? void 0 : e2.setDirty) || void 0 === t2 || t2.call(e2), null === (r2 = this._viewer) || void 0 === r2 || r2.setDirty();
    }
    async onAdded(e2) {
      var t2, r2;
      return null === (r2 = null === (t2 = e2.getPlugin(to)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === r2 || r2.registerMaterialExtension(this._bumpMapExtension), super.onAdded(e2);
    }
    async onRemove(e2) {
      var t2, r2;
      return null === (r2 = null === (t2 = e2.getPlugin(to)) || void 0 === t2 ? void 0 : t2.materials) || void 0 === r2 || r2.unregisterMaterialExtension(this._bumpMapExtension), super.onRemove(e2);
    }
  };
  wE.PluginType = "ReliefParallaxMapping", xE([M(yE.prototype._updateExtension), Je("Enabled")], wE.prototype, "enabled", void 0), xE([M(yE.prototype._updateExtension), Je("Debug Normals")], wE.prototype, "debugNormals", void 0), xE([M(yE.prototype._updateExtension), Je("Debug Hit Height")], wE.prototype, "debugHitHeight", void 0), xE([V("PARALLAX_MAP_STEPS", void 0, true, yE.prototype._updateExtension), $e("Step count", [1, 32], 1), Ce()], wE.prototype, "stepCount", void 0), xE([V("PARALLAX_MAP_B_STEPS", void 0, true, yE.prototype._updateExtension), $e("Binary search steps", [1, 8], 1), Ce()], wE.prototype, "binaryStepCount", void 0), wE = yE = xE([lt("Parallax Mapping")], wE);
  var EE = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  class SE extends zt {
    constructor(e2, t2, r2, i2 = false) {
      super({ vertexShader: Io, fragmentShader: `

${Do}
${ko}
${Po}
${Bo}
${r2}

${Ro}

varying vec2 vUv;uniform float intensity;uniform float objectRadius;uniform float rayCount;uniform float power;uniform float bias;uniform float falloff;uniform float tolerance;uniform bool autoRadius;uniform vec2 screenSize;vec3 ComputeUniformL(vec3 N,vec2 E){vec3 L;L.xy=E;L.z=interleavedGradientNoise(gl_FragCoord.xy,frameCount*5.);L=L*2.-1.;return L;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=random3(vec3(gl_FragCoord.xy,frameCount+seed));rand_e.y=random3(vec3(gl_FragCoord.yx,rand_e.x+(frameCount)*7.));return rand_e;}vec4 calculateGI(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeUniformL(normal,E);L=normalize(L);L*=sign(dot(L,normal));float cameraDist=length(cameraPositionWorld);float rayLen=autoRadius?length(viewPos-screenToView(screenPos.xy+objectRadius/10.,screenPos.z)):mix((cameraNearFar.y)+viewPos.z,-viewPos.z-cameraNearFar.x,L.z*0.5+0.5)*objectRadius;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount*14.+seed)+0.05;rayLen=max(rayLen,0.001);vec3 state=vec3(1.,(r+0.5)/float(RTAO_STEP_COUNT),2.);viewPos+=normal*max(-0.01*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,RTAO_STEP_COUNT);vec3 viewHitP=screenToView(screenHitP.xy,screenHitP.z);vec3 LRes=viewHitP-viewPos;if(state.z>1.)LRes=vec3(9999999.);float dist=length(LRes)*falloff;float EPS=0.01;float zBias=(viewPos.z)*bias;float ao=(max(dot(normal,L)+zBias,0.))/(dist*dist+EPS);
#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0
vec3 hitColor=tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy)).rgb;vec3 hitNormal=getViewNormal(screenHitP.xy);float giWeight=1.;giWeight=saturate2(giWeight/(dist+EPS),1.);giWeight*=saturate2((dot(normal,L)),1.);giWeight*=saturate2((dot(hitNormal,-L)),1.);return vec4(hitColor*giWeight,ao);
#endif
return vec4(0,0,0,ao);}float normpdf(in float x,in float sigma){return exp(-0.5*x*x/(sigma*sigma));}vec4 getLastThis(sampler2D tex,float depth,vec3 normal){vec2 direction=vec2(1,1);vec4 color=clamp(tLastThisTexelToLinear(texture2D(tex,vUv.xy)),0.,5.);return color;}void main(){float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>0.99){discard;gl_FragColor=getLastThis(tLastThis,depth,normal);return;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec4 gi=vec4(0.);gi+=calculateGI(8.,screenPos,normal,1.);if(rayCount>1.5)gi=max(gi,calculateGI(2.,screenPos,normal,0.4));if(rayCount>2.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.5));if(rayCount>3.5)gi=max(gi,calculateGI(1.,screenPos,normal,0.6));if(rayCount>4.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.));gi.a=min(1.,gi.a);gi.a=max(0.,gi.a);gi.rgb=min(vec3(3.),gi.rgb);gi.rgb=max(vec3(0.),gi.rgb);if(frameCount<3.){gl_FragColor=gi;return;}gl_FragColor=(texture2D(tLastThis,vUv));gl_FragColor=((gi+(gl_FragColor)*frameCount)/(frameCount+1.));}

            `, uniforms: { tLastThis: { value: null }, tDiffuse: { value: null }, tNormalDepth: { value: null }, tLastFrame: { value: null }, opacity: { value: 1 }, intensity: { value: 2.14 }, rayCount: { value: 0.1 }, objectRadius: { value: 1 }, autoRadius: { value: !i2 }, power: { value: 1.1 }, bias: { value: 0.015 }, falloff: { value: 0.7 }, tolerance: { value: 1.5 }, frameCount: { value: 0 }, projection: { value: new n.yGw() }, screenSize: { value: new n.FM8() }, cameraPositionWorld: { value: new n.Pa4() }, cameraNearFar: { value: new n.FM8(0.1, 1e3) } }, defines: { PERSPECTIVE_CAMERA: 1, SSGI_ENABLED: i2 ? 1 : 0 } }, "tDiffuse", "tLastFrame", "tLastThis"), this.materialExtension = { shaderExtender: (e3, t3, r3) => {
        if (!e3.defines.SSRTAO_ENABLED)
          return;
        const n2 = "vec3 totalDiffuse =";
        e3.fragmentShader = e3.fragmentShader.replace(n2, `

            
            #if defined(SSRTAO_ENABLED) && SSRTAO_ENABLED > 0
vec4 ssgi=tSSGIMapTexelToLinear(texture2D(tSSGIMap,viewToScreen(vViewPosition.xyz).xy));float ambientOcclusion=1.-ssgi.a;ambientOcclusion=max(0.,ambientOcclusion);ambientOcclusion=pow(ambientOcclusion,ssaoPower);ambientOcclusion=min(1.,ambientOcclusion);reflectedLight.indirectDiffuse*=ambientOcclusion;
#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0
vec3 ssgiColor=ssgi.rgb*ssgiIntensity;reflectedLight.indirectDiffuse+=ssgiColor*(material.diffuseColor.rgb);
#endif
#if defined( USE_ENVMAP )
float dotNV=saturate(dot(geometry.normal,geometry.viewDir));float specularOcclusion=saturate(pow(dotNV+ambientOcclusion,exp2(-16.*material.roughness-1.))-1.+ambientOcclusion);reflectedLight.indirectSpecular*=specularOcclusion;
#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0
#if !defined(SSR_ENABLED) || SSR_ENABLED < 1
reflectedLight.indirectSpecular+=ssgiColor*material.specularColor;
#endif
#endif
#endif
#endif

            
            // reflectedLight.directDiffuse = vec3(0.);
            // reflectedLight.indirectDiffuse = vec3(0.);
            // reflectedLight.directSpecular = vec3(0.);
            // reflectedLight.indirectSpecular = vec3(0.);
            
            
${n2}`), e3.fragmentShader = e3.fragmentShader.replace("#include <aomap_fragment>", ""), e3.vertexUvs = true;
      }, onObjectRender: (e3, t3, r3) => {
        var n2, i3, s2;
        this.materialExtension.extraUniforms.tSSGIMap.value = null === (n2 = this._target) || void 0 === n2 ? void 0 : n2.texture;
        const o2 = t3.materialObject, a2 = !o2.transparent && o2.transmission < 1e-3;
        let l2 = this.enabled && a2 && (this.renderWithCamera || this._renderer.frameCount > 1) && false !== r3.userData.screenSpaceRendering && !(null === (i3 = o2.userData) || void 0 === i3 ? void 0 : i3.ssrtaoDisabled) && !(null === (s2 = o2.userData) || void 0 === s2 ? void 0 : s2.ssaoDisabled) ? 1 : 0;
        o2.defines.SSRTAO_ENABLED !== l2 && (o2.defines.SSRTAO_ENABLED = l2, o2.needsUpdate = true), l2 = this.material.defines.SSGI_ENABLED, o2.defines.SSGI_ENABLED !== l2 && (o2.defines.SSGI_ENABLED = l2, o2.needsUpdate = true), l2 = this._target.texture, this.materialExtension.extraUniforms.tSSGIMap.value !== l2 && (this.materialExtension.extraUniforms.tSSGIMap.value = l2, o2.needsUpdate = true);
      }, parsFragmentSnippet: (e3) => {
        var t3;
        return w`
            uniform float ssaoPower;
            uniform float ssgiIntensity;
            uniform sampler2D tSSGIMap;
            ${U("tSSGIMap", null === (t3 = this._target) || void 0 === t3 ? void 0 : t3.texture, e3.capabilities.isWebGL2)}

            ${Oo}

        `;
      }, extraUniforms: { tSSGIMap: { value: null }, ssaoPower: this.material.uniforms.power, ssgiIntensity: this.material.uniforms.intensity }, computeCacheKey: (e3) => {
        var t3, r3;
        return this.enabled ? "1" : "0" + (null === (r3 = null === (t3 = this._target) || void 0 === t3 ? void 0 : t3.texture) || void 0 === r3 ? void 0 : r3.encoding);
      }, isCompatible: (e3) => {
        var t3;
        return !(null === (t3 = e3.materialObject.userData) || void 0 === t3 ? void 0 : t3.ssaoDisabled) && e3.isMeshStandardMaterial2;
      } }, this.intensity = 2, this.power = 1.1, this.autoRadius = true, this.objectRadius = 2, this.tolerance = 1, this.bias = 0.15, this.falloff = 0.7, this.rayCount = 2, this.stepCount = 4, this.smoothEnabled = true, this.renderWithCamera = true, this.uiConfig = { type: "folder", label: "SS Global illumination (Dev)", children: [...ot(this), { type: "checkbox", label: "GI Enabled", hidden: () => !this._giActivated, property: [this, "ssgiEnabled"] }] }, this._renderer = e2, this._target = t2, this.needsSwap = true, this._giActivated = i2, this.ssgiEnabled = i2, this.bilateralPass = new zo(this._target, r2, "rgba");
    }
    get ssgiEnabled() {
      return parseInt(this.material.defines.SSGI_ENABLED) > 0.5;
    }
    set ssgiEnabled(e2) {
      e2 = e2 && this._giActivated, this.material.defines.SSGI_ENABLED = e2 ? 1 : 0, this.material.needsUpdate = true;
    }
    render(e2, t2, r2, n2, i2) {
      this.needsSwap = false, !this.renderWithCamera && this._renderer.frameCount < 2 || (this._renderer.blit(this._target.texture, t2), this.uniforms.tLastThis.value = t2.texture, super.render(e2, this._target, r2, n2, i2), this.smoothEnabled && this.bilateralPass.render(e2, t2, r2, n2, i2));
    }
  }
  EE([Ce()], SE.prototype, "bilateralPass", void 0), EE([$e("Intensity", [0, 4]), Ce(), G()], SE.prototype, "intensity", void 0), EE([$e("Power", [0, 3]), Ce(), G()], SE.prototype, "power", void 0), EE([Je("Auto radius"), Ce(), G()], SE.prototype, "autoRadius", void 0), EE([$e("Object Radius", [0.01, 10]), Ce(), G()], SE.prototype, "objectRadius", void 0), EE([$e("Tolerance", [0.1, 5]), Ce(), G()], SE.prototype, "tolerance", void 0), EE([$e("Bias", [-0.3, 0.3]), Ce(), G()], SE.prototype, "bias", void 0), EE([$e("Falloff", [1e-4, 4]), Ce(), G()], SE.prototype, "falloff", void 0), EE([$e("Ray Count", [1, 5], 1), Ce(), G()], SE.prototype, "rayCount", void 0), EE([$e("Step count", [1, 16], 1), Ce(), V("RTAO_STEP_COUNT")], SE.prototype, "stepCount", void 0), EE([Je("Smooth Enabled"), Ce()], SE.prototype, "smoothEnabled", void 0), EE([Je("Render with Camera")], SE.prototype, "renderWithCamera", void 0);
  class CE extends So {
    constructor(e2 = true) {
      super(), this.dependencies = [to, lo, To], this._initEnabled = false, this.setDirty = this.setDirty.bind(this), this._initEnabled = e2;
    }
    get rtgiTarget() {
      return this._rtgiTarget;
    }
    async onAdded(e2) {
      var t2, r2;
      await super.onAdded(e2), this.enabled = this._initEnabled, null === (r2 = (t2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(t2, "postFrame", true);
    }
    get enabled() {
      var e2, t2;
      return (null === (t2 = null === (e2 = this.passes.ssrtgi) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.enabled) || false;
    }
    set enabled(e2) {
      var t2;
      (null === (t2 = this.passes.ssrtgi) || void 0 === t2 ? void 0 : t2.passObject) && (this.passes.ssrtgi.passObject.enabled = e2);
    }
    createPasses(e2) {
      var t2, r2, n2;
      this._rtgiTarget = e2.renderer.createTarget({ sizeMultiplier: 1 });
      let i2 = false;
      return null === (t2 = this._viewer) || void 0 === t2 || t2.getPluginByType("debug"), [no(e2, { passId: "ssrtgi", after: ["gbuffer"], before: ["render"], required: ["render", "gbuffer", "progressive"], passObject: new SE(e2.renderer, this._rtgiTarget, null !== (n2 = null === (r2 = e2.getPlugin(lo)) || void 0 === r2 ? void 0 : r2.getUnpackSnippet()) && void 0 !== n2 ? n2 : "", true), update: () => {
        var t3;
        let r3 = this.enabled;
        if (r3 && !i2) {
          const e3 = null === (t3 = this._viewer) || void 0 === t3 ? void 0 : t3.getPluginByType("SSAO");
          (null == e3 ? void 0 : e3.enabled) && (confirm("SSAO Plugin needs to be disabled to enable SSRTGI or SSRTAO. Disable now?") ? e3.enabled = false : (this.enabled = false, r3 = false));
        }
        i2 = r3, r3 && this.passes.ssrtgi.passObject.bilateralPass.updateShaderProperties([e2.getPlugin(lo)]);
      } }, () => [e2.getPlugin(lo), e2.getPlugin(To), e2.scene.activeCamera, e2.renderer])];
    }
    async onRemove(e2) {
      return e2.renderer.disposeTarget(this._rtgiTarget), super.onRemove(e2);
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    get uiConfig() {
      var e2, t2, r2, n2, i2;
      const s2 = null !== (r2 = null === (t2 = null === (e2 = this.passes.ssrtgi) || void 0 === e2 ? void 0 : e2.passObject) || void 0 === t2 ? void 0 : t2.uiConfig) && void 0 !== r2 ? r2 : {};
      return null === (i2 = null === (n2 = s2.children) || void 0 === n2 ? void 0 : n2.map((e3) => A(e3))) || void 0 === i2 || i2.flat(2).forEach((e3) => e3 && (e3.onChange = this.setDirty)), s2;
    }
  }
  CE.PluginType = "SSGI";
  class ME extends ro {
    constructor() {
      super(...arguments), this.enabled = true, this._uiNeedRefresh = false, this.dependencies = [to], this.variations = [], this._selectedSwitchNode = () => {
        var e2;
        const t2 = null === (e2 = this._picking) || void 0 === e2 ? void 0 : e2.getSelectedObject();
        if (!t2)
          return;
        const r2 = this.variations.map((e3) => e3.name);
        let n2;
        return t2.traverseAncestors((e3) => {
          n2 || r2.includes(e3.name) && (n2 = e3);
        }), n2;
      }, this.uiConfig = { label: "Switch Node", type: "folder", children: [() => [{ type: "folder", label: "All nodes", expanded: true, children: [this.variations.map((e2) => ({ type: "input", label: e2.title, property: [e2, "name"], onChange: () => this.refreshUi() }))] }, { type: "button", label: "Add Node", value: () => {
        this.variations.push({ name: "switch_node", selected: "", title: "Switch Node", camView: "front", camDistance: 1 }), this.refreshUi();
      } }, { type: "button", label: "Refresh UI", value: () => this.refreshUi() }, { type: "input", label: "Selected node title", hidden: () => !this._selectedSwitchNode(), property: () => {
        const e2 = this._selectedSwitchNode();
        return e2 ? [this.variations.find((t2) => t2.name === e2.name), "title"] : [];
      }, onChange: () => this.refreshUi() }, { type: "slider", bounds: [0.01, 2], stepSize: 0.01, label: "Cam Distance", hidden: () => !this._selectedSwitchNode(), property: () => {
        const e2 = this._selectedSwitchNode();
        return e2 ? [this.variations.find((t2) => t2.name === e2.name), "camDistance"] : [];
      } }, { type: "dropdown", label: "Cam View", hidden: () => !this._selectedSwitchNode(), property: () => {
        const e2 = this._selectedSwitchNode();
        return e2 ? [this.variations.find((t2) => t2.name === e2.name), "camView"] : [];
      }, onChange: () => this.refreshUi(), children: ["top", "bottom", "front", "back", "left", "right"].map((e2) => ({ label: e2, value: e2 })) }]] };
    }
    async onAdded(e2) {
      var t2, r2;
      await super.onAdded(e2), this._picking = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("Picking"), null === (r2 = this._picking) || void 0 === r2 || r2.addEventListener("selectedObjectChanged", () => {
        var e3, t3;
        null === (t3 = (e3 = this.uiConfig).uiRefresh) || void 0 === t3 || t3.call(e3);
      }), e2.addEventListener("postFrame", () => {
        this._uiNeedRefresh && this._refreshUi();
      }), e2.addEventListener("preRender", () => {
        if (this._viewer)
          for (const e3 of this.variations) {
            const t3 = this._viewer.scene.getObjectByName(e3.name);
            if (!t3 || t3.children.length < 1)
              return;
            e3.selected || (e3.selected = t3.children[0].name || t3.children[0].uuid);
            for (const r3 of t3.children)
              r3.visible = (r3.name || r3.uuid) === e3.selected;
          }
      }), e2.addEventListener("postRender", () => {
        if (this._viewer)
          for (const e3 of this.variations) {
            const t3 = this._viewer.scene.getObjectByName(e3.name);
            if (!t3 || t3.children.length < 1)
              return;
            for (const e4 of t3.children)
              e4.visible = true;
          }
      }), this.addEventListener("deserialize", async () => {
        await Dc(200), this.refreshUi();
      });
    }
    refreshUi() {
      this.enabled && (this._uiNeedRefresh = true);
    }
    _refreshUi() {
      var e2, t2, r2;
      if (this.enabled && this._viewer) {
        this._uiNeedRefresh = false, $y.RemoveAll(ME.PluginType);
        for (const e3 of this.variations) {
          const t3 = this._viewer.scene.getObjectByName(e3.name);
          t3 ? (t3.children.length < 1 && console.warn("SwitchNode does not have enough children", e3), $y.Create(ME.PluginType, e3.title, Math.min(5, t3.children.length), 20, 0, t3.children.map((t4) => {
            const r3 = e3.camView, i2 = new n.Pa4((r3.includes("right") ? 1 : 0) - (r3.includes("left") ? 1 : 0), (r3.includes("top") ? 1 : 0) - (r3.includes("bottom") ? 1 : 0), (r3.includes("front") ? 1 : 0) - (r3.includes("back") ? 1 : 0));
            e3.camDistance || (e3.camDistance = 1);
            const s2 = Hy(this._viewer, t4, void 0, 7, i2.multiplyScalar(0.5 * e3.camDistance));
            return { id: t4.uuid, image: s2, onClick: () => {
              var r4;
              e3.selected = t4.name || t4.uuid, null === (r4 = this._viewer) || void 0 === r4 || r4.scene.setDirty({ sceneUpdate: true, frameFade: true });
            }, tooltip: t4.name || t4.uuid };
          }), (e4, t4) => pE(e4, { placement: "bottom", content: t4.tooltip }))) : console.warn("no object found for variation, skipping", e3);
        }
        $y.RebuildUi(null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.container), null === (r2 = (t2 = this.uiConfig).uiRefresh) || void 0 === r2 || r2.call(t2);
      }
    }
  }
  ME.PluginType = "SwitchNodePlugin", function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    s2 > 3 && o2 && Object.defineProperty(t2, r2, o2);
  }([Ce()], ME.prototype, "variations", void 0);
  class TE extends n.u9r {
    constructor(e2, t2, r2 = 32, i2 = 64, s2 = false, o2 = new n.FM8(1, 1), a2 = "shape") {
      super(), this.type = "TubeShapeGeometry", this.parameters = { path: t2, shape: e2, shapeSegments: r2, tubularSegments: i2, closed: s2, primary: a2, shapeScale: o2.clone() };
      const l2 = t2.computeFrenetFrames(i2, s2);
      this.frames = l2;
      const c2 = new n.Pa4(), u2 = new n.Pa4(), h2 = new n.Pa4(), p2 = new n.FM8();
      let d2 = new n.Pa4();
      const f2 = [], m2 = [], _2 = [], g2 = e2.getSpacedPoints(r2);
      for (const e3 of g2)
        e3.multiply(o2);
      !function() {
        for (let e3 = 0; e3 < i2; e3++)
          A2(e3);
        A2(false === s2 ? i2 : 0), function() {
          for (let e3 = 0; e3 <= i2; e3++)
            for (let t3 = 0; t3 <= r2; t3++)
              p2.x = e3 / i2, p2.y = t3 / r2, m2.push(p2.x, p2.y);
        }(), function() {
          const e3 = "shape" === a2, t3 = e3 ? r2 : i2, n2 = e3 ? i2 : r2;
          for (let i3 = 1; i3 <= t3; i3++)
            for (let t4 = 1; t4 <= n2; t4++) {
              const [n3, s3] = e3 ? [t4, i3] : [i3, t4], o3 = (r2 + 1) * (n3 - 1) + (s3 - 1), a3 = (r2 + 1) * n3 + (s3 - 1), l3 = (r2 + 1) * n3 + s3, c3 = (r2 + 1) * (n3 - 1) + s3;
              _2.push(o3, a3, c3), _2.push(a3, l3, c3);
            }
        }();
      }(), this.setIndex(_2), this.setAttribute("position", new n.a$l(f2, 3)), this.setAttribute("uv", new n.a$l(m2, 2)), this.computeVertexNormals();
      const v2 = this.attributes.normal;
      function A2(e3) {
        d2 = t2.getPointAt(e3 / i2, d2);
        const n2 = l2.normals[e3], s3 = l2.binormals[e3];
        for (let e4 = 0; e4 <= r2; e4++) {
          const t3 = g2[e4 % r2];
          u2.set(0, 0, 0).addScaledVector(n2, t3.x).addScaledVector(s3, t3.y), c2.copy(d2).add(u2), f2.push(c2.x, c2.y, c2.z);
        }
      }
      !function() {
        for (let e4 = 1; e4 < r2; e4++) {
          const t3 = e4 + i2 * (r2 + 1);
          u2.fromBufferAttribute(v2, e4), h2.fromBufferAttribute(v2, t3), u2.add(h2).normalize(), v2.setXYZ(e4, u2.x, u2.y, u2.z), v2.setXYZ(t3, u2.x, u2.y, u2.z);
        }
        for (let e4 = 1; e4 < i2; e4++) {
          const t3 = e4 * (r2 + 1), n2 = t3 + r2;
          u2.fromBufferAttribute(v2, t3), h2.fromBufferAttribute(v2, n2), u2.add(h2).normalize(), v2.setXYZ(t3, u2.x, u2.y, u2.z), v2.setXYZ(n2, u2.x, u2.y, u2.z);
        }
        u2.fromBufferAttribute(v2, 0), h2.fromBufferAttribute(v2, r2), u2.add(h2);
        const e3 = i2 * (r2 + 1);
        h2.fromBufferAttribute(v2, e3), u2.add(h2), h2.fromBufferAttribute(v2, e3 + r2), u2.add(h2), u2.normalize(), v2.setXYZ(0, u2.x, u2.y, u2.z), v2.setXYZ(r2, u2.x, u2.y, u2.z), v2.setXYZ(e3, u2.x, u2.y, u2.z), v2.setXYZ(e3 + r2, u2.x, u2.y, u2.z), v2.needsUpdate = true;
      }();
    }
    createSplits(e2) {
      this.clearGroups();
      const t2 = "shape" === this.parameters.primary ? this.parameters.shapeSegments : this.parameters.tubularSegments, r2 = this.index.count, n2 = [...e2, 1].sort();
      let i2 = 0, s2 = 0;
      for (const e3 of n2) {
        const n3 = Math.round(t2 * e3) * r2 / t2;
        this.addGroup(i2, n3 - i2, s2++), i2 = n3;
      }
      return this.groups.length;
    }
    toJSON() {
      const e2 = super.toJSON();
      return e2.path = this.parameters.path.toJSON(), e2.shape = this.parameters.shape.toJSON(), e2;
    }
  }
  var IE, kE = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let DE = IE = class extends ro {
    constructor() {
      super(...arguments), this.enabled = true, this.shapeSegments = 32, this.tubularSegments = 32, this.shapeScale = new n.FM8(1, 1), this.materialSplits = "0.3, 0.6", this.horizontalSplits = true, this.extrudeCirceTube = async () => {
        var e2, t2;
        const r2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Nc)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
        if (!r2)
          return;
        let n2 = this._viewer.prompt("Radius: Radius for the circle", "1", true);
        if (!n2)
          return;
        n2 = parseFloat(n2);
        const i2 = new PE(0, 0, n2, n2, 0, 2 * Math.PI, true, 0);
        await this.extrudeObject(r2, i2);
      };
    }
    async onAdded(e2) {
      await super.onAdded(e2);
    }
    static CreateCurve(e2, t2) {
      var r2, n2;
      if ("circle" === e2)
        return new PE(0, 0, null !== (r2 = t2.radius) && void 0 !== r2 ? r2 : 1, null !== (n2 = t2.radius) && void 0 !== n2 ? n2 : 1, 0, 2 * Math.PI, true, 0);
      throw new Error("Unknown curve type");
    }
    async extrudeObject(e2, t2, r2 = this.shapeSegments, i2 = this.tubularSegments, s2 = this.shapeScale, o2 = this.materialSplits.split(",").map((e3) => parseFloat(e3.trim())), a2 = this.horizontalSplits) {
      var l2, c2, u2, h2, p2, d2, f2, m2;
      if (e2.userData.isExtrudedTube, e2.userData._extrudeSource) {
        const t3 = e2.userData._extrudeSource;
        if (e2 = null === (l2 = e2.parent) || void 0 === l2 ? void 0 : l2.children.find((e3) => t3 === e3.uuid), !e2)
          return void console.warn("Could not find extrude source with uuid", t3);
      }
      if (e2.userData.extrudedObject) {
        const t3 = e2.userData.extrudedObject, r3 = null === (c2 = e2.parent) || void 0 === c2 ? void 0 : c2.children.find((e3) => t3 === e3.uuid);
        r3 && (r3.removeFromParent(), r3.geometry.dispose(), r3.geometry = null, r3.material = null), delete e2.userData.extrudedObject;
      }
      const _2 = e2.geometry;
      if (!_2)
        return void (null === (u2 = this._viewer) || void 0 === u2 || u2.alert("Extrude: No geometry to extrude"));
      const g2 = [e2.material];
      let v2;
      try {
        const e3 = IE.ConvertGeometryToFlatShape(_2);
        v2 = new TE(e3, t2, r2, i2, true, s2, a2 ? "shape" : "path"), v2.computeBoundingBox(), v2.createSplits(o2);
      } catch (e3) {
        return void (null === (h2 = this._viewer) || void 0 === h2 || h2.alert("string" == typeof e3 ? e3 : null == e3 ? void 0 : e3.message));
      }
      g2[0].color.set(16777215);
      for (let e3 = g2.length; e3 < v2.groups.length; e3++) {
        const e4 = g2[0].clone();
        g2.push(e4), e4.color.set(16777215 * Math.random());
      }
      const A2 = new n.Kj0(v2, g2);
      A2.userData._extrudeSource = e2.uuid, A2.userData.isExtrudedTube = true, e2.visible = false, e2.userData.bboxVisible = false, A2.name = e2.name + "_extruded";
      const b2 = await (null === (f2 = null === (d2 = null === (p2 = this._viewer) || void 0 === p2 ? void 0 : p2.getManager()) || void 0 === d2 ? void 0 : d2.importer) || void 0 === f2 ? void 0 : f2.processImportedSingle(A2, { autoCenter: false, autoScale: false }));
      b2 && (null === (m2 = e2.parent) || void 0 === m2 || m2.add(b2.modelObject), e2.userData.extrudedObject = b2.modelObject.uuid, b2.dispatchEvent({ type: "select", ui: true, value: b2 }));
    }
    static ExtrudeShape(e2, t2, r2, i2, s2, o2, a2, l2) {
      const c2 = new TE(e2, i2, t2, r2, true, new n.FM8(s2, o2), l2 ? "shape" : "path");
      c2.computeBoundingBox(), c2.createSplits(a2);
      const u2 = new n.Kj0(c2, []);
      return u2.userData.isExtrudedTube = true, u2;
    }
    static ConvertGeometryToFlatShape(e2, t2 = true) {
      if (e2.userData.__planarShape)
        return e2.userData.__planarShape;
      let r2 = e2.attributes.position;
      if (!r2)
        throw "no position attribute";
      if (r2.count > 500)
        throw "too large to extrude";
      const i2 = e2;
      r2 = i2.attributes.position, i2.boundingBox || i2.computeBoundingBox();
      const s2 = i2.boundingBox.getSize(new n.Pa4()), o2 = s2.x < 1e-3 ? "x" : s2.y < 1e-3 ? "y" : s2.z < 1e-3 ? "z" : null;
      if (!o2)
        throw "geometry is not axis aligned not planar";
      let a2 = [];
      for (let e3 = 0; e3 < r2.count; e3++) {
        const t3 = new n.FM8();
        "x" === o2 ? t3.set(r2.getY(e3), r2.getZ(e3)) : "y" === o2 ? t3.set(r2.getX(e3), r2.getZ(e3)) : t3.set(r2.getX(e3), r2.getY(e3)), a2.push(t3);
      }
      if (t2) {
        let e3 = 0;
        for (let t3 = 0; t3 < a2.length; t3++)
          (a2[t3].x < a2[e3].x || a2[t3].x === a2[e3].x && a2[t3].y < a2[e3].y) && (e3 = t3);
        0 !== e3 && (a2 = a2.slice(e3).concat(a2.slice(0, e3)));
      }
      const l2 = new n.bnF(a2);
      return e2.userData.__planarShape = l2, l2;
    }
  };
  DE.PluginType = "ShapeTubeExtrudePlugin", kE([Je("Enabled")], DE.prototype, "enabled", void 0), kE([$e("Shape Segments (X)", [1, 100], 1, (e2) => ({ hidden: () => {
    var t2, r2;
    return !(null === (r2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Nc)) || void 0 === r2 ? void 0 : r2.getSelectedObject());
  } }))], DE.prototype, "shapeSegments", void 0), kE([$e("Tube Segments (Y)", [1, 100], 1, (e2) => ({ hidden: () => {
    var t2, r2;
    return !(null === (r2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Nc)) || void 0 === r2 ? void 0 : r2.getSelectedObject());
  } }))], DE.prototype, "tubularSegments", void 0), kE([et("Shape scale", [0.01, 10], 0.01, (e2) => ({ hidden: () => {
    var t2, r2;
    return !(null === (r2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Nc)) || void 0 === r2 ? void 0 : r2.getSelectedObject());
  } }))], DE.prototype, "shapeScale", void 0), kE([nt("Material Splits", (e2) => ({ hidden: () => {
    var t2, r2;
    return !(null === (r2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Nc)) || void 0 === r2 ? void 0 : r2.getSelectedObject());
  } }))], DE.prototype, "materialSplits", void 0), kE([Je("Horizontal Splits", (e2) => ({ hidden: () => {
    var t2, r2;
    return !(null === (r2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Nc)) || void 0 === r2 ? void 0 : r2.getSelectedObject());
  } }))], DE.prototype, "horizontalSplits", void 0), kE([rt("Extrude Circle Tube", (e2) => ({ hidden: () => {
    var t2, r2;
    return !(null === (r2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Nc)) || void 0 === r2 ? void 0 : r2.getSelectedObject());
  } }))], DE.prototype, "extrudeCirceTube", void 0), DE = IE = kE([lt("Extrude Tube Shapes")], DE);
  class PE extends n.Ny0 {
    getPoint(e2, t2) {
      return super.getPoint(e2, t2 || new n.Pa4());
    }
  }
  class BE extends ro {
    constructor(e2 = true) {
      super(), this.enabled = true, this.toJSON = void 0, this.fromJSON = void 0, this._lastFrameTime = 0, this._updaters = [], this.dependencies = [], this._fadeDisabled = false, this.disableFrameFade = true, this._postFrame = () => {
        var e3, t2;
        if (!this._viewer)
          return;
        if (!this.enabled || Object.keys(this.animations).length < 1)
          return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e3 = this._viewer.getPluginByType("FrameFade")) || void 0 === e3 || e3.enable(BE.PluginType), this._fadeDisabled = false));
        const r2 = Dt() / 1e3;
        this._lastFrameTime < 1 && (this._lastFrameTime = r2 - 1 / 60);
        let n2 = r2 - this._lastFrameTime;
        this._lastFrameTime = r2;
        const i2 = null === (t2 = this._viewer.getPluginByType("Progressive")) || void 0 === t2 ? void 0 : t2.postFrameConvergedRecordingDelta();
        if (i2 && i2 > 0 && (n2 = i2), 0 !== i2 && (n2 *= 1e3, !(n2 <= 1e-3) && (this._updaters.forEach((e4) => {
          let t3 = n2;
          e4.time + t3 < 0 && (t3 = -e4.time), e4.time += t3, Math.abs(t3) > 1e-3 && e4.u(t3);
        }), !this._fadeDisabled && this.disableFrameFade))) {
          const e4 = this._viewer.getPluginByType("FrameFade");
          e4 && (e4.disable(BE.PluginType), this._fadeDisabled = true);
        }
      }, this.defaultDriver = (e3) => ({ start: () => this._updaters.push({ u: e3, time: 0 }), stop: () => this._updaters.splice(this._updaters.findIndex((t2) => t2.u === e3), 1) }), this.animations = {}, this.enabled = e2, this._postFrame = this._postFrame.bind(this);
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.addEventListener("postFrame", this._postFrame);
    }
    async onRemove(e2) {
      return e2.removeEventListener("postFrame", this._postFrame), super.onRemove(e2);
    }
    animate(e2) {
      const t2 = Xe(), r2 = { id: t2, options: e2, stop: () => {
        var e3, r3, n2;
        (null === (e3 = this.animations[t2]) || void 0 === e3 ? void 0 : e3._stop) ? null === (n2 = null === (r3 = this.animations[t2]) || void 0 === r3 ? void 0 : r3._stop) || void 0 === n2 || n2.call(r3) : console.warn("Animation not started");
      } };
      return this.animations[t2] = r2, r2.promise = new Promise((r3, n2) => {
        const i2 = { driver: this.defaultDriver, onComplete: () => {
          var t3;
          null === (t3 = e2.onComplete) || void 0 === t3 || t3.call(e2), r3();
        }, onStop: () => {
          var t3;
          null === (t3 = e2.onStop) || void 0 === t3 || t3.call(e2), r3();
        }, ...e2 }, s2 = Ic(i2);
        this.animations[t2]._stop = s2.stop, this.animations[t2].options = i2;
      }).then(() => (delete this.animations[t2], t2)), this.animations[t2];
    }
    async animateAsync(e2) {
      return this.animate(e2).promise;
    }
  }
  BE.PluginType = "PopmotionPlugin";
  const RE = async (e2) => xt(await (await fetch(e2)).blob());
  async function LE(e2, t2 = RE) {
    const r2 = e2.match(/(((ftp|https?):\/\/)[\-\w@:%_\+.~#?,&\/\/=]+)/g);
    if (r2)
      for (const n2 of r2) {
        const r3 = await t2(n2);
        e2 = e2.replace(n2, r3);
      }
    return e2;
  }
  function OE(e2, t2, { width: r2, height: n2 }, i2 = true) {
    const s2 = `
<svg viewBox="0 0 ${r2} ${n2}" xmlns="http://www.w3.org/2000/svg">
    <style>
    ${t2}
    </style>
    <foreignObject x="0" y="0" width="100%" height="100%">
        <div xmlns="http://www.w3.org/1999/xhtml" style="height: 100%; width: 100%; position: absolute: top:0; left:0">
            ${e2}
        </div>
    </foreignObject>
</svg>
    `;
    return i2 ? C(s2) : s2;
  }
  async function FE(e2, t2, r2) {
    const n2 = OE(e2, t2, r2);
    return await Jy(n2, r2);
  }
  async function UE(e2, t2, r2) {
    const n2 = OE(e2, t2, r2);
    return await Zy(n2, r2);
  }
  var NE, jE, zE = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  const GE = (e2) => ({ onChange: (t2) => {
    t2.last && e2.onChange();
  } });
  let VE = NE = class {
    constructor() {
      this.text = "Custom Text", this.fontSize = 100, this.width = 1024, this.height = 1024, this.xOffset = 0, this.yOffset = 0, this.boxWidth = 1024, this.boxHeight = 1024, this.fontFamily = "", this.fontPath = "", this.maskText = false, this.innerShadow = false, this.textColor = "#000000", this.bgFillColor = "#ffffff", this.svgBackground = "#ffffff", this.onChange = () => {
      };
    }
    set(e2) {
      Object.assign(this, e2);
    }
    reset() {
      const e2 = this.onChange;
      Object.assign(this, new NE()), this.onChange = e2;
    }
    toJSON() {
      return { text: this.text, fontFamily: this.fontFamily, fontPath: this.fontPath, svgBackground: this.svgBackground, width: this.width, height: this.height, xOffset: this.xOffset, yOffset: this.yOffset, boxWidth: this.boxWidth, boxHeight: this.boxHeight, fontSize: this.fontSize, maskText: this.maskText, innerShadow: this.innerShadow, bgFillColor: this.bgFillColor, textColor: this.textColor };
    }
  };
  zE([nt("Text", GE)], VE.prototype, "text", void 0), zE([$e("Font Size", [2, 400], 1, GE)], VE.prototype, "fontSize", void 0), zE([$e("Width", [2, 4096], 1, GE)], VE.prototype, "width", void 0), zE([$e("Height", [2, 4096], 1, GE)], VE.prototype, "height", void 0), zE([$e("X Offset", [-1024, 1024], 1, GE)], VE.prototype, "xOffset", void 0), zE([$e("Y Offset", [-1024, 1024], 1, GE)], VE.prototype, "yOffset", void 0), zE([$e("V-Width", [2, 4096], 1, GE)], VE.prototype, "boxWidth", void 0), zE([$e("V-Height", [2, 4096], 1, GE)], VE.prototype, "boxHeight", void 0), zE([nt("Font", GE)], VE.prototype, "fontFamily", void 0), zE([nt("Font Url", GE)], VE.prototype, "fontPath", void 0), zE([Je("Mask Text", GE)], VE.prototype, "maskText", void 0), zE([Je("Inner Shadow", GE)], VE.prototype, "innerShadow", void 0), zE([it("Text Color", GE)], VE.prototype, "textColor", void 0), zE([it("BG Fill", GE)], VE.prototype, "bgFillColor", void 0), zE([it("SVG BG", GE)], VE.prototype, "svgBackground", void 0), VE = NE = zE([lt("Text SVG Options")], VE);
  const QE = { woff: "woff", woff2: "woff2", ttf: "truetype", otf: "opentype", eot: "embedded-opentype" }, HE = (e2) => ({ hidden: () => {
    const t2 = e2.getSelected();
    return !t2 || !t2.userData[WE.PluginType];
  } });
  let WE = jE = class extends ro {
    constructor() {
      super(), this.enabled = true, this.getSelected = () => {
        var e2, t2;
        return null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("Picking")) || void 0 === t2 ? void 0 : t2.getSelectedObject();
      }, this.options = new VE(), this.applyToMap = true, this.applyToBumpMap = false, this.applyToAlphaMap = true, this.inverseAlphaMap = false, this._lastMeta = void 0, this.fonts = { roboto: "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2" }, this._assetLoadOptions = void 0, this._selectedObjectChanged = this._selectedObjectChanged.bind(this), this.addTextToSelected = this.addTextToSelected.bind(this), this._paramsChanged = this._paramsChanged.bind(this), this.options.onChange = this._paramsChanged;
    }
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2), null === (t2 = e2.getPluginByType("Picking")) || void 0 === t2 || t2.addEventListener("selectedObjectChanged", this._selectedObjectChanged);
    }
    _selectedObjectChanged() {
      var e2, t2, r2, n2, i2, s2;
      if (!this.enabled)
        return;
      const o2 = this.getSelected();
      if (!o2)
        return void (null === (t2 = (e2 = this.uiConfig).uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true));
      const a2 = o2.userData[jE.PluginType];
      if (!a2)
        return this.options.reset(), this._lastMeta = void 0, void (null === (n2 = (r2 = this.uiConfig).uiRefresh) || void 0 === n2 || n2.call(r2, "postFrame", true));
      this._lastMeta !== a2 && (this.options.set(a2), this._lastMeta = a2), null === (s2 = (i2 = this.uiConfig).uiRefresh) || void 0 === s2 || s2.call(i2, "postFrame", true);
    }
    _paramsChanged() {
      if (!this.enabled)
        return;
      const e2 = this.getSelected();
      e2 && e2.isMesh && e2.userData[jE.PluginType] && this.updateText(e2, this.options.toJSON());
    }
    async addTextToSelected() {
      var e2;
      const t2 = this.getSelected();
      t2 && t2.isMesh ? t2.material ? (t2.userData[jE.PluginType] || !t2.material.map || await (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.confirm("Add Text: This mesh already has a texture. Adding text will replace the texture. Continue?"))) && await this.addText(t2) : console.error("no material on mesh") : console.error("no mesh is selected");
    }
    async addText(e2, t2) {
      return this.updateText(e2, Object.assign(this.options.toJSON(), t2));
    }
    async updateText(e2, t2) {
      var r2, n2;
      if (!e2.isMesh)
        return;
      if (!e2.material)
        return void console.error("updateText: no material on mesh");
      let i2 = e2.userData[jE.PluginType];
      i2 || (e2.userData[jE.PluginType] = i2 = {}), Object.assign(i2, t2);
      const s2 = e2.material;
      s2.map && (s2.map._isSimpleTextTexture && s2.map.dispose(), s2.map = void 0), s2.alphaMap && (s2.alphaMap._isSimpleTextTexture && s2.alphaMap.dispose(), s2.alphaMap = void 0), s2.bumpMap && (s2.bumpMap._isSimpleTextTexture && s2.bumpMap.dispose(), s2.bumpMap = void 0);
      const o2 = await this.makeTextSvg(i2);
      this.applyToMap && (s2.map = o2), this.applyToAlphaMap && (s2.alphaMap = o2, s2.transparent = true), this.applyToBumpMap && (s2.bumpMap = o2), s2.userData.inverseAlphaMap = this.inverseAlphaMap, s2.setDirty(), s2.needsUpdate = true, null === (n2 = (r2 = this.uiConfig).uiRefresh) || void 0 === n2 || n2.call(r2, "postFrame", true);
    }
    async makeTextSvg(e2) {
      const t2 = e2.fontFamily || "Arial", r2 = e2.fontPath || this.fonts[t2] || "";
      let i2 = e2.style;
      if (r2.length > 0) {
        const e3 = r2.split("?")[0].split(".").pop() || "woff";
        i2 += "\n" + (r2.length > 0 ? `
            @font-face {
                font-family: ${t2};
                src: url(${r2}) format(${QE[e3] || e3});
            }` : "");
      }
      let s2 = function({ text: e3 = "Custom Text", svgBackground: t3 = "#ffffff", xOffset: r3 = 0, yOffset: n2 = 0, width: i3 = 1024, height: s3 = 1024, boxWidth: o3 = 1024, boxHeight: a2 = 1024, fontFamily: l2 = "", fontSize: c2 = 32, maskText: u2 = true, innerShadow: h2 = true, bgFillColor: p2 = "#000000", textColor: d2 = "#ffffff", style: f2 = "" }) {
        return `
<svg style="background-color:${t3}" width="${i3}" height="${s3}" viewBox="0 0 ${o3} ${a2}"
 xmlns="http://www.w3.org/2000/svg"
 xmlns:xlink="http://www.w3.org/1999/xlink">
     <defs>
        <style>
        ${f2}
        </style>
    </defs>

    <g style="overflow:hidden; text-anchor: middle; font-size: ${c2}px; font-family: ${l2 || "Arial"}">
        <defs>

` + (u2 ? `
<mask id="textMask">
<text style="fill:white; font-size: ${c2}px;" x="${r3 + o3 / 2}" y="${a2 / 2 + n2 + c2 / 4}" > ${e3} </text>
</mask>
` : "") + "\n\n" + (h2 ? '\n<filter id="innerShadow" x="-20%" y="-20%" width="140%" height="140%">\n<feGaussianBlur in="SourceGraphic" stdDeviation="0.5" result="blur"/>\n<feOffset in="blur" dx="1.5" dy="1.5"/>\n</filter>\n' : "") + "\n\n        </defs>\n\n" + (u2 ? '\n        <g mask="url(#textMask)">\n' : "") + `

        <rect x="0" y="0" width="${o3}" height="${a2}" style="fill:${p2}"/>
        <text style="${h2 ? "filter: url(#innerShadow);" : ""} fill:${d2};" x="${r3 + o3 / 2}" y="${a2 / 2 + n2 + c2 / 4}"> ${e3} </text>

` + (u2 ? "\n        </g>\n" : "") + "\n\n    </g>\n</svg>\n";
      }({ ...e2, fontFamily: t2, style: i2 });
      s2 = await LE(s2, async (e3) => this._getAssetData(e3)), s2 = C(s2);
      const o2 = await this._viewer.getManager().importer.importSinglePath(s2, { generateMipmaps: false, minFilter: n.wem });
      return o2._isSimpleTextTexture = true, o2.flipY = false, o2.needsUpdate = true, o2;
    }
    async _getAssetData(e2) {
      var t2, r2;
      if (e2.startsWith("http://www.w3.org"))
        return e2;
      const n2 = null === (r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getManager()) || void 0 === r2 ? void 0 : r2.importer;
      if (!n2)
        throw new Error("no importer");
      this._assetLoadOptions = this._assetLoadOptions || { fileHandler: new b_(n2.loadingManager), processImported: false };
      try {
        return await n2.importPath(e2, this._assetLoadOptions);
      } catch (e3) {
        return console.error(e3), "";
      }
    }
  };
  WE.PluginType = "SimpleTextPlugin", zE([Ke(void 0, { params: HE })], WE.prototype, "options", void 0), zE([Je("Apply Map", HE), M(jE.prototype._paramsChanged)], WE.prototype, "applyToMap", void 0), zE([Je("Apply Bump Map", HE), M(jE.prototype._paramsChanged)], WE.prototype, "applyToBumpMap", void 0), zE([Je("Apply Alpha Map", HE), M(jE.prototype._paramsChanged)], WE.prototype, "applyToAlphaMap", void 0), zE([Je("Invert Alpha Map", HE), M(jE.prototype._paramsChanged)], WE.prototype, "inverseAlphaMap", void 0), zE([rt("Add Text", (e2) => ({ hidden: () => !e2.getSelected() }))], WE.prototype, "addTextToSelected", null), WE = jE = zE([lt("Simple Text")], WE);
  class qE {
    constructor(e2) {
      this.top = 0, this.array = new Float32Array(e2);
    }
    write(e2) {
      this.array[this.top++] = e2.x, this.array[this.top++] = e2.y, this.array[this.top++] = e2.z;
    }
  }
  class XE {
    constructor(e2) {
      this.top = 0, this.array = new Float32Array(e2);
    }
    write(e2) {
      this.array[this.top++] = e2.x, this.array[this.top++] = e2.y;
    }
  }
  class YE {
    constructor(e2) {
      this.plane = null, this.front = null, this.back = null, this.polygons = [], e2 && this.build(e2);
    }
    clone() {
      const e2 = new YE();
      return e2.plane = this.plane && this.plane.clone(), e2.front = this.front && this.front.clone(), e2.back = this.back && this.back.clone(), e2.polygons = this.polygons.map((e3) => e3.clone()), e2;
    }
    invert() {
      for (let e3 = 0; e3 < this.polygons.length; e3++)
        this.polygons[e3].flip();
      this.plane && this.plane.flip(), this.front && this.front.invert(), this.back && this.back.invert();
      const e2 = this.front;
      this.front = this.back, this.back = e2;
    }
    clipPolygons(e2) {
      if (!this.plane)
        return e2.slice();
      let t2 = new Array(), r2 = new Array();
      for (let n2 = 0; n2 < e2.length; n2++)
        this.plane.splitPolygon(e2[n2], t2, r2, t2, r2);
      return this.front && (t2 = this.front.clipPolygons(t2)), r2 = this.back ? this.back.clipPolygons(r2) : [], t2.concat(r2);
    }
    clipTo(e2) {
      this.polygons = e2.clipPolygons(this.polygons), this.front && this.front.clipTo(e2), this.back && this.back.clipTo(e2);
    }
    allPolygons() {
      let e2 = this.polygons.slice();
      return this.front && (e2 = e2.concat(this.front.allPolygons())), this.back && (e2 = e2.concat(this.back.allPolygons())), e2;
    }
    build(e2) {
      if (!e2.length)
        return;
      this.plane || (this.plane = e2[0].plane.clone());
      const t2 = [], r2 = [];
      for (let n2 = 0; n2 < e2.length; n2++)
        this.plane.splitPolygon(e2[n2], this.polygons, this.polygons, t2, r2);
      t2.length && (this.front || (this.front = new YE()), this.front.build(t2)), r2.length && (this.back || (this.back = new YE()), this.back.build(r2));
    }
  }
  class KE {
    constructor(e2 = 0, t2 = 0, r2 = 0) {
      this.x = e2, this.y = t2, this.z = r2;
    }
    copy(e2) {
      return this.x = e2.x, this.y = e2.y, this.z = e2.z, this;
    }
    clone() {
      return new KE(this.x, this.y, this.z);
    }
    negate() {
      return this.x *= -1, this.y *= -1, this.z *= -1, this;
    }
    add(e2) {
      return this.x += e2.x, this.y += e2.y, this.z += e2.z, this;
    }
    sub(e2) {
      return this.x -= e2.x, this.y -= e2.y, this.z -= e2.z, this;
    }
    times(e2) {
      return this.x *= e2, this.y *= e2, this.z *= e2, this;
    }
    dividedBy(e2) {
      return this.x /= e2, this.y /= e2, this.z /= e2, this;
    }
    lerp(e2, t2) {
      return this.add(new KE().copy(e2).sub(this).times(t2));
    }
    unit() {
      return this.dividedBy(this.length());
    }
    length() {
      return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));
    }
    normalize() {
      return this.unit();
    }
    cross(e2) {
      const t2 = this.clone(), r2 = t2.x, n2 = t2.y, i2 = t2.z, s2 = e2.x, o2 = e2.y, a2 = e2.z;
      return this.x = n2 * a2 - i2 * o2, this.y = i2 * s2 - r2 * a2, this.z = r2 * o2 - n2 * s2, this;
    }
    dot(e2) {
      return this.x * e2.x + this.y * e2.y + this.z * e2.z;
    }
    toVector3() {
      return new n.Pa4(this.x, this.y, this.z);
    }
  }
  class JE {
    constructor(e2, t2) {
      this.normal = e2, this.w = t2, this.normal = e2, this.w = t2;
    }
    clone() {
      return new JE(this.normal.clone(), this.w);
    }
    flip() {
      this.normal.negate(), this.w = -this.w;
    }
    splitPolygon(e2, t2, r2, n2, i2) {
      let s2 = 0;
      const o2 = [];
      for (let t3 = 0; t3 < e2.vertices.length; t3++) {
        const r3 = this.normal.dot(e2.vertices[t3].pos) - this.w, n3 = r3 < -JE.EPSILON ? 2 : r3 > JE.EPSILON ? 1 : 0;
        s2 |= n3, o2.push(n3);
      }
      switch (s2) {
        case 0:
          (this.normal.dot(e2.plane.normal) > 0 ? t2 : r2).push(e2);
          break;
        case 1:
          n2.push(e2);
          break;
        case 2:
          i2.push(e2);
          break;
        case 3: {
          const t3 = [], r3 = [];
          for (let n3 = 0; n3 < e2.vertices.length; n3++) {
            const i3 = (n3 + 1) % e2.vertices.length, s3 = o2[n3], a2 = o2[i3], l2 = e2.vertices[n3], c2 = e2.vertices[i3];
            if (2 != s3 && t3.push(l2), 1 != s3 && r3.push(2 != s3 ? l2.clone() : l2), 3 == (s3 | a2)) {
              const e3 = (this.w - this.normal.dot(l2.pos)) / this.normal.dot(new KE().copy(c2.pos).sub(l2.pos)), n4 = l2.interpolate(c2, e3);
              t3.push(n4), r3.push(n4.clone());
            }
          }
          t3.length >= 3 && n2.push(new ZE(t3, e2.shared)), r3.length >= 3 && i2.push(new ZE(r3, e2.shared));
          break;
        }
      }
    }
    static fromPoints(e2, t2, r2) {
      const n2 = new KE().copy(t2).sub(e2).cross(new KE().copy(r2).sub(e2)).normalize();
      return new JE(n2.clone(), n2.dot(e2));
    }
  }
  JE.EPSILON = 1e-5;
  class ZE {
    constructor(e2, t2) {
      this.vertices = e2, this.shared = t2, this.plane = JE.fromPoints(e2[0].pos, e2[1].pos, e2[2].pos);
    }
    clone() {
      return new ZE(this.vertices.map((e2) => e2.clone()), this.shared);
    }
    flip() {
      this.vertices.reverse().map((e2) => e2.flip()), this.plane.flip();
    }
  }
  class $E {
    constructor(e2, t2, r2, n2) {
      this.pos = new KE().copy(e2), this.normal = new KE().copy(t2), this.uv = new KE().copy(r2), this.uv.z = 0, n2 && (this.color = new KE().copy(n2));
    }
    clone() {
      return new $E(this.pos, this.normal, this.uv, this.color);
    }
    flip() {
      this.normal.negate();
    }
    interpolate(e2, t2) {
      return new $E(this.pos.clone().lerp(e2.pos, t2), this.normal.clone().lerp(e2.normal, t2), this.uv.clone().lerp(e2.uv, t2), this.color && e2.color && this.color.clone().lerp(e2.color, t2));
    }
  }
  class eS {
    constructor() {
      this.polygons = new Array();
    }
    static fromPolygons(e2) {
      const t2 = new eS();
      return t2.polygons = e2, t2;
    }
    static fromGeometry(e2, t2) {
      let r2 = [];
      const n2 = e2.attributes.position, i2 = e2.attributes.normal, s2 = e2.attributes.uv, o2 = e2.attributes.color, a2 = e2.groups;
      let l2;
      if (e2.index)
        l2 = e2.index.array;
      else {
        l2 = new Array(n2.array.length / n2.itemSize | 0);
        for (let e3 = 0; e3 < l2.length; e3++)
          l2[e3] = e3;
      }
      const c2 = l2.length / 3 | 0;
      r2 = new Array(c2);
      for (let e3 = 0, c3 = 0, u2 = l2.length; e3 < u2; e3 += 3, c3++) {
        const u3 = new Array(3);
        for (let t3 = 0; t3 < 3; t3++) {
          const r3 = l2[e3 + t3], a3 = 3 * r3, c4 = 2 * r3, h2 = n2.array[a3], p2 = n2.array[a3 + 1], d2 = n2.array[a3 + 2], f2 = i2.array[a3], m2 = i2.array[a3 + 1], _2 = i2.array[a3 + 2], g2 = null == s2 ? void 0 : s2.array[c4], v2 = null == s2 ? void 0 : s2.array[c4 + 1];
          u3[t3] = new $E(new KE(h2, p2, d2), new KE(f2, m2, _2), new KE(g2, v2, 0), o2 && new KE(o2.array[c4], o2.array[c4 + 1], o2.array[c4 + 2]));
        }
        if (void 0 === t2 && a2 && a2.length > 0)
          for (const t3 of a2)
            e3 >= t3.start && e3 < t3.start + t3.count && (r2[c3] = new ZE(u3, t3.materialIndex));
        else
          r2[c3] = new ZE(u3, t2);
      }
      return eS.fromPolygons(r2.filter((e3) => !isNaN(e3.plane.normal.x)));
    }
    static toGeometry(e2, t2) {
      let r2 = 0;
      const i2 = e2.polygons;
      for (const e3 of i2)
        r2 += e3.vertices.length - 2;
      const s2 = new n.u9r(), o2 = new qE(3 * r2 * 3), a2 = new qE(3 * r2 * 3), l2 = new XE(2 * r2 * 3);
      let c2;
      const u2 = [], h2 = [];
      for (const e3 of i2) {
        const t3 = e3.vertices, n2 = t3.length;
        void 0 !== e3.shared && (u2[e3.shared] || (u2[e3.shared] = [])), n2 && void 0 !== t3[0].color && (c2 || (c2 = new qE(3 * r2 * 3)));
        for (let r3 = 3; r3 <= n2; r3++)
          (void 0 === e3.shared ? h2 : u2[e3.shared]).push(o2.top / 3, o2.top / 3 + 1, o2.top / 3 + 2), o2.write(t3[0].pos), o2.write(t3[r3 - 2].pos), o2.write(t3[r3 - 1].pos), a2.write(t3[0].normal), a2.write(t3[r3 - 2].normal), a2.write(t3[r3 - 1].normal), l2 && (l2.write(t3[0].uv), l2.write(t3[r3 - 2].uv), l2.write(t3[r3 - 1].uv)), c2 && (c2.write(t3[0].color), c2.write(t3[r3 - 2].color), c2.write(t3[r3 - 1].color));
      }
      s2.setAttribute("position", new n.TlE(o2.array, 3)), s2.setAttribute("normal", new n.TlE(a2.array, 3)), l2 && s2.setAttribute("uv", new n.TlE(l2.array, 2)), c2 && s2.setAttribute("color", new n.TlE(c2.array, 3));
      for (let e3 = 0; e3 < u2.length; e3++)
        void 0 === u2[e3] && (u2[e3] = []);
      if (u2.length) {
        let e3 = [], t3 = 0;
        for (let r3 = 0; r3 < u2.length; r3++)
          s2.addGroup(t3, u2[r3].length, r3), t3 += u2[r3].length, e3 = e3.concat(u2[r3]);
        s2.addGroup(t3, h2.length, u2.length), e3 = e3.concat(h2), s2.setIndex(e3);
      }
      const p2 = new n.yGw().copy(t2).invert();
      return s2.applyMatrix4(p2), s2.computeBoundingSphere(), s2.computeBoundingBox(), s2;
    }
    static fromMesh(e2, t2) {
      const r2 = eS.fromGeometry(e2.geometry, t2), i2 = new n.Pa4(), s2 = new n.Vkp();
      s2.getNormalMatrix(e2.matrix);
      for (let t3 = 0; t3 < r2.polygons.length; t3++) {
        const n2 = r2.polygons[t3];
        for (let t4 = 0; t4 < n2.vertices.length; t4++) {
          const r3 = n2.vertices[t4];
          r3.pos.copy(i2.copy(r3.pos.toVector3()).applyMatrix4(e2.matrix)), r3.normal.copy(i2.copy(r3.normal.toVector3()).applyMatrix3(s2));
        }
      }
      return r2;
    }
    static toMesh(e2, t2, r2) {
      const i2 = eS.toGeometry(e2, t2), s2 = new n.Kj0(i2, r2);
      return s2.matrix.copy(t2), s2.matrix.decompose(s2.position, s2.quaternion, s2.scale), s2.rotation.setFromQuaternion(s2.quaternion), s2.updateMatrixWorld(), s2.castShadow = s2.receiveShadow = true, s2;
    }
    static union(e2, t2) {
      const r2 = eS.fromMesh(e2), n2 = eS.fromMesh(t2);
      return eS.toMesh(r2.union(n2), e2.matrix, e2.material);
    }
    static subtract(e2, t2) {
      const r2 = eS.fromMesh(e2), n2 = eS.fromMesh(t2);
      return eS.toMesh(r2.subtract(n2), e2.matrix, e2.material);
    }
    static intersect(e2, t2) {
      const r2 = eS.fromMesh(e2), n2 = eS.fromMesh(t2);
      return eS.toMesh(r2.intersect(n2), e2.matrix, e2.material);
    }
    clone() {
      const e2 = new eS();
      return e2.polygons = this.polygons.map((e3) => e3.clone()).filter((e3) => Number.isFinite(e3.plane.w)), e2;
    }
    toPolygons() {
      return this.polygons;
    }
    union(e2) {
      const t2 = new YE(this.clone().polygons), r2 = new YE(e2.clone().polygons);
      return t2.clipTo(r2), r2.clipTo(t2), r2.invert(), r2.clipTo(t2), r2.invert(), t2.build(r2.allPolygons()), eS.fromPolygons(t2.allPolygons());
    }
    subtract(e2) {
      const t2 = new YE(this.clone().polygons), r2 = new YE(e2.clone().polygons);
      return t2.invert(), t2.clipTo(r2), r2.clipTo(t2), r2.invert(), r2.clipTo(t2), r2.invert(), t2.build(r2.allPolygons()), t2.invert(), eS.fromPolygons(t2.allPolygons());
    }
    intersect(e2) {
      const t2 = new YE(this.clone().polygons), r2 = new YE(e2.clone().polygons);
      return t2.invert(), r2.clipTo(t2), r2.invert(), t2.clipTo(r2), r2.clipTo(t2), t2.build(r2.allPolygons()), t2.invert(), eS.fromPolygons(t2.allPolygons());
    }
    inverse() {
      const e2 = this.clone();
      for (const t2 of e2.polygons)
        t2.flip();
      return e2;
    }
    toMesh(e2, t2) {
      return eS.toMesh(this, e2, t2);
    }
    toGeometry(e2) {
      return eS.toGeometry(this, e2);
    }
  }
  var tS = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  const rS = ["union", "subtract", "intersect"];
  class nS extends ro {
    constructor() {
      super(), this.enabled = true, this.toJSON = void 0, this.dependencies = [Nc], this.rootMesh = new n.Kj0(), this.showResult = false, this.csgSelectedEnabled = false, this.csgSelectedOperation = "union", this._csgNeedsUpdate = false, this._csgVisible = false, this._sceneUpdate = this._sceneUpdate.bind(this), this._preFrame = this._preFrame.bind(this), this.makeSelectedCSGBrush = this.makeSelectedCSGBrush.bind(this), this.refreshCSG = this.refreshCSG.bind(this), this._selectedObjectChanged = this._selectedObjectChanged.bind(this), this._updateSelectedProperties = this._updateSelectedProperties.bind(this), this.downloadObject = this.downloadObject.bind(this), this.exportObject = this.exportObject.bind(this);
    }
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2), this.rootObject = await e2.createObject3D(), this.rootObject.modelObject.add(this.rootMesh), e2.scene.addEventListener("sceneUpdate", this._sceneUpdate), e2.addEventListener("preFrame", this._preFrame), null === (t2 = e2.getPlugin(Nc)) || void 0 === t2 || t2.addEventListener("selectedObjectChanged", this._selectedObjectChanged);
    }
    async makeSelectedCSGBrush() {
      var e2, t2;
      const r2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Nc)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
      r2 && r2.geometry && (r2.userData._isCSGMesh || (r2.userData.csgBrush || (r2.userData.csgBrush = { enabled: true, operation: "union" }), this._selectedObjectChanged()));
    }
    refreshCSG() {
      this._sceneUpdate();
    }
    async downloadObject() {
      const e2 = await this.exportObject();
      e2 && yt(e2, "csg." + e2.ext);
    }
    async exportObject() {
      var e2, t2;
      const r2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPluginByType("AssetExporterPlugin")) || void 0 === t2 ? void 0 : t2.exporter;
      if (!r2 || !this.rootObject)
        return;
      const n2 = this.rootMesh.visible;
      this.rootMesh.visible = true;
      const i2 = await r2.exportObject(this.rootObject.modelObject, {});
      return this.rootMesh.visible = n2, i2;
    }
    _updateSelectedProperties() {
      var e2, t2;
      const r2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Nc)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
      r2 && r2.userData.csgBrush && (r2.userData.csgBrush.enabled = this.csgSelectedEnabled, r2.userData.csgBrush.operation = this.csgSelectedOperation);
    }
    _selectedObjectChanged() {
      var e2, t2, r2, n2, i2, s2, o2, a2;
      const l2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getPlugin(Nc)) || void 0 === t2 ? void 0 : t2.getSelectedObject();
      l2 && (this.csgSelectedEnabled = null !== (n2 = null === (r2 = l2.userData.csgBrush) || void 0 === r2 ? void 0 : r2.enabled) && void 0 !== n2 && n2, this.csgSelectedOperation = null !== (s2 = null === (i2 = l2.userData.csgBrush) || void 0 === i2 ? void 0 : i2.operation) && void 0 !== s2 ? s2 : "union"), null === (a2 = null === (o2 = this.uiConfig) || void 0 === o2 ? void 0 : o2.uiRefresh) || void 0 === a2 || a2.call(o2, "postFrame", true);
    }
    _preFrame() {
      var e2, t2, r2;
      if (!this.rootObject)
        return;
      if (!this._csgNeedsUpdate && this._csgVisible === this.showResult)
        return;
      const n2 = this._findCSGMeshes();
      this._csgNeedsUpdate && (this._csgNeedsUpdate = false, null === (e2 = this.rootObject) || void 0 === e2 || e2.modelObject.updateMatrixWorld(true), (null !== (t2 = this.rootMesh.userData.dispose) && void 0 !== t2 ? t2 : this.rootMesh.removeFromParent)(), this.rootMesh = this._buildCSGMesh(n2)), this.rootMesh && !this.rootMesh.parent && (null === (r2 = this.rootObject) || void 0 === r2 || r2.modelObject.add(this.rootMesh)), this.showResult ? (n2.forEach((e3) => {
        e3[0].visible = false;
      }), this.rootObject.visible = true, this._csgVisible = true, this.rootObject.setDirty()) : (n2.forEach((e3) => {
        e3[0].visible = true;
      }), this.rootObject.visible = false, this._csgVisible = false, this.rootObject.setDirty());
    }
    _findCSGMeshes() {
      var e2;
      const t2 = [];
      return null === (e2 = this._viewer) || void 0 === e2 || e2.scene.traverse((e3) => {
        var r2;
        e3.isMesh && e3.geometry && (null === (r2 = e3.userData.csgBrush) || void 0 === r2 ? void 0 : r2.enabled) && t2.push([e3, e3.userData.csgBrush.operation]);
      }), t2;
    }
    _sceneUpdate(e2) {
      var t2, r2;
      (null === (r2 = null === (t2 = null == e2 ? void 0 : e2.object) || void 0 === t2 ? void 0 : t2.userData) || void 0 === r2 ? void 0 : r2._isCSGMesh) || (this._csgNeedsUpdate = true);
    }
  }
  tS([Je("Show Result", (e2) => ({ onChange: () => {
    var t2;
    return null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.setDirty();
  } }))], nS.prototype, "showResult", void 0), tS([rt("Make CSG Brush", (e2) => ({ hidden: () => {
    var t2, r2;
    const n2 = null === (r2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Nc)) || void 0 === r2 ? void 0 : r2.getSelectedObject();
    return !(null == n2 ? void 0 : n2.userData) || !!n2.userData.csgBrush || n2.userData._isCSGMesh;
  } }))], nS.prototype, "makeSelectedCSGBrush", null), tS([Je("Enabled", (e2) => ({ hidden: () => {
    var t2, r2;
    const n2 = null === (r2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Nc)) || void 0 === r2 ? void 0 : r2.getSelectedObject();
    return !n2 || !n2.userData.csgBrush;
  }, onChange: e2._updateSelectedProperties }))], nS.prototype, "csgSelectedEnabled", void 0), tS([tt("Operation", rS.map((e2) => ({ label: e2 })), (e2) => ({ hidden: () => {
    var t2, r2;
    const n2 = null === (r2 = null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(Nc)) || void 0 === r2 ? void 0 : r2.getSelectedObject();
    return !n2 || !n2.userData.csgBrush;
  }, onChange: e2._updateSelectedProperties }))], nS.prototype, "csgSelectedOperation", void 0), tS([rt("Refresh CSG")], nS.prototype, "refreshCSG", null), tS([rt("Export Result", (e2) => ({ hidden: () => {
    var t2;
    return !(null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.getPluginByType("AssetExporterPlugin"));
  } }))], nS.prototype, "downloadObject", null);
  function iS(e2, t2) {
    let r2 = new eS();
    const i2 = e2.map((e3) => e3[0].material).flatMap((e3) => e3);
    e2.forEach(([e3, t3]) => {
      if (!rS.includes(t3))
        return void console.error(`Unknown operation ${t3}`);
      e3.updateMatrix(), e3.updateMatrixWorld();
      const n2 = e3.matrix;
      e3.matrix = e3.matrixWorld;
      let s3 = 0;
      s3 = Array.isArray(e3.material) ? void 0 : i2.indexOf(e3.material), r2 = r2[t3](eS.fromMesh(e3, s3)), e3.matrix = n2;
    });
    const s2 = r2.toMesh(null != t2 ? t2 : new n.yGw().identity(), i2);
    return s2.userData._isCSGMesh = true, s2.geometry.groups = s2.geometry.groups.filter((e3) => e3.count > 0), s2;
  }
  let sS = class extends nS {
    _buildCSGMesh(e2) {
      return iS(e2);
    }
  };
  sS.PluginType = "CSGPluginBSP", sS = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  }([lt("CSG Plugin (BSP)")], sS);
  class oS {
    constructor() {
      this.min = 1 / 0, this.max = -1 / 0;
    }
    setFromPointsField(e2, t2) {
      let r2 = 1 / 0, n2 = -1 / 0;
      for (let i2 = 0, s2 = e2.length; i2 < s2; i2++) {
        const s3 = e2[i2][t2];
        r2 = s3 < r2 ? s3 : r2, n2 = s3 > n2 ? s3 : n2;
      }
      this.min = r2, this.max = n2;
    }
    setFromPoints(e2, t2) {
      let r2 = 1 / 0, n2 = -1 / 0;
      for (let i2 = 0, s2 = t2.length; i2 < s2; i2++) {
        const s3 = t2[i2], o2 = e2.dot(s3);
        r2 = o2 < r2 ? o2 : r2, n2 = o2 > n2 ? o2 : n2;
      }
      this.min = r2, this.max = n2;
    }
    isSeparated(e2) {
      return this.min > e2.max || e2.min > this.max;
    }
  }
  oS.prototype.setFromBox = function() {
    const e2 = new n.Pa4();
    return function(t2, r2) {
      const n2 = r2.min, i2 = r2.max;
      let s2 = 1 / 0, o2 = -1 / 0;
      for (let r3 = 0; r3 <= 1; r3++)
        for (let a2 = 0; a2 <= 1; a2++)
          for (let l2 = 0; l2 <= 1; l2++) {
            e2.x = n2.x * r3 + i2.x * (1 - r3), e2.y = n2.y * a2 + i2.y * (1 - a2), e2.z = n2.z * l2 + i2.z * (1 - l2);
            const c2 = t2.dot(e2);
            s2 = Math.min(c2, s2), o2 = Math.max(c2, o2);
          }
      this.min = s2, this.max = o2;
    };
  }(), new oS();
  const aS = function() {
    const e2 = new n.Pa4(), t2 = new n.Pa4(), r2 = new n.Pa4();
    return function(n2, i2, s2) {
      const o2 = n2.start, a2 = e2, l2 = i2.start, c2 = t2;
      r2.subVectors(o2, l2), e2.subVectors(n2.end, i2.start), t2.subVectors(i2.end, i2.start);
      const u2 = r2.dot(c2), h2 = c2.dot(a2), p2 = c2.dot(c2), d2 = r2.dot(a2), f2 = a2.dot(a2) * p2 - h2 * h2;
      let m2, _2;
      m2 = 0 !== f2 ? (u2 * h2 - d2 * p2) / f2 : 0, _2 = (u2 + m2 * h2) / p2, s2.x = m2, s2.y = _2;
    };
  }(), lS = function() {
    const e2 = new n.FM8(), t2 = new n.Pa4(), r2 = new n.Pa4();
    return function(n2, i2, s2, o2) {
      aS(n2, i2, e2);
      let a2 = e2.x, l2 = e2.y;
      if (a2 >= 0 && a2 <= 1 && l2 >= 0 && l2 <= 1)
        return n2.at(a2, s2), void i2.at(l2, o2);
      if (a2 >= 0 && a2 <= 1)
        return l2 < 0 ? i2.at(0, o2) : i2.at(1, o2), void n2.closestPointToPoint(o2, true, s2);
      if (l2 >= 0 && l2 <= 1)
        return a2 < 0 ? n2.at(0, s2) : n2.at(1, s2), void i2.closestPointToPoint(s2, true, o2);
      {
        let e3, c2;
        e3 = a2 < 0 ? n2.start : n2.end, c2 = l2 < 0 ? i2.start : i2.end;
        const u2 = t2, h2 = r2;
        return n2.closestPointToPoint(c2, true, t2), i2.closestPointToPoint(e3, true, r2), u2.distanceToSquared(c2) <= h2.distanceToSquared(e3) ? (s2.copy(u2), void o2.copy(c2)) : (s2.copy(e3), void o2.copy(h2));
      }
    };
  }(), cS = function() {
    const e2 = new n.Pa4(), t2 = new n.Pa4(), r2 = new n.JOQ(), i2 = new n.Zzh();
    return function(n2, s2) {
      const { radius: o2, center: a2 } = n2, { a: l2, b: c2, c: u2 } = s2;
      if (i2.start = l2, i2.end = c2, i2.closestPointToPoint(a2, true, e2).distanceTo(a2) <= o2)
        return true;
      if (i2.start = l2, i2.end = u2, i2.closestPointToPoint(a2, true, e2).distanceTo(a2) <= o2)
        return true;
      if (i2.start = c2, i2.end = u2, i2.closestPointToPoint(a2, true, e2).distanceTo(a2) <= o2)
        return true;
      const h2 = s2.getPlane(r2);
      if (Math.abs(h2.distanceToPoint(a2)) <= o2) {
        const e3 = h2.projectPoint(a2, t2);
        if (s2.containsPoint(e3))
          return true;
      }
      return false;
    };
  }();
  function uS(e2) {
    return Math.abs(e2) < 1e-15;
  }
  class hS extends n.CJI {
    constructor(...e2) {
      super(...e2), this.isExtendedTriangle = true, this.satAxes = new Array(4).fill().map(() => new n.Pa4()), this.satBounds = new Array(4).fill().map(() => new oS()), this.points = [this.a, this.b, this.c], this.sphere = new n.aLr(), this.plane = new n.JOQ(), this.needsUpdate = true;
    }
    intersectsSphere(e2) {
      return cS(e2, this);
    }
    update() {
      const e2 = this.a, t2 = this.b, r2 = this.c, n2 = this.points, i2 = this.satAxes, s2 = this.satBounds, o2 = i2[0], a2 = s2[0];
      this.getNormal(o2), a2.setFromPoints(o2, n2);
      const l2 = i2[1], c2 = s2[1];
      l2.subVectors(e2, t2), c2.setFromPoints(l2, n2);
      const u2 = i2[2], h2 = s2[2];
      u2.subVectors(t2, r2), h2.setFromPoints(u2, n2);
      const p2 = i2[3], d2 = s2[3];
      p2.subVectors(r2, e2), d2.setFromPoints(p2, n2), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(o2, e2), this.needsUpdate = false;
    }
  }
  hS.prototype.closestPointToSegment = function() {
    const e2 = new n.Pa4(), t2 = new n.Pa4(), r2 = new n.Zzh();
    return function(n2, i2 = null, s2 = null) {
      const { start: o2, end: a2 } = n2, l2 = this.points;
      let c2, u2 = 1 / 0;
      for (let o3 = 0; o3 < 3; o3++) {
        const a3 = (o3 + 1) % 3;
        r2.start.copy(l2[o3]), r2.end.copy(l2[a3]), lS(r2, n2, e2, t2), c2 = e2.distanceToSquared(t2), c2 < u2 && (u2 = c2, i2 && i2.copy(e2), s2 && s2.copy(t2));
      }
      return this.closestPointToPoint(o2, e2), c2 = o2.distanceToSquared(e2), c2 < u2 && (u2 = c2, i2 && i2.copy(e2), s2 && s2.copy(o2)), this.closestPointToPoint(a2, e2), c2 = a2.distanceToSquared(e2), c2 < u2 && (u2 = c2, i2 && i2.copy(e2), s2 && s2.copy(a2)), Math.sqrt(u2);
    };
  }(), hS.prototype.intersectsTriangle = function() {
    const e2 = new hS(), t2 = new Array(3), r2 = new Array(3), i2 = new oS(), s2 = new oS(), o2 = new n.Pa4(), a2 = new n.Pa4(), l2 = new n.Pa4(), c2 = new n.Pa4(), u2 = new n.Zzh(), h2 = new n.Zzh(), p2 = new n.Zzh();
    return function(n2, d2 = null) {
      this.needsUpdate && this.update(), n2.isExtendedTriangle ? n2.needsUpdate && n2.update() : (e2.copy(n2), e2.update(), n2 = e2);
      const f2 = this.plane, m2 = n2.plane;
      if (Math.abs(f2.normal.dot(m2.normal)) > 1 - 1e-10) {
        const e3 = this.satBounds, a3 = this.satAxes;
        r2[0] = n2.a, r2[1] = n2.b, r2[2] = n2.c;
        for (let t3 = 0; t3 < 4; t3++) {
          const n3 = e3[t3], s3 = a3[t3];
          if (i2.setFromPoints(s3, r2), n3.isSeparated(i2))
            return false;
        }
        const l3 = n2.satBounds, c3 = n2.satAxes;
        t2[0] = this.a, t2[1] = this.b, t2[2] = this.c;
        for (let e4 = 0; e4 < 4; e4++) {
          const r3 = l3[e4], n3 = c3[e4];
          if (i2.setFromPoints(n3, t2), r3.isSeparated(i2))
            return false;
        }
        for (let e4 = 0; e4 < 4; e4++) {
          const n3 = a3[e4];
          for (let e5 = 0; e5 < 4; e5++) {
            const a4 = c3[e5];
            if (o2.crossVectors(n3, a4), i2.setFromPoints(o2, t2), s2.setFromPoints(o2, r2), i2.isSeparated(s2))
              return false;
          }
        }
        return d2 && (console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), d2.start.set(0, 0, 0), d2.end.set(0, 0, 0)), true;
      }
      {
        const e3 = this.points;
        let t3 = false, r3 = 0;
        for (let n3 = 0; n3 < 3; n3++) {
          const i4 = e3[n3], s4 = e3[(n3 + 1) % 3];
          u2.start.copy(i4), u2.end.copy(s4), u2.delta(a2);
          const o4 = t3 ? h2.start : h2.end, l3 = uS(m2.distanceToPoint(i4));
          if (uS(m2.normal.dot(a2)) && l3) {
            h2.copy(u2), r3 = 2;
            break;
          }
          if ((m2.intersectLine(u2, o4) || l3) && !uS(o4.distanceTo(s4))) {
            if (r3++, t3)
              break;
            t3 = true;
          }
        }
        if (1 === r3 && this.containsPoint(h2.start))
          return d2 && (d2.start.copy(h2.start), d2.end.copy(h2.start)), true;
        if (2 !== r3)
          return false;
        const i3 = n2.points;
        let s3 = false, o3 = 0;
        for (let e4 = 0; e4 < 3; e4++) {
          const t4 = i3[e4], r4 = i3[(e4 + 1) % 3];
          u2.start.copy(t4), u2.end.copy(r4), u2.delta(l2);
          const n3 = s3 ? p2.start : p2.end, a3 = uS(f2.distanceToPoint(t4));
          if (uS(f2.normal.dot(l2)) && a3) {
            p2.copy(u2), o3 = 2;
            break;
          }
          if ((f2.intersectLine(u2, n3) || a3) && !uS(n3.distanceTo(r4))) {
            if (o3++, s3)
              break;
            s3 = true;
          }
        }
        if (1 === o3 && this.containsPoint(p2.start))
          return d2 && (d2.start.copy(p2.start), d2.end.copy(p2.start)), true;
        if (2 !== o3)
          return false;
        if (h2.delta(a2), p2.delta(l2), a2.dot(l2) < 0) {
          let e4 = p2.start;
          p2.start = p2.end, p2.end = e4;
        }
        const _2 = h2.start.dot(a2), g2 = h2.end.dot(a2), v2 = p2.start.dot(a2), A2 = p2.end.dot(a2), b2 = g2 < v2, y2 = _2 < A2;
        return (_2 === A2 || v2 === g2 || b2 !== y2) && (d2 && (c2.subVectors(h2.start, p2.start), c2.dot(a2) > 0 ? d2.start.copy(h2.start) : d2.start.copy(p2.start), c2.subVectors(h2.end, p2.end), c2.dot(a2) < 0 ? d2.end.copy(h2.end) : d2.end.copy(p2.end)), true);
      }
    };
  }(), hS.prototype.distanceToPoint = function() {
    const e2 = new n.Pa4();
    return function(t2) {
      return this.closestPointToPoint(t2, e2), t2.distanceTo(e2);
    };
  }(), hS.prototype.distanceToTriangle = function() {
    const e2 = new n.Pa4(), t2 = new n.Pa4(), r2 = ["a", "b", "c"], i2 = new n.Zzh(), s2 = new n.Zzh();
    return function(n2, o2 = null, a2 = null) {
      const l2 = o2 || a2 ? i2 : null;
      if (this.intersectsTriangle(n2, l2))
        return (o2 || a2) && (o2 && l2.getCenter(o2), a2 && l2.getCenter(a2)), 0;
      let c2 = 1 / 0;
      for (let t3 = 0; t3 < 3; t3++) {
        let i3;
        const s3 = r2[t3], l3 = n2[s3];
        this.closestPointToPoint(l3, e2), i3 = l3.distanceToSquared(e2), i3 < c2 && (c2 = i3, o2 && o2.copy(e2), a2 && a2.copy(l3));
        const u2 = this[s3];
        n2.closestPointToPoint(u2, e2), i3 = u2.distanceToSquared(e2), i3 < c2 && (c2 = i3, o2 && o2.copy(u2), a2 && a2.copy(e2));
      }
      for (let l3 = 0; l3 < 3; l3++) {
        const u2 = r2[l3], h2 = r2[(l3 + 1) % 3];
        i2.set(this[u2], this[h2]);
        for (let l4 = 0; l4 < 3; l4++) {
          const u3 = r2[l4], h3 = r2[(l4 + 1) % 3];
          s2.set(n2[u3], n2[h3]), lS(i2, s2, e2, t2);
          const p2 = e2.distanceToSquared(t2);
          p2 < c2 && (c2 = p2, o2 && o2.copy(e2), a2 && a2.copy(t2));
        }
      }
      return Math.sqrt(c2);
    };
  }();
  class pS {
    constructor() {
      this.intersectionSet = {}, this.ids = [];
    }
    add(e2, t2) {
      const { intersectionSet: r2, ids: n2 } = this;
      r2[e2] || (r2[e2] = [], n2.push(e2)), r2[e2].push(t2);
    }
  }
  const dS = new n.zHn(), fS = new n.yGw(), mS = new n.CJI(), _S = new n.Pa4(), gS = new n.Ltg(), vS = new n.Ltg(), AS = new n.Ltg(), bS = new n.Ltg(), yS = new n.Ltg(), xS = new n.Ltg(), wS = new n.Zzh(), ES = 1e-8;
  let SS = null;
  function CS(e2) {
    SS = e2;
  }
  function MS(e2, t2) {
    function r2() {
      return Math.random() - 0.5;
    }
    dS.origin.copy(e2.a).add(e2.b).add(e2.c).multiplyScalar(1 / 3), e2.getNormal(dS.direction);
    let i2 = 0, s2 = 1 / 0;
    for (let e3 = 0; e3 < 3; e3++) {
      dS.direction.x += r2() * ES, dS.direction.y += r2() * ES, dS.direction.z += r2() * ES;
      const o2 = t2.raycastFirst(dS, n.ehD);
      if (Boolean(o2 && dS.direction.dot(o2.face.normal) > 0) && i2++, null !== o2 && (s2 = Math.min(s2, o2.distance)), 0 === s2 || i2 / 3 > 0.5 || (e3 - i2 + 1) / 3 > 0.5)
        break;
    }
    return 0 === s2 ? 0 : i2 / 3 > 0.5 ? -1 : 1;
  }
  function TS(e2, t2, r2, n2, i2, s2, o2 = false) {
    const a2 = r2.attributes, l2 = r2.index, c2 = 3 * e2, u2 = l2.getX(c2 + 0), h2 = l2.getX(c2 + 1), p2 = l2.getX(c2 + 2);
    for (const e3 in s2) {
      const r3 = a2[e3], l3 = s2[e3];
      if (!(e3 in a2))
        throw new Error(`CSG Operations: Attribute ${e3} not available on geometry.`);
      const c3 = r3.itemSize;
      "position" === e3 ? (mS.a.fromBufferAttribute(r3, u2).applyMatrix4(n2), mS.b.fromBufferAttribute(r3, h2).applyMatrix4(n2), mS.c.fromBufferAttribute(r3, p2).applyMatrix4(n2), DS(mS.a, mS.b, mS.c, t2, 3, l3, o2)) : "normal" === e3 ? (mS.a.fromBufferAttribute(r3, u2).applyNormalMatrix(i2), mS.b.fromBufferAttribute(r3, h2).applyNormalMatrix(i2), mS.c.fromBufferAttribute(r3, p2).applyNormalMatrix(i2), o2 && (mS.a.multiplyScalar(-1), mS.b.multiplyScalar(-1), mS.c.multiplyScalar(-1)), DS(mS.a, mS.b, mS.c, t2, 3, l3, o2, true)) : (gS.fromBufferAttribute(r3, u2), vS.fromBufferAttribute(r3, h2), AS.fromBufferAttribute(r3, p2), DS(gS, vS, AS, t2, c3, l3, o2));
    }
  }
  function IS(e2, t2, r2, n2, i2, s2, o2, a2 = false) {
    PS(e2, n2, i2, s2, o2, a2), PS(t2, n2, i2, s2, o2, a2), PS(r2, n2, i2, s2, o2, a2);
  }
  function kS(e2, t2, r2 = false) {
    switch (e2) {
      case 0:
        if (1 === t2 || 0 === t2 && r2)
          return 1;
        break;
      case 1:
        if (r2) {
          if (-1 === t2)
            return 0;
        } else if (1 === t2)
          return 1;
        break;
      case 3:
        if (-1 === t2)
          return 0;
        if (1 === t2)
          return 1;
      case 4:
        if (-1 === t2 || 0 === t2 && r2)
          return 1;
        break;
      default:
        throw new Error(`Unrecognized CSG operation enum "${e2}".`);
    }
    return 2;
  }
  function DS(e2, t2, r2, n2, i2, s2, o2 = false, a2 = false) {
    const l2 = (e3) => {
      s2.push(e3.x), i2 > 1 && s2.push(e3.y), i2 > 2 && s2.push(e3.z), i2 > 3 && s2.push(e3.w);
    };
    bS.set(0, 0, 0, 0).addScaledVector(e2, n2.a.x).addScaledVector(t2, n2.a.y).addScaledVector(r2, n2.a.z), yS.set(0, 0, 0, 0).addScaledVector(e2, n2.b.x).addScaledVector(t2, n2.b.y).addScaledVector(r2, n2.b.z), xS.set(0, 0, 0, 0).addScaledVector(e2, n2.c.x).addScaledVector(t2, n2.c.y).addScaledVector(r2, n2.c.z), a2 && (bS.normalize(), yS.normalize(), xS.normalize()), l2(bS), o2 ? (l2(xS), l2(yS)) : (l2(yS), l2(xS));
  }
  function PS(e2, t2, r2, n2, i2, s2 = false) {
    for (const o2 in i2) {
      const a2 = t2[o2], l2 = i2[o2];
      if (!(o2 in t2))
        throw new Error(`CSG Operations: Attribute ${o2} no available on geometry.`);
      const c2 = a2.itemSize;
      "position" === o2 ? (_S.fromBufferAttribute(a2, e2).applyMatrix4(r2), l2.push(_S.x, _S.y, _S.z)) : "normal" === o2 ? (_S.fromBufferAttribute(a2, e2).applyNormalMatrix(n2), s2 && _S.multiplyScalar(-1), l2.push(_S.x, _S.y, _S.z)) : (l2.push(a2.getX(e2)), c2 > 1 && l2.push(a2.getY(e2)), c2 > 2 && l2.push(a2.getZ(e2)), c2 > 3 && l2.push(a2.getW(e2)));
    }
  }
  const BS = 1e-14, RS = 1e-7, LS = new n.Zzh(), OS = new n.Zzh(), FS = new n.Pa4(), US = new n.Pa4(), NS = new n.JOQ(), jS = new hS();
  function zS(e2) {
    return e2.a.distanceToSquared(e2.b) < BS || e2.a.distanceToSquared(e2.c) < BS || e2.b.distanceToSquared(e2.c) < BS;
  }
  class GS extends n.CJI {
    constructor(...e2) {
      super(...e2), this.side = null, this.originalSide = null, this.coplanarCount = 0;
    }
    init() {
      this.side = null, this.originalSide = null, this.coplanarCount = 0;
    }
    initFrom(e2) {
      this.side = e2.side, this.originalSide = e2.originalSide, this.coplanarCount = e2.coplanarCount;
    }
    updateSide(e2, t2 = null, r2 = -1) {
      if (null !== this.originalSide && null === this.side)
        return;
      FS.copy(this.a).add(this.b).add(this.c).multiplyScalar(1 / 3);
      const n2 = e2.distanceToPoint(FS) < 0 ? -1 : 1;
      t2 && -1 !== r2 ? 1 === n2 && (this.coplanarCount++, 3 === this.coplanarCount && (this.side = 0)) : (null === this.originalSide && (this.originalSide = n2, this.side = n2), n2 !== this.side && (this.side = null));
    }
  }
  class VS {
    constructor() {
      this._pool = [], this._index = 0;
    }
    getTriangle() {
      this._index >= this._pool.length && this._pool.push(new GS());
      const e2 = this._pool[this._index++];
      return e2.init(), e2;
    }
    clear() {
      this._index = 0;
    }
    reset() {
      this._pool.length = 0, this._index = 0;
    }
  }
  class QS {
    constructor() {
      this.trianglePool = new VS(), this.triangles = [], this.normal = new n.Pa4();
    }
    initialize(e2) {
      const { triangles: t2, trianglePool: r2, normal: n2 } = this;
      if (t2.length = 0, r2.clear(), Array.isArray(e2))
        for (let i2 = 0, s2 = e2.length; i2 < s2; i2++) {
          const s3 = e2[i2];
          if (0 === i2)
            s3.getNormal(n2);
          else if (Math.abs(1 - s3.getNormal(FS).dot(n2)) > BS)
            throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");
          const o2 = r2.getTriangle();
          o2.copy(s3), t2.push(o2);
        }
      else {
        e2.getNormal(n2);
        const i2 = r2.getTriangle();
        i2.copy(e2), t2.push(i2);
      }
    }
    splitByTriangle(e2) {
      const { normal: t2, triangles: r2 } = this;
      if (e2.getPlane(NS), Math.abs(1 - Math.abs(NS.normal.dot(t2))) < RS) {
        const n2 = [e2.a, e2.b, e2.c];
        for (let r3 = 0; r3 < 3; r3++) {
          const i2 = (r3 + 1) % 3, s2 = n2[r3], o2 = n2[i2];
          FS.subVectors(o2, s2).normalize(), US.crossVectors(t2, FS), NS.setFromNormalAndCoplanarPoint(US, s2), this.splitByPlane(NS, e2, r3);
        }
        for (let e3 = 0, t3 = r2.length; e3 < t3; e3++)
          r2[e3].coplanarCount = 0;
      } else
        this.splitByPlane(NS, e2);
    }
    splitByPlane(e2, t2 = null, r2 = -1) {
      const { triangles: n2, trianglePool: i2 } = this;
      let s2 = null;
      null !== t2 && (s2 = jS, s2.copy(t2), s2.needsUpdate = true);
      for (let t3 = 0, o2 = n2.length; t3 < o2; t3++) {
        const a2 = n2[t3], { a: l2, b: c2, c: u2 } = a2;
        if (s2 && (!s2.intersectsTriangle(a2, LS) || LS.distance() < 1e-5)) {
          a2.updateSide(e2, s2, r2), a2.side = null;
          continue;
        }
        let h2 = 0, p2 = -1, d2 = 0, f2 = 0, m2 = false;
        const _2 = [l2, c2, u2];
        for (let t4 = 0; t4 < 3; t4++) {
          const r3 = (t4 + 1) % 3;
          LS.start.copy(_2[t4]), LS.end.copy(_2[r3]);
          const n3 = e2.distanceToPoint(LS.start), i3 = e2.distanceToPoint(LS.end);
          Math.abs(n3) < BS ? f2++ : n3 > 0 && d2++, Math.abs(n3) < RS && Math.abs(i3) < RS && (m2 = true);
          let s3 = !!e2.intersectLine(LS, FS);
          !s3 && Math.abs(i3) < BS && (FS.copy(LS.end), s3 = true), !s3 || FS.distanceTo(LS.start) < BS || (FS.distanceTo(LS.end) < BS && (p2 = t4), 0 === h2 ? OS.start.copy(FS) : OS.end.copy(FS), h2++);
        }
        if (!m2 && f2 < 2 && 2 === h2 && OS.distance() > RS)
          if (-1 !== p2) {
            p2 = (p2 + 1) % 3;
            let l3 = 0;
            l3 === p2 && (l3 = (l3 + 1) % 3);
            let c3 = l3 + 1;
            c3 === p2 && (c3 = (c3 + 1) % 3);
            const u3 = i2.getTriangle();
            u3.a.copy(_2[c3]), u3.b.copy(OS.end), u3.c.copy(OS.start), zS(u3) || (n2.push(u3), u3.initFrom(a2), u3.updateSide(e2, s2, r2)), a2.a.copy(_2[l3]), a2.b.copy(OS.start), a2.c.copy(OS.end), zS(a2) ? (n2.splice(t3, 1), t3--, o2--) : a2.updateSide(e2, s2, r2);
          } else {
            const l3 = _2.findIndex((t4) => d2 >= 2 ? e2.distanceToPoint(t4) < 0 : e2.distanceToPoint(t4) > 0);
            if (0 === l3) {
              let e3 = OS.start;
              OS.start = OS.end, OS.end = e3;
            } else if (-1 === l3)
              continue;
            const c3 = (l3 + 1) % 3, u3 = (l3 + 2) % 3, h3 = i2.getTriangle(), p3 = i2.getTriangle();
            _2[c3].distanceToSquared(OS.start) < _2[u3].distanceToSquared(OS.end) ? (h3.a.copy(_2[c3]), h3.b.copy(OS.start), h3.c.copy(OS.end), p3.a.copy(_2[c3]), p3.b.copy(_2[u3]), p3.c.copy(OS.start)) : (h3.a.copy(_2[u3]), h3.b.copy(OS.start), h3.c.copy(OS.end), p3.a.copy(_2[c3]), p3.b.copy(_2[u3]), p3.c.copy(OS.end)), a2.a.copy(_2[l3]), a2.b.copy(OS.end), a2.c.copy(OS.start), zS(h3) || (n2.push(h3), h3.initFrom(a2), h3.updateSide(e2, s2, r2)), zS(p3) || (n2.push(p3), p3.initFrom(a2), p3.updateSide(e2, s2, r2)), zS(a2) ? (n2.splice(t3, 1), t3--, o2--) : a2.updateSide(e2, s2, r2);
          }
        else
          3 === h2 && console.warn("TriangleClipper: Coplanar clip not handled");
      }
    }
    reset() {
      this.triangles.length = 0;
    }
  }
  function HS() {
    return "undefined" != typeof SharedArrayBuffer;
  }
  function WS(e2) {
    if (e2.buffer instanceof SharedArrayBuffer)
      return e2;
    const t2 = e2.constructor, r2 = e2.buffer, n2 = new SharedArrayBuffer(r2.byteLength), i2 = new Uint8Array(r2);
    return new Uint8Array(n2).set(i2, 0), new t2(n2);
  }
  class qS {
    constructor(e2, t2 = 500) {
      const r2 = HS() ? SharedArrayBuffer : ArrayBuffer;
      this.expansionFactor = 1.5, this.type = e2, this.array = new e2(new r2(t2 * e2.BYTES_PER_ELEMENT)), this.length = 0;
    }
    expand(e2 = null) {
      const { type: t2, array: r2, expansionFactor: n2 } = this;
      null === e2 && (e2 = ~~(r2.length * n2));
      const i2 = new t2(e2);
      i2.set(r2, 0), this.array = i2;
    }
    push(...e2) {
      let { array: t2, length: r2 } = this;
      r2 + e2.length > t2.length && (this.expand(), t2 = this.array);
      for (let n2 = 0, i2 = e2.length; n2 < i2; n2++)
        t2[r2 + n2] = e2[n2];
      this.length += e2.length;
    }
    clear() {
      this.length = 0;
    }
  }
  class XS {
    constructor() {
      this.groupAttributes = [{}], this.groupCount = 0;
    }
    getType(e2) {
      return this.groupAttributes[0][e2].type;
    }
    getTotalLength(e2) {
      const { groupCount: t2, groupAttributes: r2 } = this;
      let n2 = 0;
      for (let i2 = 0; i2 < t2; i2++)
        n2 += r2[i2][e2].length;
      return n2;
    }
    getGroupSet(e2 = 0) {
      const { groupAttributes: t2 } = this;
      if (t2[e2])
        return this.groupCount = Math.max(this.groupCount, e2 + 1), t2[e2];
      const r2 = t2[0];
      for (this.groupCount = Math.max(this.groupCount, e2 + 1); e2 >= t2.length; ) {
        const e3 = {};
        t2.push(e3);
        for (const t3 in r2)
          e3[t3] = new qS(r2[t3].type);
      }
      return t2[e2];
    }
    getGroupArray(e2, t2 = 0) {
      const { groupAttributes: r2 } = this;
      if (!r2[0][e2])
        throw new Error(`TypedAttributeData: Attribute with "${e2}" has not been initialized`);
      return this.getGroupSet(t2)[e2];
    }
    initializeArray(e2, t2) {
      const { groupAttributes: r2 } = this, n2 = r2[0][e2];
      if (n2) {
        if (n2.type !== t2)
          throw new Error(`TypedAttributeData: Array ${e2} already initialized with a different type.`);
      } else
        for (let n3 = 0, i2 = r2.length; n3 < i2; n3++)
          r2[n3][e2] = new qS(t2);
    }
    clear() {
      this.groupCount = 0;
      const { groupAttributes: e2 } = this;
      e2.forEach((e3) => {
        for (const t2 in e3)
          e3[t2].clear();
      });
    }
    delete(e2) {
      this.groupAttributes.forEach((t2) => {
        delete t2[e2];
      });
    }
    reset() {
      this.groupAttributes = [];
    }
  }
  class YS {
    constructor(e2) {
      this.triangle = new n.CJI().copy(e2), this.intersects = {};
    }
    addTriangle(e2, t2) {
      this.intersects[e2] = new n.CJI().copy(t2);
    }
    getIntersectArray() {
      const e2 = [], { intersects: t2 } = this;
      for (const r2 in t2)
        e2.push(t2[r2]);
      return e2;
    }
  }
  class KS {
    constructor() {
      this.data = {};
    }
    addTriangleIntersection(e2, t2, r2, n2) {
      const { data: i2 } = this;
      i2[e2] || (i2[e2] = new YS(t2)), i2[e2].addTriangle(r2, n2);
    }
    getTrianglesAsArray(e2 = null) {
      const { data: t2 } = this, r2 = [];
      if (null !== e2)
        e2 in t2 && r2.push(t2[e2].triangle);
      else
        for (const e3 in t2)
          r2.push(t2[e3].triangle);
      return r2;
    }
    getTriangleIndices() {
      return Object.keys(this.data).map((e2) => parseInt(e2));
    }
    getIntersectionIndices(e2) {
      const { data: t2 } = this;
      return t2[e2] ? Object.keys(t2[e2].intersects).map((e3) => parseInt(e3)) : [];
    }
    getIntersectionsAsArray(e2 = null, t2 = null) {
      const { data: r2 } = this, n2 = /* @__PURE__ */ new Set(), i2 = [], s2 = (e3) => {
        if (r2[e3])
          if (null !== t2)
            r2[e3].intersects[t2] && i2.push(r2[e3].intersects[t2]);
          else {
            const t3 = r2[e3].intersects;
            for (const e4 in t3)
              n2.has(e4) || (n2.add(e4), i2.push(t3[e4]));
          }
      };
      if (null !== e2)
        s2(e2);
      else
        for (const e3 in r2)
          s2(e3);
      return i2;
    }
    reset() {
      this.data = {};
    }
  }
  class JS {
    constructor() {
      this.enabled = false, this.triangleIntersectsA = new KS(), this.triangleIntersectsB = new KS(), this.intersectionEdges = [];
    }
    addIntersectingTriangles(e2, t2, r2, n2) {
      const { triangleIntersectsA: i2, triangleIntersectsB: s2 } = this;
      i2.addTriangleIntersection(e2, t2, r2, n2), s2.addTriangleIntersection(r2, n2, e2, t2);
    }
    addEdge(e2) {
      this.intersectionEdges.push(e2.clone());
    }
    reset() {
      this.triangleIntersectsA.reset(), this.triangleIntersectsB.reset(), this.intersectionEdges = [];
    }
  }
  const ZS = new n.yGw(), $S = new n.Vkp(), eC = new n.CJI(), tC = new n.CJI(), rC = new n.CJI(), nC = new n.CJI();
  function iC(e2) {
    for (const t2 of e2)
      return t2;
  }
  function sC(e2, t2, r2, n2, i2, s2, o2, a2 = 0) {
    ZS.copy(t2.matrixWorld).invert().multiply(e2.matrixWorld), $S.getNormalMatrix(e2.matrixWorld);
    const l2 = e2.geometry.groupIndices, c2 = e2.geometry.index, u2 = e2.geometry.attributes.position, h2 = t2.geometry.boundsTree, p2 = t2.geometry.index, d2 = t2.geometry.attributes.position, f2 = r2.ids, m2 = r2.intersectionSet;
    for (let t3 = 0, r3 = f2.length; t3 < r3; t3++) {
      const r4 = f2[t3], _2 = -1 === a2 ? 0 : l2[r4] + a2, g2 = o2.getGroupSet(_2), v2 = 3 * r4, A2 = c2.getX(v2 + 0), b2 = c2.getX(v2 + 1), y2 = c2.getX(v2 + 2);
      eC.a.fromBufferAttribute(u2, A2).applyMatrix4(ZS), eC.b.fromBufferAttribute(u2, b2).applyMatrix4(ZS), eC.c.fromBufferAttribute(u2, y2).applyMatrix4(ZS), s2.initialize(eC);
      const x2 = m2[r4];
      for (let e3 = 0, t4 = x2.length; e3 < t4; e3++) {
        const t5 = 3 * x2[e3], r5 = p2.getX(t5 + 0), n3 = p2.getX(t5 + 1), i3 = p2.getX(t5 + 2);
        tC.a.fromBufferAttribute(d2, r5), tC.b.fromBufferAttribute(d2, n3), tC.c.fromBufferAttribute(d2, i3), s2.splitByTriangle(tC);
      }
      const w2 = s2.triangles;
      for (let t4 = 0, s3 = w2.length; t4 < s3; t4++) {
        const s4 = w2[t4], o3 = kS(n2, MS(s4, h2), i2);
        if (2 !== o3)
          switch (eC.getBarycoord(s4.a, nC.a), eC.getBarycoord(s4.b, nC.b), eC.getBarycoord(s4.c, nC.c), o3) {
            case 1:
              TS(r4, nC, e2.geometry, e2.matrixWorld, $S, g2);
              break;
            case 0:
              TS(r4, nC, e2.geometry, e2.matrixWorld, $S, g2, true);
          }
      }
    }
    return f2.length;
  }
  function oC(e2, t2, r2, n2, i2, s2, o2 = 0) {
    ZS.copy(t2.matrixWorld).invert().multiply(e2.matrixWorld), $S.getNormalMatrix(e2.matrixWorld);
    const a2 = t2.geometry.boundsTree, l2 = e2.geometry.groupIndices, c2 = e2.geometry.index, u2 = e2.geometry.attributes, h2 = u2.position, p2 = [], d2 = e2.geometry.halfEdges, f2 = /* @__PURE__ */ new Set();
    for (let e3 = 0, t3 = c2.count / 3; e3 < t3; e3++)
      e3 in r2.intersectionSet || f2.add(e3);
    for (; f2.size > 0; ) {
      const t3 = iC(f2);
      f2.delete(t3), p2.push(t3);
      const r3 = 3 * t3, m2 = c2.getX(r3 + 0), _2 = c2.getX(r3 + 1), g2 = c2.getX(r3 + 2);
      rC.a.fromBufferAttribute(h2, m2).applyMatrix4(ZS), rC.b.fromBufferAttribute(h2, _2).applyMatrix4(ZS), rC.c.fromBufferAttribute(h2, g2).applyMatrix4(ZS);
      const v2 = kS(n2, MS(rC, a2), i2);
      for (; p2.length > 0; ) {
        const t4 = p2.pop(), r4 = -1 === o2 ? 0 : l2[t4] + o2, n3 = s2.getGroupSet(r4);
        for (let e3 = 0; e3 < 3; e3++) {
          const r5 = d2.getSiblingTriangleIndex(t4, e3);
          -1 !== r5 && f2.has(r5) && (p2.push(r5), f2.delete(r5));
        }
        const a3 = 3 * t4, h3 = c2.getX(a3 + 0), m3 = c2.getX(a3 + 1), _3 = c2.getX(a3 + 2);
        switch (v2) {
          case 1:
            IS(h3, m3, _3, u2, e2.matrixWorld, $S, n3);
            break;
          case 0:
            IS(_3, m3, h3, u2, e2.matrixWorld, $S, n3, i2);
        }
      }
    }
  }
  const aC = 1.25, lC = 65535, cC = Math.pow(2, -24);
  class uC {
    constructor() {
    }
  }
  function hC(e2, t2, r2) {
    return r2.min.x = t2[e2], r2.min.y = t2[e2 + 1], r2.min.z = t2[e2 + 2], r2.max.x = t2[e2 + 3], r2.max.y = t2[e2 + 4], r2.max.z = t2[e2 + 5], r2;
  }
  function pC(e2) {
    let t2 = -1, r2 = -1 / 0;
    for (let n2 = 0; n2 < 3; n2++) {
      const i2 = e2[n2 + 3] - e2[n2];
      i2 > r2 && (r2 = i2, t2 = n2);
    }
    return t2;
  }
  function dC(e2, t2) {
    t2.set(e2);
  }
  function fC(e2, t2, r2) {
    let n2, i2;
    for (let s2 = 0; s2 < 3; s2++) {
      const o2 = s2 + 3;
      n2 = e2[s2], i2 = t2[s2], r2[s2] = n2 < i2 ? n2 : i2, n2 = e2[o2], i2 = t2[o2], r2[o2] = n2 > i2 ? n2 : i2;
    }
  }
  function mC(e2, t2, r2) {
    for (let n2 = 0; n2 < 3; n2++) {
      const i2 = t2[e2 + 2 * n2], s2 = t2[e2 + 2 * n2 + 1], o2 = i2 - s2, a2 = i2 + s2;
      o2 < r2[n2] && (r2[n2] = o2), a2 > r2[n2 + 3] && (r2[n2 + 3] = a2);
    }
  }
  function _C(e2) {
    const t2 = e2[3] - e2[0], r2 = e2[4] - e2[1], n2 = e2[5] - e2[2];
    return 2 * (t2 * r2 + r2 * n2 + n2 * t2);
  }
  function gC(e2, t2, r2, n2, i2 = null) {
    let s2 = 1 / 0, o2 = 1 / 0, a2 = 1 / 0, l2 = -1 / 0, c2 = -1 / 0, u2 = -1 / 0, h2 = 1 / 0, p2 = 1 / 0, d2 = 1 / 0, f2 = -1 / 0, m2 = -1 / 0, _2 = -1 / 0;
    const g2 = null !== i2;
    for (let n3 = 6 * t2, i3 = 6 * (t2 + r2); n3 < i3; n3 += 6) {
      const t3 = e2[n3 + 0], r3 = e2[n3 + 1], i4 = t3 - r3, v2 = t3 + r3;
      i4 < s2 && (s2 = i4), v2 > l2 && (l2 = v2), g2 && t3 < h2 && (h2 = t3), g2 && t3 > f2 && (f2 = t3);
      const A2 = e2[n3 + 2], b2 = e2[n3 + 3], y2 = A2 - b2, x2 = A2 + b2;
      y2 < o2 && (o2 = y2), x2 > c2 && (c2 = x2), g2 && A2 < p2 && (p2 = A2), g2 && A2 > m2 && (m2 = A2);
      const w2 = e2[n3 + 4], E2 = e2[n3 + 5], S2 = w2 - E2, C2 = w2 + E2;
      S2 < a2 && (a2 = S2), C2 > u2 && (u2 = C2), g2 && w2 < d2 && (d2 = w2), g2 && w2 > _2 && (_2 = w2);
    }
    n2[0] = s2, n2[1] = o2, n2[2] = a2, n2[3] = l2, n2[4] = c2, n2[5] = u2, g2 && (i2[0] = h2, i2[1] = p2, i2[2] = d2, i2[3] = f2, i2[4] = m2, i2[5] = _2);
  }
  const vC = (e2, t2) => e2.candidate - t2.candidate, AC = new Array(32).fill().map(() => ({ count: 0, bounds: new Float32Array(6), rightCacheBounds: new Float32Array(6), leftCacheBounds: new Float32Array(6), candidate: 0 })), bC = new Float32Array(6);
  class yC extends n.ZzF {
    constructor(...e2) {
      super(...e2), this.isOrientedBox = true, this.matrix = new n.yGw(), this.invMatrix = new n.yGw(), this.points = new Array(8).fill().map(() => new n.Pa4()), this.satAxes = new Array(3).fill().map(() => new n.Pa4()), this.satBounds = new Array(3).fill().map(() => new oS()), this.alignedSatBounds = new Array(3).fill().map(() => new oS()), this.needsUpdate = false;
    }
    set(e2, t2, r2) {
      super.set(e2, t2), this.matrix.copy(r2), this.needsUpdate = true;
    }
    copy(e2) {
      super.copy(e2), this.matrix.copy(e2.matrix), this.needsUpdate = true;
    }
  }
  yC.prototype.update = function() {
    const e2 = this.matrix, t2 = this.min, r2 = this.max, n2 = this.points;
    for (let i3 = 0; i3 <= 1; i3++)
      for (let s3 = 0; s3 <= 1; s3++)
        for (let o3 = 0; o3 <= 1; o3++) {
          const a3 = n2[1 * i3 | 2 * s3 | 4 * o3];
          a3.x = i3 ? r2.x : t2.x, a3.y = s3 ? r2.y : t2.y, a3.z = o3 ? r2.z : t2.z, a3.applyMatrix4(e2);
        }
    const i2 = this.satBounds, s2 = this.satAxes, o2 = n2[0];
    for (let e3 = 0; e3 < 3; e3++) {
      const t3 = s2[e3], r3 = i2[e3], a3 = n2[1 << e3];
      t3.subVectors(o2, a3), r3.setFromPoints(t3, n2);
    }
    const a2 = this.alignedSatBounds;
    a2[0].setFromPointsField(n2, "x"), a2[1].setFromPointsField(n2, "y"), a2[2].setFromPointsField(n2, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = false;
  }, yC.prototype.intersectsBox = function() {
    const e2 = new oS();
    return function(t2) {
      this.needsUpdate && this.update();
      const r2 = t2.min, n2 = t2.max, i2 = this.satBounds, s2 = this.satAxes, o2 = this.alignedSatBounds;
      if (e2.min = r2.x, e2.max = n2.x, o2[0].isSeparated(e2))
        return false;
      if (e2.min = r2.y, e2.max = n2.y, o2[1].isSeparated(e2))
        return false;
      if (e2.min = r2.z, e2.max = n2.z, o2[2].isSeparated(e2))
        return false;
      for (let r3 = 0; r3 < 3; r3++) {
        const n3 = s2[r3], o3 = i2[r3];
        if (e2.setFromBox(n3, t2), o3.isSeparated(e2))
          return false;
      }
      return true;
    };
  }(), yC.prototype.intersectsTriangle = function() {
    const e2 = new hS(), t2 = new Array(3), r2 = new oS(), i2 = new oS(), s2 = new n.Pa4();
    return function(n2) {
      this.needsUpdate && this.update(), n2.isExtendedTriangle ? n2.needsUpdate && n2.update() : (e2.copy(n2), e2.update(), n2 = e2);
      const o2 = this.satBounds, a2 = this.satAxes;
      t2[0] = n2.a, t2[1] = n2.b, t2[2] = n2.c;
      for (let e3 = 0; e3 < 3; e3++) {
        const n3 = o2[e3], i3 = a2[e3];
        if (r2.setFromPoints(i3, t2), n3.isSeparated(r2))
          return false;
      }
      const l2 = n2.satBounds, c2 = n2.satAxes, u2 = this.points;
      for (let e3 = 0; e3 < 3; e3++) {
        const t3 = l2[e3], n3 = c2[e3];
        if (r2.setFromPoints(n3, u2), t3.isSeparated(r2))
          return false;
      }
      for (let e3 = 0; e3 < 3; e3++) {
        const n3 = a2[e3];
        for (let e4 = 0; e4 < 4; e4++) {
          const o3 = c2[e4];
          if (s2.crossVectors(n3, o3), r2.setFromPoints(s2, t2), i2.setFromPoints(s2, u2), r2.isSeparated(i2))
            return false;
        }
      }
      return true;
    };
  }(), yC.prototype.closestPointToPoint = function(e2, t2) {
    return this.needsUpdate && this.update(), t2.copy(e2).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t2;
  }, yC.prototype.distanceToPoint = function() {
    const e2 = new n.Pa4();
    return function(t2) {
      return this.closestPointToPoint(t2, e2), t2.distanceTo(e2);
    };
  }(), yC.prototype.distanceToBox = function() {
    const e2 = ["x", "y", "z"], t2 = new Array(12).fill().map(() => new n.Zzh()), r2 = new Array(12).fill().map(() => new n.Zzh()), i2 = new n.Pa4(), s2 = new n.Pa4();
    return function(n2, o2 = 0, a2 = null, l2 = null) {
      if (this.needsUpdate && this.update(), this.intersectsBox(n2))
        return (a2 || l2) && (n2.getCenter(s2), this.closestPointToPoint(s2, i2), n2.closestPointToPoint(i2, s2), a2 && a2.copy(i2), l2 && l2.copy(s2)), 0;
      const c2 = o2 * o2, u2 = n2.min, h2 = n2.max, p2 = this.points;
      let d2 = 1 / 0;
      for (let e3 = 0; e3 < 8; e3++) {
        const t3 = p2[e3];
        s2.copy(t3).clamp(u2, h2);
        const r3 = t3.distanceToSquared(s2);
        if (r3 < d2 && (d2 = r3, a2 && a2.copy(t3), l2 && l2.copy(s2), r3 < c2))
          return Math.sqrt(r3);
      }
      let f2 = 0;
      for (let n3 = 0; n3 < 3; n3++)
        for (let i3 = 0; i3 <= 1; i3++)
          for (let s3 = 0; s3 <= 1; s3++) {
            const o3 = (n3 + 1) % 3, a3 = (n3 + 2) % 3, l3 = 1 << n3 | i3 << o3 | s3 << a3, c3 = p2[i3 << o3 | s3 << a3], d3 = p2[l3];
            t2[f2].set(c3, d3);
            const m2 = e2[n3], _2 = e2[o3], g2 = e2[a3], v2 = r2[f2], A2 = v2.start, b2 = v2.end;
            A2[m2] = u2[m2], A2[_2] = i3 ? u2[_2] : h2[_2], A2[g2] = s3 ? u2[g2] : h2[_2], b2[m2] = h2[m2], b2[_2] = i3 ? u2[_2] : h2[_2], b2[g2] = s3 ? u2[g2] : h2[_2], f2++;
          }
      for (let e3 = 0; e3 <= 1; e3++)
        for (let t3 = 0; t3 <= 1; t3++)
          for (let r3 = 0; r3 <= 1; r3++) {
            s2.x = e3 ? h2.x : u2.x, s2.y = t3 ? h2.y : u2.y, s2.z = r3 ? h2.z : u2.z, this.closestPointToPoint(s2, i2);
            const n3 = s2.distanceToSquared(i2);
            if (n3 < d2 && (d2 = n3, a2 && a2.copy(i2), l2 && l2.copy(s2), n3 < c2))
              return Math.sqrt(n3);
          }
      for (let e3 = 0; e3 < 12; e3++) {
        const n3 = t2[e3];
        for (let e4 = 0; e4 < 12; e4++) {
          const t3 = r2[e4];
          lS(n3, t3, i2, s2);
          const o3 = i2.distanceToSquared(s2);
          if (o3 < d2 && (d2 = o3, a2 && a2.copy(i2), l2 && l2.copy(s2), o3 < c2))
            return Math.sqrt(o3);
        }
      }
      return Math.sqrt(d2);
    };
  }();
  const xC = new n.Pa4(), wC = new n.Pa4(), EC = new n.Pa4(), SC = new n.FM8(), CC = new n.FM8(), MC = new n.FM8(), TC = new n.Pa4();
  function IC(e2, t2, r2, i2, s2) {
    const o2 = 3 * i2, a2 = e2.index.getX(o2), l2 = e2.index.getX(o2 + 1), c2 = e2.index.getX(o2 + 2), u2 = function(e3, t3, r3, i3, s3, o3, a3) {
      xC.fromBufferAttribute(t3, i3), wC.fromBufferAttribute(t3, s3), EC.fromBufferAttribute(t3, o3);
      const l3 = function(e4, t4, r4, i4, s4, o4) {
        let a4;
        return a4 = o4 === n._Li ? e4.intersectTriangle(i4, r4, t4, true, s4) : e4.intersectTriangle(t4, r4, i4, o4 !== n.ehD, s4), null === a4 ? null : { distance: e4.origin.distanceTo(s4), point: s4.clone() };
      }(e3, xC, wC, EC, TC, a3);
      if (l3) {
        r3 && (SC.fromBufferAttribute(r3, i3), CC.fromBufferAttribute(r3, s3), MC.fromBufferAttribute(r3, o3), l3.uv = n.CJI.getUV(TC, xC, wC, EC, SC, CC, MC, new n.FM8()));
        const e4 = { a: i3, b: s3, c: o3, normal: new n.Pa4(), materialIndex: 0 };
        n.CJI.getNormal(xC, wC, EC, e4.normal), l3.face = e4, l3.faceIndex = i3;
      }
      return l3;
    }(r2, e2.attributes.position, e2.attributes.uv, a2, l2, c2, t2);
    return u2 ? (u2.faceIndex = i2, s2 && s2.push(u2), u2) : null;
  }
  function kC(e2, t2, r2) {
    return null === e2 ? null : (e2.point.applyMatrix4(t2.matrixWorld), e2.distance = e2.point.distanceTo(r2.ray.origin), e2.object = t2, e2.distance < r2.near || e2.distance > r2.far ? null : e2);
  }
  function DC(e2, t2, r2, n2) {
    const i2 = e2.a, s2 = e2.b, o2 = e2.c;
    let a2 = t2, l2 = t2 + 1, c2 = t2 + 2;
    r2 && (a2 = r2.getX(t2), l2 = r2.getX(t2 + 1), c2 = r2.getX(t2 + 2)), i2.x = n2.getX(a2), i2.y = n2.getY(a2), i2.z = n2.getZ(a2), s2.x = n2.getX(l2), s2.y = n2.getY(l2), s2.z = n2.getZ(l2), o2.x = n2.getX(c2), o2.y = n2.getY(c2), o2.z = n2.getZ(c2);
  }
  function PC(e2, t2, r2, n2, i2, s2, o2) {
    const a2 = r2.index, l2 = r2.attributes.position;
    for (let r3 = e2, c2 = t2 + e2; r3 < c2; r3++)
      if (DC(o2, 3 * r3, a2, l2), o2.needsUpdate = true, n2(o2, r3, i2, s2))
        return true;
    return false;
  }
  class BC {
    constructor(e2) {
      this._getNewPrimitive = e2, this._primitives = [];
    }
    getPrimitive() {
      const e2 = this._primitives;
      return 0 === e2.length ? this._getNewPrimitive() : e2.pop();
    }
    releasePrimitive(e2) {
      this._primitives.push(e2);
    }
  }
  function RC(e2, t2) {
    return 65535 === t2[e2 + 15];
  }
  function LC(e2, t2) {
    return t2[e2 + 6];
  }
  function OC(e2, t2) {
    return t2[e2 + 14];
  }
  function FC(e2) {
    return e2 + 8;
  }
  function UC(e2, t2) {
    return t2[e2 + 6];
  }
  const NC = new n.ZzF(), jC = new n.Pa4(), zC = ["x", "y", "z"];
  function GC(e2, t2, r2, n2, i2) {
    let s2 = 2 * e2, o2 = YC, a2 = KC, l2 = JC;
    if (RC(s2, a2))
      !function(e3, t3, r3, n3, i3, s3) {
        for (let o3 = n3, a3 = n3 + i3; o3 < a3; o3++)
          IC(e3, t3, r3, o3, s3);
      }(t2, r2, n2, LC(e2, l2), OC(s2, a2), i2);
    else {
      const s3 = FC(e2);
      WC(s3, o2, n2, jC) && GC(s3, t2, r2, n2, i2);
      const a3 = UC(e2, l2);
      WC(a3, o2, n2, jC) && GC(a3, t2, r2, n2, i2);
    }
  }
  function VC(e2, t2, r2, n2) {
    let i2 = 2 * e2, s2 = YC, o2 = KC, a2 = JC;
    if (RC(i2, o2))
      return function(e3, t3, r3, n3, i3) {
        let s3 = 1 / 0, o3 = null;
        for (let a3 = n3, l2 = n3 + i3; a3 < l2; a3++) {
          const n4 = IC(e3, t3, r3, a3);
          n4 && n4.distance < s3 && (o3 = n4, s3 = n4.distance);
        }
        return o3;
      }(t2, r2, n2, LC(e2, a2), OC(i2, o2));
    {
      const i3 = function(e3, t3) {
        return t3[e3 + 7];
      }(e2, a2), o3 = zC[i3], l2 = n2.direction[o3] >= 0;
      let c2, u2;
      l2 ? (c2 = FC(e2), u2 = UC(e2, a2)) : (c2 = UC(e2, a2), u2 = FC(e2));
      const h2 = WC(c2, s2, n2, jC) ? VC(c2, t2, r2, n2) : null;
      if (h2) {
        const e3 = h2.point[o3];
        if (l2 ? e3 <= s2[u2 + i3] : e3 >= s2[u2 + i3 + 3])
          return h2;
      }
      const p2 = WC(u2, s2, n2, jC) ? VC(u2, t2, r2, n2) : null;
      return h2 && p2 ? h2.distance <= p2.distance ? h2 : p2 : h2 || p2 || null;
    }
  }
  const QC = function() {
    let e2, t2;
    const r2 = [], i2 = new BC(() => new n.ZzF());
    return function(...n2) {
      e2 = i2.getPrimitive(), t2 = i2.getPrimitive(), r2.push(e2, t2);
      const o2 = s2(...n2);
      i2.releasePrimitive(e2), i2.releasePrimitive(t2), r2.pop(), r2.pop();
      const a2 = r2.length;
      return a2 > 0 && (t2 = r2[a2 - 1], e2 = r2[a2 - 2]), o2;
    };
    function s2(r3, n2, i3, o2, a2 = null, l2 = 0, c2 = 0) {
      function u2(e3) {
        let t3 = 2 * e3, r4 = KC, n3 = JC;
        for (; !RC(t3, r4); )
          t3 = 2 * (e3 = FC(e3));
        return LC(e3, n3);
      }
      function h2(e3) {
        let t3 = 2 * e3, r4 = KC, n3 = JC;
        for (; !RC(t3, r4); )
          t3 = 2 * (e3 = UC(e3, n3));
        return LC(e3, n3) + OC(t3, r4);
      }
      let p2 = 2 * r3, d2 = YC, f2 = KC, m2 = JC;
      if (RC(p2, f2)) {
        const t3 = LC(r3, m2), n3 = OC(p2, f2);
        return hC(r3, d2, e2), o2(t3, n3, false, c2, l2 + r3, e2);
      }
      {
        const p3 = FC(r3), _2 = UC(r3, m2);
        let g2, v2, A2, b2, y2 = p3, x2 = _2;
        if (a2 && (A2 = e2, b2 = t2, hC(y2, d2, A2), hC(x2, d2, b2), g2 = a2(A2), v2 = a2(b2), v2 < g2)) {
          y2 = _2, x2 = p3;
          const e3 = g2;
          g2 = v2, v2 = e3, A2 = b2;
        }
        A2 || (A2 = e2, hC(y2, d2, A2));
        const w2 = i3(A2, RC(2 * y2, f2), g2, c2 + 1, l2 + y2);
        let E2;
        if (2 === w2) {
          const e3 = u2(y2);
          E2 = o2(e3, h2(y2) - e3, true, c2 + 1, l2 + y2, A2);
        } else
          E2 = w2 && s2(y2, n2, i3, o2, a2, l2, c2 + 1);
        if (E2)
          return true;
        b2 = t2, hC(x2, d2, b2);
        const S2 = i3(b2, RC(2 * x2, f2), v2, c2 + 1, l2 + x2);
        let C2;
        if (2 === S2) {
          const e3 = u2(x2);
          C2 = o2(e3, h2(x2) - e3, true, c2 + 1, l2 + x2, b2);
        } else
          C2 = S2 && s2(x2, n2, i3, o2, a2, l2, c2 + 1);
        return !!C2;
      }
    }
  }(), HC = function() {
    const e2 = new hS(), t2 = new hS(), r2 = new n.yGw(), i2 = new yC(), s2 = new yC();
    return function n2(o2, a2, l2, c2, u2 = null) {
      let h2 = 2 * o2, p2 = YC, d2 = KC, f2 = JC;
      if (null === u2 && (l2.boundingBox || l2.computeBoundingBox(), i2.set(l2.boundingBox.min, l2.boundingBox.max, c2), u2 = i2), !RC(h2, d2)) {
        const e3 = o2 + 8, t3 = f2[o2 + 6];
        return hC(e3, p2, NC), u2.intersectsBox(NC) && n2(e3, a2, l2, c2, u2) ? true : (hC(t3, p2, NC), !(!u2.intersectsBox(NC) || !n2(t3, a2, l2, c2, u2)));
      }
      {
        const n3 = a2, i3 = n3.index, u3 = n3.attributes.position, m2 = l2.index, _2 = l2.attributes.position, g2 = LC(o2, f2), v2 = OC(h2, d2);
        if (r2.copy(c2).invert(), l2.boundsTree) {
          hC(o2, p2, s2), s2.matrix.copy(r2), s2.needsUpdate = true;
          const e3 = l2.boundsTree.shapecast({ intersectsBounds: (e4) => s2.intersectsBox(e4), intersectsTriangle: (e4) => {
            e4.a.applyMatrix4(c2), e4.b.applyMatrix4(c2), e4.c.applyMatrix4(c2), e4.needsUpdate = true;
            for (let r3 = 3 * g2, n4 = 3 * (v2 + g2); r3 < n4; r3 += 3)
              if (DC(t2, r3, i3, u3), t2.needsUpdate = true, e4.intersectsTriangle(t2))
                return true;
            return false;
          } });
          return e3;
        }
        for (let n4 = 3 * g2, s3 = v2 + 3 * g2; n4 < s3; n4 += 3) {
          DC(e2, n4, i3, u3), e2.a.applyMatrix4(r2), e2.b.applyMatrix4(r2), e2.c.applyMatrix4(r2), e2.needsUpdate = true;
          for (let r3 = 0, n5 = m2.count; r3 < n5; r3 += 3)
            if (DC(t2, r3, m2, _2), t2.needsUpdate = true, e2.intersectsTriangle(t2))
              return true;
        }
      }
    };
  }();
  function WC(e2, t2, r2, n2) {
    return hC(e2, t2, NC), r2.intersectBox(NC, n2);
  }
  const qC = [];
  let XC, YC, KC, JC;
  function ZC(e2) {
    XC && qC.push(XC), XC = e2, YC = new Float32Array(e2), KC = new Uint16Array(e2), JC = new Uint32Array(e2);
  }
  function $C() {
    XC = null, YC = null, KC = null, JC = null, qC.length && ZC(qC.pop());
  }
  const eM = Symbol("skip tree generation"), tM = new n.ZzF(), rM = new n.ZzF(), nM = new n.yGw(), iM = new yC(), sM = new yC(), oM = new n.Pa4(), aM = new n.Pa4(), lM = new n.Pa4(), cM = new n.Pa4(), uM = new n.Pa4(), hM = new n.ZzF(), pM = new BC(() => new hS());
  class dM {
    static serialize(e2, t2 = {}) {
      if (t2.isBufferGeometry)
        return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."), dM.serialize(arguments[0], { cloneBuffers: void 0 === arguments[2] || arguments[2] });
      t2 = { cloneBuffers: true, ...t2 };
      const r2 = e2.geometry, n2 = e2._roots, i2 = r2.getIndex();
      let s2;
      return s2 = t2.cloneBuffers ? { roots: n2.map((e3) => e3.slice()), index: i2.array.slice() } : { roots: n2, index: i2.array }, s2;
    }
    static deserialize(e2, t2, r2 = {}) {
      if ("boolean" == typeof r2)
        return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."), dM.deserialize(arguments[0], arguments[1], { setIndex: void 0 === arguments[2] || arguments[2] });
      r2 = { setIndex: true, ...r2 };
      const { index: i2, roots: s2 } = e2, o2 = new dM(t2, { ...r2, [eM]: true });
      if (o2._roots = s2, r2.setIndex) {
        const r3 = t2.getIndex();
        if (null === r3) {
          const r4 = new n.TlE(e2.index, 1, false);
          t2.setIndex(r4);
        } else
          r3.array !== i2 && (r3.array.set(i2), r3.needsUpdate = true);
      }
      return o2;
    }
    constructor(e2, t2 = {}) {
      if (!e2.isBufferGeometry)
        throw new Error("MeshBVH: Only BufferGeometries are supported.");
      if (e2.index && e2.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
      if ((t2 = Object.assign({ strategy: 0, maxDepth: 40, maxLeafTris: 10, verbose: true, useSharedArrayBuffer: false, setBoundingBox: true, onProgress: null, [eM]: false }, t2)).useSharedArrayBuffer && "undefined" == typeof SharedArrayBuffer)
        throw new Error("MeshBVH: SharedArrayBuffer is not available.");
      this._roots = null, t2[eM] || (this._roots = function(e3, t3) {
        const r2 = function(e4, t4) {
          function r3(e5) {
            d2 && d2(e5 / f2);
          }
          function i3(t5, n2, s4, d3 = null, f3 = 0) {
            if (!m2 && f3 >= c3 && (m2 = true, u3 && (console.warn(`MeshBVH: Max depth of ${c3} reached when generating BVH. Consider increasing maxDepth.`), console.warn(e4))), s4 <= h2 || f3 >= c3)
              return r3(n2 + s4), t5.offset = n2, t5.count = s4, t5;
            const _3 = function(e5, t6, r4, n3, i4, s5) {
              let o4 = -1, a4 = 0;
              if (0 === s5)
                o4 = pC(t6), -1 !== o4 && (a4 = (t6[o4] + t6[o4 + 3]) / 2);
              else if (1 === s5)
                o4 = pC(e5), -1 !== o4 && (a4 = function(e6, t7, r5, n4) {
                  let i5 = 0;
                  for (let s6 = t7, o5 = t7 + r5; s6 < o5; s6++)
                    i5 += e6[6 * s6 + 2 * n4];
                  return i5 / r5;
                }(r4, n3, i4, o4));
              else if (2 === s5) {
                const s6 = _C(e5);
                let l4 = aC * i4;
                const c4 = 6 * n3, u4 = 6 * (n3 + i4);
                for (let e6 = 0; e6 < 3; e6++) {
                  const n4 = t6[e6], h3 = (t6[e6 + 3] - n4) / 32;
                  if (i4 < 8) {
                    const t7 = [...AC];
                    t7.length = i4;
                    let n5 = 0;
                    for (let i5 = c4; i5 < u4; i5 += 6, n5++) {
                      const s7 = t7[n5];
                      s7.candidate = r4[i5 + 2 * e6], s7.count = 0;
                      const { bounds: o5, leftCacheBounds: a5, rightCacheBounds: l5 } = s7;
                      for (let e7 = 0; e7 < 3; e7++)
                        l5[e7] = 1 / 0, l5[e7 + 3] = -1 / 0, a5[e7] = 1 / 0, a5[e7 + 3] = -1 / 0, o5[e7] = 1 / 0, o5[e7 + 3] = -1 / 0;
                      mC(i5, r4, o5);
                    }
                    t7.sort(vC);
                    let h4 = i4;
                    for (let e7 = 0; e7 < h4; e7++) {
                      const r5 = t7[e7];
                      for (; e7 + 1 < h4 && t7[e7 + 1].candidate === r5.candidate; )
                        t7.splice(e7 + 1, 1), h4--;
                    }
                    for (let n6 = c4; n6 < u4; n6 += 6) {
                      const i5 = r4[n6 + 2 * e6];
                      for (let e7 = 0; e7 < h4; e7++) {
                        const s7 = t7[e7];
                        i5 >= s7.candidate ? mC(n6, r4, s7.rightCacheBounds) : (mC(n6, r4, s7.leftCacheBounds), s7.count++);
                      }
                    }
                    for (let r5 = 0; r5 < h4; r5++) {
                      const n6 = t7[r5], c5 = n6.count, u5 = i4 - n6.count, h5 = n6.leftCacheBounds, p3 = n6.rightCacheBounds;
                      let d4 = 0;
                      0 !== c5 && (d4 = _C(h5) / s6);
                      let f4 = 0;
                      0 !== u5 && (f4 = _C(p3) / s6);
                      const m3 = 1 + aC * (d4 * c5 + f4 * u5);
                      m3 < l4 && (o4 = e6, l4 = m3, a4 = n6.candidate);
                    }
                  } else {
                    for (let e7 = 0; e7 < 32; e7++) {
                      const t8 = AC[e7];
                      t8.count = 0, t8.candidate = n4 + h3 + e7 * h3;
                      const r5 = t8.bounds;
                      for (let e8 = 0; e8 < 3; e8++)
                        r5[e8] = 1 / 0, r5[e8 + 3] = -1 / 0;
                    }
                    for (let t8 = c4; t8 < u4; t8 += 6) {
                      let i5 = ~~((r4[t8 + 2 * e6] - n4) / h3);
                      i5 >= 32 && (i5 = 31);
                      const s7 = AC[i5];
                      s7.count++, mC(t8, r4, s7.bounds);
                    }
                    const t7 = AC[31];
                    dC(t7.bounds, t7.rightCacheBounds);
                    for (let e7 = 30; e7 >= 0; e7--) {
                      const t8 = AC[e7], r5 = AC[e7 + 1];
                      fC(t8.bounds, r5.rightCacheBounds, t8.rightCacheBounds);
                    }
                    let p3 = 0;
                    for (let t8 = 0; t8 < 31; t8++) {
                      const r5 = AC[t8], n5 = r5.count, c5 = r5.bounds, u5 = AC[t8 + 1].rightCacheBounds;
                      0 !== n5 && (0 === p3 ? dC(c5, bC) : fC(c5, bC, bC)), p3 += n5;
                      let h4 = 0, d4 = 0;
                      0 !== p3 && (h4 = _C(bC) / s6);
                      const f4 = i4 - p3;
                      0 !== f4 && (d4 = _C(u5) / s6);
                      const m3 = 1 + aC * (h4 * p3 + d4 * f4);
                      m3 < l4 && (o4 = e6, l4 = m3, a4 = r5.candidate);
                    }
                  }
                }
              } else
                console.warn(`MeshBVH: Invalid build strategy value ${s5} used.`);
              return { axis: o4, pos: a4 };
            }(t5.boundingData, d3, a3, n2, s4, p2);
            if (-1 === _3.axis)
              return r3(n2 + s4), t5.offset = n2, t5.count = s4, t5;
            const g3 = function(e5, t6, r4, n3, i4) {
              let s5 = r4, o4 = r4 + n3 - 1;
              const a4 = i4.pos, l4 = 2 * i4.axis;
              for (; ; ) {
                for (; s5 <= o4 && t6[6 * s5 + l4] < a4; )
                  s5++;
                for (; s5 <= o4 && t6[6 * o4 + l4] >= a4; )
                  o4--;
                if (!(s5 < o4))
                  return s5;
                for (let r5 = 0; r5 < 3; r5++) {
                  let n4 = e5[3 * s5 + r5];
                  e5[3 * s5 + r5] = e5[3 * o4 + r5], e5[3 * o4 + r5] = n4;
                  let i5 = t6[6 * s5 + 2 * r5 + 0];
                  t6[6 * s5 + 2 * r5 + 0] = t6[6 * o4 + 2 * r5 + 0], t6[6 * o4 + 2 * r5 + 0] = i5;
                  let a5 = t6[6 * s5 + 2 * r5 + 1];
                  t6[6 * s5 + 2 * r5 + 1] = t6[6 * o4 + 2 * r5 + 1], t6[6 * o4 + 2 * r5 + 1] = a5;
                }
                s5++, o4--;
              }
            }(l3, a3, n2, s4, _3);
            if (g3 === n2 || g3 === n2 + s4)
              r3(n2 + s4), t5.offset = n2, t5.count = s4;
            else {
              t5.splitAxis = _3.axis;
              const e5 = new uC(), r4 = n2, l4 = g3 - n2;
              t5.left = e5, e5.boundingData = new Float32Array(6), gC(a3, r4, l4, e5.boundingData, o3), i3(e5, r4, l4, o3, f3 + 1);
              const c4 = new uC(), u4 = g3, h3 = s4 - l4;
              t5.right = c4, c4.boundingData = new Float32Array(6), gC(a3, u4, h3, c4.boundingData, o3), i3(c4, u4, h3, o3, f3 + 1);
            }
            return t5;
          }
          !function(e5, t5) {
            if (!e5.index) {
              const r4 = e5.attributes.position.count, i4 = t5.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
              let s4;
              s4 = r4 > 65535 ? new Uint32Array(new i4(4 * r4)) : new Uint16Array(new i4(2 * r4)), e5.setIndex(new n.TlE(s4, 1));
              for (let e6 = 0; e6 < r4; e6++)
                s4[e6] = e6;
            }
          }(e4, t4);
          const s3 = new Float32Array(6), o3 = new Float32Array(6), a3 = function(e5, t5) {
            const r4 = e5.attributes.position, n2 = r4.array, i4 = e5.index.array, s4 = i4.length / 3, o4 = new Float32Array(6 * s4), a4 = r4.offset || 0;
            let l4 = 3;
            r4.isInterleavedBufferAttribute && (l4 = r4.data.stride);
            for (let e6 = 0; e6 < s4; e6++) {
              const r5 = 3 * e6, s5 = 6 * e6, c4 = i4[r5 + 0] * l4 + a4, u4 = i4[r5 + 1] * l4 + a4, h3 = i4[r5 + 2] * l4 + a4;
              for (let e7 = 0; e7 < 3; e7++) {
                const r6 = n2[c4 + e7], i5 = n2[u4 + e7], a5 = n2[h3 + e7];
                let l5 = r6;
                i5 < l5 && (l5 = i5), a5 < l5 && (l5 = a5);
                let p3 = r6;
                i5 > p3 && (p3 = i5), a5 > p3 && (p3 = a5);
                const d3 = (p3 - l5) / 2, f3 = 2 * e7;
                o4[s5 + f3 + 0] = l5 + d3, o4[s5 + f3 + 1] = d3 + (Math.abs(l5) + d3) * cC, l5 < t5[e7] && (t5[e7] = l5), p3 > t5[e7 + 3] && (t5[e7 + 3] = p3);
              }
            }
            return o4;
          }(e4, s3), l3 = e4.index.array, c3 = t4.maxDepth, u3 = t4.verbose, h2 = t4.maxLeafTris, p2 = t4.strategy, d2 = t4.onProgress, f2 = e4.index.count / 3;
          let m2 = false;
          const _2 = [], g2 = function(e5) {
            if (!e5.groups || !e5.groups.length)
              return [{ offset: 0, count: e5.index.count / 3 }];
            const t5 = [], r4 = /* @__PURE__ */ new Set();
            for (const t6 of e5.groups)
              r4.add(t6.start), r4.add(t6.start + t6.count);
            const n2 = Array.from(r4.values()).sort((e6, t6) => e6 - t6);
            for (let e6 = 0; e6 < n2.length - 1; e6++) {
              const r5 = n2[e6], i4 = n2[e6 + 1];
              t5.push({ offset: r5 / 3, count: (i4 - r5) / 3 });
            }
            return t5;
          }(e4);
          if (1 === g2.length) {
            const e5 = g2[0], t5 = new uC();
            t5.boundingData = s3, function(e6, t6, r4, n2) {
              let i4 = 1 / 0, s4 = 1 / 0, o4 = 1 / 0, a4 = -1 / 0, l4 = -1 / 0, c4 = -1 / 0;
              for (let n3 = 6 * t6, u4 = 6 * (t6 + r4); n3 < u4; n3 += 6) {
                const t7 = e6[n3 + 0];
                t7 < i4 && (i4 = t7), t7 > a4 && (a4 = t7);
                const r5 = e6[n3 + 2];
                r5 < s4 && (s4 = r5), r5 > l4 && (l4 = r5);
                const u5 = e6[n3 + 4];
                u5 < o4 && (o4 = u5), u5 > c4 && (c4 = u5);
              }
              n2[0] = i4, n2[1] = s4, n2[2] = o4, n2[3] = a4, n2[4] = l4, n2[5] = c4;
            }(a3, e5.offset, e5.count, o3), i3(t5, e5.offset, e5.count, o3), _2.push(t5);
          } else
            for (let e5 of g2) {
              const t5 = new uC();
              t5.boundingData = new Float32Array(6), gC(a3, e5.offset, e5.count, t5.boundingData, o3), i3(t5, e5.offset, e5.count, o3), _2.push(t5);
            }
          return _2;
        }(e3, t3);
        let i2, s2, o2;
        const a2 = [], l2 = t3.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
        for (let e4 = 0; e4 < r2.length; e4++) {
          const t4 = r2[e4], n2 = new l2(32 * c2(t4));
          i2 = new Float32Array(n2), s2 = new Uint32Array(n2), o2 = new Uint16Array(n2), u2(0, t4), a2.push(n2);
        }
        return a2;
        function c2(e4) {
          return e4.count ? 1 : 1 + c2(e4.left) + c2(e4.right);
        }
        function u2(e4, t4) {
          const r3 = e4 / 4, n2 = e4 / 2, a3 = !!t4.count, l3 = t4.boundingData;
          for (let e5 = 0; e5 < 6; e5++)
            i2[r3 + e5] = l3[e5];
          if (a3) {
            const i3 = t4.offset, a4 = t4.count;
            return s2[r3 + 6] = i3, o2[n2 + 14] = a4, o2[n2 + 15] = lC, e4 + 32;
          }
          {
            const n3 = t4.left, i3 = t4.right, o3 = t4.splitAxis;
            let a4;
            if (a4 = u2(e4 + 32, n3), a4 / 4 > Math.pow(2, 32))
              throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
            return s2[r3 + 6] = a4 / 4, a4 = u2(a4, i3), s2[r3 + 7] = o3, a4;
          }
        }
      }(e2, t2), !e2.boundingBox && t2.setBoundingBox && (e2.boundingBox = this.getBoundingBox(new n.ZzF()))), this.geometry = e2;
    }
    refit(e2 = null) {
      e2 && Array.isArray(e2) && (e2 = new Set(e2));
      const t2 = this.geometry, r2 = t2.index.array, n2 = t2.attributes.position, i2 = n2.array, s2 = n2.offset || 0;
      let o2, a2, l2, c2, u2 = 3;
      n2.isInterleavedBufferAttribute && (u2 = n2.data.stride);
      let h2 = 0;
      const p2 = this._roots;
      for (let e3 = 0, t3 = p2.length; e3 < t3; e3++)
        o2 = p2[e3], a2 = new Uint32Array(o2), l2 = new Uint16Array(o2), c2 = new Float32Array(o2), d2(0, h2), h2 += o2.byteLength;
      function d2(t3, n3, o3 = false) {
        const h3 = 2 * t3;
        if (l2[h3 + 15] === lC) {
          const e3 = a2[t3 + 6];
          let n4 = 1 / 0, o4 = 1 / 0, p3 = 1 / 0, d3 = -1 / 0, f2 = -1 / 0, m2 = -1 / 0;
          for (let t4 = 3 * e3, a3 = 3 * (e3 + l2[h3 + 14]); t4 < a3; t4++) {
            const e4 = r2[t4] * u2 + s2, a4 = i2[e4 + 0], l3 = i2[e4 + 1], c3 = i2[e4 + 2];
            a4 < n4 && (n4 = a4), a4 > d3 && (d3 = a4), l3 < o4 && (o4 = l3), l3 > f2 && (f2 = l3), c3 < p3 && (p3 = c3), c3 > m2 && (m2 = c3);
          }
          return (c2[t3 + 0] !== n4 || c2[t3 + 1] !== o4 || c2[t3 + 2] !== p3 || c2[t3 + 3] !== d3 || c2[t3 + 4] !== f2 || c2[t3 + 5] !== m2) && (c2[t3 + 0] = n4, c2[t3 + 1] = o4, c2[t3 + 2] = p3, c2[t3 + 3] = d3, c2[t3 + 4] = f2, c2[t3 + 5] = m2, true);
        }
        {
          const r3 = t3 + 8, i3 = a2[t3 + 6], s3 = r3 + n3, l3 = i3 + n3;
          let u3 = o3, h4 = false, p3 = false;
          e2 ? u3 || (h4 = e2.has(s3), p3 = e2.has(l3), u3 = !h4 && !p3) : (h4 = true, p3 = true);
          const f2 = u3 || p3;
          let m2 = false;
          (u3 || h4) && (m2 = d2(r3, n3, u3));
          let _2 = false;
          f2 && (_2 = d2(i3, n3, u3));
          const g2 = m2 || _2;
          if (g2)
            for (let e3 = 0; e3 < 3; e3++) {
              const n4 = r3 + e3, s4 = i3 + e3, o4 = c2[n4], a3 = c2[n4 + 3], l4 = c2[s4], u4 = c2[s4 + 3];
              c2[t3 + e3] = o4 < l4 ? o4 : l4, c2[t3 + e3 + 3] = a3 > u4 ? a3 : u4;
            }
          return g2;
        }
      }
    }
    traverse(e2, t2 = 0) {
      const r2 = this._roots[t2], n2 = new Uint32Array(r2), i2 = new Uint16Array(r2);
      !function t3(s2, o2 = 0) {
        const a2 = 2 * s2, l2 = i2[a2 + 15] === lC;
        if (l2) {
          const t4 = n2[s2 + 6], c2 = i2[a2 + 14];
          e2(o2, l2, new Float32Array(r2, 4 * s2, 6), t4, c2);
        } else {
          const i3 = s2 + 8, a3 = n2[s2 + 6], c2 = n2[s2 + 7];
          e2(o2, l2, new Float32Array(r2, 4 * s2, 6), c2) || (t3(i3, o2 + 1), t3(a3, o2 + 1));
        }
      }(0);
    }
    raycast(e2, t2 = n.Wl3) {
      const r2 = this._roots, i2 = this.geometry, s2 = [], o2 = t2.isMaterial, a2 = Array.isArray(t2), l2 = i2.groups, c2 = o2 ? t2.side : t2;
      for (let n2 = 0, o3 = r2.length; n2 < o3; n2++) {
        const o4 = a2 ? t2[l2[n2].materialIndex].side : c2, u2 = s2.length;
        if (ZC(r2[n2]), GC(0, i2, o4, e2, s2), $C(), a2) {
          const e3 = l2[n2].materialIndex;
          for (let t3 = u2, r3 = s2.length; t3 < r3; t3++)
            s2[t3].face.materialIndex = e3;
        }
      }
      return s2;
    }
    raycastFirst(e2, t2 = n.Wl3) {
      const r2 = this._roots, i2 = this.geometry, s2 = t2.isMaterial, o2 = Array.isArray(t2);
      let a2 = null;
      const l2 = i2.groups, c2 = s2 ? t2.side : t2;
      for (let n2 = 0, s3 = r2.length; n2 < s3; n2++) {
        const s4 = o2 ? t2[l2[n2].materialIndex].side : c2;
        ZC(r2[n2]);
        const u2 = VC(0, i2, s4, e2);
        $C(), null != u2 && (null == a2 || u2.distance < a2.distance) && (a2 = u2, o2 && (u2.face.materialIndex = l2[n2].materialIndex));
      }
      return a2;
    }
    intersectsGeometry(e2, t2) {
      const r2 = this.geometry;
      let n2 = false;
      for (const i2 of this._roots)
        if (ZC(i2), n2 = HC(0, r2, e2, t2), $C(), n2)
          break;
      return n2;
    }
    shapecast(e2, t2, r2) {
      const n2 = this.geometry;
      if (e2 instanceof Function) {
        if (t2) {
          const e3 = t2;
          t2 = (t3, r3, n3, i3) => {
            const s3 = 3 * r3;
            return e3(t3, s3, s3 + 1, s3 + 2, n3, i3);
          };
        }
        e2 = { boundsTraverseOrder: r2, intersectsBounds: e2, intersectsTriangle: t2, intersectsRange: null }, console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.");
      }
      const i2 = pM.getPrimitive();
      let { boundsTraverseOrder: s2, intersectsBounds: o2, intersectsRange: a2, intersectsTriangle: l2 } = e2;
      if (a2 && l2) {
        const e3 = a2;
        a2 = (t3, r3, s3, o3, a3) => !!e3(t3, r3, s3, o3, a3) || PC(t3, r3, n2, l2, s3, o3, i2);
      } else
        a2 || (a2 = l2 ? (e3, t3, r3, s3) => PC(e3, t3, n2, l2, r3, s3, i2) : (e3, t3, r3) => r3);
      let c2 = false, u2 = 0;
      for (const e3 of this._roots) {
        if (ZC(e3), c2 = QC(0, n2, o2, a2, s2, u2), $C(), c2)
          break;
        u2 += e3.byteLength;
      }
      return pM.releasePrimitive(i2), c2;
    }
    bvhcast(e2, t2, r2) {
      let { intersectsRanges: n2, intersectsTriangles: i2 } = r2;
      const s2 = this.geometry.index, o2 = this.geometry.attributes.position, a2 = e2.geometry.index, l2 = e2.geometry.attributes.position;
      nM.copy(t2).invert();
      const c2 = pM.getPrimitive(), u2 = pM.getPrimitive();
      if (i2) {
        let p2 = function(e3, r3, n3, h3, p3, d2, f2, m2) {
          for (let _2 = n3, g2 = n3 + h3; _2 < g2; _2++) {
            DC(u2, 3 * _2, a2, l2), u2.a.applyMatrix4(t2), u2.b.applyMatrix4(t2), u2.c.applyMatrix4(t2), u2.needsUpdate = true;
            for (let t3 = e3, n4 = e3 + r3; t3 < n4; t3++)
              if (DC(c2, 3 * t3, s2, o2), c2.needsUpdate = true, i2(c2, u2, t3, _2, p3, d2, f2, m2))
                return true;
          }
          return false;
        };
        if (n2) {
          const d2 = n2;
          n2 = function(e3, t3, r3, n3, i3, s3, o3, a3) {
            return !!d2(e3, t3, r3, n3, i3, s3, o3, a3) || p2(e3, t3, r3, n3, i3, s3, o3, a3);
          };
        } else
          n2 = p2;
      }
      e2.getBoundingBox(rM), rM.applyMatrix4(t2);
      const h2 = this.shapecast({ intersectsBounds: (e3) => rM.intersectsBox(e3), intersectsRange: (t3, r3, i3, s3, o3, a3) => (tM.copy(a3), tM.applyMatrix4(nM), e2.shapecast({ intersectsBounds: (e3) => tM.intersectsBox(e3), intersectsRange: (e3, i4, a4, l3, c3) => n2(t3, r3, e3, i4, s3, o3, l3, c3) })) });
      return pM.releasePrimitive(c2), pM.releasePrimitive(u2), h2;
    }
    intersectsBox(e2, t2) {
      return iM.set(e2.min, e2.max, t2), iM.needsUpdate = true, this.shapecast({ intersectsBounds: (e3) => iM.intersectsBox(e3), intersectsTriangle: (e3) => iM.intersectsTriangle(e3) });
    }
    intersectsSphere(e2) {
      return this.shapecast({ intersectsBounds: (t2) => e2.intersectsBox(t2), intersectsTriangle: (t2) => t2.intersectsSphere(e2) });
    }
    closestPointToGeometry(e2, t2, r2 = {}, n2 = {}, i2 = 0, s2 = 1 / 0) {
      e2.boundingBox || e2.computeBoundingBox(), iM.set(e2.boundingBox.min, e2.boundingBox.max, t2), iM.needsUpdate = true;
      const o2 = this.geometry, a2 = o2.attributes.position, l2 = o2.index, c2 = e2.attributes.position, u2 = e2.index, h2 = pM.getPrimitive(), p2 = pM.getPrimitive();
      let d2 = aM, f2 = lM, m2 = null, _2 = null;
      n2 && (m2 = cM, _2 = uM);
      let g2 = 1 / 0, v2 = null, A2 = null;
      return nM.copy(t2).invert(), sM.matrix.copy(nM), this.shapecast({ boundsTraverseOrder: (e3) => iM.distanceToBox(e3), intersectsBounds: (e3, t3, r3) => r3 < g2 && r3 < s2 && (t3 && (sM.min.copy(e3.min), sM.max.copy(e3.max), sM.needsUpdate = true), true), intersectsRange: (r3, n3) => {
        if (e2.boundsTree)
          return e2.boundsTree.shapecast({ boundsTraverseOrder: (e3) => sM.distanceToBox(e3), intersectsBounds: (e3, t3, r4) => r4 < g2 && r4 < s2, intersectsRange: (e3, s3) => {
            for (let o3 = 3 * e3, b2 = 3 * (e3 + s3); o3 < b2; o3 += 3) {
              DC(p2, o3, u2, c2), p2.a.applyMatrix4(t2), p2.b.applyMatrix4(t2), p2.c.applyMatrix4(t2), p2.needsUpdate = true;
              for (let e4 = 3 * r3, t3 = 3 * (r3 + n3); e4 < t3; e4 += 3) {
                DC(h2, e4, l2, a2), h2.needsUpdate = true;
                const t4 = h2.distanceToTriangle(p2, d2, m2);
                if (t4 < g2 && (f2.copy(d2), _2 && _2.copy(m2), g2 = t4, v2 = e4 / 3, A2 = o3 / 3), t4 < i2)
                  return true;
              }
            }
          } });
        for (let e3 = 0, s3 = u2 ? u2.count : c2.count; e3 < s3; e3 += 3) {
          DC(p2, e3, u2, c2), p2.a.applyMatrix4(t2), p2.b.applyMatrix4(t2), p2.c.applyMatrix4(t2), p2.needsUpdate = true;
          for (let t3 = 3 * r3, s4 = 3 * (r3 + n3); t3 < s4; t3 += 3) {
            DC(h2, t3, l2, a2), h2.needsUpdate = true;
            const r4 = h2.distanceToTriangle(p2, d2, m2);
            if (r4 < g2 && (f2.copy(d2), _2 && _2.copy(m2), g2 = r4, v2 = t3 / 3, A2 = e3 / 3), r4 < i2)
              return true;
          }
        }
      } }), pM.releasePrimitive(h2), pM.releasePrimitive(p2), g2 === 1 / 0 ? null : (r2.point ? r2.point.copy(f2) : r2.point = f2.clone(), r2.distance = g2, r2.faceIndex = v2, n2 && (n2.point ? n2.point.copy(_2) : n2.point = _2.clone(), n2.point.applyMatrix4(nM), f2.applyMatrix4(nM), n2.distance = f2.sub(n2.point).length(), n2.faceIndex = A2), r2);
    }
    closestPointToPoint(e2, t2 = {}, r2 = 0, n2 = 1 / 0) {
      const i2 = r2 * r2, s2 = n2 * n2;
      let o2 = 1 / 0, a2 = null;
      if (this.shapecast({ boundsTraverseOrder: (t3) => (oM.copy(e2).clamp(t3.min, t3.max), oM.distanceToSquared(e2)), intersectsBounds: (e3, t3, r3) => r3 < o2 && r3 < s2, intersectsTriangle: (t3, r3) => {
        t3.closestPointToPoint(e2, oM);
        const n3 = e2.distanceToSquared(oM);
        return n3 < o2 && (aM.copy(oM), o2 = n3, a2 = r3), n3 < i2;
      } }), o2 === 1 / 0)
        return null;
      const l2 = Math.sqrt(o2);
      return t2.point ? t2.point.copy(aM) : t2.point = aM.clone(), t2.distance = l2, t2.faceIndex = a2, t2;
    }
    getBoundingBox(e2) {
      return e2.makeEmpty(), this._roots.forEach((t2) => {
        hC(0, new Float32Array(t2), hM), e2.union(hM);
      }), e2;
    }
  }
  const fM = dM.prototype.raycast;
  dM.prototype.raycast = function(...e2) {
    if (e2[0].isMesh) {
      console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');
      const [t2, r2, n2, i2] = e2;
      return fM.call(this, n2, t2.material).forEach((e3) => {
        (e3 = kC(e3, t2, r2)) && i2.push(e3);
      }), i2;
    }
    return fM.apply(this, e2);
  };
  const mM = dM.prototype.raycastFirst;
  dM.prototype.raycastFirst = function(...e2) {
    if (e2[0].isMesh) {
      console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');
      const [t2, r2, n2] = e2;
      return kC(mM.call(this, n2, t2.material), t2, r2);
    }
    return mM.apply(this, e2);
  };
  const _M = dM.prototype.closestPointToPoint;
  dM.prototype.closestPointToPoint = function(...e2) {
    if (e2[0].isMesh) {
      console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'), e2.unshift();
      const t2 = e2[1], r2 = {};
      return e2[1] = r2, _M.apply(this, e2), t2 && t2.copy(r2.point), r2.distance;
    }
    return _M.apply(this, e2);
  };
  const gM = dM.prototype.closestPointToGeometry;
  dM.prototype.closestPointToGeometry = function(...e2) {
    const t2 = e2[2], r2 = e2[3];
    if (t2 && t2.isVector3 || r2 && r2.isVector3) {
      console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');
      const n2 = {}, i2 = {}, s2 = e2[1];
      return e2[2] = n2, e2[3] = i2, gM.apply(this, e2), t2 && t2.copy(n2.point), r2 && r2.copy(i2.point).applyMatrix4(s2), n2.distance;
    }
    return gM.apply(this, e2);
  };
  const vM = dM.prototype.refit;
  dM.prototype.refit = function(...e2) {
    const t2 = e2[0], r2 = e2[1];
    if (r2 && (r2 instanceof Set || Array.isArray(r2))) {
      console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');
      const e3 = /* @__PURE__ */ new Set();
      r2.forEach((t3) => e3.add(t3)), t2 && t2.forEach((t3) => e3.add(t3)), vM.call(this, e3);
    } else
      vM.apply(this, e2);
  }, ["intersectsGeometry", "shapecast", "intersectsBox", "intersectsSphere"].forEach((e2) => {
    const t2 = dM.prototype[e2];
    dM.prototype[e2] = function(...r2) {
      return (null === r2[0] || r2[0].isMesh) && (r2.shift(), console.warn(`MeshBVH: The function signature for "${e2}" has changed and no longer takes Mesh. See docs for new signature.`)), t2.apply(this, r2);
    };
  });
  const AM = [new n.Pa4(), new n.Pa4(), new n.Pa4()];
  function bM(e2) {
    return ~~(1e4 * e2);
  }
  function yM(e2) {
    return `${bM(e2.x)},${bM(e2.y)},${bM(e2.z)}`;
  }
  class xM {
    constructor(e2 = null) {
      this.data = null, this.unmatchedEdges = null, this.matchedEdges = null, this.useDrawRange = true, e2 && this.updateFrom(e2);
    }
    getSiblingTriangleIndex(e2, t2) {
      const r2 = this.data[3 * e2 + t2];
      return -1 === r2 ? -1 : ~~(r2 / 3);
    }
    getSiblingEdgeIndex(e2, t2) {
      const r2 = this.data[3 * e2 + t2];
      return -1 === r2 ? -1 : r2 % 3;
    }
    updateFrom(e2) {
      const t2 = /* @__PURE__ */ new Map(), { attributes: r2 } = e2, n2 = e2.index, i2 = r2.position;
      let s2 = n2 ? n2.count / 3 : i2.count / 3;
      const o2 = s2;
      let a2 = 0;
      this.useDrawRange && (a2 = e2.drawRange.start, e2.drawRange.count !== 1 / 0 && (s2 = ~~(e2.drawRange.count / 3)));
      let l2 = this.data;
      (!l2 || l2.length < 3 * o2) && (l2 = new Int32Array(3 * o2)), l2.fill(-1);
      let c2 = 0, u2 = 0;
      for (let e3 = 0; e3 < s2; e3++) {
        const r3 = 3 * e3 + a2;
        for (let e4 = 0; e4 < 3; e4++) {
          let t3 = r3 + e4;
          n2 && (t3 = n2.getX(t3)), AM[e4].fromBufferAttribute(i2, t3);
        }
        for (let e4 = 0; e4 < 3; e4++) {
          const n3 = (e4 + 1) % 3, i3 = AM[e4], s3 = AM[n3], o3 = yM(i3), a3 = yM(s3), h2 = `${a3}_${o3}`;
          if (t2.has(h2)) {
            const n4 = t2.get(h2);
            l2[r3 + e4] = n4, l2[n4] = r3 + e4, t2.delete(h2), c2--, u2++;
          } else {
            const n4 = `${o3}_${a3}`;
            t2.set(n4, r3 + e4), c2++;
          }
        }
      }
      this.matchedEdges = u2, this.unmatchedEdges = c2, this.data = l2;
    }
  }
  class wM extends n.Kj0 {
    constructor(...e2) {
      super(...e2), this.isBrush = true, this._previousMatrix = new n.yGw(), this._previousMatrix.elements.fill(0);
    }
    markUpdated() {
      this._previousMatrix.copy(this.matrix);
    }
    isDirty() {
      const { matrix: e2, _previousMatrix: t2 } = this, r2 = e2.elements, n2 = t2.elements;
      for (let e3 = 0; e3 < 16; e3++)
        if (r2[e3] !== n2[e3])
          return true;
      return false;
    }
    prepareGeometry() {
      const e2 = this.geometry, t2 = e2.attributes;
      if (HS())
        for (const e3 in t2) {
          const r2 = t2[e3];
          if (r2.isInterleavedBufferAttribute)
            throw new Error("Brush: InterleavedBufferAttributes are not supported.");
          r2.array = WS(r2.array);
        }
      if (e2.boundsTree || (e2.boundsTree = new dM(e2, { maxLeafTris: 3 }), e2.halfEdges && e2.halfEdges.updateFrom(e2)), e2.halfEdges || (e2.halfEdges = new xM(e2)), !e2.groupIndices) {
        const t3 = e2.index.count / 3, r2 = new Uint16Array(t3), n2 = e2.groups;
        for (let e3 = 0, t4 = n2.length; e3 < t4; e3++) {
          const { start: t5, count: i2 } = n2[e3];
          for (let n3 = t5 / 3, s2 = (t5 + i2) / 3; n3 < s2; n3++)
            r2[n3] = e3;
        }
        e2.groupIndices = r2;
      }
    }
    disposeCacheData() {
      const { geometry: e2 } = this;
      e2.halfEdges = null, e2.boundsTree = null, e2.groupIndices = null;
    }
  }
  function EM(e2, t2) {
    let r2 = t2;
    return Array.isArray(t2) || (r2 = [], e2.forEach((e3) => {
      r2[e3.materialIndex] = t2;
    })), r2;
  }
  class SM {
    constructor() {
      this.triangleSplitter = new QS(), this.attributeData = new XS(), this.attributes = ["position", "uv", "normal"], this.useGroups = true, this.debug = new JS();
    }
    evaluate(e2, t2, r2, i2 = new wM()) {
      e2.prepareGeometry(), t2.prepareGeometry();
      const { triangleSplitter: s2, attributeData: o2, attributes: a2, useGroups: l2, debug: c2 } = this, u2 = i2.geometry, h2 = e2.geometry.attributes;
      for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) {
        const t4 = a2[e3], r3 = h2[t4];
        o2.initializeArray(t4, r3.array.constructor);
      }
      for (const e3 in o2.attributes)
        a2.includes(e3) || o2.delete(e3);
      for (const e3 in u2.attributes)
        a2.includes(e3) || (u2.deleteAttribute(e3), u2.dispose());
      o2.clear(), c2.enabled && (c2.reset(), CS(c2)), function(e3, t3, r3, n2, i3, s3) {
        const { useGroups: o3 = true } = s3, { aIntersections: a3, bIntersections: l3 } = function(e4, t4) {
          const r4 = new pS(), n3 = new pS();
          return fS.copy(e4.matrixWorld).invert().multiply(t4.matrixWorld), e4.geometry.boundsTree.bvhcast(t4.geometry.boundsTree, fS, { intersectsTriangles: (e5, t5, i4, s4) => (e5.intersectsTriangle(t5, wS) && wS.distance() > 1e-5 && (r4.add(i4, s4), n3.add(s4, i4), SS && (SS.addEdge(wS), SS.addIntersectingTriangles(i4, e5, s4, t5))), false) }), { aIntersections: r4, bIntersections: n3 };
        }(e3, t3);
        let c3;
        c3 = o3 ? 0 : -1, oC(e3, t3, a3, r3, false, i3, c3), sC(e3, t3, a3, r3, false, n2, i3, c3), c3 = o3 ? e3.geometry.groups.length || 1 : -1, oC(t3, e3, l3, r3, true, i3, c3), sC(t3, e3, l3, r3, true, n2, i3, c3);
      }(e2, t2, r2, s2, o2, { useGroups: l2 }), c2.enabled && CS(null);
      const p2 = l2 && 0 !== e2.geometry.groups.length ? e2.geometry.groups.map((e3) => ({ ...e3 })) : [{ start: 0, count: 1 / 0, materialIndex: 0 }], d2 = l2 && 0 !== t2.geometry.groups.length ? t2.geometry.groups.map((e3) => ({ ...e3 })) : [{ start: 0, count: 1 / 0, materialIndex: 0 }], f2 = EM(p2, e2.material), m2 = EM(d2, t2.material);
      d2.forEach((e3) => {
        e3.materialIndex += f2.length;
      }), function(e3, t3, r3, i3) {
        let s3 = false, o3 = -1;
        const a3 = i3.groupCount, l3 = e3.attributes, c3 = i3.groupAttributes[0];
        for (const r4 in c3) {
          const u4 = i3.getTotalLength(r4, a3), h3 = c3[r4].type;
          let p3 = l3[r4];
          if (!p3 || p3.array.length < u4) {
            const i4 = t3.attributes[r4];
            p3 = new n.TlE(new h3(u4), i4.itemSize, i4.normalized), e3.setAttribute(r4, p3), s3 = true;
          }
          let d3 = 0;
          for (let e4 = 0; e4 < a3; e4++) {
            const { array: t4, type: n2, length: s4 } = i3.groupAttributes[e4][r4], o4 = new n2(t4.buffer, 0, s4);
            p3.array.set(o4, d3), d3 += o4.length;
          }
          p3.needsUpdate = true, o3 = u4 / p3.itemSize;
        }
        e3.setDrawRange(0, o3), e3.clearGroups();
        let u3 = 0;
        for (let t4 = 0; t4 < a3; t4++) {
          const n2 = i3.getGroupArray("position", t4).length / 3;
          if (0 !== n2) {
            const i4 = r3[t4];
            e3.addGroup(u3, n2, i4.materialIndex), u3 += n2;
          }
        }
        if (e3.index) {
          const t4 = e3.index.array;
          if (t4.length < o3)
            e3.index = null, s3 = true;
          else
            for (let e4 = 0, r4 = t4.length; e4 < r4; e4++)
              t4[e4] = e4;
        }
        e3.boundsTree = null, s3 && e3.dispose();
      }(u2, e2.geometry, [...p2, ...d2], o2);
      const _2 = u2.groups;
      if (l2) {
        const e3 = /* @__PURE__ */ new Map(), t3 = [...f2, ...m2];
        let r3 = 0;
        for (let n2 = 0, i3 = t3.length; n2 < i3; n2++)
          Boolean(_2.find((e4) => e4.materialIndex === n2)) ? (e3.set(n2, r3), r3++) : t3[n2] = null;
        for (let t4 = 0, r4 = _2.length; t4 < r4; t4++) {
          const r5 = _2[t4];
          r5.materialIndex = e3.get(r5.materialIndex);
        }
        i2.material = t3.filter((e4) => e4);
      }
      return i2;
    }
    evaluateHierarchy(e2, t2 = new wM()) {
      e2.updateMatrixWorld(true);
      const r2 = (e3, t3) => {
        const n3 = e3.children;
        for (let e4 = 0, i2 = n3.length; e4 < i2; e4++) {
          const i3 = n3[e4];
          i3.isOperationGroup ? r2(i3, t3) : t3(i3);
        }
      }, n2 = (e3) => {
        const t3 = e3.children;
        let i2 = false;
        for (let e4 = 0, r3 = t3.length; e4 < r3; e4++) {
          const r4 = t3[e4];
          i2 = n2(r4) || i2;
        }
        const s2 = e3.isDirty();
        if (s2 && e3.markUpdated(), i2 && !e3.isOperationGroup) {
          let t4;
          return r2(e3, (r3) => {
            t4 = t4 ? this.evaluate(t4, r3, r3.operation) : this.evaluate(e3, r3, r3.operation);
          }), e3._cachedGeometry = t4.geometry, e3._cachedMaterials = t4.material, true;
        }
        return i2 || s2;
      };
      return n2(e2), t2.geometry = e2._cachedGeometry, t2.material = e2._cachedMaterials, t2;
    }
    reset() {
      this.triangleSplitter.reset();
    }
  }
  const CM = { union: 0, subtract: 1, intersect: 4, difference: 3 };
  function MM(e2, t2) {
    const r2 = new SM();
    r2.useGroups = true, r2.attributes = ["position", "normal", "uv"], e2.forEach((e3) => {
      for (const t3 of [...r2.attributes])
        e3[0].geometry.getAttribute(t3) || r2.attributes.splice(r2.attributes.indexOf(t3), 1);
    });
    let i2 = new wM(new n._12(0.01, 0.01, 2, 2));
    e2.forEach(([e3, t3]) => {
      if (!Object.keys(CM).includes(t3))
        return void console.error(`Unknown operation ${t3}`);
      e3.updateMatrix(), e3.updateMatrixWorld();
      const n2 = new wM();
      n2.geometry = e3.geometry, n2.material = e3.material, e3.matrixWorld.decompose(n2.position, n2.quaternion, n2.scale), n2.updateMatrix(), n2.updateMatrixWorld(), i2 = r2.evaluate(i2, n2, CM[t3]);
    });
    const s2 = i2;
    return s2.userData._isCSGMesh = true, s2;
  }
  let TM = class extends nS {
    _buildCSGMesh(e2) {
      return MM(e2);
    }
  };
  TM.PluginType = "CSGPluginBVH", TM = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  }([lt("CSG Plugin (BVH)")], TM);
  var IM = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  const kM = new n.Pa4(0, 0, 1), DM = new n.USm(), PM = new n._fP(), BM = new n._fP(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)), RM = new n._fP(), LM = { type: "change" };
  let OM = class extends r {
    constructor(e2) {
      super(), this.enabled = false, this.lastOrder = "XYZ", this.dampingFactor = 0.05, this.lastQuaternion = new n._fP(), this.onDeviceOrientationChangeEvent = (e3) => {
        this.deviceOrientation = e3;
      }, this.onScreenOrientationChangeEvent = () => {
        this.screenOrientation = screen.orientation;
      }, this._initQuaternion = new n._fP(), this._initQuaternionInvert = new n._fP(), this._initQuaternionDest = new n._fP(), this._lastTime = -1, false === window.isSecureContext && console.error("DeviceOrientationControls2: DeviceOrientationEvent is only available in secure contexts (https)"), this.object = e2, this.lastOrder = this.object.rotation.order, this.object.rotation.reorder("YXZ"), this.connect();
    }
    connect() {
      this.onScreenOrientationChangeEvent(), void 0 !== window.DeviceOrientationEvent && "function" == typeof window.DeviceOrientationEvent.requestPermission ? window.DeviceOrientationEvent.requestPermission().then((e2) => {
        "granted" == e2 && (window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent));
      }).catch((e2) => {
        console.error("DeviceOrientationControls2: Unable to use DeviceOrientation API:", e2);
      }) : (window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent)), this.enabled = true, this._initQuaternion.copy(this.object.quaternion), this._initQuaternionInvert.copy(this.object.quaternion).invert();
    }
    disconnect() {
      window.removeEventListener("orientationchange", this.onScreenOrientationChangeEvent), window.removeEventListener("deviceorientation", this.onDeviceOrientationChangeEvent), this._initQuaternion.identity(), this._initQuaternionInvert.identity(), this._initQuaternionDest = new n._fP(), this.object.rotation.reorder(this.lastOrder), this.lastOrder = "XYZ", this.enabled = false;
    }
    update() {
      if (!this.enabled)
        return;
      const e2 = this.deviceOrientation;
      if (e2) {
        const t2 = null !== e2.alpha ? n.M8C.degToRad(e2.alpha) : 0, r2 = null !== e2.beta ? n.M8C.degToRad(e2.beta) : 0, i2 = null !== e2.gamma ? n.M8C.degToRad(e2.gamma) : 0, s2 = this.screenOrientation ? n.M8C.degToRad(this.screenOrientation.angle) : 0;
        this.setObjectQuaternion(t2, r2, i2, s2), 8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > 1e-6 && (this.lastQuaternion.copy(this.object.quaternion), this.dispatchEvent(LM));
      }
    }
    dispose() {
      this.disconnect();
    }
    setObjectQuaternion(e2, t2, r2, n2) {
      const i2 = Dt() / 1e3;
      DM.set(t2, e2, -r2, "YXZ"), RM.setFromEuler(DM), RM.multiply(BM), RM.multiply(PM.setFromAxisAngle(kM, -n2)), this._initQuaternionDest.__init || (this._initQuaternionDest.copy(RM).invert(), this._initQuaternionDest.__init = true), RM.premultiply(this._initQuaternionDest), this.object.quaternion.slerp(RM, this.dampingFactor / (Math.min(1, i2 - this._lastTime) / (1 / 60))), this._lastTime = i2;
    }
  };
  IM([Ce(), $e("Damping", [0, 1], 0.01)], OM.prototype, "dampingFactor", void 0), OM = IM([lt("Device Orientation Controls")], OM);
  class FM extends ro {
    constructor() {
      super(...arguments), this.enabled = true, this.toJSON = void 0, this._cameraChanged = (e2) => {
        var t2, r2, n2, i2;
        null === (r2 = null === (t2 = e2.lastCamera) || void 0 === t2 ? void 0 : t2.removeControlsCtor) || void 0 === r2 || r2.call(t2, this.controlsKey), null === (i2 = null === (n2 = e2.camera) || void 0 === n2 ? void 0 : n2.setControlsCtor) || void 0 === i2 || i2.call(n2, this.controlsKey, this._controlsCtor);
      };
    }
    async onAdded(e2) {
      await super.onAdded(e2), this._cameraChanged({ camera: e2.scene.activeCamera }), e2.scene.addEventListener("activeCameraChange", this._cameraChanged);
    }
    async onRemove(e2) {
      return this._cameraChanged({ lastCamera: e2.scene.activeCamera }), e2.scene.removeEventListener("activeCameraChange", this._cameraChanged), super.onRemove(e2);
    }
  }
  class UM extends FM {
    constructor() {
      super(...arguments), this.controlsKey = "deviceOrientation", this._controlsCtor = (e2, t2) => new OM(e2);
    }
  }
  UM.PluginType = "DeviceOrientationControlsPlugin";
  var NM = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  const jM = new n.Pa4(), zM = new n.$V(), GM = new n.Pa4(), VM = { type: "change" };
  let QM = class extends r {
    constructor(e2, t2) {
      super(), this.enabled = true, this.enableKeys = true, this.movementSpeed = 1, this.lookSpeed = 5e-3, this.lookVertical = true, this.autoForward = false, this.activeLook = true, this.heightSpeed = false, this.heightCoef = 1, this.heightMin = 0, this.heightMax = 1, this.constrainVertical = false, this.verticalMin = 0, this.verticalMax = Math.PI, this.mouseDragOn = false, this.autoSpeedFactor = 0, this.mouseX = 0, this.mouseY = 0, this.moveForward = false, this.moveBackward = false, this.moveLeft = false, this.moveRight = false, this.moveUp = false, this.moveDown = false, this.viewHalfX = 0, this.viewHalfY = 0, this.lat = 0, this.lon = 0, this.targetPosition = new n.Pa4(), this._lastTime = -1, this.object = e2, this.domElement = t2, this.onMouseMove = this.onMouseMove.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onMouseUp = this.onMouseUp.bind(this), this.onKeyDown = this.onKeyDown.bind(this), this.onKeyUp = this.onKeyUp.bind(this), this.onContextMenu = this.onContextMenu.bind(this), this.domElement.addEventListener("contextmenu", this.onContextMenu), this.domElement.addEventListener("mousemove", this.onMouseMove), this.domElement.addEventListener("mousedown", this.onMouseDown), this.domElement.addEventListener("mouseup", this.onMouseUp), window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp), this.handleResize(), this.setOrientation();
    }
    setOrientation() {
      const e2 = this.object.quaternion;
      jM.set(0, 0, -1).applyQuaternion(e2), zM.setFromVector3(jM), this.lat = 90 - n.M8C.radToDeg(zM.phi), this.lon = n.M8C.radToDeg(zM.theta);
    }
    handleResize() {
      this.domElement === document ? (this.viewHalfX = window.innerWidth / 2, this.viewHalfY = window.innerHeight / 2) : (this.viewHalfX = this.domElement.offsetWidth / 2, this.viewHalfY = this.domElement.offsetHeight / 2);
    }
    onMouseDown(e2) {
      if (this.domElement !== document && this.domElement.focus(), this.activeLook)
        switch (e2.button) {
          case 0:
            this.moveForward = true;
            break;
          case 2:
            this.moveBackward = true;
        }
      this.mouseDragOn = true;
    }
    onMouseUp(e2) {
      if (this.activeLook)
        switch (e2.button) {
          case 0:
            this.moveForward = false;
            break;
          case 2:
            this.moveBackward = false;
        }
      this.mouseDragOn = false;
    }
    onMouseMove(e2) {
      this.domElement === document ? (this.mouseX = e2.pageX - this.viewHalfX, this.mouseY = e2.pageY - this.viewHalfY) : (this.mouseX = e2.pageX - this.domElement.offsetLeft - this.viewHalfX, this.mouseY = e2.pageY - this.domElement.offsetTop - this.viewHalfY);
    }
    onKeyDown(e2) {
      if (this.enableKeys)
        switch (e2.code) {
          case "ArrowUp":
          case "KeyW":
            this.moveForward = true;
            break;
          case "ArrowLeft":
          case "KeyA":
            this.moveLeft = true;
            break;
          case "ArrowDown":
          case "KeyS":
            this.moveBackward = true;
            break;
          case "ArrowRight":
          case "KeyD":
            this.moveRight = true;
            break;
          case "KeyR":
            this.moveUp = true;
            break;
          case "KeyF":
            this.moveDown = true;
        }
    }
    onKeyUp(e2) {
      if (this.enableKeys)
        switch (e2.code) {
          case "ArrowUp":
          case "KeyW":
            this.moveForward = false;
            break;
          case "ArrowLeft":
          case "KeyA":
            this.moveLeft = false;
            break;
          case "ArrowDown":
          case "KeyS":
            this.moveBackward = false;
            break;
          case "ArrowRight":
          case "KeyD":
            this.moveRight = false;
            break;
          case "KeyR":
            this.moveUp = false;
            break;
          case "KeyF":
            this.moveDown = false;
        }
    }
    lookAt(e2, t2, r2) {
      return e2.isVector3 ? GM.copy(e2) : void 0 === t2 || void 0 === r2 ? console.error("FirstPersonControls2.lookAt: y and z parameters are required") : GM.set(e2, t2, r2), this.object.lookAt(GM), this.setOrientation(), this;
    }
    update() {
      const e2 = Dt(), t2 = (this._lastTime < 0 ? 16 : Math.min(e2 - this._lastTime, 1e3)) / 1e3;
      if (this._lastTime = e2, !this.enabled)
        return;
      if (this.heightSpeed) {
        const e3 = n.M8C.clamp(this.object.position.y, this.heightMin, this.heightMax) - this.heightMin;
        this.autoSpeedFactor = t2 * (e3 * this.heightCoef);
      } else
        this.autoSpeedFactor = 0;
      const r2 = t2 * this.movementSpeed;
      (this.moveForward || this.autoForward && !this.moveBackward) && this.object.translateZ(-(r2 + this.autoSpeedFactor)), this.moveBackward && this.object.translateZ(r2), this.moveLeft && this.object.translateX(-r2), this.moveRight && this.object.translateX(r2), this.moveUp && this.object.translateY(r2), this.moveDown && this.object.translateY(-r2);
      let i2 = t2 * this.lookSpeed;
      this.activeLook || (i2 = 0);
      let s2 = 1;
      this.constrainVertical && (s2 = Math.PI / (this.verticalMax - this.verticalMin)), this.lon -= this.mouseX * i2, this.lookVertical && (this.lat -= this.mouseY * i2 * s2), this.lat = Math.max(-85, Math.min(85, this.lat));
      let o2 = n.M8C.degToRad(90 - this.lat);
      const a2 = n.M8C.degToRad(this.lon);
      this.constrainVertical && (o2 = n.M8C.mapLinear(o2, 0, Math.PI, this.verticalMin, this.verticalMax));
      const l2 = this.object.position;
      this.targetPosition.setFromSphericalCoords(1, o2, a2).add(l2), this.object.lookAt(this.targetPosition), this.dispatchEvent(VM);
    }
    dispose() {
      this.domElement.removeEventListener("contextmenu", this.onContextMenu), this.domElement.removeEventListener("mousedown", this.onMouseDown), this.domElement.removeEventListener("mousemove", this.onMouseMove), this.domElement.removeEventListener("mouseup", this.onMouseUp), window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp);
    }
    onContextMenu(e2) {
      this.enableKeys && e2.preventDefault();
    }
  };
  NM([Ce(), Je()], QM.prototype, "enabled", void 0), NM([Ce(), Je()], QM.prototype, "enableKeys", void 0), NM([Ce(), nt()], QM.prototype, "movementSpeed", void 0), NM([Ce(), nt()], QM.prototype, "lookSpeed", void 0), NM([Ce(), Je()], QM.prototype, "lookVertical", void 0), NM([Ce(), Je()], QM.prototype, "autoForward", void 0), NM([Ce(), Je()], QM.prototype, "activeLook", void 0), NM([Ce(), Je()], QM.prototype, "heightSpeed", void 0), NM([Ce(), nt()], QM.prototype, "heightCoef", void 0), NM([Ce(), nt()], QM.prototype, "heightMin", void 0), NM([Ce(), nt()], QM.prototype, "heightMax", void 0), NM([Ce(), Je()], QM.prototype, "constrainVertical", void 0), NM([Ce(), nt()], QM.prototype, "verticalMin", void 0), NM([Ce(), nt()], QM.prototype, "verticalMax", void 0), NM([Ce(), Je()], QM.prototype, "mouseDragOn", void 0), QM = NM([lt("First Person Controls")], QM);
  class HM extends FM {
    constructor() {
      super(...arguments), this.controlsKey = "firstPerson", this._controlsCtor = (e2, t2) => new QM(e2, t2);
    }
  }
  HM.PluginType = "FirstPersonControlsPlugin";
  var WM = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  const qM = new n.USm(0, 0, 0, "YXZ"), XM = new n.Pa4(), YM = { type: "change" }, KM = { type: "lock" }, JM = { type: "unlock" }, ZM = Math.PI / 2;
  let $M = class extends r {
    constructor(e2, t2) {
      super(), this.isLocked = false, this.enabled = true, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.pointerSpeed = 1, this.autoLockOnClick = true, this._movementX = 0, this._movementY = 0, this._forwardDirection = new n.Pa4(0, 0, -1), this.domElement = t2, this.object = e2, this.onElementClick = this.onElementClick.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.onPointerlockChange = this.onPointerlockChange.bind(this), this.onPointerlockError = this.onPointerlockError.bind(this), this.connect();
    }
    onElementClick(e2) {
      this.isLocked || this.autoLockOnClick && (e2.preventDefault(), this.lock());
    }
    onMouseMove(e2) {
      this.isLocked && (this._movementX += e2.movementX || e2.mozMovementX || e2.webkitMovementX || 0, this._movementY += e2.movementY || e2.mozMovementY || e2.webkitMovementY || 0);
    }
    onPointerlockChange() {
      this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(KM), this.isLocked = true) : (this.dispatchEvent(JM), this.isLocked = false);
    }
    onPointerlockError() {
      console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
    }
    connect() {
      this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError), this.domElement.addEventListener("click", this.onElementClick);
    }
    disconnect() {
      this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError), this.domElement.removeEventListener("click", this.onElementClick);
    }
    dispose() {
      this.disconnect();
    }
    getDirection(e2) {
      return e2.copy(this._forwardDirection).applyQuaternion(this.object.quaternion);
    }
    moveForward(e2) {
      XM.setFromMatrixColumn(this.object.matrix, 0), XM.crossVectors(this.object.up, XM), this.object.position.addScaledVector(XM, e2);
    }
    moveRight(e2) {
      XM.setFromMatrixColumn(this.object.matrix, 0), this.object.position.addScaledVector(XM, e2);
    }
    lock() {
      this.domElement.requestPointerLock();
    }
    unlock() {
      this.domElement.ownerDocument.exitPointerLock();
    }
    update() {
      qM.setFromQuaternion(this.object.quaternion), qM.y -= 2e-3 * this._movementX * this.pointerSpeed, qM.x -= 2e-3 * this._movementY * this.pointerSpeed, this._movementX = 0, this._movementY = 0, qM.x = Math.max(ZM - this.maxPolarAngle, Math.min(ZM - this.minPolarAngle, qM.x)), this.object.quaternion.setFromEuler(qM), this.dispatchEvent(YM);
    }
  };
  WM([Je(), Ce()], $M.prototype, "enabled", void 0), WM([nt(), Ce()], $M.prototype, "minPolarAngle", void 0), WM([nt(), Ce()], $M.prototype, "maxPolarAngle", void 0), WM([nt(), Ce()], $M.prototype, "pointerSpeed", void 0), WM([Je(), Ce()], $M.prototype, "autoLockOnClick", void 0), $M = WM([lt("Pointer Lock Controls")], $M);
  class eT extends FM {
    constructor() {
      super(...arguments), this.controlsKey = "pointerLock", this._controlsCtor = (e2, t2) => new $M(e2, t2.ownerDocument ? t2 : t2.documentElement);
    }
  }
  eT.PluginType = "PointerLockControlsPlugin";
  var tT = __webpackgi_require__2(819);
  class rT {
    static _initialize() {
      this._inited = true, Mt(E`
          #customContextMenu {
            background: #2c2c2e99;
            backdrop-filter: blur(8px);
            border: 0.5px solid rgba(20, 20, 20, 0.3);
            width: auto;
            height: auto;
            position: absolute;
            display: flex;
            flex-direction: column;
            z-index: 9999;
            padding: 0.35rem 0.20rem;
            border-radius: 0.375rem;
            min-width: 6rem;
            pointer-events: auto;
            box-shadow: 0px 2px 10px rgba(12, 12, 12, 0.2);
          }

          .customContextMenuItems {
            color: white;
            font-size: 0.65rem;
            font-family: "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
            background-color: transparent;
            cursor: pointer;
            padding: 0.12rem 0.35rem;
            border-radius: 0.25rem;
            line-height: 1rem;
            font-weight: 500;
          }

          .customContextMenuItems:hover {
            color: white;
            background-color: #017AFF;
          }
        `), document.addEventListener("mouseup", (e2) => {
        this.Element && !this.Element.contains(e2.target) && this.Remove();
      });
    }
    static Create(e2, t2, r2) {
      this._inited || this._initialize(), this.Element && this.Remove();
      const n2 = St({ id: "customContextMenu", addToBody: false });
      n2.style.top = r2 + "px", n2.style.left = t2 + "px";
      for (const [t3, r3] of Object.entries(e2)) {
        const e3 = St({ classList: ["customContextMenuItems"], addToBody: false, innerHTML: t3 });
        n2.appendChild(e3), e3.onclick = r3;
      }
      return this.Element = n2, n2;
    }
    static Remove() {
      var e2;
      null === (e2 = this.Element) || void 0 === e2 || e2.remove(), this.Element = void 0;
    }
  }
  rT.Element = void 0, rT._inited = false;
  var nT = __webpackgi_require__2(665);
  const iT = (e2, t2, r2) => {
    var n2, i2, s2;
    const o2 = e2.controller_, a2 = null === (i2 = null === (n2 = o2.parent) || void 0 === n2 ? void 0 : n2.children) || void 0 === i2 ? void 0 : i2.indexOf(o2), l2 = ((e3, t3) => t3.controller_.rackController.rack === e3.controller_.parent)(e2, t2);
    return !(l2 && a2 === r2 || (void 0 !== a2 && a2 >= 0 && (null === (s2 = o2.parent) || void 0 === s2 || s2.remove(e2)), t2.add(e2, r2), 0));
  }, sT = (e2, t2, r2, n2) => {
    var i2, s2, o2, a2, l2;
    let c2 = t2.uiRef;
    const u2 = null == c2 ? void 0 : c2.expanded;
    if (c2 || (c2 = e2.addFolder({ title: "" }), c2.on("fold", (e3) => {
      var r3, n3, i3;
      let s3 = c2.expanded;
      _(t2, "expanded", s3, true), s3 = null !== (r3 = A(t2.expanded)) && void 0 !== r3 ? r3 : s3, s3 !== c2.expanded && (c2.expanded = s3), null === (n3 = t2.uiRefresh) || void 0 === n3 || n3.call(t2, "postFrame", true), s3 && (null === (i3 = t2.onExpand) || void 0 === i3 || i3.call(t2, t2));
    })), !c2)
      return c2;
    c2.expanded = null !== (s2 = null !== (i2 = A(t2.expanded)) && void 0 !== i2 ? i2 : u2) && void 0 !== s2 && s2;
    const h2 = (null !== (o2 = t2.children) && void 0 !== o2 ? o2 : []).map((e3) => e3 && A(e3)).flat(2).filter((e3) => e3);
    let p2 = 0;
    for (const e3 of h2) {
      let t3 = e3.uiRef;
      t3 && t3.controller_.viewProps.get("disposed") && (e3.uiRef = void 0), t3 = e3.uiRef, t3 || (r2.appendUiObject({ uiConfig: e3 }, c2), t3 = e3.uiRef), t3 && iT(t3, c2, p2++) && r2.appendUiObject({ uiConfig: e3 }, c2);
    }
    let d2 = c2.children;
    for (; d2.length > p2; ) {
      const e3 = d2[d2.length - 1];
      c2.remove(e3), d2 = c2.children;
    }
    c2.controller_.props.set("title", null !== (a2 = A(t2.label)) && void 0 !== a2 ? a2 : "");
    const f2 = c2.controller_.view.containerElement, m2 = A(t2.domChildren, []);
    if (void 0 !== (null == m2 ? void 0 : m2.length)) {
      const e3 = [];
      for (let t3 = 0; t3 < f2.children.length; t3++) {
        const r3 = f2.children[t3];
        (null === (l2 = r3.dataset) || void 0 === l2 ? void 0 : l2.tpCustomDOM) && e3.push(r3);
      }
      for (const t3 of e3)
        f2.removeChild(t3);
      for (const e4 of m2)
        e4.parentElement !== f2 && (f2.appendChild(e4), e4.dataset.tpCustomDOM = "true");
      c2.controller_.foldable.cleanUpTransition();
    }
    return c2;
  }, oT = (e2, t2, r2, n2) => {
    var i2, s2;
    const [o2, a2] = null !== (i2 = t2.property) && void 0 !== i2 ? i2 : [void 0, void 0], l2 = null !== (s2 = A(t2.label)) && void 0 !== s2 ? s2 : a2;
    let c2 = t2.uiRef;
    return c2 || (c2 = e2.addButton({ title: "" }), c2.on("click", async () => {
      var e3;
      const n3 = [];
      t2.prompt && n3.push(await r2.prompt(...t2.prompt));
      const i3 = null !== (e3 = o2 && a2 ? o2[a2] : void 0) && void 0 !== e3 ? e3 : t2.value;
      if ("function" == typeof i3) {
        const e4 = () => {
          r2.removeEventListener("postFrame", e4), i3(...n3);
        };
        r2.addEventListener("postFrame", e4);
      } else
        console.warn("Invalid action type for button");
    })), c2 && (c2.title = null != l2 ? l2 : "click me"), c2;
  }, aT = (e2, t2, r2, n2) => {
    var i2;
    const s2 = Object.fromEntries((null !== (i2 = A(t2.children)) && void 0 !== i2 ? i2 : []).map((e3) => A(e3)).flat(2).filter((e3) => e3).map((e3) => {
      var t3;
      const r3 = A(e3.label);
      return [r3, null !== (t3 = e3.value) && void 0 !== t3 ? t3 : r3];
    }));
    return hT(e2, t2, r2, { options: s2, ...null != n2 ? n2 : {} });
  }, lT = (e2, t2, r2, n2) => {
    var i2, s2;
    const o2 = A(t2.bounds), a2 = (null !== (i2 = null == o2 ? void 0 : o2.length) && void 0 !== i2 ? i2 : 0) >= 2 ? o2[1] : 1, l2 = (null !== (s2 = null == o2 ? void 0 : o2.length) && void 0 !== s2 ? s2 : 0) >= 1 ? o2[0] : 0, c2 = t2.stepSize || void 0;
    return hT(e2, t2, r2, { min: l2, max: a2, step: c2, ...null != n2 ? n2 : {} });
  }, cT = (e2, t2, r2, i2) => {
    var s2, o2, a2;
    const l2 = A(t2.bounds);
    if (!l2 || l2.length < 1)
      return hT(e2, t2, r2, { ...null != i2 ? i2 : {} });
    const c2 = (null !== (s2 = l2.length) && void 0 !== s2 ? s2 : 0) >= 2 ? l2[1] : 1, u2 = (null !== (o2 = l2.length) && void 0 !== o2 ? o2 : 0) >= 1 ? l2[0] : 0, h2 = { min: u2, max: c2, step: null !== (a2 = t2.stepSize) && void 0 !== a2 ? a2 : (c2 - u2) / 100 }, p2 = { x: h2, y: h2 };
    "vec3" !== t2.type && "vec4" !== t2.type || (p2.z = h2), "vec4" === t2.type && (p2.w = h2);
    const d2 = t2.property;
    if (void 0 === t2.value && d2 && d2[0] && "object" == typeof d2[0] && d2[0][d2[1]] && Array.isArray(d2[0][d2[1]])) {
      const [e3, r3] = d2, i3 = e3[r3], s3 = i3.length, o3 = new (2 === s3 ? n.FM8 : 3 === s3 ? n.Pa4 : n.Ltg)().fromArray(i3);
      t2.value = o3, t2.property = void 0, t2.onChange = [() => {
        e3[r3] = o3.toArray();
      }, ...Array.isArray(t2.onChange) ? t2.onChange : [t2.onChange]].filter((e4) => e4), void 0 === t2.label && (t2.label = r3);
    }
    return hT(e2, t2, r2, { ...p2, ...null != i2 ? i2 : {} });
  }, uT = (e2, t2, r2, n2) => {
    var i2;
    const s2 = t2.property;
    if (void 0 === t2.value && s2 && "object" == typeof s2[0] && (null === (i2 = s2[0][s2[1]]) || void 0 === i2 ? void 0 : i2.isColor)) {
      const [e3, r3] = s2, n3 = new Ae().set(e3[r3]).convertSRGBToLinear();
      Object.defineProperty(t2, "value", { get: () => {
        const t3 = e3[r3];
        return t3 ? n3.set(t3).convertLinearToSRGB().getHex() : 0;
      }, set: (t3) => {
        const i3 = e3[r3];
        n3.setHex(t3).convertSRGBToLinear(), i3.isColor ? i3.copy(n3) : "number" == typeof i3 ? e3[r3] = n3.getHex() : "string" == typeof i3 && (e3[r3] = "#" + n3.getHexString()), "function" == typeof (null == e3 ? void 0 : e3.setDirty) && e3.setDirty();
      } }), t2.property = void 0, t2.onChange = [...Array.isArray(t2.onChange) ? t2.onChange : [t2.onChange]].filter((e4) => e4), void 0 === t2.label && (t2.label = r3);
    }
    return (n2 = null != n2 ? n2 : {}).view = "color", A(t2.inlinePicker) && (n2.picker = "inline"), hT(e2, t2, r2, n2);
  }, hT = (e2, t2, r2, n2) => {
    var i2;
    let s2 = A(t2.property);
    if ((t2.getValue || t2.setValue) && s2 && console.error("specify either property or value, or getValue and setValue", t2), s2)
      t2.value && console.warn("Both property and value are defined, value will be ignored", t2);
    else if (void 0 === t2.value && (t2.getValue || t2.setValue) && (Object.defineProperty(t2, "value", { get: () => {
      var e3;
      return null === (e3 = t2.getValue) || void 0 === e3 ? void 0 : e3.call(t2);
    }, set: (e3) => {
      var r3;
      return null === (r3 = t2.setValue) || void 0 === r3 ? void 0 : r3.call(t2, e3);
    } }), s2 = [t2, "value"]), s2 || void 0 === t2.value || (s2 = [t2, "value"]), !s2)
      return void console.error("cannot determine property", t2);
    n2 = null != n2 ? n2 : {};
    const o2 = { label: null !== (i2 = A(t2.label)) && void 0 !== i2 ? i2 : s2[1], ...n2 };
    let a2 = t2.uiRef;
    if (!a2 && "object" == typeof s2[0] && s2[0]) {
      const [r3, n3] = s2;
      try {
        a2 = t2.isMonitor ? e2.addMonitor(r3, n3, o2) : e2.addInput(r3, n3, o2).on("change", (e3) => {
          [t2.onChange].flat().forEach((t3) => "function" == typeof t3 && (null == t3 ? void 0 : t3(e3))), "function" == typeof (null == r3 ? void 0 : r3.setDirty) && r3.setDirty(e3);
        });
      } catch (e3) {
        if (!e3.message.startsWith("No matching controller for"))
          throw e3;
        a2 = void 0;
      }
    }
    if (a2) {
      for (const [e3, t3] of Object.entries(o2)) {
        const r3 = a2.controller_.props.value(e3);
        void 0 !== r3 && r3.rawValue !== t3 && a2.controller_.props.set(e3, t3);
      }
      "slider" === t2.type && (void 0 !== o2.min && a2.controller_.valueController.sliderController.props.set("minValue", o2.min), void 0 !== o2.max && a2.controller_.valueController.sliderController.props.set("maxValue", o2.max)), a2.refresh();
    }
    return a2;
  };
  class pT extends r {
    constructor(e2 = false, t2 = false, r2 = false, n2 = true, i2 = document.body) {
      super(), this._refreshQueue = { preRender: [], postRender: [], preFrame: [], postFrame: [] }, this._lastModeTime = { preRender: 0, postRender: 0, preFrame: 0, postFrame: 0 }, this._typeGenerators = { folder: sT, input: hT, slider: lT, dropdown: aT, checkbox: hT, color: uT, vec: cT, vec2: cT, vec3: cT, vec4: cT, button: oT, monitor: (e3, t3, r3, n3) => (t3.isMonitor = true, hT(e3, t3, r3, n3)), dummy: (e3, t3, r3, n3) => hT(e3, t3, r3, n3) }, this.alert = async (e3) => alert(e3), this.confirm = async (e3) => confirm(e3), this.prompt = async (e3, t3, r3 = true) => prompt(e3, t3), this._expand = e2, this._limitedOptions = r2;
      const s2 = this._createUiContainer();
      i2.appendChild(s2), this._pane = new nT.Pane({ title: "Configuration", container: s2 }), this._pane.expanded = this._expand, n2 && (this.addEventListener("postFrame", () => this.refreshQueue("postFrame")), setTimeout(() => {
        this.dispatchEvent({ type: "postFrame" });
      }, 32));
    }
    refreshQueue(e2) {
      const t2 = this._refreshQueue[e2], r2 = [], n2 = Dt(), i2 = n2 - this._lastModeTime[e2];
      t2.forEach((e3) => {
        e3[2] > 1e-3 ? (e3[2] -= i2, r2.push(e3)) : this._refreshUiObject(e3[0], e3[1], e3[2]);
      }), this._refreshQueue[e2] = r2, this._lastModeTime[e2] = n2;
    }
    addToRefreshQueue(e2, t2) {
      var r2;
      const n2 = null === (r2 = t2[0]) || void 0 === r2 ? void 0 : r2.uiConfig, i2 = null == n2 ? void 0 : n2.uuid, s2 = this._refreshQueue[e2], o2 = s2.find((e3) => e3[3] === i2);
      o2 ? o2[2] = Math.max(o2[2], t2[2]) : s2.push([...t2, i2]), this._refreshQueue[e2] = s2;
    }
    dispose() {
      var e2;
      null === (e2 = this._pane) || void 0 === e2 || e2.dispose(), this._pane = void 0;
    }
    appendUiObject(e2, t2) {
      e2 && this._appendUiObject(e2, t2);
    }
    _appendUiObject(e2, t2) {
      var r2, n2, i2, s2;
      const { uiConfig: o2 } = null != e2 ? e2 : {};
      if (o2 && (!this._limitedOptions || o2.limitedUi) && (t2 = null != t2 ? t2 : this._pane, o2.type)) {
        o2.uuid || (o2.uuid = Xe()), o2.uiRef && o2.uiRefType !== o2.type && (console.log("Removing UI object because of type mismatch", o2.uiRef), this.removeUiConfig(o2));
        const a2 = null === (n2 = (r2 = this._typeGenerators)[o2.type]) || void 0 === n2 ? void 0 : n2.call(r2, t2, o2, this);
        a2 && (a2.hidden = null !== (i2 = A(o2.hidden)) && void 0 !== i2 && i2, a2.disabled = null !== (s2 = A(o2.disabled)) && void 0 !== s2 && s2), o2.uiRef = a2, o2.uiRefType = a2 ? o2.type : void 0, o2.uiRefresh = (r3 = "postFrame", n3 = false, i3 = 0) => {
          var s3;
          return this._uiObjectRefresh(r3, null !== (s3 = null == e2 ? void 0 : e2.uiConfig) && void 0 !== s3 ? s3 : o2, t2, n3, i3);
        };
      }
    }
    removeUiObject(e2) {
      this.removeUiConfig(null == e2 ? void 0 : e2.uiConfig);
    }
    removeUiConfig(e2) {
      var t2, r2;
      e2 && e2.uiRef && (null === (r2 = (t2 = e2.uiRef).dispose) || void 0 === r2 || r2.call(t2), e2.uiRef = void 0, e2.uiRefType = void 0, e2.uiRefresh = void 0);
    }
    _uiObjectRefresh(e2, t2, r2, n2, i2) {
      (n2 ? dT(t2, r2) : [{ uiConfig: t2, parentFolder: r2 }]).forEach((t3) => {
        const r3 = [{ uiConfig: t3.uiConfig }, t3.parentFolder, i2];
        "immediate" === e2 ? this._refreshUiObject(...r3) : this.addToRefreshQueue(e2, r3);
      });
    }
    _refreshUiObject(e2, t2, r2 = 0) {
      this._appendUiObject(e2, t2), r2 > 1e-4 && console.error("no support for immediate delay");
    }
    _createUiContainer() {
      const e2 = St({ id: "tweakpaneUiContainer", addToBody: false });
      return Mt(E`
          :root{
            --tweakpane-ui-container-width: 300px;
          }
          @media only screen and (min-width: 1500px) {
            :root{
              --tweakpane-ui-container-width: 300px;
            }
          }
          @media only screen and (min-width: 2500px) {
            :root{
              --tweakpane-ui-container-width: 500px;
            }
          }
          #tweakpaneUiContainer {
            position: fixed;
            top: 0px;
            padding-right: 4px;
            padding-bottom: 10px;
            right: 10px;
            width: var(--tweakpane-ui-container-width);
            height: auto;
            overflow-y: scroll;
            z-index: 100;
            pointer-events: auto;
            max-height: calc(100% - 6rem);
            border-radius: 0.5rem;
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, "system-ui", "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
          }
        `), e2;
    }
  }
  function dT(e2, t2, r2) {
    var n2;
    return r2 = null != r2 ? r2 : [], e2 ? (r2.push({ uiConfig: e2, parentFolder: t2 }), null === (n2 = e2.children) || void 0 === n2 || n2.forEach((t3) => r2 = dT(t3, e2.uiRef, r2)), r2) : r2;
  }
  class fT {
    constructor() {
      fT.prototype.isMatrix3 = true, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    set(e2, t2, r2, n2, i2, s2, o2, a2, l2) {
      const c2 = this.elements;
      return c2[0] = e2, c2[1] = n2, c2[2] = o2, c2[3] = t2, c2[4] = i2, c2[5] = a2, c2[6] = r2, c2[7] = s2, c2[8] = l2, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e2) {
      const t2 = this.elements, r2 = e2.elements;
      return t2[0] = r2[0], t2[1] = r2[1], t2[2] = r2[2], t2[3] = r2[3], t2[4] = r2[4], t2[5] = r2[5], t2[6] = r2[6], t2[7] = r2[7], t2[8] = r2[8], this;
    }
    extractBasis(e2, t2, r2) {
      return e2.setFromMatrix3Column(this, 0), t2.setFromMatrix3Column(this, 1), r2.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(e2) {
      const t2 = e2.elements;
      return this.set(t2[0], t2[4], t2[8], t2[1], t2[5], t2[9], t2[2], t2[6], t2[10]), this;
    }
    multiply(e2) {
      return this.multiplyMatrices(this, e2);
    }
    premultiply(e2) {
      return this.multiplyMatrices(e2, this);
    }
    multiplyMatrices(e2, t2) {
      const r2 = e2.elements, n2 = t2.elements, i2 = this.elements, s2 = r2[0], o2 = r2[3], a2 = r2[6], l2 = r2[1], c2 = r2[4], u2 = r2[7], h2 = r2[2], p2 = r2[5], d2 = r2[8], f2 = n2[0], m2 = n2[3], _2 = n2[6], g2 = n2[1], v2 = n2[4], A2 = n2[7], b2 = n2[2], y2 = n2[5], x2 = n2[8];
      return i2[0] = s2 * f2 + o2 * g2 + a2 * b2, i2[3] = s2 * m2 + o2 * v2 + a2 * y2, i2[6] = s2 * _2 + o2 * A2 + a2 * x2, i2[1] = l2 * f2 + c2 * g2 + u2 * b2, i2[4] = l2 * m2 + c2 * v2 + u2 * y2, i2[7] = l2 * _2 + c2 * A2 + u2 * x2, i2[2] = h2 * f2 + p2 * g2 + d2 * b2, i2[5] = h2 * m2 + p2 * v2 + d2 * y2, i2[8] = h2 * _2 + p2 * A2 + d2 * x2, this;
    }
    multiplyScalar(e2) {
      const t2 = this.elements;
      return t2[0] *= e2, t2[3] *= e2, t2[6] *= e2, t2[1] *= e2, t2[4] *= e2, t2[7] *= e2, t2[2] *= e2, t2[5] *= e2, t2[8] *= e2, this;
    }
    determinant() {
      const e2 = this.elements, t2 = e2[0], r2 = e2[1], n2 = e2[2], i2 = e2[3], s2 = e2[4], o2 = e2[5], a2 = e2[6], l2 = e2[7], c2 = e2[8];
      return t2 * s2 * c2 - t2 * o2 * l2 - r2 * i2 * c2 + r2 * o2 * a2 + n2 * i2 * l2 - n2 * s2 * a2;
    }
    invert() {
      const e2 = this.elements, t2 = e2[0], r2 = e2[1], n2 = e2[2], i2 = e2[3], s2 = e2[4], o2 = e2[5], a2 = e2[6], l2 = e2[7], c2 = e2[8], u2 = c2 * s2 - o2 * l2, h2 = o2 * a2 - c2 * i2, p2 = l2 * i2 - s2 * a2, d2 = t2 * u2 + r2 * h2 + n2 * p2;
      if (0 === d2)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f2 = 1 / d2;
      return e2[0] = u2 * f2, e2[1] = (n2 * l2 - c2 * r2) * f2, e2[2] = (o2 * r2 - n2 * s2) * f2, e2[3] = h2 * f2, e2[4] = (c2 * t2 - n2 * a2) * f2, e2[5] = (n2 * i2 - o2 * t2) * f2, e2[6] = p2 * f2, e2[7] = (r2 * a2 - l2 * t2) * f2, e2[8] = (s2 * t2 - r2 * i2) * f2, this;
    }
    transpose() {
      let e2;
      const t2 = this.elements;
      return e2 = t2[1], t2[1] = t2[3], t2[3] = e2, e2 = t2[2], t2[2] = t2[6], t2[6] = e2, e2 = t2[5], t2[5] = t2[7], t2[7] = e2, this;
    }
    getNormalMatrix(e2) {
      return this.setFromMatrix4(e2).invert().transpose();
    }
    transposeIntoArray(e2) {
      const t2 = this.elements;
      return e2[0] = t2[0], e2[1] = t2[3], e2[2] = t2[6], e2[3] = t2[1], e2[4] = t2[4], e2[5] = t2[7], e2[6] = t2[2], e2[7] = t2[5], e2[8] = t2[8], this;
    }
    setUvTransform(e2, t2, r2, n2, i2, s2, o2) {
      const a2 = Math.cos(i2), l2 = Math.sin(i2);
      return this.set(r2 * a2, r2 * l2, -r2 * (a2 * s2 + l2 * o2) + s2 + e2, -n2 * l2, n2 * a2, -n2 * (-l2 * s2 + a2 * o2) + o2 + t2, 0, 0, 1), this;
    }
    scale(e2, t2) {
      const r2 = this.elements;
      return r2[0] *= e2, r2[3] *= e2, r2[6] *= e2, r2[1] *= t2, r2[4] *= t2, r2[7] *= t2, this;
    }
    rotate(e2) {
      const t2 = Math.cos(e2), r2 = Math.sin(e2), n2 = this.elements, i2 = n2[0], s2 = n2[3], o2 = n2[6], a2 = n2[1], l2 = n2[4], c2 = n2[7];
      return n2[0] = t2 * i2 + r2 * a2, n2[3] = t2 * s2 + r2 * l2, n2[6] = t2 * o2 + r2 * c2, n2[1] = -r2 * i2 + t2 * a2, n2[4] = -r2 * s2 + t2 * l2, n2[7] = -r2 * o2 + t2 * c2, this;
    }
    translate(e2, t2) {
      const r2 = this.elements;
      return r2[0] += e2 * r2[2], r2[3] += e2 * r2[5], r2[6] += e2 * r2[8], r2[1] += t2 * r2[2], r2[4] += t2 * r2[5], r2[7] += t2 * r2[8], this;
    }
    equals(e2) {
      const t2 = this.elements, r2 = e2.elements;
      for (let e3 = 0; e3 < 9; e3++)
        if (t2[e3] !== r2[e3])
          return false;
      return true;
    }
    fromArray(e2, t2 = 0) {
      for (let r2 = 0; r2 < 9; r2++)
        this.elements[r2] = e2[r2 + t2];
      return this;
    }
    toArray(e2 = [], t2 = 0) {
      const r2 = this.elements;
      return e2[t2] = r2[0], e2[t2 + 1] = r2[1], e2[t2 + 2] = r2[2], e2[t2 + 3] = r2[3], e2[t2 + 4] = r2[4], e2[t2 + 5] = r2[5], e2[t2 + 6] = r2[6], e2[t2 + 7] = r2[7], e2[t2 + 8] = r2[8], e2;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  function mT(e2) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", e2);
  }
  let _T;
  Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
  class gT {
    constructor(e2 = null) {
      this.isSource = true, this.uuid = $(), this.data = e2, this.version = 0;
    }
    set needsUpdate(e2) {
      true === e2 && this.version++;
    }
    toJSON(e2) {
      const t2 = void 0 === e2 || "string" == typeof e2;
      if (!t2 && void 0 !== e2.images[this.uuid])
        return e2.images[this.uuid];
      const r2 = { uuid: this.uuid, url: "" }, n2 = this.data;
      if (null !== n2) {
        let e3;
        if (Array.isArray(n2)) {
          e3 = [];
          for (let t3 = 0, r3 = n2.length; t3 < r3; t3++)
            n2[t3].isDataTexture ? e3.push(vT(n2[t3].image)) : e3.push(vT(n2[t3]));
        } else
          e3 = vT(n2);
        r2.url = e3;
      }
      return t2 || (e2.images[this.uuid] = r2), r2;
    }
  }
  function vT(e2) {
    if ("undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e2 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap)
      return class {
        static getDataURL(e3, t2 = false) {
          if (/^data:/i.test(e3.src))
            return e3.src;
          if ("undefined" == typeof HTMLCanvasElement)
            return e3.src;
          let r2;
          if (e3 instanceof HTMLCanvasElement)
            r2 = e3;
          else {
            void 0 === _T && (_T = mT("canvas")), _T.width = e3.width, _T.height = e3.height;
            const t3 = _T.getContext("2d");
            e3 instanceof ImageData ? t3.putImageData(e3, 0, 0) : t3.drawImage(e3, 0, 0, e3.width, e3.height), r2 = _T;
          }
          return !t2 && (r2.width > 2048 || r2.height > 2048) ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e3), r2.toDataURL("image/jpeg", 0.6)) : r2.toDataURL("image/png");
        }
        static sRGBToLinear(e3) {
          if ("undefined" != typeof HTMLImageElement && e3 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e3 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e3 instanceof ImageBitmap) {
            const t2 = mT("canvas");
            t2.width = e3.width, t2.height = e3.height;
            const r2 = t2.getContext("2d");
            r2.drawImage(e3, 0, 0, e3.width, e3.height);
            const n2 = r2.getImageData(0, 0, e3.width, e3.height), i2 = n2.data;
            for (let e4 = 0; e4 < i2.length; e4++)
              i2[e4] = 255 * ce(i2[e4] / 255);
            return r2.putImageData(n2, 0, 0), t2;
          }
          if (e3.data) {
            const t2 = e3.data.slice(0);
            for (let e4 = 0; e4 < t2.length; e4++)
              t2 instanceof Uint8Array || t2 instanceof Uint8ClampedArray ? t2[e4] = Math.floor(255 * ce(t2[e4] / 255)) : t2[e4] = ce(t2[e4]);
            return { data: t2, width: e3.width, height: e3.height };
          }
          return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e3;
        }
      }.getDataURL(e2);
    if (e2.data) {
      let t2 = [];
      try {
        t2 = Array.from(e2.data);
      } catch (r2) {
        r2.message.includes("Invalid array length") ? console.warn("Serializing large texture, might not be saved in JSON structure.") : console.error(r2), t2 = e2.data;
      }
      return { data: t2, width: e2.width, height: e2.height, type: e2.data.constructor.name };
    }
    return console.warn("THREE.Texture: Unable to serialize Texture."), {};
  }
  let AT = 0;
  class bT extends class {
    addEventListener(e2, t2) {
      void 0 === this._listeners && (this._listeners = {});
      const r2 = this._listeners;
      void 0 === r2[e2] && (r2[e2] = []), -1 === r2[e2].indexOf(t2) && r2[e2].push(t2);
    }
    hasEventListener(e2, t2) {
      if (void 0 === this._listeners)
        return false;
      const r2 = this._listeners;
      return void 0 !== r2[e2] && -1 !== r2[e2].indexOf(t2);
    }
    removeEventListener(e2, t2) {
      if (void 0 === this._listeners)
        return;
      const r2 = this._listeners[e2];
      if (void 0 !== r2) {
        const e3 = r2.indexOf(t2);
        -1 !== e3 && r2.splice(e3, 1);
      }
    }
    dispatchEvent(e2) {
      if (void 0 === this._listeners)
        return;
      const t2 = this._listeners[e2.type];
      if (void 0 !== t2) {
        e2.target = this;
        const r2 = t2.slice(0);
        for (let t3 = 0, n2 = r2.length; t3 < n2; t3++)
          r2[t3].call(this, e2);
        e2.target = null;
      }
    }
  } {
    constructor(e2 = bT.DEFAULT_IMAGE, t2 = bT.DEFAULT_MAPPING, r2 = 1001, n2 = 1001, i2 = oe, s2 = 1008, o2 = 1023, a2 = 1009, l2 = 1, c2 = 3e3) {
      super(), this.isTexture = true, Object.defineProperty(this, "id", { value: AT++ }), this.uuid = $(), this.name = "", this.source = new gT(e2), this.mipmaps = [], this.mapping = t2, this.wrapS = r2, this.wrapT = n2, this.magFilter = i2, this.minFilter = s2, this.anisotropy = l2, this.format = o2, this.internalFormat = null, this.type = a2, this.offset = new I(0, 0), this.repeat = new I(1, 1), this.center = new I(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new fT(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = c2, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.needsPMREMUpdate = false;
    }
    get image() {
      return this.source.data;
    }
    set image(e2) {
      this.source.data = e2;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e2) {
      return this.name = e2.name, this.source = e2.source, this.mipmaps = e2.mipmaps.slice(0), this.mapping = e2.mapping, this.wrapS = e2.wrapS, this.wrapT = e2.wrapT, this.magFilter = e2.magFilter, this.minFilter = e2.minFilter, this.anisotropy = e2.anisotropy, this.format = e2.format, this.internalFormat = e2.internalFormat, this.type = e2.type, this.offset.copy(e2.offset), this.repeat.copy(e2.repeat), this.center.copy(e2.center), this.rotation = e2.rotation, this.matrixAutoUpdate = e2.matrixAutoUpdate, this.matrix.copy(e2.matrix), this.generateMipmaps = e2.generateMipmaps, this.premultiplyAlpha = e2.premultiplyAlpha, this.flipY = e2.flipY, this.unpackAlignment = e2.unpackAlignment, this.encoding = e2.encoding, this.userData = JSON.parse(JSON.stringify(e2.userData)), this.needsUpdate = true, this;
    }
    toJSON(e2) {
      const t2 = void 0 === e2 || "string" == typeof e2;
      if (!t2 && void 0 !== e2.textures[this.uuid])
        return e2.textures[this.uuid];
      const r2 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e2).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
      return "{}" !== JSON.stringify(this.userData) && (r2.userData = this.userData), t2 || (e2.textures[this.uuid] = r2), r2;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(e2) {
      if (300 !== this.mapping)
        return e2;
      if (e2.applyMatrix3(this.matrix), e2.x < 0 || e2.x > 1)
        switch (this.wrapS) {
          case 1e3:
            e2.x = e2.x - Math.floor(e2.x);
            break;
          case 1001:
            e2.x = e2.x < 0 ? 0 : 1;
            break;
          case 1002:
            1 === Math.abs(Math.floor(e2.x) % 2) ? e2.x = Math.ceil(e2.x) - e2.x : e2.x = e2.x - Math.floor(e2.x);
        }
      if (e2.y < 0 || e2.y > 1)
        switch (this.wrapT) {
          case 1e3:
            e2.y = e2.y - Math.floor(e2.y);
            break;
          case 1001:
            e2.y = e2.y < 0 ? 0 : 1;
            break;
          case 1002:
            1 === Math.abs(Math.floor(e2.y) % 2) ? e2.y = Math.ceil(e2.y) - e2.y : e2.y = e2.y - Math.floor(e2.y);
        }
      return this.flipY && (e2.y = 1 - e2.y), e2;
    }
    set needsUpdate(e2) {
      true === e2 && (this.version++, this.source.needsUpdate = true);
    }
  }
  bT.DEFAULT_IMAGE = null, bT.DEFAULT_MAPPING = 300;
  var yT = __webpackgi_require__2(898), xT = {};
  yT.Z && yT.Z.locals && (xT.locals = yT.Z.locals);
  var wT, ET = 0, ST = {};
  ST.styleTagTransform = cp(), ST.setAttributes = sp(), ST.insert = function(e2, t2) {
    (t2.target || document.head).appendChild(e2);
  }, ST.domAPI = np(), ST.insertStyleElement = ap(), xT.use = function(e2) {
    return ST.options = e2 || {}, ET++ || (wT = tp()(yT.Z, ST)), xT;
  }, xT.unuse = function() {
    ET > 0 && !--ET && (wT(), wT = null);
  };
  var CT = xT;
  class MT extends pT {
    constructor(e2 = false, t2 = false, r2 = false, n2 = document.body) {
      super(e2, t2, r2, false), this.dependencies = [to], this._preRender = () => this.refreshQueue("preRender"), this._postRender = () => this.refreshQueue("postRender"), this._postFrame = (e3) => {
        this.dispatchEvent(e3), this.refreshQueue("postFrame");
      }, this._preFrame = () => this.refreshQueue("preFrame"), this._plugins = [], this.alert = async (e3) => this._viewer ? this._viewer.alert(e3) : super.alert(e3), this.confirm = async (e3) => this._viewer ? this._viewer.confirm(e3) : super.confirm(e3), this.prompt = async (e3, t3, r3 = true) => this._viewer ? this._viewer.prompt(e3, t3, r3) : super.prompt(e3, t3, r3), this._pane.registerPlugin(tT), CT.use({ target: n2 });
    }
    async onAdded(e2) {
      this._viewer = e2, this._typeGenerators.image = ((e3) => (t2, r2, i2, s2) => {
        const o2 = r2.property, a2 = "placeholder";
        if (void 0 === r2.value && o2 && "object" == typeof o2[0]) {
          const [t3, i3] = o2, s3 = Ky("Render Target"), l2 = Ky("Data Texture"), c2 = Ky("CUBE Texture"), u2 = Ky("Compressed Texture"), h2 = {}, p2 = {};
          Object.defineProperty(r2, "value", { get: () => {
            var e4;
            let r3, n2 = t3[i3];
            if ((null == n2 ? void 0 : n2.get) && (n2 = n2.get()), !n2)
              return a2;
            if (n2.isRenderTargetTexture && !n2.image.tp_src && (n2.image.tp_src = s3), n2.isDataTexture && !n2.image.tp_src && (n2.image.tp_src = l2), n2.isCompressedTexture && !n2.image.tp_src && (n2.image.tp_src = u2), n2.isTexture ? (n2.image && (n2.image instanceof ImageBitmap || n2.image instanceof HTMLImageElement || n2.image instanceof HTMLVideoElement) && !n2.image.tp_src && (n2.image.tp_src = It(n2.image, 160)), n2.image && (r3 = n2.image.tp_src_uuid, r3 = r3 ? h2[r3] : void 0, r3 || (r3 = n2.image.tp_src || n2.image.src))) : "string" == typeof n2 ? r3 = n2 : n2.domainMin ? (r3 = n2.texture, n2.texture.image && !n2.texture.image.tp_src && (n2.texture.image.tp_src = c2), n2.texture.image && (r3 = n2.texture.image.tp_src_uuid, r3 = r3 ? h2[r3] : void 0, r3 || (r3 = n2.texture.image.tp_src || n2.texture.image.src))) : n2 && console.error("unknown value", n2), r3 || (r3 = a2), n2.image && !n2.image.tp_src_uuid) {
              const e5 = Xe();
              n2.image.tp_src_uuid = e5, p2[r3] = e5;
            }
            return "string" == typeof r3 && (r3 = null !== (e4 = h2[r3]) && void 0 !== e4 ? e4 : r3), r3;
          }, set: (s4) => {
            var o3, l3, c3, u3, d2, f2, m2, _2, g2, v2, A2;
            const b2 = t3[i3], y2 = (e4) => {
              var r3;
              t3[i3] = e4, (null == e4 ? void 0 : e4.isTexture) && (e4.flipY = e4.isDataTexture ? e4.flipY : null === (r3 = null == b2 ? void 0 : b2.flipY) || void 0 === r3 || r3);
            };
            if ("string" == typeof s4)
              return void ("string" == typeof b2 && y2(s4));
            if (!s4)
              return void (r2.value = a2);
            if (s4.isPlaceholder)
              return void (b2 && (y2("string" == typeof b2 ? "" : null), "function" == typeof (null == t3 ? void 0 : t3.setDirty) && t3.setDirty()));
            let x2 = s4.tp_src_uuid;
            if (x2 || (x2 = null !== (o3 = s4.src) && void 0 !== o3 ? o3 : s4.tp_src, x2 = null !== (l3 = p2[x2]) && void 0 !== l3 ? l3 : x2, delete p2[x2], s4.tp_src_uuid = x2), x2 && (h2[x2] = s4), "string" != typeof b2) {
              if (!((null == b2 ? void 0 : b2.image) === s4 || (null === (c3 = null == b2 ? void 0 : b2.image) || void 0 === c3 ? void 0 : c3.src) === s4.src || (null === (u3 = null == b2 ? void 0 : b2.image) || void 0 === u3 ? void 0 : u3.tp_src) === s4.tp_src && null != s4.tp_src || (null === (d2 = null == b2 ? void 0 : b2.image) || void 0 === d2 ? void 0 : d2.tp_src) === s4.src && null != s4.src || (null === (f2 = null == b2 ? void 0 : b2.image) || void 0 === f2 ? void 0 : f2.src) === s4.tp_src && null != s4.tp_src))
                if (s4 instanceof File) {
                  const n2 = null == e3 ? void 0 : e3.getPlugin(to);
                  if (!n2)
                    throw "Viewer or AssetManagerPlugin not found";
                  null === (m2 = n2.importer) || void 0 === m2 || m2.importSingle({ file: s4, path: s4.src }).then((e4) => {
                    var n3, i4, o4, a3;
                    if (e4) {
                      e4.isDataTexture && (e4.needsUpdate = true);
                      const l4 = null === (o4 = null === (i4 = null === (n3 = s4.src) || void 0 === n3 ? void 0 : n3.split("?")) || void 0 === i4 ? void 0 : i4[0]) || void 0 === o4 ? void 0 : o4.split(".").pop();
                      e4.userData && (e4.userData.mimeType || (e4.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(l4) ? "jpeg" : "png"))), y2(e4), [r2.onChange].flat().forEach((e5) => "function" == typeof e5 && (null == e5 ? void 0 : e5())), "function" == typeof (null == t3 ? void 0 : t3.setDirty) && t3.setDirty(), null === (a3 = r2.uiRefresh) || void 0 === a3 || a3.call(r2, "postFrame", false);
                    }
                  });
                } else {
                  const e4 = new bT(s4);
                  e4.assetType = "texture", e4.needsUpdate = true;
                  const o4 = null === (v2 = null === (g2 = null === (_2 = s4.src) || void 0 === _2 ? void 0 : _2.split("?")) || void 0 === g2 ? void 0 : g2[0]) || void 0 === v2 ? void 0 : v2.split(".").pop();
                  e4.userData.mimeType || (e4.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(o4) ? "jpeg" : "png")), y2(e4);
                  const a3 = ["normalMap", "aoMap", "emissiveMap", "roughnessMap", "metalnessMap", "displacementMap", "bumpMap", "alphaMap"].includes(i3);
                  e4.encoding = a3 ? n.rnI : n.knz, e4.wrapS = n.rpg, e4.wrapT = n.rpg, [r2.onChange].flat().forEach((e5) => "function" == typeof e5 && (null == e5 ? void 0 : e5())), "function" == typeof (null == t3 ? void 0 : t3.setDirty) && t3.setDirty(), null === (A2 = r2.uiRefresh) || void 0 === A2 || A2.call(r2, "postFrame", false);
                }
            } else
              y2(x2);
          } }), r2.property = void 0, void 0 === r2.label && (r2.label = i3);
        }
        return (s2 = null != s2 ? s2 : {}).extensions = [".jpg", ".png", ".svg", ".hdr", ".exr", ".jpeg", ".bmp", ".gif", ".webp", ".cube"], void 0 === s2.imageFit && (s2.imageFit = "contain"), void 0 === s2.clickCallback && (s2.clickCallback = (t3, s3) => {
          var l2;
          const c2 = null == t3 ? void 0 : t3.target, u2 = null == c2 ? void 0 : c2.getBoundingClientRect();
          if (!u2)
            return void s3.click();
          const h2 = r2.uiRef.controller_.valueController.value.rawValue, p2 = h2 === a2 || (null == h2 ? void 0 : h2.isPlaceholder) ? {} : { "remove image": () => {
            var e4;
            r2.uiRef.controller_.valueController.value.setRawValue("");
            const [t4, n2] = o2 || [r2, "value"], i3 = "string" == typeof t4[n2];
            t4[n2] = i3 ? "" : null, [r2.onChange].flat().forEach((e5) => "function" == typeof e5 && (null == e5 ? void 0 : e5())), "function" == typeof (null == t4 ? void 0 : t4.setDirty) && t4.setDirty(), null === (e4 = r2.uiRefresh) || void 0 === e4 || e4.call(r2, "postFrame", false), rT.Remove();
          }, "download image": () => {
            var e4, t4, n2;
            const [i3, s4] = o2 || [r2, "value"];
            let a3 = null !== (t4 = null === (e4 = i3[s4]) || void 0 === e4 ? void 0 : e4.image) && void 0 !== t4 ? t4 : r2.uiRef.controller_.valueController.value.rawValue;
            a3 && (a3 instanceof ImageBitmap || a3 instanceof HTMLImageElement || a3 instanceof HTMLVideoElement) && !a3.src && (a3 = It(a3));
            const l3 = document.createElement("a");
            document.body.appendChild(l3), l3.style.display = "none", l3.href = null !== (n2 = null == a3 ? void 0 : a3.src) && void 0 !== n2 ? n2 : a3, l3.download = "image.png", l3.click(), document.body.removeChild(l3), rT.Remove();
          } }, d2 = rT.Create({ ...p2, "set/replace image": () => {
            s3.click(), rT.Remove();
          }, "from url": async () => {
            var t4, s4;
            let a3 = "";
            if (a3 && (a3.startsWith("http") || a3.startsWith("data:image")) || (a3 = ""), a3 = await i2.prompt("Load texture: Enter Image/Texture URL", a3, true), !a3 || !a3.startsWith("http") && !a3.startsWith("data:image"))
              return null !== a3 && await i2.alert("Loading Image: Invalid URL"), void rT.Remove();
            const [l3, c3] = o2 || [r2, "value"], u3 = l3[c3];
            if ("string" == typeof u3)
              l3[c3] = a3, [r2.onChange].flat().forEach((e4) => "function" == typeof e4 && (null == e4 ? void 0 : e4())), "function" == typeof (null == l3 ? void 0 : l3.setDirty) && l3.setDirty(), null === (t4 = r2.uiRefresh) || void 0 === t4 || t4.call(r2, "postFrame", false);
            else {
              const t5 = null == e3 ? void 0 : e3.getPlugin(to);
              if (!t5)
                throw "Viewer or AssetManagerPlugin not found";
              null === (s4 = t5.importer) || void 0 === s4 || s4.importSinglePath(a3).then((e4) => {
                var t6;
                if (e4) {
                  e4.isDataTexture ? e4.needsUpdate = true : e4 && void 0 !== (null == u3 ? void 0 : u3.flipY) && (e4.flipY = u3.flipY), l3[c3] = e4;
                  const i3 = ["normalMap", "aoMap", "emissiveMap", "roughnessMap", "metalnessMap", "displacementMap", "bumpMap", "alphaMap"].includes(c3);
                  e4.encoding = i3 ? n.rnI : n.knz, [r2.onChange].flat().forEach((e5) => "function" == typeof e5 && (null == e5 ? void 0 : e5())), "function" == typeof (null == l3 ? void 0 : l3.setDirty) && l3.setDirty(), null === (t6 = r2.uiRefresh) || void 0 === t6 || t6.call(r2, "postFrame", false);
                }
              });
            }
            rT.Remove();
          }, cancel: () => {
            rT.Remove();
          } }, 2, u2.height + 8);
          null === (l2 = c2.parentElement) || void 0 === l2 || l2.appendChild(d2), u2.y > 0.7 * document.body.clientHeight && (d2.style.top = "auto", d2.style.bottom = u2.height + 8 + "px");
        }), s2.view = "input-image", hT(t2, r2, i2, s2);
      })(this._viewer), e2.addEventListener("preRender", this._preRender), e2.addEventListener("postRender", this._postRender), e2.addEventListener("preFrame", this._preFrame), e2.addEventListener("postFrame", this._postFrame);
    }
    async onDispose(e2) {
      this.dispose();
    }
    async onRemove(e2) {
      this._viewer = void 0, e2.removeEventListener("preRender", this._preRender), e2.removeEventListener("postRender", this._postRender), e2.removeEventListener("preFrame", this._preFrame), e2.removeEventListener("postFrame", this._postFrame), this.dispose();
    }
    setupPluginUi(e2) {
      var t2;
      const r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.getPlugin(e2);
      if (!r2)
        return void console.warn("plugin not found:", e2);
      this._plugins.push(r2), r2.uiConfig && (r2.uiConfig.limitedUi = true), r2.uiConfig && void 0 === r2.uiConfig.hidden && (r2.uiConfig.hidden = false), this._appendUiObject(r2);
      const n2 = r2.uiConfig;
      if ((null == n2 ? void 0 : n2.uiRef) && r2.toJSON) {
        const e3 = n2.uiRef.controller_.view.element, t3 = St({ innerHTML: "&#8942;", classList: ["pluginOptionsButton"], elementTag: "button" });
        t3.onclick = (t4) => {
          const n3 = {};
          "function" == typeof r2.toJSON && (n3["download preset"] = async () => {
            var e4, t5;
            const n4 = null === (t5 = null === (e4 = this._viewer) || void 0 === e4 ? void 0 : e4.getPlugin(to)) || void 0 === t5 ? void 0 : t5.exportPluginPreset(r2);
            await yt(new Blob([JSON.stringify(n4, null, 2)], { type: "application/json" }), "preset." + r2.constructor.PluginType + ".json"), rT.Remove();
          }), "function" == typeof r2.fromJSON && (n3["upload preset"] = async () => {
            var e4, t5;
            rT.Remove();
            const n4 = await Et(false, false);
            if (0 === n4.length)
              return;
            const i3 = n4[0], s2 = await i3.text(), o2 = JSON.parse(s2);
            await (null === (t5 = null === (e4 = this._viewer) || void 0 === e4 ? void 0 : e4.getPlugin(to)) || void 0 === t5 ? void 0 : t5.importPluginPreset(o2, r2));
          });
          const i2 = rT.Create(n3, e3.clientWidth - 120, 12);
          e3.append(i2), t4.preventDefault();
        }, e3.appendChild(t3);
      }
      return n2;
    }
    setupPlugins(...e2) {
      e2.forEach((e3) => this.setupPluginUi(e3));
    }
    refreshPluginsEnabled() {
      this._plugins.forEach((e2) => {
        var t2;
        const r2 = e2.uiConfig;
        r2 && (true !== A(r2.hidden) ? null === (t2 = r2.uiRefresh) || void 0 === t2 || t2.call(r2, "postFrame", true) : r2.uiRef && (r2.uiRef.hidden = true));
      });
    }
  }
  MT.PluginType = "TweakpaneUi";
  class TT extends ro {
    constructor() {
      super(...arguments), this.enabled = true, this.toJSON = void 0, this.bgUIConfig = { label: "Color", type: "color", inlinePicker: true, onChange: () => {
        if (!this._viewer)
          return;
        const e2 = new Ae(this.bgUIConfig.value || 16777215).convertSRGBToLinear();
        this._viewer.setBackground(e2.getHex());
      }, expanded: true, limitedUi: true }, this.uiConfig = { label: "Background / Environment", type: "folder", expanded: false, limitedUi: true, children: [this.bgUIConfig, { label: "Image", property: [this, "sceneBackground"], type: "image", limitedUi: true }, { label: "EnvMap BG", type: "checkbox", property: [this, "envmapBg"] }, () => ({ type: "slider", label: "BG Intensity", property: [this._viewer, "backgroundIntensity"], bounds: [0, 16] }), { label: "Set Transparent BG", type: "button", hidden: () => !this._viewer || this._viewer.useRgbm, value: () => {
        var e2;
        null === (e2 = this._viewer) || void 0 === e2 || e2.setBackground(null);
      } }, { label: "Environment", property: [this, "sceneEnvironment"], type: "image", limitedUi: true }, { type: "slider", label: "Env Rotation", property: [this, "sceneEnvironmentRotation"], bounds: [0, 2 * Math.PI], limitedUi: true }, { type: "slider", label: "Env Intensity", property: [this, "sceneEnvironmentIntensity"], bounds: [0, 4], limitedUi: true }] };
    }
    get sceneBackground() {
      var e2;
      const t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getBackground();
      return t2 && (t2.isTexture || "texture" === t2.assetType) ? t2 : null;
    }
    set sceneBackground(e2) {
      var t2, r2;
      e2 ? null === (t2 = this._viewer) || void 0 === t2 || t2.setBackground(e2) : null === (r2 = this._viewer) || void 0 === r2 || r2.setBackground(this.bgUIConfig.value);
    }
    get sceneEnvironment() {
      var e2;
      return null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.getEnvironment();
    }
    set sceneEnvironment(e2) {
      var t2;
      null === (t2 = this._viewer) || void 0 === t2 || t2.scene.setEnvironment(e2);
    }
    get sceneEnvironmentRotation() {
      var e2, t2, r2;
      return null !== (r2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.getEnvironment()) || void 0 === t2 ? void 0 : t2.rotation) && void 0 !== r2 ? r2 : 0;
    }
    set sceneEnvironmentRotation(e2) {
      var t2, r2;
      const n2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.getEnvironment();
      n2 && (n2.rotation = e2, null === (r2 = this._viewer) || void 0 === r2 || r2.scene.setDirty());
    }
    get sceneEnvironmentIntensity() {
      var e2, t2;
      return null !== (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.envMapIntensity) && void 0 !== t2 ? t2 : 1;
    }
    set sceneEnvironmentIntensity(e2) {
      var t2;
      (null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene) && (this._viewer.scene.envMapIntensity = e2);
    }
    get envmapBg() {
      var e2;
      return (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.getBackground(true)) === vo;
    }
    set envmapBg(e2) {
      if (this._viewer)
        if (e2) {
          const e3 = this._viewer.getBackground(true);
          e3 && e3 !== vo && (this.lastBgVal = e3), this._viewer.setBackground(vo);
        } else
          this._viewer.getBackground() === this._viewer.scene.getEnvironment() && this._viewer.setBackground(this.lastBgVal || this.bgUIConfig.value);
    }
    async onAdded(e2) {
      var t2;
      await super.onAdded(e2);
      const r2 = e2.getBackground();
      this.bgUIConfig.value = "string" == typeof r2 && r2 !== vo || "number" == typeof r2 || (null === (t2 = r2) || void 0 === t2 ? void 0 : t2.isColor) ? "#" + new Ae(r2).getHexString() : "#000000", this.lastBgVal = r2;
    }
  }
  TT.PluginType = "SimpleBackgroundEnvUiPlugin1";
  class IT extends ro {
    constructor() {
      super(), this.enabled = true, this.toJSON = void 0, this._uiConfig = { type: "folder", label: "Scene Objects", children: [], onExpand: () => {
        var e2, t2;
        null === (t2 = (e2 = this._uiConfig).uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true);
      } }, this._clearSceneButton = { type: "button", label: "Clear Scene", value: () => {
        var e2;
        null === (e2 = this._viewer) || void 0 === e2 || e2.scene.disposeSceneModels();
      } }, this._sceneUpdate = this._sceneUpdate.bind(this);
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("sceneUpdate", this._sceneUpdate);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("sceneUpdate", this._sceneUpdate), super.onRemove(e2);
    }
    setDirty() {
      var e2;
      null === (e2 = this._viewer) || void 0 === e2 || e2.setDirty();
    }
    get uiConfig() {
      var e2, t2, r2;
      return this._viewer ? (this._uiConfig.children = [this._clearSceneButton], this._uiConfig.children.push(...null !== (r2 = null === (t2 = null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.modelRoot.modelObject.children) || void 0 === t2 ? void 0 : t2.map((e3) => "light" === e3.assetType ? null : e3.uiConfig).filter((e3) => null != e3)) && void 0 !== r2 ? r2 : []), this._uiConfig) : this._uiConfig;
    }
    _sceneUpdate() {
      var e2, t2;
      null === (t2 = null === (e2 = this._uiConfig) || void 0 === e2 ? void 0 : e2.uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true);
    }
  }
  IT.PluginType = "SimpleUi";
  var kT = __webpackgi_require__2(1), DT = __webpackgi_require__2.n(kT)();
  class PT extends ro {
    constructor(e2 = true) {
      super(), this.enabled = true, this.toJSON = void 0, this.treeView = void 0, this.hierarchyDiv = St({ innerHTML: "", id: "tpHierarchyContainer", addToBody: false }), this._uiConfig = { type: "folder", label: "Hierarchy", children: [] }, this._buildData = (e3, t2) => (e3.push({ text: t2.name || "unnamed", id: t2.uuid, children: t2.children.reduce(this._buildData, []) }), e3), this._findVisible = (e3, t2) => t2.visible ? (t2.children.length < 1 ? e3.push(t2.uuid) : e3.push(...t2.children.reduce(this._findVisible, [])), e3) : e3, this._setVisible = (e3) => {
        var t2, r2, n2;
        const i2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.modelRoot;
        if (!i2 || null == e3)
          return;
        const s2 = /* @__PURE__ */ new Set();
        i2.traverse((t3) => {
          t3 !== i2 && (t3.visible = e3.includes(t3.uuid), t3.visible && t3.traverseAncestors((e4) => s2.add(e4)));
        }), s2.forEach((e4) => e4.visible = true), null === (n2 = null === (r2 = this._viewer) || void 0 === r2 ? void 0 : r2.scene) || void 0 === n2 || n2.setDirty({ sceneUpdate: true, fromHierarchyPlugin: true, updateGround: false });
      }, this.enabled = e2, this.reset = this.reset.bind(this), Mt(E`
#tpHierarchyContainer{
  width: 100%;
  height: auto;
  background-color: transparent;
  color: #e9e9ed;
  margin-top: 0;
}
`);
    }
    reset(e2) {
      var t2;
      if (null == e2 ? void 0 : e2.fromHierarchyPlugin)
        return;
      if (!(null == e2 ? void 0 : e2.hierarchyChanged))
        return;
      for (; this.hierarchyDiv.firstChild; )
        this.hierarchyDiv.firstChild.remove();
      const r2 = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.modelRoot;
      if (!r2)
        return;
      const n2 = r2.children.reduce(this._buildData, []), i2 = r2.children.reduce(this._findVisible, []);
      let s2 = false;
      return new Promise((e3, t3) => {
        this.treeView = new DT(this.hierarchyDiv, { closeDepth: 1, data: n2, loaded: function() {
          this.values = i2, e3();
        }, onChange: () => {
          s2 ? Dc(200).then(() => {
            this.treeView && this._setVisible(this.treeView.values);
          }) : s2 = true;
        }, onItemLabelClick: (e4) => {
          var t4;
          const n3 = null === (t4 = this._viewer) || void 0 === t4 ? void 0 : t4.scene.modelRoot.modelObject.getObjectByProperty("uuid", e4);
          n3 && r2.visible && n3.dispatchEvent({ type: "select", value: n3, ui: true });
        } });
      });
    }
    async onAdded(e2) {
      await super.onAdded(e2), this.reset(), e2.scene.addEventListener("sceneUpdate", this.reset);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("sceneUpdate", this.reset), super.onRemove(e2);
    }
    async onDispose(e2) {
      return super.onDispose(e2);
    }
    get uiConfig() {
      return this._uiConfig.domChildren || (this._uiConfig.domChildren = [this.hierarchyDiv]), this._uiConfig;
    }
  }
  PT.PluginType = "HierarchyUiPlugin";
  class BT extends ro {
    constructor() {
      super(), this.toJSON = void 0, this.enabled = true, this.uiConfig = { type: "folder", label: "Lights", children: [{ type: "button", label: "Add Directional Light", value: () => {
        if (!this._viewer)
          return;
        const e2 = new Ws();
        e2.position.set(0, 0, 0), e2.target.position.set(0, 0, -1).normalize(), e2.intensity = 2, e2.shadow.mapSize.set(1024, 1024), this._viewer.scene.addLight(e2);
      } }], limitedUi: true }, this.dependencies = [to], this._sceneUpdate = (e2) => {
        var t2, r2, n2;
        if (!e2.hierarchyChanged)
          return;
        const i2 = [];
        null === (t2 = this._viewer) || void 0 === t2 || t2.traverseSceneObjects((e3) => {
          if (!e3.lightObject)
            return;
          const t3 = e3.uiConfig;
          t3 && !i2.includes(t3) && i2.push(t3);
        }), [...this.uiConfig.children].forEach((e3) => {
          var t3;
          "button" === (null === (t3 = e3) || void 0 === t3 ? void 0 : t3.type) || i2.includes(e3) || this.uiConfig.children.splice(this.uiConfig.children.indexOf(e3), 1);
        }), i2.forEach((e3) => {
          this.uiConfig.children.includes(e3) || this.uiConfig.children.push(e3);
        }), null === (n2 = (r2 = this.uiConfig).uiRefresh) || void 0 === n2 || n2.call(r2, "postFrame", true);
      };
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("sceneUpdate", this._sceneUpdate);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("sceneUpdate", this._sceneUpdate), super.onRemove(e2);
    }
  }
  BT.PluginType = "SimpleLightsUi";
  class RT extends ro {
    constructor() {
      super(), this.toJSON = void 0, this.enabled = true, this.uiConfig = { type: "folder", label: "Cameras (Loaded)", children: [{ type: "button", label: "Add Camera", hidden: true }], limitedUi: true }, this.dependencies = [to], this._sceneUpdate = (e2) => {
        var t2, r2, n2;
        if (!e2.hierarchyChanged)
          return;
        const i2 = [];
        null === (t2 = this._viewer) || void 0 === t2 || t2.traverseSceneObjects((e3) => {
          if (!e3.cameraObject)
            return;
          const t3 = e3.uiConfig;
          t3 && !i2.includes(t3) && i2.push(t3);
        }), [...this.uiConfig.children].forEach((e3) => {
          var t3;
          "button" === (null === (t3 = e3) || void 0 === t3 ? void 0 : t3.type) || i2.includes(e3) || this.uiConfig.children.splice(this.uiConfig.children.indexOf(e3), 1);
        }), i2.forEach((e3) => {
          this.uiConfig.children.includes(e3) || this.uiConfig.children.push(e3);
        }), null === (n2 = (r2 = this.uiConfig).uiRefresh) || void 0 === n2 || n2.call(r2, "postFrame", true);
      };
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("sceneUpdate", this._sceneUpdate);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("sceneUpdate", this._sceneUpdate), super.onRemove(e2);
    }
  }
  RT.PluginType = "SimpleSceneCamerasUi";
  var LT, OT = function(e2, t2, r2, n2) {
    var i2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, r2) : n2;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      o2 = Reflect.decorate(e2, t2, r2, n2);
    else
      for (var a2 = e2.length - 1; a2 >= 0; a2--)
        (i2 = e2[a2]) && (o2 = (s2 < 3 ? i2(o2) : s2 > 3 ? i2(t2, r2, o2) : i2(t2, r2)) || o2);
    return s2 > 3 && o2 && Object.defineProperty(t2, r2, o2), o2;
  };
  let FT = LT = class extends ro {
    constructor() {
      super(), this.enabled = true, this.width = 0, this.height = 0, this.scale = 1, this._sizeChanged = this._sizeChanged.bind(this), this._refresh = this._refresh.bind(this);
    }
    refreshSize() {
      this._sizeChanged();
    }
    _sizeChanged() {
      var e2;
      if (!this._viewer)
        return;
      const t2 = { width: Math.round(this.width), height: Math.round(this.height) }, r2 = this._viewer.container.getBoundingClientRect();
      t2.width >= r2.width && delete t2.width, t2.height >= r2.height && delete t2.height, null === (e2 = this._viewer) || void 0 === e2 || e2.setSize(t2), this._viewer.renderer.displayCanvasScaling = this.scale;
    }
    async onAdded(e2) {
      await super.onAdded(e2);
      const t2 = e2.canvas.clientWidth, r2 = e2.canvas.clientHeight, n2 = e2.renderer.displayCanvasScaling;
      this.width = t2, this.height = r2, this.scale = n2, e2.renderer.addEventListener("resize", this._refresh), this.addEventListener("deserialize", this._sizeChanged), this._refresh();
    }
    async onRemove(e2) {
      return this.removeEventListener("deserialize", this._sizeChanged), e2.renderer.removeEventListener("resize", this._refresh), super.onRemove(e2);
    }
    _refresh() {
      var e2, t2;
      null === (t2 = null === (e2 = this.uiConfig) || void 0 === e2 ? void 0 : e2.uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true);
    }
  };
  FT.PluginType = "RendererParamsUiPlugin", OT([Ce(), M(LT.prototype._sizeChanged), $e("Width", void 0, 1, (e2) => ({ bounds: () => {
    var t2;
    return [10, (null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.container.getBoundingClientRect().width) || 1024];
  } }))], FT.prototype, "width", void 0), OT([Ce(), M(LT.prototype._sizeChanged), $e("Height", void 0, 1, (e2) => ({ bounds: () => {
    var t2;
    return [10, (null === (t2 = e2._viewer) || void 0 === t2 ? void 0 : t2.container.getBoundingClientRect().height) || 1024];
  } }))], FT.prototype, "height", void 0), OT([Ce(), M(LT.prototype._sizeChanged), $e("Scale", [0.25, 4], 0.25, { limitedUi: true })], FT.prototype, "scale", void 0), FT = LT = OT([lt("Renderer")], FT);
  class UT extends ro {
    constructor() {
      super(), this.enabled = true, this.serializeWithViewer = false, this._refresh = this._refresh.bind(this);
    }
    async onAdded(e2) {
      await super.onAdded(e2), e2.scene.addEventListener("activeCameraChange", this._refresh), e2.scene.addEventListener("sceneUpdate", this._refresh);
    }
    async onRemove(e2) {
      return e2.scene.removeEventListener("activeCameraChange", this._refresh), e2.scene.removeEventListener("sceneUpdate", this._refresh), super.onRemove(e2);
    }
    toJSON(e2) {
      var t2;
      const r2 = super.toJSON(e2);
      return r2.activeCamera = null === (t2 = this._viewer) || void 0 === t2 ? void 0 : t2.scene.activeCamera.toJSON(), r2;
    }
    fromJSON(e2, t2) {
      var r2;
      return e2.activeCamera && (null === (r2 = this._viewer) || void 0 === r2 || r2.scene.activeCamera.fromJSON(e2.activeCamera), delete (e2 = { ...e2 }).activeCamera), super.fromJSON(e2, t2);
    }
    _refresh() {
      var e2, t2;
      this._viewer && (null === (t2 = (e2 = this.uiConfig).uiRefresh) || void 0 === t2 || t2.call(e2, "postFrame", true));
    }
    get uiConfig() {
      var e2;
      return (null === (e2 = this._viewer) || void 0 === e2 ? void 0 : e2.scene.activeCamera.uiConfig) || {};
    }
  }
  UT.PluginType = "CameraUiPlugin";
  let NT = { create: (e2) => {
    let t2 = "button" + (e2.type ? " " + e2.type : ""), r2 = GT.createDiv(t2, e2.text);
    return r2.addEventListener("click", e2.onClick), r2;
  } };
  var jT = NT;
  let zT = { createElement: (e2, t2, r2, n2) => {
    let i2 = document.createElement(e2);
    if (t2 && (i2.className = t2), r2 && (i2.innerHTML = r2), n2)
      for (let e3 in n2)
        i2.setAttribute(e3, n2[e3]);
    return i2;
  }, createDiv: (e2, t2, r2) => zT.createElement("div", e2, t2, r2), createDomTree: (e2) => {
    if (!e2 || !e2.hasOwnProperty("dom"))
      return e2;
    let t2 = e2.dom;
    if (e2.children)
      for (let r2 in e2.children)
        e2.children[r2] && t2.appendChild(zT.createDomTree(e2.children[r2]));
    return t2;
  }, removeElement: (e2) => {
    null != e2 && e2.parentNode.removeChild(e2);
  }, appendToBody: (e2) => {
    document.body.appendChild(e2);
  }, makeIconHTML: (e2) => {
    let t2 = "";
    return "ok" == e2 && (t2 = "#tick"), "error" == e2 && (t2 = "#cancel"), "info" == e2 && (t2 = "#info-button"), "caution" == e2 && (t2 = "#danger"), "min" == e2 && (t2 = "#line"), "close" == e2 && (t2 = "#close"), `<svg class="icon ${e2}"><use xlink:href="${t2}" /></svg>`;
  }, makeNftContent: (e2) => {
    let t2 = null;
    if (e2.type) {
      let r2 = null;
      r2 = "string" == typeof e2.content ? zT.createDiv("inner-content", e2.content) : zT.createDomTree({ dom: zT.createDiv("inner-content"), children: [e2.content] }), t2 = "text" == e2.type ? zT.createDomTree({ dom: zT.createDiv("content text"), children: [r2] }) : zT.createDomTree({ dom: zT.createDiv("content"), children: [zT.createDiv("state", zT.makeIconHTML(e2.type)), r2] });
    } else
      "string" == typeof e2.content && (t2 = zT.createDiv("content", e2.content));
    return t2;
  }, standardizeButtons: (e2, t2) => {
    let r2 = [];
    if (void 0 === t2.buttons)
      return "caution" != t2.type && "info" != t2.type || r2.push({ key: 27, text: "Cancel", onClick: e2.close.bind(e2, "cancel") }), r2.push({ key: 13, text: "OK", type: "main", onClick: e2.close.bind(e2, "ok") }), r2;
    r2 = t2.buttons, r2.constructor !== Array && (r2 = [r2]);
    for (let t3 in r2)
      !r2[t3].onClick && (r2[t3].onClick = e2.close.bind(e2, r2[t3].id));
    return r2;
  }, makeButtons: (e2) => {
    let t2 = [];
    if (e2)
      for (let r2 in e2)
        t2.push(jT.create({ text: e2[r2].text ? e2[r2].text : "OK", type: e2[r2].normal ? null : "main", onClick: e2[r2].onClick }));
    return zT.createDomTree({ dom: zT.createDiv("button-wrapper"), children: t2 });
  }, bindButtonKeyEvents: (e2) => {
    let t2 = (t3) => {
      for (let r2 in e2)
        if (e2[r2].key === t3.keyCode)
          return void e2[r2].onClick();
    };
    return window.addEventListener("keydown", t2), t2;
  }, unbindButtonKeyEvents: (e2) => {
    window.removeEventListener("keydown", e2);
  } };
  var GT = zT, VT = __webpackgi_require__2(476);
  var QT = { "wwise-overlay-in-1": { opacity: "0" }, "wwise-overlay-in-2": { opacity: "1" }, "wwise-overlay-out-1": { opacity: "0" }, "wwise-pop-in-1": { transform: "scale(0.5, 0.5)", "margin-top": "50px", opacity: ".5" }, "wwise-pop-in-2": { transform: "scale(1, 1)", "margin-top": "0", opacity: "1" }, "wwise-pop-in-3": { transform: "scale(1.05, 1.05)" }, "wwise-pop-in-4": { transform: "scale(1, 1)" }, "wwise-pop-out-1": { transform: "scale(0.25, 0.25)", "margin-top": "50px", opacity: "0" }, "wwise-flip-in-1": { transform: "rotateX(60deg) scaleX(.5)", opacity: ".2" }, "wwise-flip-in-2": { transform: "none", opacity: "1" }, "wwise-flip-out-1": { transform: "rotateX(60deg) scaleX(.5)", opacity: "0" }, "wwise-top-in-1": { transform: "translateY(-30vh)", opacity: ".5" }, "wwise-top-in-2": { transform: "none", opacity: "1" }, "wwise-top-out-1": { transform: "translateY(-30vh)", opacity: "0" }, "wwise-bottom-in-1": { transform: "translateY(30vh)", opacity: ".5" }, "wwise-bottom-in-2": { transform: "none", opacity: "1" }, "wwise-bottom-out-1": { transform: "translateY(30vh)", opacity: "0" }, "wwise-left-in-1": { transform: "translateX(-30vw)", opacity: ".5" }, "wwise-left-in-2": { transform: "none", opacity: "1" }, "wwise-left-out-1": { transform: "translateX(-30vw)", opacity: "0" }, "wwise-right-in-1": { transform: "translateX(30vw)", opacity: ".5" }, "wwise-right-in-2": { transform: "none", opacity: "1" }, "wwise-right-out-1": { transform: "translateX(30vw)", opacity: "0" }, "wwise-min-in-1": { "margin-top": "0", transform: "rotateX(-60deg) scale(0.2, 1.8) translateY(80vh)", opacity: ".2" }, "wwise-min-in-2": { transform: "none", opacity: "1" }, "wwise-min-out-1": { "margin-top": "30vh", transform: "rotateX(-60deg) scale(0.05, 2) translateY(30vh)", opacity: "0" } };
  let HT = {};
  HT.overlay_in = [new VT.Frame(QT["wwise-overlay-in-1"], 0), new VT.Frame(QT["wwise-overlay-in-2"], 400)], HT.overlay_out = [new VT.Frame(QT["wwise-overlay-out-1"], 300)], HT.pop_in = [new VT.Frame(QT["wwise-pop-in-1"], 0), new VT.Frame(QT["wwise-pop-in-2"], { duration: 200, "timing-function": "ease-in" }), new VT.Frame(QT["wwise-pop-in-3"], { duration: 100, "timing-function": "linear" }), new VT.Frame(QT["wwise-pop-in-4"], { duration: 100, "timing-function": "linear" })], HT.pop_out = [new VT.Frame(QT["wwise-pop-out-1"], { duration: 250, "timing-function": "ease-in" })], HT.flip_in = [new VT.Frame(QT["wwise-flip-in-1"], 0), new VT.Frame(QT["wwise-flip-in-2"], 500)], HT.flip_out = [new VT.Frame(QT["wwise-flip-out-1"], 400)], HT.min_in = [new VT.Frame(QT["wwise-min-in-1"], 0), new VT.Frame(QT["wwise-min-in-2"], 350)], HT.min_out = [new VT.Frame(QT["wwise-min-out-1"], 400)];
  let WT = ["top", "bottom", "left", "right"];
  for (let e2 in WT) {
    let t2 = WT[e2];
    HT[t2 + "_in"] = [new VT.Frame(QT["wwise-" + t2 + "-in-1"], 0), new VT.Frame(QT["wwise-" + t2 + "-in-2"], { duration: 400, "timing-function": "ease-out" })], HT[t2 + "_out"] = [new VT.Frame(QT["wwise-" + t2 + "-out-1"], { duration: 400, "timing-function": "ease-in" })];
  }
  var qT = HT;
  let XT = { animation: "pop", topbar: { showClose: true, showMin: false }, keepOverlay: false, position: "center", overlay: false, clickOverlayToClose: true, removeBackground: false, noRadius: false, zIndex: null };
  class YT {
    static create(e2, t2) {
      let r2 = e2.getElementsByClassName("title")[0];
      r2 && (r2 = r2.innerHTML);
      let n2 = e2.getElementsByClassName("content")[0];
      return n2 && (n2 = n2.innerHTML), GT.removeElement(e2), t2.title = r2, t2.content = n2, new YT(t2);
    }
    constructor(e2) {
      this.options = JSON.parse(JSON.stringify(XT));
      for (let t3 in e2)
        null != e2[t3] && (this.options[t3] = e2[t3]);
      let t2 = this.options.position;
      if (-1 == t2.indexOf(" ") && ("left" == t2 || "right" == t2 ? t2 += " center" : t2 = "top" == t2 || "bottom" == t2 ? "center " + t2 : t2 + " " + t2), this.options.position = t2, this.options.overlay) {
        let e3 = document.getElementsByClassName("wwise-overlay");
        e3.length ? (this.overlay = e3[0], this.hasOverlay = true) : (this.overlay = GT.createDiv("wwise-overlay"), this.options.zIndex && (this.overlay.style.zIndex = this.options.zIndex)), this.overlayClickHandler = this.close.bind(this, void 0);
      } else
        this.options.clickOverlayToClose = false;
      let r2 = "content";
      if (this.options.topbar) {
        let e3 = [];
        this.options.topbar.showMin && (e3.push(GT.createDiv(null, GT.makeIconHTML("min"))), e3[e3.length - 1].addEventListener("click", this.min.bind(this))), this.options.topbar.showClose && (e3.push(GT.createDiv(null, GT.makeIconHTML("close"))), e3[e3.length - 1].addEventListener("click", this.close.bind(this, void 0)));
        let t3 = null;
        t3 = "string" == typeof this.options.title ? GT.createDiv("title", this.options.title) : GT.createDomTree({ dom: GT.createDiv("title"), children: [this.options.title] }), this.topbar = GT.createDomTree({ dom: GT.createDiv("topbar"), children: [{ dom: GT.createDiv("control"), children: e3.map((e4) => ({ dom: e4 })) }, { dom: t3 }, { dom: GT.createDiv("clear") }] });
      } else
        r2 += " no-topbar";
      "string" == typeof this.options.content ? this.content = GT.createDomTree({ dom: GT.createDiv(r2, this.options.content) }) : this.content = GT.createDomTree({ dom: GT.createDiv(r2), children: [this.options.content] }), this.options.removeBackground && (this.content.style.background = "initial"), this.window = GT.createDomTree({ dom: GT.createDiv("wwise" + (this.options.noRadius ? " no-radius" : "")), children: [this.topbar, this.content] });
      let n2 = GT.createDiv("wwise-wrapper");
      this.options.zIndex && (n2.style.zIndex = this.options.zIndex), this.wrapper = GT.createDomTree({ dom: n2, children: [this.window] }), this.dom = GT.createDomTree({ dom: GT.createDiv(), children: [this.wrapper] });
      let i2 = this.options.position.split(" "), s2 = -50, o2 = -50;
      if ("left" == i2[0] ? (s2 = 0, this.wrapper.classList.add("left")) : "right" == i2[0] ? (s2 = -100, this.wrapper.classList.add("right")) : "center" == i2[0] ? this.wrapper.classList.add("h-center") : this.wrapper.style.left = i2[0], "top" == i2[1] ? (o2 = 0, this.wrapper.classList.add("top")) : "bottom" == i2[1] ? (o2 = -100, this.wrapper.classList.add("bottom")) : "center" == i2[1] ? this.wrapper.classList.add("v-center") : this.wrapper.style.top = t2[1], this.window.style.transform = `translate(${s2}%, ${o2}%)`, this.options.style)
        for (let e3 in this.options.style)
          this.window.style[e3] = this.options.style[e3];
      this.options.margin && (this.wrapper.style.margin = this.options.margin), this.options.draggable && this.draggable();
    }
    open(e2) {
      if (this.opened)
        return;
      this.promise = new Promise((e3) => {
        this.promiseResolve = e3;
      }), this.appendDoms(), this.opened = true, this.options.clickOverlayToClose && (this.overlay.addEventListener("click", this.overlayClickHandler), this.overlay.addEventListener("touchstart", this.overlayClickHandler));
      let t2 = e2 ? "min" : this.options.animation;
      if (t2) {
        "min" != t2 && "flip" != t2 || this.dom.classList.add("wwise-perspective");
        let e3 = [new VT.Queue(this.wrapper, qT[t2 + "_in"], { instant: true, applyOnEnd: true }).getPromise()];
        return this.options.overlay && !this.hasOverlay && e3.push(new VT.Queue(this.overlay, qT.overlay_in, { instant: true, applyOnEnd: true }).getPromise()), Promise.all(e3).then(() => {
          this.dom.classList.remove("wwise-perspective");
        });
      }
      return Promise.resolve();
    }
    close(e2) {
      if (!this.opened)
        return;
      this.opened = false;
      let t2 = e2 ? "min" : this.options.animation;
      if (this.overlay && (this.overlay.removeEventListener("click", this.overlayClickHandler), this.overlay.removeEventListener("touchstart", this.overlayClickHandler)), t2) {
        "min" != t2 && "flip" != t2 || this.dom.classList.add("wwise-perspective");
        let e3 = [new VT.Queue(this.wrapper, qT[t2 + "_out"], { instant: true, applyOnEnd: true }).getPromise()];
        return this.options.overlay && !this.options.keepOverlay && e3.push(new VT.Queue(this.overlay, qT.overlay_out, { instant: true, applyOnEnd: true }).getPromise()), Promise.all(e3).then(() => {
          this.removeDoms(), this.dom.classList.remove("wwise-perspective"), this.promiseResolve();
        });
      }
      return this.removeDoms(), this.promiseResolve(), Promise.resolve();
    }
    min() {
      return this.close(true);
    }
    resume() {
      return this.open(true);
    }
    getPromise() {
      return this.promise;
    }
    appendDoms() {
      this.options.overlay && !this.hasOverlay && (GT.appendToBody(this.overlay), document.body.classList.add("wwise-no-scroll"), this.overlay.addEventListener("touchstart", (e2) => {
        e2.preventDefault();
      })), GT.appendToBody(this.dom);
    }
    removeDoms() {
      GT.removeElement(this.dom), !this.options.keepOverlay && this.overlay && (GT.removeElement(this.overlay), document.body.classList.remove("wwise-no-scroll"));
    }
    draggable(e2 = true) {
      this.topbar && (e2 ? (this.draggableMouseMoveHandler = this.handleDraggableMouseMove.bind(this), this.draggableMouseDownHandler = this.handleDraggableMouseDown.bind(this), this.draggableMouseUpHandler = this.handleDraggableMouseUp.bind(this), this.draggableMouseOutHandler = this.handleDraggableMouseOut.bind(this), window.addEventListener("mousemove", this.draggableMouseMoveHandler), window.addEventListener("mouseout", this.draggableMouseOutHandler), this.topbar.addEventListener("mousedown", this.draggableMouseDownHandler), window.addEventListener("mouseup", this.draggableMouseUpHandler)) : (window.removeEventListener("mousemove", this.draggableMouseMoveHandler), window.removeEventListener("mouseout", this.draggableMouseOutHandler), this.topbar.removeEventListener("mousedown", this.draggableMouseDownHandler), window.removeEventListener("mouseup", this.draggableMouseUpHandler)));
    }
    handleDraggableMouseMove(e2) {
      if (this.inDragging) {
        let t2 = { x: e2.clientX - this.dragPrev.x, y: e2.clientY - this.dragPrev.y }, r2 = window.getComputedStyle(this.wrapper), n2 = this.options.draggable, i2 = parseFloat(r2.left), s2 = parseFloat(r2.top);
        if (-1 != r2.left.indexOf("%")) {
          i2 = r2.left, i2 = i2.substr(0, i2.length - 1), i2 = parseInt(i2);
          let e3 = window, t3 = document, n3 = t3.documentElement, s3 = t3.getElementsByTagName("body")[0];
          i2 = i2 * (e3.innerWidth || n3.clientWidth || s3.clientWidth) / 100;
        }
        if (-1 != r2.top.indexOf("%")) {
          s2 = r2.top, s2 = s2.substr(0, s2.length - 1), s2 = parseInt(s2);
          let e3 = window, t3 = document, n3 = t3.documentElement, i3 = t3.getElementsByTagName("body")[0];
          s2 = s2 * (e3.innerHeight || n3.clientHeight || i3.clientHeight) / 100;
        }
        1 != n2 && "horizontal" != n2 || (this.wrapper.style.left = i2 + t2.x + "px"), 1 != n2 && "vertical" != n2 || (this.wrapper.style.top = s2 + t2.y + "px"), this.dragPrev = { x: e2.clientX, y: e2.clientY };
      }
    }
    handleDraggableMouseDown(e2) {
      this.inDragging = true, this.dragPrev = { x: e2.clientX, y: e2.clientY };
    }
    handleDraggableMouseUp(e2) {
      this.inDragging = false;
    }
    handleDraggableMouseOut(e2) {
      let t2 = e2.relatedTarget;
      t2 && "HTML" != t2.nodeName || (this.inDragging = false);
    }
  }
  var KT = YT, JT = class {
    constructor(e2) {
      let t2 = this.options = e2;
      !t2.type && (t2.type = "ok");
      let r2 = { topbar: false };
      r2.content = this.constructContent({ type: t2.type, title: t2.title, text: t2.text, content: t2.content, buttons: t2.buttons }), r2.overlay = true, r2.keepOverlay = t2.keepOverlay, r2.clickOverlayToClose = false, r2.animation = t2.animation, r2.zIndex = t2.zIndex, this.wwise = new KT(r2);
    }
    constructContent(e2) {
      let t2 = GT.createDiv("modal"), r2 = GT.createDomTree({ dom: GT.createDiv("main " + e2.type), children: [GT.createDiv(null, GT.makeIconHTML(e2.type)), GT.createDiv("title", e2.title), GT.createDiv("text", e2.text)] });
      this.buttonArr = GT.standardizeButtons(this, e2);
      let n2 = GT.makeButtons(this.buttonArr), i2 = null;
      e2.content && (i2 = "string" == typeof e2.content ? GT.createDiv(null, e2.content) : e2.content);
      let s2 = null;
      return n2.innerHTML && (s2 = GT.createDomTree({ dom: GT.createDiv("operation " + e2.type), children: [n2] })), i2 || s2 || r2.classList.add("no-op"), GT.createDomTree({ dom: t2, children: [r2, i2, s2] });
    }
    open() {
      if (this.wwise.opened)
        return;
      let e2 = this.wwise.open();
      return this.value = void 0, this.promise = new Promise((e3) => {
        this.promiseResolve = e3;
      }), this.wwise.getPromise().then(this.handlePromiseResolve.bind(this)), this.keyHandler = GT.bindButtonKeyEvents(this.buttonArr), this.options.closeAfter && window.setTimeout(() => {
        this.close("timer");
      }, this.options.closeAfter), e2;
    }
    close(e2) {
      if (this.wwise.opened)
        return this.value = e2, GT.unbindButtonKeyEvents(this.keyHandler), this.wwise.close();
    }
    getPromise() {
      return this.promise;
    }
    handlePromiseResolve() {
      this.promiseResolve(this.value);
    }
  };
  let ZT = { showCancel: false, okText: "OK", cancelText: "Cancel", placeholder: "", validator: null }, $T = { type: "info", keepOverlay: false, title: "Input", text: "", zIndex: null };
  var eI = __webpackgi_require__2(513), tI = {};
  eI.Z && eI.Z.locals && (tI.locals = eI.Z.locals);
  var rI, nI = 0, iI = {};
  iI.styleTagTransform = cp(), iI.setAttributes = sp(), iI.insert = function(e2, t2) {
    (t2.target || document.head).appendChild(e2);
  }, iI.domAPI = np(), iI.insertStyleElement = ap(), tI.use = function(e2) {
    return iI.options = e2 || {}, nI++ || (rI = tp()(eI.Z, iI)), tI;
  }, tI.unuse = function() {
    nI > 0 && !--nI && (rI(), rI = null);
  };
  var sI = tI;
  class oI extends ro {
    constructor() {
      super(...arguments), this.enabled = true, this.toJSON = void 0, this._previousMappings = {};
    }
    async onAdded(e2) {
      await super.onAdded(e2), this._previousMappings = { alert: e2.alert, confirm: e2.confirm, prompt: e2.prompt }, GT.appendToBody = (t2) => {
        e2.container.appendChild(t2);
      }, GT.makeIconHTML = (e3) => "", sI.use({ target: e2.container }), e2.alert = async (e3) => {
        const t2 = null == e3 ? void 0 : e3.split(":")[0], r2 = new JT({ type: "info", title: null != t2 ? t2 : "&ndsp;", text: (null == e3 ? void 0 : e3.replace(t2 + ":", "")) || "", buttons: [{ key: 13, text: "OK", type: "main", id: "ok" }], animation: "overlay" });
        return r2.open(), r2.getPromise();
      }, e2.confirm = async (e3) => {
        const t2 = null == e3 ? void 0 : e3.split(":")[0], r2 = new JT({ type: "info", title: null != t2 ? t2 : "&ndsp;", text: (null == e3 ? void 0 : e3.replace(t2 || "", "").replace(":", "")) || "", buttons: [{ id: "no", key: 27, text: "No", normal: true }, { id: "yes", key: 13, text: "Yes" }], animation: "overlay" });
        return r2.open(), "yes" === await r2.getPromise();
      }, e2.prompt = async (e3, t2, r2 = true) => {
        const n2 = null == e3 ? void 0 : e3.split(":")[0], i2 = new class {
          constructor(e4) {
            this.options = JSON.parse(JSON.stringify(ZT));
            for (let t4 in e4)
              null != e4[t4] && (this.options[t4] = e4[t4]);
            let t3 = this.options, r3 = JSON.parse(JSON.stringify($T));
            for (let e5 in r3)
              t3.hasOwnProperty(e5) && (r3[e5] = t3[e5]);
            let n3 = [];
            t3.showCancel && n3.push({ key: 27, text: t3.cancelText, normal: true, onClick: this.handleCancel.bind(this) }), n3.push({ key: 13, text: t3.okText, onClick: this.handleOk.bind(this) }), r3.buttons = n3, this.input = GT.createElement("input", "input", null, { placeholder: t3.placeholder }), this.error = GT.createDiv("error"), r3.content = GT.createDomTree({ dom: GT.createDiv("input-wrapper"), children: [this.input, this.error] }), this.modal = new JT(r3);
          }
          handleCancel() {
            this.close().then(this.promiseReject.bind(this));
          }
          handleOk() {
            this.options.validator ? this.options.validator(this.input.value).then(() => {
              this.close().then(this.promiseResolve.bind(this, this.input.value));
            }, (e4) => {
              this.error.innerText = e4;
            }) : this.close().then(this.promiseResolve.bind(this, this.input.value));
          }
          open() {
            if (this.modal.wwise.opened)
              return;
            let e4 = this.modal.open();
            return this.input.value = "", this.error.innerText = "", this.input.focus(), this.promise = new Promise((e5, t3) => {
              this.promiseResolve = e5, this.promiseReject = t3;
            }), e4;
          }
          close() {
            if (this.modal.wwise.opened)
              return this.modal.close();
          }
          getPromise() {
            return this.promise;
          }
        }({ type: "info", title: null != n2 ? n2 : "&ndsp;", placeholder: null != t2 ? t2 : "", showCancel: r2, animation: "overlay", text: (null == e3 ? void 0 : e3.replace(n2 || "", "").replace(":", "")) || "" });
        return i2.open(), await i2.getPromise().catch(async () => null);
      };
    }
    async onRemove(e2) {
      return e2.alert = this._previousMappings.alert, e2.confirm = this._previousMappings.confirm, e2.prompt = this._previousMappings.prompt, super.onRemove(e2);
    }
  }
  oI.PluginType = "WindowiseDialogPlugin";
  var aI = Yx({ defaultModifiers: [Zx, nw, ow, aw] }), lI = __webpackgi_require__2(388), cI = __webpackgi_require__2.n(lI);
  function uI(e2) {
    const t2 = [];
    e2.traverse((e3) => {
      e3.geometry && t2.push(e3);
    });
    const r2 = {}, n2 = {};
    t2.forEach((e3) => {
      var t3;
      if (!r2[e3.geometry.uuid]) {
        const t4 = e3.geometry.toJSON().data, n3 = t4 ? cI()({ a: t4.attributes || {}, b: t4.index || [] }) : "";
        r2[e3.geometry.uuid] = n3;
      }
      const i2 = r2[e3.geometry.uuid], s2 = null !== (t3 = n2[i2]) && void 0 !== t3 ? t3 : n2[i2] = [];
      s2.includes(e3) || s2.push(e3);
    }), Object.values(n2).forEach((e3) => {
      if (e3.length < 2)
        return;
      const t3 = e3[0].geometry;
      e3.forEach((e4, r3) => {
        r3 < 1 || (e4.geometry.dispose(), e4.geometry = t3);
      });
    });
  }
  const hI = new n.Pa4(), pI = new n.Pa4(), dI = new n.Pa4(), fI = new n.Pa4(), mI = new n.Pa4(), _I = new n.Pa4();
  let gI = 1;
  const vI = new n.Pa4(0, 1, 0);
  class AI extends pt {
    constructor(e2, t2) {
      super(e2, t2), this.targetOffset = new n.Pa4(0, 0, 0);
      const r2 = this.update;
      this.update = () => this._update(r2);
    }
    _update(e2) {
      this.target.add(this.targetOffset), hI.copy(this.object.position).sub(this.target), gI = hI.length(), _I.copy(this.target);
      const t2 = e2();
      return _I.sub(this.target), hI.copy(this.object.position).sub(this.target), gI /= hI.length(), this.target.add(_I), this.object.position.copy(this.target).add(hI), hI.normalize(), pI.crossVectors(vI, hI).normalize(), dI.crossVectors(hI, pI).normalize(), fI.crossVectors(pI, dI).normalize().negate(), pI.length() > 0.1 && this.object.up.crossVectors(hI.clone().normalize(), pI), this.enablePan && (mI.set(0, 0, 0).addScaledVector(pI, _I.x).addScaledVector(dI, _I.y).addScaledVector(fI, _I.z), this.targetOffset.add(mI), this.targetOffset.multiplyScalar(1 / gI)), mI.set(0, 0, 0).addScaledVector(pI, -this.targetOffset.x).addScaledVector(dI, -this.targetOffset.y).addScaledVector(fI, -this.targetOffset.z), this.object.lookAt(mI.add(this.target)), this.object.updateMatrixWorld(), this.object.isCamera && this.object.updateProjectionMatrix(), this.target.sub(this.targetOffset), t2;
    }
  }
  class bI extends ja {
    constructor() {
      super(), this.boundingScaleMultiplier = 1.2, this._initGeometry(new n.cJO(1, 0));
    }
  }
  function yI(e2, t2) {
    var r2, n2;
    const i2 = Array.from((null !== (r2 = e2.access) && void 0 !== r2 ? r2 : "").split(".")), s2 = i2.pop();
    let o2 = null !== (n2 = e2.targetObject) && void 0 !== n2 ? n2 : t2;
    if (!s2 || 0 === s2.length)
      return { key: void 0, tar: o2 };
    if (o2 = g(i2, o2), o2 && !(s2 in o2))
      throw console.error("invalid key", s2, o2, t2, e2), "";
    return { key: s2, tar: o2 };
  }
  function xI(e2, t2, r2, n2) {
    const { key: i2, tar: s2 } = yI(e2, t2);
    return i2 && s2 ? Pc(s2, i2, () => {
      var t3;
      r2 && (null === (t3 = e2.updater) || void 0 === t3 ? void 0 : t3.length) && e2.updater.forEach((e3) => r2[e3]()), null == n2 || n2();
    }) : (r3) => console.warn("Unable to set ", r3, i2, s2, e2, t2);
  }
  async function wI(e2, t2, r2) {
    var n2, i2, s2, o2;
    const { key: a2, tar: l2 } = yI(t2, e2), c2 = t2.animSet ? [EI(l2, t2.animSet, r2, null !== (n2 = t2.animSetParallel) && void 0 !== n2 && n2)] : [];
    if (a2 && l2) {
      const e3 = null !== (o2 = t2.updater) && void 0 !== o2 ? o2 : [], n3 = async () => Rc(l2, a2, { ...t2, onUpdate: (n4) => {
        var i3;
        null === (i3 = t2.onUpdate) || void 0 === i3 || i3.call(t2, n4), e3.forEach((e4) => {
          var t3;
          return null === (t3 = r2[e4]) || void 0 === t3 ? void 0 : t3.call(r2);
        });
      } });
      t2.delay ? c2.push(Dc(t2.delay).then(n3)) : c2.push(n3());
    } else
      (t2.duration || t2.delay) && c2.push(Dc((null !== (i2 = t2.delay) && void 0 !== i2 ? i2 : 0) + (null !== (s2 = t2.duration) && void 0 !== s2 ? s2 : 0)));
    return 1 === c2.length ? c2[0] : Promise.all(c2);
  }
  async function EI(e2, t2, r2, n2 = false) {
    if (n2)
      return Promise.all(t2.map(async (t3) => wI(e2, t3, r2)));
    for (const n3 of t2)
      await wI(e2, n3, r2);
  }
  function SI(e2, t2, r2, n2) {
    var i2, s2, o2, a2, l2, c2, u2;
    if (!e2)
      return;
    t2 || (t2 = []);
    const h2 = null != n2 ? n2 : {}, p2 = e2;
    for (let e3 = 0, d2 = t2.length; e3 < d2; e3++) {
      const d3 = t2[e3];
      if (d3.uiRef) {
        const t3 = null !== (l2 = null == p2 ? void 0 : p2.indexOf(d3.uiRef)) && void 0 !== l2 ? l2 : -1;
        t3 !== e3 && (t3 >= 0 && (null == p2 || p2.splice(t3, 1)), null == p2 || p2.splice(e3, 0, d3.uiRef));
      } else {
        d3.uiRef = { type: "folder", label: null !== (i2 = d3.name) && void 0 !== i2 ? i2 : "Animation " + e3, children: [] };
        const t3 = [{ type: "button", label: "animate", value: () => {
          wI(r2, d3, h2).then(() => {
            var e4;
            return console.log((null === (e4 = d3.uiRef) || void 0 === e4 ? void 0 : e4.label) + " finished");
          });
        } }];
        void 0 !== d3.access && t3.push({ type: "input", property: [d3, "access"] }), void 0 !== d3.from && t3.push({ type: null !== (s2 = d3.uiObjectType) && void 0 !== s2 ? s2 : "input", property: [d3, "from"], onChange: () => {
          var e4;
          xI(d3, r2)(d3.from), null === (e4 = d3.updater) || void 0 === e4 || e4.forEach((e5) => e5 in h2 && h2[e5]());
        } }), void 0 !== d3.to && t3.push({ type: null !== (o2 = d3.uiObjectType) && void 0 !== o2 ? o2 : "input", property: [d3, "to"], onChange: () => {
          var e4;
          xI(d3, r2)(d3.to), null === (e4 = d3.updater) || void 0 === e4 || e4.forEach((e5) => e5 in h2 && h2[e5]());
        } }), void 0 !== d3.duration && t3.push({ type: "input", property: [d3, "duration"] }), d3.animSet && (d3.animSetParallel || (d3.animSetParallel = false), t3.push({ type: "input", label: "run parallel", property: [d3, "animSetParallel"] })), d3.animSet && t3.push({ type: "folder", label: "AnimSet", expanded: false, children: [], animSetContainer: true }), null === (a2 = d3.uiRef.children) || void 0 === a2 || a2.push(...t3), null == p2 || p2.splice(e3, 0, d3.uiRef);
      }
      const f2 = null === (c2 = d3.uiRef.children) || void 0 === c2 ? void 0 : c2.map((e4) => A(e4)).flat(2).find((e4) => null == e4 ? void 0 : e4.animSetContainer);
      d3.animSet && f2 && SI(f2.children, d3.animSet, null !== (u2 = d3.targetObject) && void 0 !== u2 ? u2 : r2, n2);
    }
  }
  function CI(e2, t2) {
    return t2 ? e2 * (1e3 / t2) : 0;
  }
  function MI(e2) {
    var t2, r2 = e2.from, n2 = void 0 === r2 ? 0 : r2, i2 = e2.velocity, s2 = void 0 === i2 ? 0 : i2, o2 = e2.min, a2 = e2.max, l2 = e2.power, c2 = void 0 === l2 ? 0.8 : l2, u2 = e2.timeConstant, h2 = void 0 === u2 ? 750 : u2, p2 = e2.bounceStiffness, d2 = void 0 === p2 ? 500 : p2, f2 = e2.bounceDamping, m2 = void 0 === f2 ? 10 : f2, _2 = e2.restDelta, g2 = void 0 === _2 ? 1 : _2, v2 = e2.modifyTarget, A2 = e2.driver, b2 = e2.onUpdate, y2 = e2.onComplete;
    function x2(e3) {
      return void 0 !== o2 && e3 < o2 || void 0 !== a2 && e3 > a2;
    }
    function w2(e3) {
      return void 0 === o2 ? a2 : void 0 === a2 || Math.abs(o2 - e3) < Math.abs(a2 - e3) ? o2 : a2;
    }
    function E2(e3) {
      null == t2 || t2.stop(), t2 = Ic(al(al({}, e3), { driver: A2, onUpdate: function(t3) {
        var r3;
        null == b2 || b2(t3), null === (r3 = e3.onUpdate) || void 0 === r3 || r3.call(e3, t3);
      }, onComplete: y2 }));
    }
    function S2(e3) {
      E2(al({ type: "spring", stiffness: d2, damping: m2, restDelta: g2 }, e3));
    }
    if (x2(n2))
      S2({ from: n2, velocity: s2, to: w2(n2) });
    else {
      var C2 = c2 * s2 + n2;
      void 0 !== v2 && (C2 = v2(C2));
      var M2, T2, I2 = w2(C2), k2 = I2 === o2 ? -1 : 1;
      E2({ type: "decay", from: n2, velocity: s2, timeConstant: h2, power: c2, restDelta: g2, modifyTarget: v2, onUpdate: x2(C2) ? function(e3) {
        M2 = T2, T2 = e3, s2 = CI(e3 - M2, Sc().delta), (1 === k2 && e3 > I2 || -1 === k2 && e3 < I2) && S2({ from: e3, to: I2, velocity: s2 });
      } : void 0 });
    }
    return { stop: function() {
      return null == t2 ? void 0 : t2.stop();
    } };
  }
  var TI = function(e2) {
    return 180 * e2 / Math.PI;
  }, II = function(e2, t2) {
    return void 0 === t2 && (t2 = Kl), TI(Math.atan2(t2.y - e2.y, t2.x - e2.x));
  }, kI = function(e2, t2) {
    var r2 = true;
    return void 0 === t2 && (t2 = e2, r2 = false), function(n2) {
      return r2 ? n2 - e2 + t2 : (e2 = n2, r2 = true, t2);
    };
  }, DI = function(e2) {
    return e2;
  }, PI = function(e2) {
    return void 0 === e2 && (e2 = DI), function(t2, r2, n2) {
      var i2 = r2 - n2, s2 = -(0 - t2 + 1) * (0 - e2(Math.abs(i2)));
      return i2 <= 0 ? r2 + s2 : r2 - s2;
    };
  }, BI = PI(), RI = PI(Math.sqrt), LI = function(e2) {
    return e2 * Math.PI / 180;
  }, OI = function(e2) {
    return e2.hasOwnProperty("x") && e2.hasOwnProperty("y");
  }, FI = function(e2) {
    return OI(e2) && e2.hasOwnProperty("z");
  }, UI = function(e2, t2) {
    return Math.abs(e2 - t2);
  };
  function NI(e2, t2) {
    if (Jl(e2) && Jl(t2))
      return UI(e2, t2);
    if (OI(e2) && OI(t2)) {
      var r2 = UI(e2.x, t2.x), n2 = UI(e2.y, t2.y), i2 = FI(e2) && FI(t2) ? UI(e2.z, t2.z) : 0;
      return Math.sqrt(Math.pow(r2, 2) + Math.pow(n2, 2) + Math.pow(i2, 2));
    }
  }
  var jI = function(e2, t2, r2) {
    return t2 = LI(t2), { x: r2 * Math.cos(t2) + e2.x, y: r2 * Math.sin(t2) + e2.y };
  }, zI = function(e2, t2) {
    return void 0 === t2 && (t2 = 2), t2 = Math.pow(10, t2), Math.round(e2 * t2) / t2;
  }, GI = function(e2, t2, r2, n2) {
    return void 0 === n2 && (n2 = 0), zI(e2 + r2 * (t2 - e2) / Math.max(n2, r2));
  }, VI = function(e2) {
    void 0 === e2 && (e2 = 50);
    var t2 = 0, r2 = 0;
    return function(n2) {
      var i2 = Sc().timestamp, s2 = i2 !== r2 ? i2 - r2 : 0, o2 = s2 ? GI(t2, n2, s2, e2) : t2;
      return r2 = i2, t2 = o2, o2;
    };
  }, QI = function(e2) {
    if ("number" == typeof e2)
      return function(t3) {
        return Math.round(t3 / e2) * e2;
      };
    var t2 = 0, r2 = e2.length;
    return function(n2) {
      var i2 = Math.abs(e2[0] - n2);
      for (t2 = 1; t2 < r2; t2++) {
        var s2 = e2[t2], o2 = Math.abs(s2 - n2);
        if (0 === o2)
          return s2;
        if (o2 > i2)
          return e2[t2 - 1];
        if (t2 === r2 - 1)
          return s2;
        i2 = o2;
      }
    };
  };
  function HI(e2, t2) {
    return e2 / (1e3 / t2);
  }
  var WI = function(e2, t2, r2) {
    var n2 = t2 - e2;
    return ((r2 - e2) % n2 + n2) % n2 + e2;
  }, qI = function(e2, t2) {
    return 1 - 3 * t2 + 3 * e2;
  }, XI = function(e2, t2) {
    return 3 * t2 - 6 * e2;
  }, YI = function(e2) {
    return 3 * e2;
  }, KI = function(e2, t2, r2) {
    return ((qI(t2, r2) * e2 + XI(t2, r2)) * e2 + YI(t2)) * e2;
  }, JI = function(e2, t2, r2) {
    return 3 * qI(t2, r2) * e2 * e2 + 2 * XI(t2, r2) * e2 + YI(t2);
  }, ZI = 0.1;
  function $I(e2, t2, r2, n2) {
    if (e2 === t2 && r2 === n2)
      return qa;
    for (var i2 = new Float32Array(11), s2 = 0; s2 < 11; ++s2)
      i2[s2] = KI(s2 * ZI, e2, r2);
    return function(s3) {
      return 0 === s3 || 1 === s3 ? s3 : KI(function(t3) {
        for (var n3 = 0, s4 = 1; 10 !== s4 && i2[s4] <= t3; ++s4)
          n3 += ZI;
        --s4;
        var o2 = n3 + (t3 - i2[s4]) / (i2[s4 + 1] - i2[s4]) * ZI, a2 = JI(o2, e2, r2);
        return a2 >= 1e-3 ? function(e3, t4, r3, n4) {
          for (var i3 = 0; i3 < 8; ++i3) {
            var s5 = JI(t4, r3, n4);
            if (0 === s5)
              return t4;
            t4 -= (KI(t4, r3, n4) - e3) / s5;
          }
          return t4;
        }(t3, o2, e2, r2) : 0 === a2 ? o2 : function(e3, t4, r3, n4, i3) {
          var s5, o3, a3 = 0;
          do {
            (s5 = KI(o3 = t4 + (r3 - t4) / 2, n4, i3) - e3) > 0 ? r3 = o3 : t4 = o3;
          } while (Math.abs(s5) > 1e-7 && ++a3 < 10);
          return o3;
        }(t3, n3, n3 + ZI, e2, r2);
      }(s3), t2, n2);
    };
  }
  var ek = function(e2, t2) {
    return void 0 === t2 && (t2 = "end"), function(r2) {
      var n2 = (r2 = "end" === t2 ? Math.min(r2, 0.999) : Math.max(r2, 1e-3)) * e2, i2 = "end" === t2 ? Math.floor(n2) : Math.ceil(n2);
      return cl(0, 1, i2 / e2);
    };
  };
  async function tk(e2, { debug: t2 = false, ground: r2 = true, bloom: n2 = true, depthTonemap: i2 = false, importPopup: s2 = true, caching: o2 = true }) {
    const a2 = new go(e2);
    a2.enabled = false, t2 && await a2.addPlugin(Yc), await a2.addPlugin(to, void 0, void 0, { storage: o2 && window.caches ? await window.caches.open("webgi-cache-storage") : void 0 }), await a2.addPlugin(tg), await a2.addPlugin(Vb), s2 && await a2.addPlugin(vp), await a2.addPlugin(oI), await a2.addPlugin(m_), await a2.addPlugin(qm), await a2.addPlugin(Zm), await a2.addPlugin(t_), await a2.addPlugin(ym), await a2.addPlugin(v_), await a2.addPlugin($m), await a2.addPlugin(wo), await a2.addPlugin(Nc, za, false, true), await Wp(a2, { ground: r2, bloom: n2, depthTonemap: i2 }), await a2.addPlugin(CE, false), await a2.addPlugin(wE, false), await a2.addPlugin(Ob, false), await a2.addPlugin(Nb, false), await a2.addPlugin(UM), await a2.addPlugin(HM), await a2.addPlugin(eT), await a2.addPlugin(vy, false), await a2.addPlugin(bE), await a2.addPlugin(DE), await a2.addPlugin(WE), await a2.addPlugin(dE), await a2.addPlugin(ME), await a2.addPlugin(mE), await a2.addPlugin(Ny), await a2.addPlugin($u), await a2.addPlugin(PT), await a2.addPlugin(IT), await a2.addPlugin(BT), await a2.addPlugin(RT), await a2.addPlugin(FT), await a2.addPlugin(UT), await a2.addPlugin(TT);
    const l2 = await a2.addPlugin(new MT(!Pt()));
    return a2.renderer.refreshPipeline(), a2.scene.addEventListener("textureAdded", (e3) => {
      e3.texture && a2.scene.setEnvironment(e3.texture);
    }), l2.setupPluginUi(yo), l2.setupPluginUi(FT), l2.setupPluginUi(UT), l2.setupPluginUi(wo), l2.setupPluginUi(TT), l2.setupPluginUi(tg), l2.setupPluginUi(Wc), l2.setupPluginUi(hh), l2.setupPluginUi(ME), l2.setupPluginUi(dE), l2.setupPluginUi(PT), l2.setupPluginUi(mE), l2.setupPluginUi(Gc), l2.setupPluginUi(Nc), r2 && l2.setupPluginUi(_u), l2.setupPluginUi(No), l2.setupPluginUi(nh), l2.setupPluginUi(Ny), l2.setupPluginUi(Ip), l2.setupPluginUi(zp), l2.setupPluginUi(Hp), l2.setupPluginUi(Bp), l2.setupPluginUi(Fp), l2.setupPluginUi(bh), l2.setupPluginUi(Qo), l2.setupPluginUi(Ob), l2.setupPluginUi(Nb), l2.setupPluginUi(IT), l2.setupPluginUi(bE), l2.setupPluginUi(DE), l2.setupPluginUi(To), l2.setupPluginUi(BT), l2.setupPluginUi(RT), l2.setupPluginUi(Cu), l2.setupPluginUi(Du), n2 && l2.setupPluginUi(bu), l2.setupPluginUi($u), l2.setupPluginUi(xu), l2.setupPluginUi(Ku), l2.setupPluginUi(fh), l2.setupPluginUi(CE), l2.setupPluginUi(WE), l2.setupPluginUi(Oc), l2.setupPluginUi(Xu), l2.setupPluginUi(Jh), l2.setupPluginUi(Fu), l2.setupPluginUi(wE), l2.setupPluginUi(vp), l2.setupPluginUi($h), l2.setupPluginUi(vy), a2.enabled = true, a2;
  }
}();
var __webpackgi_exports__ACESFilmicToneMapping = __webpackgi_exports__2.LY2;
var __webpackgi_exports__AMaterialManager = __webpackgi_exports__2.HRj;
var __webpackgi_exports__ARPlacementBox = __webpackgi_exports__2.li4;
var __webpackgi_exports__ARPlugin = __webpackgi_exports__2.FO5;
var __webpackgi_exports__ARTouchInputHelper = __webpackgi_exports__2.Nlh;
var __webpackgi_exports__AViewerPlugin = __webpackgi_exports__2.QvI;
var __webpackgi_exports__AddBlendPass = __webpackgi_exports__2.JHp;
var __webpackgi_exports__AddEquation = __webpackgi_exports__2.bGH;
var __webpackgi_exports__AddOperation = __webpackgi_exports__2.NDo;
var __webpackgi_exports__AdditiveAnimationBlendMode = __webpackgi_exports__2.gSk;
var __webpackgi_exports__AdditiveBlending = __webpackgi_exports__2.WMw;
var __webpackgi_exports__AlphaFormat = __webpackgi_exports__2.OTo;
var __webpackgi_exports__AlwaysDepth = __webpackgi_exports__2.Se2;
var __webpackgi_exports__AlwaysStencilFunc = __webpackgi_exports__2.cum;
var __webpackgi_exports__AmbientLight = __webpackgi_exports__2.Mig;
var __webpackgi_exports__AmbientLight2 = __webpackgi_exports__2.B$7;
var __webpackgi_exports__AmbientLightProbe = __webpackgi_exports__2.i_9;
var __webpackgi_exports__AnimationClip = __webpackgi_exports__2.m7l;
var __webpackgi_exports__AnimationLoader = __webpackgi_exports__2.sYA;
var __webpackgi_exports__AnimationMixer = __webpackgi_exports__2.Xcj;
var __webpackgi_exports__AnimationObjectGroup = __webpackgi_exports__2.mzJ;
var __webpackgi_exports__AnimationUtils = __webpackgi_exports__2.ZZA;
var __webpackgi_exports__AnisotropyPlugin = __webpackgi_exports__2.$Ph;
var __webpackgi_exports__ArcCurve = __webpackgi_exports__2.T__;
var __webpackgi_exports__ArrayCamera = __webpackgi_exports__2.HkE;
var __webpackgi_exports__ArrowHelper = __webpackgi_exports__2.tGC;
var __webpackgi_exports__AssetExporter = __webpackgi_exports__2.g1S;
var __webpackgi_exports__AssetExporterPlugin = __webpackgi_exports__2.I$C;
var __webpackgi_exports__AssetImporter = __webpackgi_exports__2.QIH;
var __webpackgi_exports__AssetManagerBasicPopupPlugin = __webpackgi_exports__2._JE;
var __webpackgi_exports__AssetManagerPlugin = __webpackgi_exports__2.ksm;
var __webpackgi_exports__AsyncCompress = __webpackgi_exports__2.jl_;
var __webpackgi_exports__AsyncDecompress = __webpackgi_exports__2.b7R;
var __webpackgi_exports__AsyncDeflate = __webpackgi_exports__2.BDV;
var __webpackgi_exports__AsyncGunzip = __webpackgi_exports__2.Ea_;
var __webpackgi_exports__AsyncGzip = __webpackgi_exports__2.qff;
var __webpackgi_exports__AsyncInflate = __webpackgi_exports__2.tmC;
var __webpackgi_exports__AsyncUnzipInflate = __webpackgi_exports__2.BON;
var __webpackgi_exports__AsyncUnzlib = __webpackgi_exports__2.P40;
var __webpackgi_exports__AsyncZipDeflate = __webpackgi_exports__2.wLL;
var __webpackgi_exports__AsyncZlib = __webpackgi_exports__2.iHO;
var __webpackgi_exports__Audio = __webpackgi_exports__2.BbS;
var __webpackgi_exports__AudioAnalyser = __webpackgi_exports__2.kqm;
var __webpackgi_exports__AudioContext = __webpackgi_exports__2.Hmr;
var __webpackgi_exports__AudioListener = __webpackgi_exports__2.SJI;
var __webpackgi_exports__AudioLoader = __webpackgi_exports__2.mTL;
var __webpackgi_exports__AxesHelper = __webpackgi_exports__2.y8_;
var __webpackgi_exports__BackSide = __webpackgi_exports__2._Li;
var __webpackgi_exports__BaseGroundPlugin = __webpackgi_exports__2.g56;
var __webpackgi_exports__BaseRenderer = __webpackgi_exports__2.bj3;
var __webpackgi_exports__BasicDepthPacking = __webpackgi_exports__2.z81;
var __webpackgi_exports__BasicShadowMap = __webpackgi_exports__2._MY;
var __webpackgi_exports__BlobLoader = __webpackgi_exports__2.yEv;
var __webpackgi_exports__BloomPlugin = __webpackgi_exports__2.dFZ;
var __webpackgi_exports__Bone = __webpackgi_exports__2.N$j;
var __webpackgi_exports__BooleanKeyframeTrack = __webpackgi_exports__2._YM;
var __webpackgi_exports__Box2 = __webpackgi_exports__2.TUj;
var __webpackgi_exports__Box3 = __webpackgi_exports__2.ZzF;
var __webpackgi_exports__Box3B = __webpackgi_exports__2.qzb;
var __webpackgi_exports__Box3Helper = __webpackgi_exports__2.GQ;
var __webpackgi_exports__BoxBufferGeometry = __webpackgi_exports__2.nvb;
var __webpackgi_exports__BoxGeometry = __webpackgi_exports__2.DvJ;
var __webpackgi_exports__BoxHelper = __webpackgi_exports__2.fQA;
var __webpackgi_exports__BoxSelectionWidget = __webpackgi_exports__2.cPz;
var __webpackgi_exports__BufferAttribute = __webpackgi_exports__2.TlE;
var __webpackgi_exports__BufferGeometry = __webpackgi_exports__2.u9r;
var __webpackgi_exports__BufferGeometryLoader = __webpackgi_exports__2.s4_;
var __webpackgi_exports__ByteType = __webpackgi_exports__2.T95;
var __webpackgi_exports__CSGPluginBSP = __webpackgi_exports__2.F5w;
var __webpackgi_exports__CSGPluginBVH = __webpackgi_exports__2.NlP;
var __webpackgi_exports__CSGPluginBase = __webpackgi_exports__2.$8Z;
var __webpackgi_exports__CSS3DRendererPlugin = __webpackgi_exports__2.YYN;
var __webpackgi_exports__Cache = __webpackgi_exports__2.CtF;
var __webpackgi_exports__Camera = __webpackgi_exports__2.V1s;
var __webpackgi_exports__CameraController = __webpackgi_exports__2.jOv;
var __webpackgi_exports__CameraHelper = __webpackgi_exports__2.Rki;
var __webpackgi_exports__CameraUiPlugin = __webpackgi_exports__2.pzV;
var __webpackgi_exports__CameraView = __webpackgi_exports__2.itZ;
var __webpackgi_exports__CameraViewPlugin = __webpackgi_exports__2.qKx;
var __webpackgi_exports__CanvasRecorder = __webpackgi_exports__2.vlJ;
var __webpackgi_exports__CanvasRecorderPlugin = __webpackgi_exports__2.nPO;
var __webpackgi_exports__CanvasSnipper = __webpackgi_exports__2.zcQ;
var __webpackgi_exports__CanvasSnipperPlugin = __webpackgi_exports__2.GH1;
var __webpackgi_exports__CanvasTexture = __webpackgi_exports__2.ROQ;
var __webpackgi_exports__CapsuleBufferGeometry = __webpackgi_exports__2.YN5;
var __webpackgi_exports__CapsuleGeometry = __webpackgi_exports__2.BVQ;
var __webpackgi_exports__CatmullRomCurve3 = __webpackgi_exports__2.YT8;
var __webpackgi_exports__ChromaticAberrationPlugin = __webpackgi_exports__2._DE;
var __webpackgi_exports__CineonToneMapping = __webpackgi_exports__2.YGz;
var __webpackgi_exports__CircleBufferGeometry = __webpackgi_exports__2.trn;
var __webpackgi_exports__CircleGeometry = __webpackgi_exports__2.zf8;
var __webpackgi_exports__ClampToEdgeWrapping = __webpackgi_exports__2.uWy;
var __webpackgi_exports__ClearcoatTintPlugin = __webpackgi_exports__2.wYQ;
var __webpackgi_exports__Clock = __webpackgi_exports__2.SUY;
var __webpackgi_exports__Color = __webpackgi_exports__2.Ilk;
var __webpackgi_exports__ColorKeyframeTrack = __webpackgi_exports__2.R2R;
var __webpackgi_exports__ColorManagement = __webpackgi_exports__2.epp;
var __webpackgi_exports__CombinedPostPlugin = __webpackgi_exports__2.xmJ;
var __webpackgi_exports__Compress = __webpackgi_exports__2.GD$;
var __webpackgi_exports__CompressedTexture = __webpackgi_exports__2.EB7;
var __webpackgi_exports__CompressedTextureLoader = __webpackgi_exports__2.DqL;
var __webpackgi_exports__ConeBufferGeometry = __webpackgi_exports__2._3;
var __webpackgi_exports__ConeGeometry = __webpackgi_exports__2.b_z;
var __webpackgi_exports__ContactShadowGroundPlugin = __webpackgi_exports__2.OCn;
var __webpackgi_exports__CubeCamera = __webpackgi_exports__2._am;
var __webpackgi_exports__CubeNormalsCaptureHelper = __webpackgi_exports__2.kB7;
var __webpackgi_exports__CubeReflectionMapping = __webpackgi_exports__2.fY$;
var __webpackgi_exports__CubeRefractionMapping = __webpackgi_exports__2.vxC;
var __webpackgi_exports__CubeTexture = __webpackgi_exports__2.BtG;
var __webpackgi_exports__CubeTextureLoader = __webpackgi_exports__2.cBK;
var __webpackgi_exports__CubeUVReflectionMapping = __webpackgi_exports__2.g8_;
var __webpackgi_exports__CubicBezierCurve = __webpackgi_exports__2.AXT;
var __webpackgi_exports__CubicBezierCurve3 = __webpackgi_exports__2.yj7;
var __webpackgi_exports__CubicInterpolant = __webpackgi_exports__2.dYG;
var __webpackgi_exports__CullFaceBack = __webpackgi_exports__2.tm_;
var __webpackgi_exports__CullFaceFront = __webpackgi_exports__2.S2y;
var __webpackgi_exports__CullFaceFrontBack = __webpackgi_exports__2.B02;
var __webpackgi_exports__CullFaceNone = __webpackgi_exports__2.PeU;
var __webpackgi_exports__Curve = __webpackgi_exports__2.Hyl;
var __webpackgi_exports__CurvePath = __webpackgi_exports__2.Wqd;
var __webpackgi_exports__CustomBlending = __webpackgi_exports__2.Xaj;
var __webpackgi_exports__CustomBumpMapPlugin = __webpackgi_exports__2.DUb;
var __webpackgi_exports__CustomToneMapping = __webpackgi_exports__2.dZ3;
var __webpackgi_exports__CylinderBufferGeometry = __webpackgi_exports__2.m_w;
var __webpackgi_exports__CylinderGeometry = __webpackgi_exports__2.fHI;
var __webpackgi_exports__Cylindrical = __webpackgi_exports__2.LBq;
var __webpackgi_exports__DECAY_MILLISECONDS = __webpackgi_exports__2.dHf;
var __webpackgi_exports__DRACOLoader2 = __webpackgi_exports__2.Qww;
var __webpackgi_exports__Damper = __webpackgi_exports__2.CGV;
var __webpackgi_exports__Data3DTexture = __webpackgi_exports__2.JUT;
var __webpackgi_exports__DataArrayTexture = __webpackgi_exports__2.p3g;
var __webpackgi_exports__DataTexture = __webpackgi_exports__2.IEO;
var __webpackgi_exports__DataTexture2DArray = __webpackgi_exports__2.CN8;
var __webpackgi_exports__DataTexture3D = __webpackgi_exports__2.zob;
var __webpackgi_exports__DataTextureLoader = __webpackgi_exports__2.yxD;
var __webpackgi_exports__DataUrlLoader = __webpackgi_exports__2.CUS;
var __webpackgi_exports__DataUtils = __webpackgi_exports__2.A5E;
var __webpackgi_exports__DebugPlugin = __webpackgi_exports__2.zqG;
var __webpackgi_exports__DecodeUTF8 = __webpackgi_exports__2.PfX;
var __webpackgi_exports__Decompress = __webpackgi_exports__2.Q1o;
var __webpackgi_exports__DecrementStencilOp = __webpackgi_exports__2.jfJ;
var __webpackgi_exports__DecrementWrapStencilOp = __webpackgi_exports__2.T_J;
var __webpackgi_exports__DefaultLoadingManager = __webpackgi_exports__2.tEQ;
var __webpackgi_exports__Deflate = __webpackgi_exports__2.gb4;
var __webpackgi_exports__DepthFormat = __webpackgi_exports__2.qkB;
var __webpackgi_exports__DepthOfFieldPass = __webpackgi_exports__2.cvk;
var __webpackgi_exports__DepthOfFieldPlugin = __webpackgi_exports__2.HWo;
var __webpackgi_exports__DepthStencilFormat = __webpackgi_exports__2.brP;
var __webpackgi_exports__DepthTexture = __webpackgi_exports__2.$YQ;
var __webpackgi_exports__DeviceOrientationControls2 = __webpackgi_exports__2.X8d;
var __webpackgi_exports__DeviceOrientationControlsPlugin = __webpackgi_exports__2.Zdt;
var __webpackgi_exports__DiamondMaterial = __webpackgi_exports__2.yNB;
var __webpackgi_exports__DiamondPlugin = __webpackgi_exports__2.h7x;
var __webpackgi_exports__DirectionalLight = __webpackgi_exports__2.Ox3;
var __webpackgi_exports__DirectionalLight2 = __webpackgi_exports__2.qtn;
var __webpackgi_exports__DirectionalLightHelper = __webpackgi_exports__2.cBI;
var __webpackgi_exports__DiscreteInterpolant = __webpackgi_exports__2.cU9;
var __webpackgi_exports__DodecahedronBufferGeometry = __webpackgi_exports__2.DT1;
var __webpackgi_exports__DodecahedronGeometry = __webpackgi_exports__2.Kgo;
var __webpackgi_exports__DoubleSide = __webpackgi_exports__2.ehD;
var __webpackgi_exports__Dropzone = __webpackgi_exports__2.fhJ;
var __webpackgi_exports__DropzonePlugin = __webpackgi_exports__2.y1s;
var __webpackgi_exports__DstAlphaFactor = __webpackgi_exports__2.fSK;
var __webpackgi_exports__DstColorFactor = __webpackgi_exports__2.Vdb;
var __webpackgi_exports__DynamicCopyUsage = __webpackgi_exports__2.l8J;
var __webpackgi_exports__DynamicDrawUsage = __webpackgi_exports__2.dj0;
var __webpackgi_exports__DynamicReadUsage = __webpackgi_exports__2.QM0;
var __webpackgi_exports__EXRLoadPlugin = __webpackgi_exports__2.OIS;
var __webpackgi_exports__EasingFunctions = __webpackgi_exports__2.q8b;
var __webpackgi_exports__EdgesGeometry = __webpackgi_exports__2.TOt;
var __webpackgi_exports__EffectComposer2 = __webpackgi_exports__2.xaN;
var __webpackgi_exports__EllipseCurve = __webpackgi_exports__2.Ny0;
var __webpackgi_exports__EllipseCurve3D = __webpackgi_exports__2.NeD;
var __webpackgi_exports__EncodeUTF8 = __webpackgi_exports__2.Zof;
var __webpackgi_exports__EqualDepth = __webpackgi_exports__2.eD;
var __webpackgi_exports__EqualStencilFunc = __webpackgi_exports__2.jwo;
var __webpackgi_exports__EquirectangularReflectionMapping = __webpackgi_exports__2.dSO;
var __webpackgi_exports__EquirectangularRefractionMapping = __webpackgi_exports__2.Bf4;
var __webpackgi_exports__Euler = __webpackgi_exports__2.USm;
var __webpackgi_exports__EventDispatcher = __webpackgi_exports__2.pBf;
var __webpackgi_exports__ExtrudeBufferGeometry = __webpackgi_exports__2.$Vf;
var __webpackgi_exports__ExtrudeGeometry = __webpackgi_exports__2.O7d;
var __webpackgi_exports__FBXLoadPlugin = __webpackgi_exports__2.ksq;
var __webpackgi_exports__FSShadowMaterial = __webpackgi_exports__2.gXf;
var __webpackgi_exports__FileLoader = __webpackgi_exports__2.hH6;
var __webpackgi_exports__FilmicGrainPlugin = __webpackgi_exports__2.kpi;
var __webpackgi_exports__FirstPersonControls2 = __webpackgi_exports__2.DwZ;
var __webpackgi_exports__FirstPersonControlsPlugin = __webpackgi_exports__2.kN3;
var __webpackgi_exports__Float16BufferAttribute = __webpackgi_exports__2.e62;
var __webpackgi_exports__Float32BufferAttribute = __webpackgi_exports__2.a$l;
var __webpackgi_exports__Float64BufferAttribute = __webpackgi_exports__2.OM3;
var __webpackgi_exports__FloatType = __webpackgi_exports__2.VzW;
var __webpackgi_exports__Fog = __webpackgi_exports__2.ybr;
var __webpackgi_exports__FogExp2 = __webpackgi_exports__2.yo9;
var __webpackgi_exports__FrameFadePlugin = __webpackgi_exports__2.$Bt;
var __webpackgi_exports__FramebufferTexture = __webpackgi_exports__2.Wzm;
var __webpackgi_exports__FrontSide = __webpackgi_exports__2.Wl3;
var __webpackgi_exports__Frustum = __webpackgi_exports__2.iWj;
var __webpackgi_exports__FullScreenPlugin = __webpackgi_exports__2.DNz;
var __webpackgi_exports__GBufferPlugin = __webpackgi_exports__2.m1M;
var __webpackgi_exports__GLBufferAttribute = __webpackgi_exports__2.ylh;
var __webpackgi_exports__GLSL1 = __webpackgi_exports__2.v9Y;
var __webpackgi_exports__GLSL3 = __webpackgi_exports__2.LSk;
var __webpackgi_exports__GLTFAnimationPlugin = __webpackgi_exports__2.LHE;
var __webpackgi_exports__GLTFDracoExportPlugin = __webpackgi_exports__2.KE0;
var __webpackgi_exports__GLTFDracoExporter = __webpackgi_exports__2.KCF;
var __webpackgi_exports__GLTFExporter2 = __webpackgi_exports__2.a4n;
var __webpackgi_exports__GLTFLoader2 = __webpackgi_exports__2.zIH;
var __webpackgi_exports__GLTFMaterialsAlphaMapExtensionName = __webpackgi_exports__2.Hfk;
var __webpackgi_exports__GLTFMaterialsBumpMapExtensionName = __webpackgi_exports__2.png;
var __webpackgi_exports__GLTFMaterialsDisplacementMapExtensionName = __webpackgi_exports__2.tAj;
var __webpackgi_exports__GLTFMaterialsLightMapExtensionName = __webpackgi_exports__2.Eb_;
var __webpackgi_exports__GLTFMeshOptPlugin = __webpackgi_exports__2.BT2;
var __webpackgi_exports__GLTFWriter2 = __webpackgi_exports__2._8p;
var __webpackgi_exports__GammaCorrectionExtension = __webpackgi_exports__2.V5Z;
var __webpackgi_exports__GammaCorrectionPlugin = __webpackgi_exports__2.s5b;
var __webpackgi_exports__GenericBlendTexturePass = __webpackgi_exports__2.hkn;
var __webpackgi_exports__GenericFilterPlugin = __webpackgi_exports__2.GFY;
var __webpackgi_exports__GreaterDepth = __webpackgi_exports__2.w$m;
var __webpackgi_exports__GreaterEqualDepth = __webpackgi_exports__2.ksN;
var __webpackgi_exports__GreaterEqualStencilFunc = __webpackgi_exports__2.j4z;
var __webpackgi_exports__GreaterStencilFunc = __webpackgi_exports__2.OAl;
var __webpackgi_exports__GridHelper = __webpackgi_exports__2.VLJ;
var __webpackgi_exports__GroundPlugin = __webpackgi_exports__2.C73;
var __webpackgi_exports__Group = __webpackgi_exports__2.ZAu;
var __webpackgi_exports__Gunzip = __webpackgi_exports__2.ibP;
var __webpackgi_exports__Gzip = __webpackgi_exports__2._fI;
var __webpackgi_exports__HDRiGroundPlugin = __webpackgi_exports__2.hUN;
var __webpackgi_exports__HalfFloatType = __webpackgi_exports__2.cLu;
var __webpackgi_exports__HemisphereLight = __webpackgi_exports__2.vmT;
var __webpackgi_exports__HemisphereLightHelper = __webpackgi_exports__2.Qpg;
var __webpackgi_exports__HemisphereLightProbe = __webpackgi_exports__2.So8;
var __webpackgi_exports__HierarchyUiPlugin = __webpackgi_exports__2.eOv;
var __webpackgi_exports__IcosahedronBufferGeometry = __webpackgi_exports__2.Wjw;
var __webpackgi_exports__IcosahedronGeometry = __webpackgi_exports__2.cJO;
var __webpackgi_exports__ImageBitmapLoader = __webpackgi_exports__2.QRU;
var __webpackgi_exports__ImageLoader = __webpackgi_exports__2.S3k;
var __webpackgi_exports__ImageUtils = __webpackgi_exports__2.PpQ;
var __webpackgi_exports__ImmediateRenderObject = __webpackgi_exports__2.AHu;
var __webpackgi_exports__Importer = __webpackgi_exports__2.q_9;
var __webpackgi_exports__IncrementStencilOp = __webpackgi_exports__2.ZRs;
var __webpackgi_exports__IncrementWrapStencilOp = __webpackgi_exports__2.oqc;
var __webpackgi_exports__Inflate = __webpackgi_exports__2.T_x;
var __webpackgi_exports__InstancedBufferAttribute = __webpackgi_exports__2.lb7;
var __webpackgi_exports__InstancedBufferGeometry = __webpackgi_exports__2.L5s;
var __webpackgi_exports__InstancedInterleavedBuffer = __webpackgi_exports__2.$TI;
var __webpackgi_exports__InstancedMesh = __webpackgi_exports__2.SPe;
var __webpackgi_exports__Int16BufferAttribute = __webpackgi_exports__2.aVm;
var __webpackgi_exports__Int32BufferAttribute = __webpackgi_exports__2.j87;
var __webpackgi_exports__Int8BufferAttribute = __webpackgi_exports__2.RNb;
var __webpackgi_exports__IntType = __webpackgi_exports__2.Kz5;
var __webpackgi_exports__InterleavedBuffer = __webpackgi_exports__2.vpT;
var __webpackgi_exports__InterleavedBufferAttribute = __webpackgi_exports__2.kB5;
var __webpackgi_exports__Interpolant = __webpackgi_exports__2._C8;
var __webpackgi_exports__InterpolateDiscrete = __webpackgi_exports__2.Syv;
var __webpackgi_exports__InterpolateLinear = __webpackgi_exports__2.NMF;
var __webpackgi_exports__InterpolateSmooth = __webpackgi_exports__2.pIN;
var __webpackgi_exports__InvertStencilOp = __webpackgi_exports__2.eMJ;
var __webpackgi_exports__KHR_TEXTURE_BASISU = __webpackgi_exports__2.rN7;
var __webpackgi_exports__KTX2LoadPlugin = __webpackgi_exports__2.iUp;
var __webpackgi_exports__KTXLoadPlugin = __webpackgi_exports__2.GFd;
var __webpackgi_exports__KeepStencilOp = __webpackgi_exports__2.x5V;
var __webpackgi_exports__KeyframeTrack = __webpackgi_exports__2.tUh;
var __webpackgi_exports__LOD = __webpackgi_exports__2.z8B;
var __webpackgi_exports__LUTPlugin = __webpackgi_exports__2.vcl;
var __webpackgi_exports__LatheBufferGeometry = __webpackgi_exports__2.GZb;
var __webpackgi_exports__LatheGeometry = __webpackgi_exports__2.p7y;
var __webpackgi_exports__Layers = __webpackgi_exports__2.S9g;
var __webpackgi_exports__LessDepth = __webpackgi_exports__2.Zr5;
var __webpackgi_exports__LessEqualDepth = __webpackgi_exports__2.vCF;
var __webpackgi_exports__LessEqualStencilFunc = __webpackgi_exports__2.yt0;
var __webpackgi_exports__LessStencilFunc = __webpackgi_exports__2.uXU;
var __webpackgi_exports__Light = __webpackgi_exports__2._kC;
var __webpackgi_exports__LightProbe = __webpackgi_exports__2.lk7;
var __webpackgi_exports__LightsUiPlugin = __webpackgi_exports__2.USc;
var __webpackgi_exports__Line = __webpackgi_exports__2.x12;
var __webpackgi_exports__Line3 = __webpackgi_exports__2.Zzh;
var __webpackgi_exports__LineBasicMaterial = __webpackgi_exports__2.nls;
var __webpackgi_exports__LineCurve = __webpackgi_exports__2.g_z;
var __webpackgi_exports__LineCurve3 = __webpackgi_exports__2.U7;
var __webpackgi_exports__LineDashedMaterial = __webpackgi_exports__2.FT0;
var __webpackgi_exports__LineLoop = __webpackgi_exports__2.blk;
var __webpackgi_exports__LineSegments = __webpackgi_exports__2.ejS;
var __webpackgi_exports__LinearEncoding = __webpackgi_exports__2.rnI;
var __webpackgi_exports__LinearFilter = __webpackgi_exports__2.wem;
var __webpackgi_exports__LinearInterpolant = __webpackgi_exports__2.lfu;
var __webpackgi_exports__LinearMipMapLinearFilter = __webpackgi_exports__2.FDw;
var __webpackgi_exports__LinearMipMapNearestFilter = __webpackgi_exports__2.lRj;
var __webpackgi_exports__LinearMipmapLinearFilter = __webpackgi_exports__2.D1R;
var __webpackgi_exports__LinearMipmapNearestFilter = __webpackgi_exports__2.qyh;
var __webpackgi_exports__LinearSRGBColorSpace = __webpackgi_exports__2.GUF;
var __webpackgi_exports__LinearToneMapping = __webpackgi_exports__2.EoG;
var __webpackgi_exports__Loader = __webpackgi_exports__2.aNw;
var __webpackgi_exports__LoaderUtils = __webpackgi_exports__2.Zp0;
var __webpackgi_exports__LoadingManager = __webpackgi_exports__2.lLk;
var __webpackgi_exports__LoopOnce = __webpackgi_exports__2.jAl;
var __webpackgi_exports__LoopPingPong = __webpackgi_exports__2.uEv;
var __webpackgi_exports__LoopRepeat = __webpackgi_exports__2.YKA;
var __webpackgi_exports__LuminanceAlphaFormat = __webpackgi_exports__2.cRx;
var __webpackgi_exports__LuminanceFormat = __webpackgi_exports__2.Y8D;
var __webpackgi_exports__MOUSE = __webpackgi_exports__2.RsA;
var __webpackgi_exports__MTLLoader2 = __webpackgi_exports__2.Y0m;
var __webpackgi_exports__Material = __webpackgi_exports__2.F5T;
var __webpackgi_exports__MaterialConfiguratorBasePlugin = __webpackgi_exports__2.EDU;
var __webpackgi_exports__MaterialConfiguratorPlugin = __webpackgi_exports__2.z$Q;
var __webpackgi_exports__MaterialExtender = __webpackgi_exports__2.KA8;
var __webpackgi_exports__MaterialLibraryBasePlugin = __webpackgi_exports__2.XUj;
var __webpackgi_exports__MaterialLibraryPlugin = __webpackgi_exports__2.Me$;
var __webpackgi_exports__MaterialLoader = __webpackgi_exports__2.u7G;
var __webpackgi_exports__MaterialManager = __webpackgi_exports__2.PEk;
var __webpackgi_exports__MaterialPreviewGenerator = __webpackgi_exports__2.BG4;
var __webpackgi_exports__MathUtils = __webpackgi_exports__2.M8C;
var __webpackgi_exports__Matrix3 = __webpackgi_exports__2.Vkp;
var __webpackgi_exports__Matrix4 = __webpackgi_exports__2.yGw;
var __webpackgi_exports__MaxEquation = __webpackgi_exports__2.Sm8;
var __webpackgi_exports__Mesh = __webpackgi_exports__2.Kj0;
var __webpackgi_exports__MeshBasicMaterial = __webpackgi_exports__2.vBJ;
var __webpackgi_exports__MeshBasicMaterial2 = __webpackgi_exports__2.QfV;
var __webpackgi_exports__MeshDepthMaterial = __webpackgi_exports__2.lRF;
var __webpackgi_exports__MeshDistanceMaterial = __webpackgi_exports__2.Lun;
var __webpackgi_exports__MeshLambertMaterial = __webpackgi_exports__2.YBo;
var __webpackgi_exports__MeshMatcapMaterial = __webpackgi_exports__2.kaV;
var __webpackgi_exports__MeshNormalMaterial = __webpackgi_exports__2.RSm;
var __webpackgi_exports__MeshPhongMaterial = __webpackgi_exports__2.xoR;
var __webpackgi_exports__MeshPhysicalMaterial = __webpackgi_exports__2.EJi;
var __webpackgi_exports__MeshStandardMaterial = __webpackgi_exports__2.Wid;
var __webpackgi_exports__MeshStandardMaterial2 = __webpackgi_exports__2.iuj;
var __webpackgi_exports__MeshToonMaterial = __webpackgi_exports__2.IKL;
var __webpackgi_exports__MinEquation = __webpackgi_exports__2.r_;
var __webpackgi_exports__MirroredRepeatWrapping = __webpackgi_exports__2.OoA;
var __webpackgi_exports__MixOperation = __webpackgi_exports__2.qhX;
var __webpackgi_exports__MultiFilterPlugin = __webpackgi_exports__2.qPT;
var __webpackgi_exports__MultiplyBlending = __webpackgi_exports__2.M5h;
var __webpackgi_exports__MultiplyOperation = __webpackgi_exports__2.Ns1;
var __webpackgi_exports__NearestFilter = __webpackgi_exports__2.TyD;
var __webpackgi_exports__NearestMipMapLinearFilter = __webpackgi_exports__2.vZf;
var __webpackgi_exports__NearestMipMapNearestFilter = __webpackgi_exports__2.HTd;
var __webpackgi_exports__NearestMipmapLinearFilter = __webpackgi_exports__2.aH4;
var __webpackgi_exports__NearestMipmapNearestFilter = __webpackgi_exports__2.YLQ;
var __webpackgi_exports__NeverDepth = __webpackgi_exports__2.BVF;
var __webpackgi_exports__NeverStencilFunc = __webpackgi_exports__2.MyG;
var __webpackgi_exports__NoBlending = __webpackgi_exports__2.jFi;
var __webpackgi_exports__NoColorSpace = __webpackgi_exports__2.aCh;
var __webpackgi_exports__NoToneMapping = __webpackgi_exports__2.uL9;
var __webpackgi_exports__NoiseBumpMaterialPlugin = __webpackgi_exports__2.TNj;
var __webpackgi_exports__NormalAnimationBlendMode = __webpackgi_exports__2.IFH;
var __webpackgi_exports__NormalBlending = __webpackgi_exports__2.bdR;
var __webpackgi_exports__NormalCaptureMaterial = __webpackgi_exports__2.kM_;
var __webpackgi_exports__NotEqualDepth = __webpackgi_exports__2.M6v;
var __webpackgi_exports__NotEqualStencilFunc = __webpackgi_exports__2.RvT;
var __webpackgi_exports__NumberKeyframeTrack = __webpackgi_exports__2.dUE;
var __webpackgi_exports__OBJLoader2 = __webpackgi_exports__2.oe_;
var __webpackgi_exports__ObjMtlLoadPlugin = __webpackgi_exports__2.BuN;
var __webpackgi_exports__Object3D = __webpackgi_exports__2.Tme;
var __webpackgi_exports__Object3DModel = __webpackgi_exports__2.N9P;
var __webpackgi_exports__ObjectLoader = __webpackgi_exports__2.Gql;
var __webpackgi_exports__ObjectLoader2 = __webpackgi_exports__2.$XY;
var __webpackgi_exports__ObjectPicker = __webpackgi_exports__2.O9d;
var __webpackgi_exports__ObjectProcessorMap = __webpackgi_exports__2.zEO;
var __webpackgi_exports__ObjectRotationPlugin = __webpackgi_exports__2.qfx;
var __webpackgi_exports__ObjectSpaceNormalMap = __webpackgi_exports__2.PA7;
var __webpackgi_exports__OctahedronBufferGeometry = __webpackgi_exports__2.REq;
var __webpackgi_exports__OctahedronGeometry = __webpackgi_exports__2.pQR;
var __webpackgi_exports__OneFactor = __webpackgi_exports__2.ghN;
var __webpackgi_exports__OneMinusDstAlphaFactor = __webpackgi_exports__2.Hy8;
var __webpackgi_exports__OneMinusDstColorFactor = __webpackgi_exports__2.Wpd;
var __webpackgi_exports__OneMinusSrcAlphaFactor = __webpackgi_exports__2.LgZ;
var __webpackgi_exports__OneMinusSrcColorFactor = __webpackgi_exports__2.iWC;
var __webpackgi_exports__OrbitControls2 = __webpackgi_exports__2.mqn;
var __webpackgi_exports__OrbitControls3 = __webpackgi_exports__2.SKe;
var __webpackgi_exports__OrthographicCamera = __webpackgi_exports__2.iKG;
var __webpackgi_exports__PCFShadowMap = __webpackgi_exports__2._iA;
var __webpackgi_exports__PCFSoftShadowMap = __webpackgi_exports__2.ntZ;
var __webpackgi_exports__PMREMGenerator = __webpackgi_exports__2.anP;
var __webpackgi_exports__PMREMGeneratorPlugin = __webpackgi_exports__2.X2e;
var __webpackgi_exports__ParallaxMappingPlugin = __webpackgi_exports__2.FCo;
var __webpackgi_exports__Path = __webpackgi_exports__2.y$t;
var __webpackgi_exports__PerspectiveCamera = __webpackgi_exports__2.cPb;
var __webpackgi_exports__PickingPlugin = __webpackgi_exports__2.lmx;
var __webpackgi_exports__Plane = __webpackgi_exports__2.JOQ;
var __webpackgi_exports__PlaneBufferGeometry = __webpackgi_exports__2.BKK;
var __webpackgi_exports__PlaneGeometry = __webpackgi_exports__2._12;
var __webpackgi_exports__PlaneHelper = __webpackgi_exports__2.tJx;
var __webpackgi_exports__PointLight = __webpackgi_exports__2.cek;
var __webpackgi_exports__PointLight2 = __webpackgi_exports__2.qD0;
var __webpackgi_exports__PointLightHelper = __webpackgi_exports__2.xG9;
var __webpackgi_exports__PointerLockControls2 = __webpackgi_exports__2.wI8;
var __webpackgi_exports__PointerLockControlsPlugin = __webpackgi_exports__2.Sgv;
var __webpackgi_exports__Points = __webpackgi_exports__2.woe;
var __webpackgi_exports__PointsMaterial = __webpackgi_exports__2.UY4;
var __webpackgi_exports__PolarGridHelper = __webpackgi_exports__2.aq0;
var __webpackgi_exports__PolyhedronBufferGeometry = __webpackgi_exports__2.ujx;
var __webpackgi_exports__PolyhedronGeometry = __webpackgi_exports__2.Uol;
var __webpackgi_exports__PopmotionPlugin = __webpackgi_exports__2.JiH;
var __webpackgi_exports__PositionalAudio = __webpackgi_exports__2.VYz;
var __webpackgi_exports__PresetLibraryPlugin = __webpackgi_exports__2._Pm;
var __webpackgi_exports__ProgressivePlugin = __webpackgi_exports__2.EsW;
var __webpackgi_exports__PropertyBinding = __webpackgi_exports__2.iUV;
var __webpackgi_exports__PropertyMixer = __webpackgi_exports__2.tf;
var __webpackgi_exports__QuadraticBezierCurve = __webpackgi_exports__2.ZQ6;
var __webpackgi_exports__QuadraticBezierCurve3 = __webpackgi_exports__2.mXe;
var __webpackgi_exports__Quaternion = __webpackgi_exports__2._fP;
var __webpackgi_exports__QuaternionKeyframeTrack = __webpackgi_exports__2.iLg;
var __webpackgi_exports__QuaternionLinearInterpolant = __webpackgi_exports__2.zbs;
var __webpackgi_exports__REVISION = __webpackgi_exports__2.UZH;
var __webpackgi_exports__RGBADepthPacking = __webpackgi_exports__2.mSO;
var __webpackgi_exports__RGBAFormat = __webpackgi_exports__2.wk1;
var __webpackgi_exports__RGBAIntegerFormat = __webpackgi_exports__2.E2K;
var __webpackgi_exports__RGBA_ASTC_10x10_Format = __webpackgi_exports__2.FUD;
var __webpackgi_exports__RGBA_ASTC_10x5_Format = __webpackgi_exports__2.pKu;
var __webpackgi_exports__RGBA_ASTC_10x6_Format = __webpackgi_exports__2.GG6;
var __webpackgi_exports__RGBA_ASTC_10x8_Format = __webpackgi_exports__2.Gih;
var __webpackgi_exports__RGBA_ASTC_12x10_Format = __webpackgi_exports__2.iiP;
var __webpackgi_exports__RGBA_ASTC_12x12_Format = __webpackgi_exports__2.SvJ;
var __webpackgi_exports__RGBA_ASTC_4x4_Format = __webpackgi_exports__2.ptH;
var __webpackgi_exports__RGBA_ASTC_5x4_Format = __webpackgi_exports__2.jZA;
var __webpackgi_exports__RGBA_ASTC_5x5_Format = __webpackgi_exports__2.y2t;
var __webpackgi_exports__RGBA_ASTC_6x5_Format = __webpackgi_exports__2.gi4;
var __webpackgi_exports__RGBA_ASTC_6x6_Format = __webpackgi_exports__2.Djp;
var __webpackgi_exports__RGBA_ASTC_8x5_Format = __webpackgi_exports__2.BG$;
var __webpackgi_exports__RGBA_ASTC_8x6_Format = __webpackgi_exports__2.NYV;
var __webpackgi_exports__RGBA_ASTC_8x8_Format = __webpackgi_exports__2.xJs;
var __webpackgi_exports__RGBA_BPTC_Format = __webpackgi_exports__2.bsb;
var __webpackgi_exports__RGBA_ETC2_EAC_Format = __webpackgi_exports__2.ekQ;
var __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format = __webpackgi_exports__2.CaW;
var __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format = __webpackgi_exports__2.eaV;
var __webpackgi_exports__RGBA_S3TC_DXT1_Format = __webpackgi_exports__2.BFQ;
var __webpackgi_exports__RGBA_S3TC_DXT3_Format = __webpackgi_exports__2.v3W;
var __webpackgi_exports__RGBA_S3TC_DXT5_Format = __webpackgi_exports__2.ILR;
var __webpackgi_exports__RGBFormat = __webpackgi_exports__2.UCm;
var __webpackgi_exports__RGBM16Encoding = __webpackgi_exports__2.Inb;
var __webpackgi_exports__RGBM16Encoding_ = __webpackgi_exports__2.U1$;
var __webpackgi_exports__RGBM7Encoding = __webpackgi_exports__2.LgE;
var __webpackgi_exports__RGB_ETC1_Format = __webpackgi_exports__2.fto;
var __webpackgi_exports__RGB_ETC2_Format = __webpackgi_exports__2.l0P;
var __webpackgi_exports__RGB_PVRTC_2BPPV1_Format = __webpackgi_exports__2.vCx;
var __webpackgi_exports__RGB_PVRTC_4BPPV1_Format = __webpackgi_exports__2._AM;
var __webpackgi_exports__RGB_S3TC_DXT1_Format = __webpackgi_exports__2.wuA;
var __webpackgi_exports__RGFormat = __webpackgi_exports__2.av9;
var __webpackgi_exports__RGIntegerFormat = __webpackgi_exports__2.CtA;
var __webpackgi_exports__RandomizedDirectionalLight = __webpackgi_exports__2.BvQ;
var __webpackgi_exports__RandomizedDirectionalLightPlugin = __webpackgi_exports__2.FZJ;
var __webpackgi_exports__RawShaderMaterial = __webpackgi_exports__2.FIo;
var __webpackgi_exports__Ray = __webpackgi_exports__2.zHn;
var __webpackgi_exports__Raycaster = __webpackgi_exports__2.iMs;
var __webpackgi_exports__RectAreaLight = __webpackgi_exports__2.T_f;
var __webpackgi_exports__RedFormat = __webpackgi_exports__2.hEm;
var __webpackgi_exports__RedIntegerFormat = __webpackgi_exports__2.D9w;
var __webpackgi_exports__Reflector2 = __webpackgi_exports__2.sHH;
var __webpackgi_exports__ReinhardToneMapping = __webpackgi_exports__2.CdI;
var __webpackgi_exports__RendererUiPlugin = __webpackgi_exports__2.rkc;
var __webpackgi_exports__RepeatWrapping = __webpackgi_exports__2.rpg;
var __webpackgi_exports__ReplaceStencilOp = __webpackgi_exports__2.ce8;
var __webpackgi_exports__ReverseSubtractEquation = __webpackgi_exports__2.rOj;
var __webpackgi_exports__Rhino3dmLoadPlugin = __webpackgi_exports__2.P6m;
var __webpackgi_exports__Rhino3dmLoader2 = __webpackgi_exports__2.JA6;
var __webpackgi_exports__RingBufferGeometry = __webpackgi_exports__2.V4E;
var __webpackgi_exports__RingGeometry = __webpackgi_exports__2.o8S;
var __webpackgi_exports__RootScene = __webpackgi_exports__2.flB;
var __webpackgi_exports__SETTLING_TIME = __webpackgi_exports__2.DUH;
var __webpackgi_exports__SRGBColorSpace = __webpackgi_exports__2.KI_;
var __webpackgi_exports__SSAOPlugin = __webpackgi_exports__2.iLN;
var __webpackgi_exports__SSContactShadows = __webpackgi_exports__2.jsw;
var __webpackgi_exports__SSGIPlugin = __webpackgi_exports__2.srG;
var __webpackgi_exports__SSRPlugin = __webpackgi_exports__2.i6Z;
var __webpackgi_exports__STLLoadPlugin = __webpackgi_exports__2.vfv;
var __webpackgi_exports__Scene = __webpackgi_exports__2.xsS;
var __webpackgi_exports__SceneCamerasUiPlugin = __webpackgi_exports__2.or;
var __webpackgi_exports__SceneLoopPlugin = __webpackgi_exports__2.EQj;
var __webpackgi_exports__SelectionWidget = __webpackgi_exports__2.ov0;
var __webpackgi_exports__ShaderChunk = __webpackgi_exports__2.WdD;
var __webpackgi_exports__ShaderLib = __webpackgi_exports__2.Vj0;
var __webpackgi_exports__ShaderMaterial = __webpackgi_exports__2.jyz;
var __webpackgi_exports__ShaderMaterial2 = __webpackgi_exports__2.mTM;
var __webpackgi_exports__ShaderMaterialEncodingSupport = __webpackgi_exports__2.Mn1;
var __webpackgi_exports__ShaderPass2 = __webpackgi_exports__2.Hlq;
var __webpackgi_exports__ShadowMapBaker = __webpackgi_exports__2.Fi7;
var __webpackgi_exports__ShadowMaterial = __webpackgi_exports__2.Tn7;
var __webpackgi_exports__Shape = __webpackgi_exports__2.bnF;
var __webpackgi_exports__ShapeBufferGeometry = __webpackgi_exports__2.HW6;
var __webpackgi_exports__ShapeGeometry = __webpackgi_exports__2.oa8;
var __webpackgi_exports__ShapePath = __webpackgi_exports__2.T_1;
var __webpackgi_exports__ShapeTubeExtrudePlugin = __webpackgi_exports__2.zHJ;
var __webpackgi_exports__ShapeUtils = __webpackgi_exports__2.iDF;
var __webpackgi_exports__ShortType = __webpackgi_exports__2.iAb;
var __webpackgi_exports__SimpleAssetList = __webpackgi_exports__2.d4E;
var __webpackgi_exports__SimpleBackgroundEnvUiPlugin = __webpackgi_exports__2.lBg;
var __webpackgi_exports__SimpleDataSource = __webpackgi_exports__2.JeJ;
var __webpackgi_exports__SimpleEventDispatcher = __webpackgi_exports__2.FKY;
var __webpackgi_exports__SimpleJSONExporter = __webpackgi_exports__2.zlZ;
var __webpackgi_exports__SimpleJSONLoader = __webpackgi_exports__2.vkg;
var __webpackgi_exports__SimpleTextExporter = __webpackgi_exports__2.brh;
var __webpackgi_exports__SimpleTextPlugin = __webpackgi_exports__2.kZK;
var __webpackgi_exports__SimpleViewerUi = __webpackgi_exports__2.puG;
var __webpackgi_exports__Skeleton = __webpackgi_exports__2.OdW;
var __webpackgi_exports__SkeletonHelper = __webpackgi_exports__2._YX;
var __webpackgi_exports__SkinnedMesh = __webpackgi_exports__2.TUv;
var __webpackgi_exports__Source = __webpackgi_exports__2.Hw6;
var __webpackgi_exports__Sphere = __webpackgi_exports__2.aLr;
var __webpackgi_exports__SphereBufferGeometry = __webpackgi_exports__2.Aip;
var __webpackgi_exports__SphereGeometry = __webpackgi_exports__2.xo$;
var __webpackgi_exports__SphereSelectionWidget = __webpackgi_exports__2.bIn;
var __webpackgi_exports__Spherical = __webpackgi_exports__2.$V;
var __webpackgi_exports__SphericalHarmonics3 = __webpackgi_exports__2.lDi;
var __webpackgi_exports__SplineCurve = __webpackgi_exports__2.gti;
var __webpackgi_exports__SpotLight = __webpackgi_exports__2.PMe;
var __webpackgi_exports__SpotLight2 = __webpackgi_exports__2.iwP;
var __webpackgi_exports__SpotLightHelper = __webpackgi_exports__2.FvO;
var __webpackgi_exports__Sprite = __webpackgi_exports__2.jyi;
var __webpackgi_exports__SpriteMaterial = __webpackgi_exports__2.xeV;
var __webpackgi_exports__SrcAlphaFactor = __webpackgi_exports__2.k74;
var __webpackgi_exports__SrcAlphaSaturateFactor = __webpackgi_exports__2.RlZ;
var __webpackgi_exports__SrcColorFactor = __webpackgi_exports__2.KhW;
var __webpackgi_exports__StaticCopyUsage = __webpackgi_exports__2.HgB;
var __webpackgi_exports__StaticDrawUsage = __webpackgi_exports__2.W2J;
var __webpackgi_exports__StaticReadUsage = __webpackgi_exports__2.JWc;
var __webpackgi_exports__StereoCamera = __webpackgi_exports__2.u37;
var __webpackgi_exports__StreamCopyUsage = __webpackgi_exports__2.Z6B;
var __webpackgi_exports__StreamDrawUsage = __webpackgi_exports__2.QZ1;
var __webpackgi_exports__StreamReadUsage = __webpackgi_exports__2.Ir4;
var __webpackgi_exports__StringKeyframeTrack = __webpackgi_exports__2.NwF;
var __webpackgi_exports__SubtractEquation = __webpackgi_exports__2.Wbm;
var __webpackgi_exports__SubtractiveBlending = __webpackgi_exports__2.N4l;
var __webpackgi_exports__SwitchNodePlugin = __webpackgi_exports__2.ej9;
var __webpackgi_exports__TOUCH = __webpackgi_exports__2.QmN;
var __webpackgi_exports__TangentSpaceNormalMap = __webpackgi_exports__2.IOt;
var __webpackgi_exports__TemporalAAPlugin = __webpackgi_exports__2.NOD;
var __webpackgi_exports__TetrahedronBufferGeometry = __webpackgi_exports__2.L5g;
var __webpackgi_exports__TetrahedronGeometry = __webpackgi_exports__2.H$k;
var __webpackgi_exports__TextSVGOptions = __webpackgi_exports__2.cuP;
var __webpackgi_exports__Texture = __webpackgi_exports__2.xEZ;
var __webpackgi_exports__TextureLoader = __webpackgi_exports__2.dpR;
var __webpackgi_exports__ThinFilmLayerPlugin = __webpackgi_exports__2.wOD;
var __webpackgi_exports__ThreeMaterialLoader = __webpackgi_exports__2.KNb;
var __webpackgi_exports__TonemapPlugin = __webpackgi_exports__2.IiN;
var __webpackgi_exports__TorusBufferGeometry = __webpackgi_exports__2.Cne;
var __webpackgi_exports__TorusGeometry = __webpackgi_exports__2.XvJ;
var __webpackgi_exports__TorusKnotBufferGeometry = __webpackgi_exports__2.XZw;
var __webpackgi_exports__TorusKnotGeometry = __webpackgi_exports__2.FE5;
var __webpackgi_exports__TransformControls2 = __webpackgi_exports__2.lVp;
var __webpackgi_exports__Triangle = __webpackgi_exports__2.CJI;
var __webpackgi_exports__TriangleFanDrawMode = __webpackgi_exports__2.z$h;
var __webpackgi_exports__TriangleStripDrawMode = __webpackgi_exports__2.UlW;
var __webpackgi_exports__TrianglesDrawMode = __webpackgi_exports__2.WwZ;
var __webpackgi_exports__TubeBufferGeometry = __webpackgi_exports__2.Lcc;
var __webpackgi_exports__TubeGeometry = __webpackgi_exports__2.WXh;
var __webpackgi_exports__TubeShapeGeometry = __webpackgi_exports__2.Vjr;
var __webpackgi_exports__TweakpaneUiPlugin = __webpackgi_exports__2.LuM;
var __webpackgi_exports__TweakpaneWrapper = __webpackgi_exports__2.LP5;
var __webpackgi_exports__UVMapping = __webpackgi_exports__2.xfE;
var __webpackgi_exports__Uint16BufferAttribute = __webpackgi_exports__2.qlB;
var __webpackgi_exports__Uint32BufferAttribute = __webpackgi_exports__2.lCJ;
var __webpackgi_exports__Uint8BufferAttribute = __webpackgi_exports__2.WTc;
var __webpackgi_exports__Uint8ClampedBufferAttribute = __webpackgi_exports__2.rAo;
var __webpackgi_exports__Uncharted2Tonemapping = __webpackgi_exports__2.LZj;
var __webpackgi_exports__Uniform = __webpackgi_exports__2.xWb;
var __webpackgi_exports__UniformsGroup = __webpackgi_exports__2.gH0;
var __webpackgi_exports__UniformsLib = __webpackgi_exports__2.rBU;
var __webpackgi_exports__UniformsUtils = __webpackgi_exports__2.rDY;
var __webpackgi_exports__UnsignedByteType = __webpackgi_exports__2.ywz;
var __webpackgi_exports__UnsignedInt248Type = __webpackgi_exports__2.wJv;
var __webpackgi_exports__UnsignedIntType = __webpackgi_exports__2.JQ4;
var __webpackgi_exports__UnsignedShort4444Type = __webpackgi_exports__2.k0A;
var __webpackgi_exports__UnsignedShort5551Type = __webpackgi_exports__2.irR;
var __webpackgi_exports__UnsignedShortType = __webpackgi_exports__2.LsT;
var __webpackgi_exports__Unzip = __webpackgi_exports__2.q5h;
var __webpackgi_exports__UnzipInflate = __webpackgi_exports__2.TKh;
var __webpackgi_exports__UnzipPassThrough = __webpackgi_exports__2.tyg;
var __webpackgi_exports__Unzlib = __webpackgi_exports__2.Ro5;
var __webpackgi_exports__VSMShadowMap = __webpackgi_exports__2.dwk;
var __webpackgi_exports__Vector2 = __webpackgi_exports__2.FM8;
var __webpackgi_exports__Vector3 = __webpackgi_exports__2.Pa4;
var __webpackgi_exports__Vector4 = __webpackgi_exports__2.Ltg;
var __webpackgi_exports__VectorKeyframeTrack = __webpackgi_exports__2.yC1;
var __webpackgi_exports__VelocityBufferPlugin = __webpackgi_exports__2.lHq;
var __webpackgi_exports__VideoTexture = __webpackgi_exports__2.fO1;
var __webpackgi_exports__ViewerApp = __webpackgi_exports__2.oMA;
var __webpackgi_exports__ViewerState = __webpackgi_exports__2.JzW;
var __webpackgi_exports__VignettePlugin = __webpackgi_exports__2.QEt;
var __webpackgi_exports__WebGL1Renderer = __webpackgi_exports__2.b5g;
var __webpackgi_exports__WebGL3DRenderTarget = __webpackgi_exports__2.Ywn;
var __webpackgi_exports__WebGLArrayRenderTarget = __webpackgi_exports__2.GVz;
var __webpackgi_exports__WebGLCubeRenderTarget = __webpackgi_exports__2.oAp;
var __webpackgi_exports__WebGLMultipleRenderTargets = __webpackgi_exports__2.kFz;
var __webpackgi_exports__WebGLMultisampleRenderTarget = __webpackgi_exports__2.p7A;
var __webpackgi_exports__WebGLRenderTarget = __webpackgi_exports__2.dd2;
var __webpackgi_exports__WebGLRenderer = __webpackgi_exports__2.CP7;
var __webpackgi_exports__WebGLUtils = __webpackgi_exports__2.fQK;
var __webpackgi_exports__WebGiViewerElement = __webpackgi_exports__2.Wd$;
var __webpackgi_exports__WindowiseDialogPlugin = __webpackgi_exports__2.t1_;
var __webpackgi_exports__WireframeGeometry = __webpackgi_exports__2.Uk6;
var __webpackgi_exports__WrapAroundEnding = __webpackgi_exports__2._sL;
var __webpackgi_exports__ZeroCurvatureEnding = __webpackgi_exports__2.Pnf;
var __webpackgi_exports__ZeroFactor = __webpackgi_exports__2.c8b;
var __webpackgi_exports__ZeroSlopeEnding = __webpackgi_exports__2._lf;
var __webpackgi_exports__ZeroStencilOp = __webpackgi_exports__2.ad5;
var __webpackgi_exports__Zip = __webpackgi_exports__2.sZV;
var __webpackgi_exports__ZipDeflate = __webpackgi_exports__2.TfA;
var __webpackgi_exports__ZipLoader = __webpackgi_exports__2.sKX;
var __webpackgi_exports__ZipPassThrough = __webpackgi_exports__2.UdM;
var __webpackgi_exports__Zlib = __webpackgi_exports__2.P0y;
var __webpackgi_exports___SRGBAFormat = __webpackgi_exports__2.L_r;
var __webpackgi_exports__addBasePlugins = __webpackgi_exports__2.Bve;
var __webpackgi_exports__addDracoLoader = __webpackgi_exports__2.UeO;
var __webpackgi_exports__addGLTFExporter = __webpackgi_exports__2.$nx;
var __webpackgi_exports__addGLTFLoader = __webpackgi_exports__2.Bk6;
var __webpackgi_exports__addRGBELoader = __webpackgi_exports__2.y4l;
var __webpackgi_exports__addZipLoader = __webpackgi_exports__2.pQ0;
var __webpackgi_exports__afterMain = __webpackgi_exports__2.wXW;
var __webpackgi_exports__afterRead = __webpackgi_exports__2.r5x;
var __webpackgi_exports__afterWrite = __webpackgi_exports__2.MSI;
var __webpackgi_exports__angle = __webpackgi_exports__2.EUu;
var __webpackgi_exports__animate = __webpackgi_exports__2.jtH;
var __webpackgi_exports__animateAsync = __webpackgi_exports__2.T0T;
var __webpackgi_exports__animateObject = __webpackgi_exports__2.gAb;
var __webpackgi_exports__animatePromise = __webpackgi_exports__2.iwT;
var __webpackgi_exports__animateSet = __webpackgi_exports__2.je_;
var __webpackgi_exports__animateTarget = __webpackgi_exports__2.wBP;
var __webpackgi_exports__anticipate = __webpackgi_exports__2.LU2;
var __webpackgi_exports__applyOffset = __webpackgi_exports__2.wQL;
var __webpackgi_exports__applyStyles = __webpackgi_exports__2.Zs7;
var __webpackgi_exports__arrow = __webpackgi_exports__2.x7s;
var __webpackgi_exports__attract = __webpackgi_exports__2.Mnd;
var __webpackgi_exports__attractExpo = __webpackgi_exports__2.A0_;
var __webpackgi_exports__auto = __webpackgi_exports__2.d73;
var __webpackgi_exports__autoCenterObject3D = __webpackgi_exports__2.HCD;
var __webpackgi_exports__autoScaleObject3D = __webpackgi_exports__2.RG9;
var __webpackgi_exports__backIn = __webpackgi_exports__2.G2P;
var __webpackgi_exports__backInOut = __webpackgi_exports__2.XLf;
var __webpackgi_exports__backOut = __webpackgi_exports__2.CGN;
var __webpackgi_exports__basePlacements = __webpackgi_exports__2.mvg;
var __webpackgi_exports__basicMaterialPropList = __webpackgi_exports__2.Hiy;
var __webpackgi_exports__beforeMain = __webpackgi_exports__2.XMc;
var __webpackgi_exports__beforeRead = __webpackgi_exports__2.N7M;
var __webpackgi_exports__beforeWrite = __webpackgi_exports__2.iv;
var __webpackgi_exports__blobToDataURL = __webpackgi_exports__2.n55;
var __webpackgi_exports__bottom = __webpackgi_exports__2.IaC;
var __webpackgi_exports__bounceIn = __webpackgi_exports__2.h9t;
var __webpackgi_exports__bounceInOut = __webpackgi_exports__2.yDW;
var __webpackgi_exports__bounceOut = __webpackgi_exports__2.gJv;
var __webpackgi_exports__buildCSGMeshBSP = __webpackgi_exports__2.l$g;
var __webpackgi_exports__buildCSGMeshBVH = __webpackgi_exports__2.vQi;
var __webpackgi_exports__cLinearToRGBM = __webpackgi_exports__2.$MY;
var __webpackgi_exports__cRGBMToLinear = __webpackgi_exports__2.wJl;
var __webpackgi_exports__circIn = __webpackgi_exports__2.Z7Y;
var __webpackgi_exports__circInOut = __webpackgi_exports__2.X7D;
var __webpackgi_exports__circOut = __webpackgi_exports__2.BnX;
var __webpackgi_exports__clamp = __webpackgi_exports__2.uZ5;
var __webpackgi_exports__clippingParents = __webpackgi_exports__2.zVI;
var __webpackgi_exports__combineDofShader = __webpackgi_exports__2.DpF;
var __webpackgi_exports__compress = __webpackgi_exports__2.nNb;
var __webpackgi_exports__compressSync = __webpackgi_exports__2.cqZ;
var __webpackgi_exports__computeAverageGeometryNormal = __webpackgi_exports__2.pKN;
var __webpackgi_exports__computeEigenVectors = __webpackgi_exports__2.d_$;
var __webpackgi_exports__computeGeometryCenter = __webpackgi_exports__2.DdI;
var __webpackgi_exports__computeGeometrySize = __webpackgi_exports__2.rrX;
var __webpackgi_exports__computeOffsetMatrix = __webpackgi_exports__2.KlC;
var __webpackgi_exports__computeScreenSpaceBoundingBox = __webpackgi_exports__2.KVn;
var __webpackgi_exports__computeStyles = __webpackgi_exports__2.oau;
var __webpackgi_exports__copyMaterialUserData = __webpackgi_exports__2.aw9;
var __webpackgi_exports__copyObject3DUserData = __webpackgi_exports__2.Aap;
var __webpackgi_exports__copyProps = __webpackgi_exports__2.Dxg;
var __webpackgi_exports__copyTextureUserData = __webpackgi_exports__2.MjT;
var __webpackgi_exports__createAnticipate = __webpackgi_exports__2.F7Q;
var __webpackgi_exports__createAttractor = __webpackgi_exports__2.IFq;
var __webpackgi_exports__createBackIn = __webpackgi_exports__2.IJl;
var __webpackgi_exports__createCanvasElement = __webpackgi_exports__2.O5A;
var __webpackgi_exports__createDiv = __webpackgi_exports__2.wCn;
var __webpackgi_exports__createExpoIn = __webpackgi_exports__2.gGT;
var __webpackgi_exports__createIFrameCSS3DObject = __webpackgi_exports__2.pEc;
var __webpackgi_exports__createImage = __webpackgi_exports__2.Bi6;
var __webpackgi_exports__createPopper = __webpackgi_exports__2.fi_;
var __webpackgi_exports__createPopperBase = __webpackgi_exports__2.TT;
var __webpackgi_exports__createPopperLite = __webpackgi_exports__2.q2Z;
var __webpackgi_exports__createRenderTargetKey = __webpackgi_exports__2.NyK;
var __webpackgi_exports__createScriptFromURL = __webpackgi_exports__2.bgu;
var __webpackgi_exports__createStyles = __webpackgi_exports__2.kcS;
var __webpackgi_exports__csgOperations = __webpackgi_exports__2.rRN;
var __webpackgi_exports__css = __webpackgi_exports__2.ivY;
var __webpackgi_exports__cubicBezier = __webpackgi_exports__2._s1;
var __webpackgi_exports__dataTextureFromColor = __webpackgi_exports__2._HO;
var __webpackgi_exports__dataTextureFromVec4 = __webpackgi_exports__2.tpL;
var __webpackgi_exports__decay = __webpackgi_exports__2.DMK;
var __webpackgi_exports__decompress = __webpackgi_exports__2.LjN;
var __webpackgi_exports__decompressSync = __webpackgi_exports__2.iFs;
var __webpackgi_exports__deepAccessObject = __webpackgi_exports__2.qTg;
var __webpackgi_exports__deflate = __webpackgi_exports__2.Wtl;
var __webpackgi_exports__deflateSync = __webpackgi_exports__2.DmK;
var __webpackgi_exports__degreesToRadians = __webpackgi_exports__2.Htt;
var __webpackgi_exports__deserializeObject = __webpackgi_exports__2.Hx7;
var __webpackgi_exports__deserializers = __webpackgi_exports__2.imt;
var __webpackgi_exports__detectOverflow = __webpackgi_exports__2.US6;
var __webpackgi_exports__diamondMaterialPropList = __webpackgi_exports__2.vZs;
var __webpackgi_exports__distance = __webpackgi_exports__2.TE$;
var __webpackgi_exports__downloadBlob = __webpackgi_exports__2.lmu;
var __webpackgi_exports__downloadFile = __webpackgi_exports__2.SvO;
var __webpackgi_exports__easeIn = __webpackgi_exports__2.YQY;
var __webpackgi_exports__easeInOut = __webpackgi_exports__2.mZN;
var __webpackgi_exports__easeOut = __webpackgi_exports__2.VvG;
var __webpackgi_exports__embedUrlRefs = __webpackgi_exports__2.omp;
var __webpackgi_exports__end = __webpackgi_exports__2.utz;
var __webpackgi_exports__envMapBackground = __webpackgi_exports__2.TFV;
var __webpackgi_exports__escapeRegExp = __webpackgi_exports__2.hrz;
var __webpackgi_exports__eventListeners = __webpackgi_exports__2.JKM;
var __webpackgi_exports__extractAnimationKey = __webpackgi_exports__2.jZf;
var __webpackgi_exports__flattenUiConfig = __webpackgi_exports__2.RjL;
var __webpackgi_exports__flip = __webpackgi_exports__2.RRI;
var __webpackgi_exports__fontFormatExtensionMap = __webpackgi_exports__2.RUq;
var __webpackgi_exports__generateUiConfig = __webpackgi_exports__2._t4;
var __webpackgi_exports__generateUiFolder = __webpackgi_exports__2.YHh;
var __webpackgi_exports__getEncodingComponents = __webpackgi_exports__2.R8g;
var __webpackgi_exports__getFilenameFromPath = __webpackgi_exports__2.Bbl;
var __webpackgi_exports__getKeyByValue = __webpackgi_exports__2.V9r;
var __webpackgi_exports__getOrCall = __webpackgi_exports__2.PZ2;
var __webpackgi_exports__getPropertyDescriptor = __webpackgi_exports__2.w7A;
var __webpackgi_exports__getTexelDecoding = __webpackgi_exports__2.N6S;
var __webpackgi_exports__getTexelDecoding2 = __webpackgi_exports__2.Uxp;
var __webpackgi_exports__getTexelDecodingFunction = __webpackgi_exports__2.tAz;
var __webpackgi_exports__getTexelEncoding = __webpackgi_exports__2.R$F;
var __webpackgi_exports__getTexelEncodingFunction = __webpackgi_exports__2.N33;
var __webpackgi_exports__getTextureDataType = __webpackgi_exports__2.gw2;
var __webpackgi_exports__getTextureEncodingFromMap = __webpackgi_exports__2.KlU;
var __webpackgi_exports__getUrlQueryParam = __webpackgi_exports__2.wo6;
var __webpackgi_exports__glsl = __webpackgi_exports__2.H4P;
var __webpackgi_exports__gunzip = __webpackgi_exports__2.swA;
var __webpackgi_exports__gunzipSync = __webpackgi_exports__2._Z3;
var __webpackgi_exports__gzip = __webpackgi_exports__2.ivc;
var __webpackgi_exports__gzipSync = __webpackgi_exports__2.rZ1;
var __webpackgi_exports__hide = __webpackgi_exports__2.CpZ;
var __webpackgi_exports__html = __webpackgi_exports__2.dyc;
var __webpackgi_exports__htmlToCanvas = __webpackgi_exports__2.MxZ;
var __webpackgi_exports__htmlToPng = __webpackgi_exports__2.btp;
var __webpackgi_exports__htmlToSvg = __webpackgi_exports__2.mXy;
var __webpackgi_exports__iGeometryIgnoredUserData = __webpackgi_exports__2.Ej0;
var __webpackgi_exports__iMaterialIgnoredUserData = __webpackgi_exports__2.ep4;
var __webpackgi_exports__iModelIgnoredUserData = __webpackgi_exports__2.DQP;
var __webpackgi_exports__iTextureIgnoredUserData = __webpackgi_exports__2.VNr;
var __webpackgi_exports__imageBitmapToBase64 = __webpackgi_exports__2.V7q;
var __webpackgi_exports__imageToCanvas = __webpackgi_exports__2.zEk;
var __webpackgi_exports__imageUrlToImageData = __webpackgi_exports__2.qfq;
var __webpackgi_exports__includesAll = __webpackgi_exports__2.piB;
var __webpackgi_exports__inertia = __webpackgi_exports__2.IIc;
var __webpackgi_exports__inflate = __webpackgi_exports__2.rrF;
var __webpackgi_exports__inflateSync = __webpackgi_exports__2.naq;
var __webpackgi_exports__interpolate = __webpackgi_exports__2.sXR;
var __webpackgi_exports__isAnimatableType = __webpackgi_exports__2.p5I;
var __webpackgi_exports__isPoint = __webpackgi_exports__2.wps;
var __webpackgi_exports__isPoint3D = __webpackgi_exports__2.wuo;
var __webpackgi_exports__isPropertyWritable = __webpackgi_exports__2.GpE;
var __webpackgi_exports__keyframes = __webpackgi_exports__2.F4b;
var __webpackgi_exports__left = __webpackgi_exports__2.t$v;
var __webpackgi_exports__lerpAngle = __webpackgi_exports__2.tdn;
var __webpackgi_exports__lerpAngle2 = __webpackgi_exports__2.Y9t;
var __webpackgi_exports__linear = __webpackgi_exports__2.GEo;
var __webpackgi_exports__main = __webpackgi_exports__2.DH3;
var __webpackgi_exports__makeColorSvg = __webpackgi_exports__2.uxM;
var __webpackgi_exports__makeColorSvgCircle = __webpackgi_exports__2.zH3;
var __webpackgi_exports__makeFilter = __webpackgi_exports__2.MLs;
var __webpackgi_exports__makeSamplerUi = __webpackgi_exports__2.xXG;
var __webpackgi_exports__makeSetterFor = __webpackgi_exports__2.YM4;
var __webpackgi_exports__makeSetterForAnimObject = __webpackgi_exports__2.B3r;
var __webpackgi_exports__makeTextSvg = __webpackgi_exports__2.iAx;
var __webpackgi_exports__matDefine = __webpackgi_exports__2.lDn;
var __webpackgi_exports__mirrorEasing = __webpackgi_exports__2.oaQ;
var __webpackgi_exports__mix = __webpackgi_exports__2.CD7;
var __webpackgi_exports__mixColor = __webpackgi_exports__2.Rc0;
var __webpackgi_exports__mixComplex = __webpackgi_exports__2.iPG;
var __webpackgi_exports__mobileAndTabletCheck = __webpackgi_exports__2.TIc;
var __webpackgi_exports__modifierPhases = __webpackgi_exports__2.xsC;
var __webpackgi_exports__now = __webpackgi_exports__2.zOc;
var __webpackgi_exports__offset = __webpackgi_exports__2.r46;
var __webpackgi_exports__onChange = __webpackgi_exports__2.z2C;
var __webpackgi_exports__parseFileExtension = __webpackgi_exports__2._X$;
var __webpackgi_exports__patchShaderEncodingSupport = __webpackgi_exports__2._yn;
var __webpackgi_exports__pathJoin = __webpackgi_exports__2.Dyg;
var __webpackgi_exports__physicalMaterialPropList = __webpackgi_exports__2.cUc;
var __webpackgi_exports__pipe = __webpackgi_exports__2.zGw;
var __webpackgi_exports__placements = __webpackgi_exports__2.Ctq;
var __webpackgi_exports__pointFromVector = __webpackgi_exports__2.$ch;
var __webpackgi_exports__popper = __webpackgi_exports__2.k5b;
var __webpackgi_exports__popperGenerator = __webpackgi_exports__2.kZl;
var __webpackgi_exports__popperOffsets = __webpackgi_exports__2.OCg;
var __webpackgi_exports__preventOverflow = __webpackgi_exports__2.YjH;
var __webpackgi_exports__processViewer = __webpackgi_exports__2.Ui8;
var __webpackgi_exports__progress = __webpackgi_exports__2.YD2;
var __webpackgi_exports__radiansToDegrees = __webpackgi_exports__2.vi9;
var __webpackgi_exports__read = __webpackgi_exports__2.ij3;
var __webpackgi_exports__reference = __webpackgi_exports__2.YPW;
var __webpackgi_exports__removeDuplicateGeometries = __webpackgi_exports__2.Bg1;
var __webpackgi_exports__replaceAll = __webpackgi_exports__2.kon;
var __webpackgi_exports__reverseEasing = __webpackgi_exports__2.M3g;
var __webpackgi_exports__right = __webpackgi_exports__2.F2z;
var __webpackgi_exports__rotateDuplicatedMesh = __webpackgi_exports__2.pJF;
var __webpackgi_exports__sRGBEncoding = __webpackgi_exports__2.knz;
var __webpackgi_exports__safeSetProperty = __webpackgi_exports__2.Ejo;
var __webpackgi_exports__serializable = __webpackgi_exports__2.BgY;
var __webpackgi_exports__serialize = __webpackgi_exports__2.qCG;
var __webpackgi_exports__serializeObject = __webpackgi_exports__2.HD9;
var __webpackgi_exports__serializers = __webpackgi_exports__2.fEB;
var __webpackgi_exports__setMeshGeometry = __webpackgi_exports__2.Udc;
var __webpackgi_exports__setMeshMaterial = __webpackgi_exports__2.ZQg;
var __webpackgi_exports__setThreeRendererMode = __webpackgi_exports__2.ofC;
var __webpackgi_exports__setUrlQueryParam = __webpackgi_exports__2.yRy;
var __webpackgi_exports__setupCoreWebGiViewer = __webpackgi_exports__2._NL;
var __webpackgi_exports__setupIModel = __webpackgi_exports__2.LCA;
var __webpackgi_exports__setupObject3dModel = __webpackgi_exports__2.j1w;
var __webpackgi_exports__setupSandboxWebGiEditor = __webpackgi_exports__2.i8J;
var __webpackgi_exports__shaderReplaceString = __webpackgi_exports__2.p7C;
var __webpackgi_exports__slerp = __webpackgi_exports__2.ZAS;
var __webpackgi_exports__smooth = __webpackgi_exports__2.ipH;
var __webpackgi_exports__smoothFrame = __webpackgi_exports__2.$TF;
var __webpackgi_exports__snap = __webpackgi_exports__2.uZI;
var __webpackgi_exports__snapObject = __webpackgi_exports__2.VWG;
var __webpackgi_exports__sphericalFromObject = __webpackgi_exports__2.pQ7;
var __webpackgi_exports__spring = __webpackgi_exports__2.STw;
var __webpackgi_exports__standardMaterialPropList = __webpackgi_exports__2.jc8;
var __webpackgi_exports__start = __webpackgi_exports__2.BL_;
var __webpackgi_exports__steps = __webpackgi_exports__2.S6;
var __webpackgi_exports__strFromU8 = __webpackgi_exports__2.T8U;
var __webpackgi_exports__strToU8 = __webpackgi_exports__2.TD6;
var __webpackgi_exports__svgToCanvas = __webpackgi_exports__2.akS;
var __webpackgi_exports__svgToPng = __webpackgi_exports__2.QKE;
var __webpackgi_exports__svgUrl = __webpackgi_exports__2.dKx;
var __webpackgi_exports__syncAnimSetUi = __webpackgi_exports__2.OvX;
var __webpackgi_exports__timeout = __webpackgi_exports__2.VsW;
var __webpackgi_exports__toDecimal = __webpackgi_exports__2.YMc;
var __webpackgi_exports__toIndexedGeometry = __webpackgi_exports__2.aPg;
var __webpackgi_exports__toTitleCase = __webpackgi_exports__2.LFn;
var __webpackgi_exports__top = __webpackgi_exports__2.wey;
var __webpackgi_exports__uiButton = __webpackgi_exports__2.MaE;
var __webpackgi_exports__uiColor = __webpackgi_exports__2.s4x;
var __webpackgi_exports__uiConfig = __webpackgi_exports__2.FJA;
var __webpackgi_exports__uiDropdown = __webpackgi_exports__2.vIA;
var __webpackgi_exports__uiFolder = __webpackgi_exports__2.Spv;
var __webpackgi_exports__uiImage = __webpackgi_exports__2.w8l;
var __webpackgi_exports__uiInput = __webpackgi_exports__2.riG;
var __webpackgi_exports__uiMonitor = __webpackgi_exports__2.Kbh;
var __webpackgi_exports__uiSlider = __webpackgi_exports__2.t8K;
var __webpackgi_exports__uiToggle = __webpackgi_exports__2.Q7n;
var __webpackgi_exports__uiVector = __webpackgi_exports__2.KGF;
var __webpackgi_exports__uniform = __webpackgi_exports__2.e5;
var __webpackgi_exports__unzip = __webpackgi_exports__2.Rik;
var __webpackgi_exports__unzipSync = __webpackgi_exports__2.GZo;
var __webpackgi_exports__unzlib = __webpackgi_exports__2.Bds;
var __webpackgi_exports__unzlibSync = __webpackgi_exports__2.HTu;
var __webpackgi_exports__uploadFile = __webpackgi_exports__2.cTq;
var __webpackgi_exports__vLinearToRGBM = __webpackgi_exports__2.X_Y;
var __webpackgi_exports__vRGBMToLinear = __webpackgi_exports__2.dA8;
var __webpackgi_exports__variationPlacements = __webpackgi_exports__2.bwS;
var __webpackgi_exports__velocityPerFrame = __webpackgi_exports__2.Lks;
var __webpackgi_exports__velocityPerSecond = __webpackgi_exports__2.Rvq;
var __webpackgi_exports__verifyPermission = __webpackgi_exports__2.P4F;
var __webpackgi_exports__viewerGLTFExtension = __webpackgi_exports__2.Pd0;
var __webpackgi_exports__viewport = __webpackgi_exports__2.Pjo;
var __webpackgi_exports__webgiLightExtrasExtension = __webpackgi_exports__2.Tum;
var __webpackgi_exports__webgiMaterialExtrasExtension = __webpackgi_exports__2.dRH;
var __webpackgi_exports__webgiObject3DExtrasExtension = __webpackgi_exports__2.RX0;
var __webpackgi_exports__wrap = __webpackgi_exports__2.reQ;
var __webpackgi_exports__write = __webpackgi_exports__2.cWm;
var __webpackgi_exports__writeFile = __webpackgi_exports__2.NC9;
var __webpackgi_exports__zip = __webpackgi_exports__2.$Re;
var __webpackgi_exports__zipSync = __webpackgi_exports__2.Xo9;
var __webpackgi_exports__zlib = __webpackgi_exports__2.LNO;
var __webpackgi_exports__zlibSync = __webpackgi_exports__2.iZP;
export {
  __webpackgi_exports__ACESFilmicToneMapping as ACESFilmicToneMapping,
  __webpackgi_exports__AMaterialManager as AMaterialManager,
  __webpackgi_exports__ARPlacementBox as ARPlacementBox,
  __webpackgi_exports__ARPlugin as ARPlugin,
  __webpackgi_exports__ARTouchInputHelper as ARTouchInputHelper,
  __webpackgi_exports__AViewerPlugin as AViewerPlugin,
  __webpackgi_exports__AddBlendPass as AddBlendPass,
  __webpackgi_exports__AddEquation as AddEquation,
  __webpackgi_exports__AddOperation as AddOperation,
  __webpackgi_exports__AdditiveAnimationBlendMode as AdditiveAnimationBlendMode,
  __webpackgi_exports__AdditiveBlending as AdditiveBlending,
  __webpackgi_exports__AlphaFormat as AlphaFormat,
  __webpackgi_exports__AlwaysDepth as AlwaysDepth,
  __webpackgi_exports__AlwaysStencilFunc as AlwaysStencilFunc,
  __webpackgi_exports__AmbientLight as AmbientLight,
  __webpackgi_exports__AmbientLight2 as AmbientLight2,
  __webpackgi_exports__AmbientLightProbe as AmbientLightProbe,
  __webpackgi_exports__AnimationClip as AnimationClip,
  __webpackgi_exports__AnimationLoader as AnimationLoader,
  __webpackgi_exports__AnimationMixer as AnimationMixer,
  __webpackgi_exports__AnimationObjectGroup as AnimationObjectGroup,
  __webpackgi_exports__AnimationUtils as AnimationUtils,
  __webpackgi_exports__AnisotropyPlugin as AnisotropyPlugin,
  __webpackgi_exports__ArcCurve as ArcCurve,
  __webpackgi_exports__ArrayCamera as ArrayCamera,
  __webpackgi_exports__ArrowHelper as ArrowHelper,
  __webpackgi_exports__AssetExporter as AssetExporter,
  __webpackgi_exports__AssetExporterPlugin as AssetExporterPlugin,
  __webpackgi_exports__AssetImporter as AssetImporter,
  __webpackgi_exports__AssetManagerBasicPopupPlugin as AssetManagerBasicPopupPlugin,
  __webpackgi_exports__AssetManagerPlugin as AssetManagerPlugin,
  __webpackgi_exports__AsyncCompress as AsyncCompress,
  __webpackgi_exports__AsyncDecompress as AsyncDecompress,
  __webpackgi_exports__AsyncDeflate as AsyncDeflate,
  __webpackgi_exports__AsyncGunzip as AsyncGunzip,
  __webpackgi_exports__AsyncGzip as AsyncGzip,
  __webpackgi_exports__AsyncInflate as AsyncInflate,
  __webpackgi_exports__AsyncUnzipInflate as AsyncUnzipInflate,
  __webpackgi_exports__AsyncUnzlib as AsyncUnzlib,
  __webpackgi_exports__AsyncZipDeflate as AsyncZipDeflate,
  __webpackgi_exports__AsyncZlib as AsyncZlib,
  __webpackgi_exports__Audio as Audio,
  __webpackgi_exports__AudioAnalyser as AudioAnalyser,
  __webpackgi_exports__AudioContext as AudioContext,
  __webpackgi_exports__AudioListener as AudioListener,
  __webpackgi_exports__AudioLoader as AudioLoader,
  __webpackgi_exports__AxesHelper as AxesHelper,
  __webpackgi_exports__BackSide as BackSide,
  __webpackgi_exports__BaseGroundPlugin as BaseGroundPlugin,
  __webpackgi_exports__BaseRenderer as BaseRenderer,
  __webpackgi_exports__BasicDepthPacking as BasicDepthPacking,
  __webpackgi_exports__BasicShadowMap as BasicShadowMap,
  __webpackgi_exports__BlobLoader as BlobLoader,
  __webpackgi_exports__BloomPlugin as BloomPlugin,
  __webpackgi_exports__Bone as Bone,
  __webpackgi_exports__BooleanKeyframeTrack as BooleanKeyframeTrack,
  __webpackgi_exports__Box2 as Box2,
  __webpackgi_exports__Box3 as Box3,
  __webpackgi_exports__Box3B as Box3B,
  __webpackgi_exports__Box3Helper as Box3Helper,
  __webpackgi_exports__BoxBufferGeometry as BoxBufferGeometry,
  __webpackgi_exports__BoxGeometry as BoxGeometry,
  __webpackgi_exports__BoxHelper as BoxHelper,
  __webpackgi_exports__BoxSelectionWidget as BoxSelectionWidget,
  __webpackgi_exports__BufferAttribute as BufferAttribute,
  __webpackgi_exports__BufferGeometry as BufferGeometry,
  __webpackgi_exports__BufferGeometryLoader as BufferGeometryLoader,
  __webpackgi_exports__ByteType as ByteType,
  __webpackgi_exports__CSGPluginBSP as CSGPluginBSP,
  __webpackgi_exports__CSGPluginBVH as CSGPluginBVH,
  __webpackgi_exports__CSGPluginBase as CSGPluginBase,
  __webpackgi_exports__CSS3DRendererPlugin as CSS3DRendererPlugin,
  __webpackgi_exports__Cache as Cache,
  __webpackgi_exports__Camera as Camera,
  __webpackgi_exports__CameraController as CameraController,
  __webpackgi_exports__CameraHelper as CameraHelper,
  __webpackgi_exports__CameraUiPlugin as CameraUiPlugin,
  __webpackgi_exports__CameraView as CameraView,
  __webpackgi_exports__CameraViewPlugin as CameraViewPlugin,
  __webpackgi_exports__CanvasRecorder as CanvasRecorder,
  __webpackgi_exports__CanvasRecorderPlugin as CanvasRecorderPlugin,
  __webpackgi_exports__CanvasSnipper as CanvasSnipper,
  __webpackgi_exports__CanvasSnipperPlugin as CanvasSnipperPlugin,
  __webpackgi_exports__CanvasTexture as CanvasTexture,
  __webpackgi_exports__CapsuleBufferGeometry as CapsuleBufferGeometry,
  __webpackgi_exports__CapsuleGeometry as CapsuleGeometry,
  __webpackgi_exports__CatmullRomCurve3 as CatmullRomCurve3,
  __webpackgi_exports__ChromaticAberrationPlugin as ChromaticAberrationPlugin,
  __webpackgi_exports__CineonToneMapping as CineonToneMapping,
  __webpackgi_exports__CircleBufferGeometry as CircleBufferGeometry,
  __webpackgi_exports__CircleGeometry as CircleGeometry,
  __webpackgi_exports__ClampToEdgeWrapping as ClampToEdgeWrapping,
  __webpackgi_exports__ClearcoatTintPlugin as ClearcoatTintPlugin,
  __webpackgi_exports__Clock as Clock,
  __webpackgi_exports__Color as Color,
  __webpackgi_exports__ColorKeyframeTrack as ColorKeyframeTrack,
  __webpackgi_exports__ColorManagement as ColorManagement,
  __webpackgi_exports__CombinedPostPlugin as CombinedPostPlugin,
  __webpackgi_exports__Compress as Compress,
  __webpackgi_exports__CompressedTexture as CompressedTexture,
  __webpackgi_exports__CompressedTextureLoader as CompressedTextureLoader,
  __webpackgi_exports__ConeBufferGeometry as ConeBufferGeometry,
  __webpackgi_exports__ConeGeometry as ConeGeometry,
  __webpackgi_exports__ContactShadowGroundPlugin as ContactShadowGroundPlugin,
  __webpackgi_exports__CubeCamera as CubeCamera,
  __webpackgi_exports__CubeNormalsCaptureHelper as CubeNormalsCaptureHelper,
  __webpackgi_exports__CubeReflectionMapping as CubeReflectionMapping,
  __webpackgi_exports__CubeRefractionMapping as CubeRefractionMapping,
  __webpackgi_exports__CubeTexture as CubeTexture,
  __webpackgi_exports__CubeTextureLoader as CubeTextureLoader,
  __webpackgi_exports__CubeUVReflectionMapping as CubeUVReflectionMapping,
  __webpackgi_exports__CubicBezierCurve as CubicBezierCurve,
  __webpackgi_exports__CubicBezierCurve3 as CubicBezierCurve3,
  __webpackgi_exports__CubicInterpolant as CubicInterpolant,
  __webpackgi_exports__CullFaceBack as CullFaceBack,
  __webpackgi_exports__CullFaceFront as CullFaceFront,
  __webpackgi_exports__CullFaceFrontBack as CullFaceFrontBack,
  __webpackgi_exports__CullFaceNone as CullFaceNone,
  __webpackgi_exports__Curve as Curve,
  __webpackgi_exports__CurvePath as CurvePath,
  __webpackgi_exports__CustomBlending as CustomBlending,
  __webpackgi_exports__CustomBumpMapPlugin as CustomBumpMapPlugin,
  __webpackgi_exports__CustomToneMapping as CustomToneMapping,
  __webpackgi_exports__CylinderBufferGeometry as CylinderBufferGeometry,
  __webpackgi_exports__CylinderGeometry as CylinderGeometry,
  __webpackgi_exports__Cylindrical as Cylindrical,
  __webpackgi_exports__DECAY_MILLISECONDS as DECAY_MILLISECONDS,
  __webpackgi_exports__DRACOLoader2 as DRACOLoader2,
  __webpackgi_exports__Damper as Damper,
  __webpackgi_exports__Data3DTexture as Data3DTexture,
  __webpackgi_exports__DataArrayTexture as DataArrayTexture,
  __webpackgi_exports__DataTexture as DataTexture,
  __webpackgi_exports__DataTexture2DArray as DataTexture2DArray,
  __webpackgi_exports__DataTexture3D as DataTexture3D,
  __webpackgi_exports__DataTextureLoader as DataTextureLoader,
  __webpackgi_exports__DataUrlLoader as DataUrlLoader,
  __webpackgi_exports__DataUtils as DataUtils,
  __webpackgi_exports__DebugPlugin as DebugPlugin,
  __webpackgi_exports__DecodeUTF8 as DecodeUTF8,
  __webpackgi_exports__Decompress as Decompress,
  __webpackgi_exports__DecrementStencilOp as DecrementStencilOp,
  __webpackgi_exports__DecrementWrapStencilOp as DecrementWrapStencilOp,
  __webpackgi_exports__DefaultLoadingManager as DefaultLoadingManager,
  __webpackgi_exports__Deflate as Deflate,
  __webpackgi_exports__DepthFormat as DepthFormat,
  __webpackgi_exports__DepthOfFieldPass as DepthOfFieldPass,
  __webpackgi_exports__DepthOfFieldPlugin as DepthOfFieldPlugin,
  __webpackgi_exports__DepthStencilFormat as DepthStencilFormat,
  __webpackgi_exports__DepthTexture as DepthTexture,
  __webpackgi_exports__DeviceOrientationControls2 as DeviceOrientationControls2,
  __webpackgi_exports__DeviceOrientationControlsPlugin as DeviceOrientationControlsPlugin,
  __webpackgi_exports__DiamondMaterial as DiamondMaterial,
  __webpackgi_exports__DiamondPlugin as DiamondPlugin,
  __webpackgi_exports__DirectionalLight as DirectionalLight,
  __webpackgi_exports__DirectionalLight2 as DirectionalLight2,
  __webpackgi_exports__DirectionalLightHelper as DirectionalLightHelper,
  __webpackgi_exports__DiscreteInterpolant as DiscreteInterpolant,
  __webpackgi_exports__DodecahedronBufferGeometry as DodecahedronBufferGeometry,
  __webpackgi_exports__DodecahedronGeometry as DodecahedronGeometry,
  __webpackgi_exports__DoubleSide as DoubleSide,
  __webpackgi_exports__Dropzone as Dropzone,
  __webpackgi_exports__DropzonePlugin as DropzonePlugin,
  __webpackgi_exports__DstAlphaFactor as DstAlphaFactor,
  __webpackgi_exports__DstColorFactor as DstColorFactor,
  __webpackgi_exports__DynamicCopyUsage as DynamicCopyUsage,
  __webpackgi_exports__DynamicDrawUsage as DynamicDrawUsage,
  __webpackgi_exports__DynamicReadUsage as DynamicReadUsage,
  __webpackgi_exports__EXRLoadPlugin as EXRLoadPlugin,
  __webpackgi_exports__EasingFunctions as EasingFunctions,
  __webpackgi_exports__EdgesGeometry as EdgesGeometry,
  __webpackgi_exports__EffectComposer2 as EffectComposer2,
  __webpackgi_exports__EllipseCurve as EllipseCurve,
  __webpackgi_exports__EllipseCurve3D as EllipseCurve3D,
  __webpackgi_exports__EncodeUTF8 as EncodeUTF8,
  __webpackgi_exports__EqualDepth as EqualDepth,
  __webpackgi_exports__EqualStencilFunc as EqualStencilFunc,
  __webpackgi_exports__EquirectangularReflectionMapping as EquirectangularReflectionMapping,
  __webpackgi_exports__EquirectangularRefractionMapping as EquirectangularRefractionMapping,
  __webpackgi_exports__Euler as Euler,
  __webpackgi_exports__EventDispatcher as EventDispatcher,
  __webpackgi_exports__ExtrudeBufferGeometry as ExtrudeBufferGeometry,
  __webpackgi_exports__ExtrudeGeometry as ExtrudeGeometry,
  __webpackgi_exports__FBXLoadPlugin as FBXLoadPlugin,
  __webpackgi_exports__FSShadowMaterial as FSShadowMaterial,
  __webpackgi_exports__FileLoader as FileLoader,
  __webpackgi_exports__FilmicGrainPlugin as FilmicGrainPlugin,
  __webpackgi_exports__FirstPersonControls2 as FirstPersonControls2,
  __webpackgi_exports__FirstPersonControlsPlugin as FirstPersonControlsPlugin,
  __webpackgi_exports__Float16BufferAttribute as Float16BufferAttribute,
  __webpackgi_exports__Float32BufferAttribute as Float32BufferAttribute,
  __webpackgi_exports__Float64BufferAttribute as Float64BufferAttribute,
  __webpackgi_exports__FloatType as FloatType,
  __webpackgi_exports__Fog as Fog,
  __webpackgi_exports__FogExp2 as FogExp2,
  __webpackgi_exports__FrameFadePlugin as FrameFadePlugin,
  __webpackgi_exports__FramebufferTexture as FramebufferTexture,
  __webpackgi_exports__FrontSide as FrontSide,
  __webpackgi_exports__Frustum as Frustum,
  __webpackgi_exports__FullScreenPlugin as FullScreenPlugin,
  __webpackgi_exports__GBufferPlugin as GBufferPlugin,
  __webpackgi_exports__GLBufferAttribute as GLBufferAttribute,
  __webpackgi_exports__GLSL1 as GLSL1,
  __webpackgi_exports__GLSL3 as GLSL3,
  __webpackgi_exports__GLTFAnimationPlugin as GLTFAnimationPlugin,
  __webpackgi_exports__GLTFDracoExportPlugin as GLTFDracoExportPlugin,
  __webpackgi_exports__GLTFDracoExporter as GLTFDracoExporter,
  __webpackgi_exports__GLTFExporter2 as GLTFExporter2,
  __webpackgi_exports__GLTFLoader2 as GLTFLoader2,
  __webpackgi_exports__GLTFMaterialsAlphaMapExtensionName as GLTFMaterialsAlphaMapExtensionName,
  __webpackgi_exports__GLTFMaterialsBumpMapExtensionName as GLTFMaterialsBumpMapExtensionName,
  __webpackgi_exports__GLTFMaterialsDisplacementMapExtensionName as GLTFMaterialsDisplacementMapExtensionName,
  __webpackgi_exports__GLTFMaterialsLightMapExtensionName as GLTFMaterialsLightMapExtensionName,
  __webpackgi_exports__GLTFMeshOptPlugin as GLTFMeshOptPlugin,
  __webpackgi_exports__GLTFWriter2 as GLTFWriter2,
  __webpackgi_exports__GammaCorrectionExtension as GammaCorrectionExtension,
  __webpackgi_exports__GammaCorrectionPlugin as GammaCorrectionPlugin,
  __webpackgi_exports__GenericBlendTexturePass as GenericBlendTexturePass,
  __webpackgi_exports__GenericFilterPlugin as GenericFilterPlugin,
  __webpackgi_exports__GreaterDepth as GreaterDepth,
  __webpackgi_exports__GreaterEqualDepth as GreaterEqualDepth,
  __webpackgi_exports__GreaterEqualStencilFunc as GreaterEqualStencilFunc,
  __webpackgi_exports__GreaterStencilFunc as GreaterStencilFunc,
  __webpackgi_exports__GridHelper as GridHelper,
  __webpackgi_exports__GroundPlugin as GroundPlugin,
  __webpackgi_exports__Group as Group,
  __webpackgi_exports__Gunzip as Gunzip,
  __webpackgi_exports__Gzip as Gzip,
  __webpackgi_exports__HDRiGroundPlugin as HDRiGroundPlugin,
  __webpackgi_exports__HalfFloatType as HalfFloatType,
  __webpackgi_exports__HemisphereLight as HemisphereLight,
  __webpackgi_exports__HemisphereLightHelper as HemisphereLightHelper,
  __webpackgi_exports__HemisphereLightProbe as HemisphereLightProbe,
  __webpackgi_exports__HierarchyUiPlugin as HierarchyUiPlugin,
  __webpackgi_exports__IcosahedronBufferGeometry as IcosahedronBufferGeometry,
  __webpackgi_exports__IcosahedronGeometry as IcosahedronGeometry,
  __webpackgi_exports__ImageBitmapLoader as ImageBitmapLoader,
  __webpackgi_exports__ImageLoader as ImageLoader,
  __webpackgi_exports__ImageUtils as ImageUtils,
  __webpackgi_exports__ImmediateRenderObject as ImmediateRenderObject,
  __webpackgi_exports__Importer as Importer,
  __webpackgi_exports__IncrementStencilOp as IncrementStencilOp,
  __webpackgi_exports__IncrementWrapStencilOp as IncrementWrapStencilOp,
  __webpackgi_exports__Inflate as Inflate,
  __webpackgi_exports__InstancedBufferAttribute as InstancedBufferAttribute,
  __webpackgi_exports__InstancedBufferGeometry as InstancedBufferGeometry,
  __webpackgi_exports__InstancedInterleavedBuffer as InstancedInterleavedBuffer,
  __webpackgi_exports__InstancedMesh as InstancedMesh,
  __webpackgi_exports__Int16BufferAttribute as Int16BufferAttribute,
  __webpackgi_exports__Int32BufferAttribute as Int32BufferAttribute,
  __webpackgi_exports__Int8BufferAttribute as Int8BufferAttribute,
  __webpackgi_exports__IntType as IntType,
  __webpackgi_exports__InterleavedBuffer as InterleavedBuffer,
  __webpackgi_exports__InterleavedBufferAttribute as InterleavedBufferAttribute,
  __webpackgi_exports__Interpolant as Interpolant,
  __webpackgi_exports__InterpolateDiscrete as InterpolateDiscrete,
  __webpackgi_exports__InterpolateLinear as InterpolateLinear,
  __webpackgi_exports__InterpolateSmooth as InterpolateSmooth,
  __webpackgi_exports__InvertStencilOp as InvertStencilOp,
  __webpackgi_exports__KHR_TEXTURE_BASISU as KHR_TEXTURE_BASISU,
  __webpackgi_exports__KTX2LoadPlugin as KTX2LoadPlugin,
  __webpackgi_exports__KTXLoadPlugin as KTXLoadPlugin,
  __webpackgi_exports__KeepStencilOp as KeepStencilOp,
  __webpackgi_exports__KeyframeTrack as KeyframeTrack,
  __webpackgi_exports__LOD as LOD,
  __webpackgi_exports__LUTPlugin as LUTPlugin,
  __webpackgi_exports__LatheBufferGeometry as LatheBufferGeometry,
  __webpackgi_exports__LatheGeometry as LatheGeometry,
  __webpackgi_exports__Layers as Layers,
  __webpackgi_exports__LessDepth as LessDepth,
  __webpackgi_exports__LessEqualDepth as LessEqualDepth,
  __webpackgi_exports__LessEqualStencilFunc as LessEqualStencilFunc,
  __webpackgi_exports__LessStencilFunc as LessStencilFunc,
  __webpackgi_exports__Light as Light,
  __webpackgi_exports__LightProbe as LightProbe,
  __webpackgi_exports__LightsUiPlugin as LightsUiPlugin,
  __webpackgi_exports__Line as Line,
  __webpackgi_exports__Line3 as Line3,
  __webpackgi_exports__LineBasicMaterial as LineBasicMaterial,
  __webpackgi_exports__LineCurve as LineCurve,
  __webpackgi_exports__LineCurve3 as LineCurve3,
  __webpackgi_exports__LineDashedMaterial as LineDashedMaterial,
  __webpackgi_exports__LineLoop as LineLoop,
  __webpackgi_exports__LineSegments as LineSegments,
  __webpackgi_exports__LinearEncoding as LinearEncoding,
  __webpackgi_exports__LinearFilter as LinearFilter,
  __webpackgi_exports__LinearInterpolant as LinearInterpolant,
  __webpackgi_exports__LinearMipMapLinearFilter as LinearMipMapLinearFilter,
  __webpackgi_exports__LinearMipMapNearestFilter as LinearMipMapNearestFilter,
  __webpackgi_exports__LinearMipmapLinearFilter as LinearMipmapLinearFilter,
  __webpackgi_exports__LinearMipmapNearestFilter as LinearMipmapNearestFilter,
  __webpackgi_exports__LinearSRGBColorSpace as LinearSRGBColorSpace,
  __webpackgi_exports__LinearToneMapping as LinearToneMapping,
  __webpackgi_exports__Loader as Loader,
  __webpackgi_exports__LoaderUtils as LoaderUtils,
  __webpackgi_exports__LoadingManager as LoadingManager,
  __webpackgi_exports__LoopOnce as LoopOnce,
  __webpackgi_exports__LoopPingPong as LoopPingPong,
  __webpackgi_exports__LoopRepeat as LoopRepeat,
  __webpackgi_exports__LuminanceAlphaFormat as LuminanceAlphaFormat,
  __webpackgi_exports__LuminanceFormat as LuminanceFormat,
  __webpackgi_exports__MOUSE as MOUSE,
  __webpackgi_exports__MTLLoader2 as MTLLoader2,
  __webpackgi_exports__Material as Material,
  __webpackgi_exports__MaterialConfiguratorBasePlugin as MaterialConfiguratorBasePlugin,
  __webpackgi_exports__MaterialConfiguratorPlugin as MaterialConfiguratorPlugin,
  __webpackgi_exports__MaterialExtender as MaterialExtender,
  __webpackgi_exports__MaterialLibraryBasePlugin as MaterialLibraryBasePlugin,
  __webpackgi_exports__MaterialLibraryPlugin as MaterialLibraryPlugin,
  __webpackgi_exports__MaterialLoader as MaterialLoader,
  __webpackgi_exports__MaterialManager as MaterialManager,
  __webpackgi_exports__MaterialPreviewGenerator as MaterialPreviewGenerator,
  __webpackgi_exports__MathUtils as MathUtils,
  __webpackgi_exports__Matrix3 as Matrix3,
  __webpackgi_exports__Matrix4 as Matrix4,
  __webpackgi_exports__MaxEquation as MaxEquation,
  __webpackgi_exports__Mesh as Mesh,
  __webpackgi_exports__MeshBasicMaterial as MeshBasicMaterial,
  __webpackgi_exports__MeshBasicMaterial2 as MeshBasicMaterial2,
  __webpackgi_exports__MeshDepthMaterial as MeshDepthMaterial,
  __webpackgi_exports__MeshDistanceMaterial as MeshDistanceMaterial,
  __webpackgi_exports__MeshLambertMaterial as MeshLambertMaterial,
  __webpackgi_exports__MeshMatcapMaterial as MeshMatcapMaterial,
  __webpackgi_exports__MeshNormalMaterial as MeshNormalMaterial,
  __webpackgi_exports__MeshPhongMaterial as MeshPhongMaterial,
  __webpackgi_exports__MeshPhysicalMaterial as MeshPhysicalMaterial,
  __webpackgi_exports__MeshStandardMaterial as MeshStandardMaterial,
  __webpackgi_exports__MeshStandardMaterial2 as MeshStandardMaterial2,
  __webpackgi_exports__MeshToonMaterial as MeshToonMaterial,
  __webpackgi_exports__MinEquation as MinEquation,
  __webpackgi_exports__MirroredRepeatWrapping as MirroredRepeatWrapping,
  __webpackgi_exports__MixOperation as MixOperation,
  __webpackgi_exports__MultiFilterPlugin as MultiFilterPlugin,
  __webpackgi_exports__MultiplyBlending as MultiplyBlending,
  __webpackgi_exports__MultiplyOperation as MultiplyOperation,
  __webpackgi_exports__NearestFilter as NearestFilter,
  __webpackgi_exports__NearestMipMapLinearFilter as NearestMipMapLinearFilter,
  __webpackgi_exports__NearestMipMapNearestFilter as NearestMipMapNearestFilter,
  __webpackgi_exports__NearestMipmapLinearFilter as NearestMipmapLinearFilter,
  __webpackgi_exports__NearestMipmapNearestFilter as NearestMipmapNearestFilter,
  __webpackgi_exports__NeverDepth as NeverDepth,
  __webpackgi_exports__NeverStencilFunc as NeverStencilFunc,
  __webpackgi_exports__NoBlending as NoBlending,
  __webpackgi_exports__NoColorSpace as NoColorSpace,
  __webpackgi_exports__NoToneMapping as NoToneMapping,
  __webpackgi_exports__NoiseBumpMaterialPlugin as NoiseBumpMaterialPlugin,
  __webpackgi_exports__NormalAnimationBlendMode as NormalAnimationBlendMode,
  __webpackgi_exports__NormalBlending as NormalBlending,
  __webpackgi_exports__NormalCaptureMaterial as NormalCaptureMaterial,
  __webpackgi_exports__NotEqualDepth as NotEqualDepth,
  __webpackgi_exports__NotEqualStencilFunc as NotEqualStencilFunc,
  __webpackgi_exports__NumberKeyframeTrack as NumberKeyframeTrack,
  __webpackgi_exports__OBJLoader2 as OBJLoader2,
  __webpackgi_exports__ObjMtlLoadPlugin as ObjMtlLoadPlugin,
  __webpackgi_exports__Object3D as Object3D,
  __webpackgi_exports__Object3DModel as Object3DModel,
  __webpackgi_exports__ObjectLoader as ObjectLoader,
  __webpackgi_exports__ObjectLoader2 as ObjectLoader2,
  __webpackgi_exports__ObjectPicker as ObjectPicker,
  __webpackgi_exports__ObjectProcessorMap as ObjectProcessorMap,
  __webpackgi_exports__ObjectRotationPlugin as ObjectRotationPlugin,
  __webpackgi_exports__ObjectSpaceNormalMap as ObjectSpaceNormalMap,
  __webpackgi_exports__OctahedronBufferGeometry as OctahedronBufferGeometry,
  __webpackgi_exports__OctahedronGeometry as OctahedronGeometry,
  __webpackgi_exports__OneFactor as OneFactor,
  __webpackgi_exports__OneMinusDstAlphaFactor as OneMinusDstAlphaFactor,
  __webpackgi_exports__OneMinusDstColorFactor as OneMinusDstColorFactor,
  __webpackgi_exports__OneMinusSrcAlphaFactor as OneMinusSrcAlphaFactor,
  __webpackgi_exports__OneMinusSrcColorFactor as OneMinusSrcColorFactor,
  __webpackgi_exports__OrbitControls2 as OrbitControls2,
  __webpackgi_exports__OrbitControls3 as OrbitControls3,
  __webpackgi_exports__OrthographicCamera as OrthographicCamera,
  __webpackgi_exports__PCFShadowMap as PCFShadowMap,
  __webpackgi_exports__PCFSoftShadowMap as PCFSoftShadowMap,
  __webpackgi_exports__PMREMGenerator as PMREMGenerator,
  __webpackgi_exports__PMREMGeneratorPlugin as PMREMGeneratorPlugin,
  __webpackgi_exports__ParallaxMappingPlugin as ParallaxMappingPlugin,
  __webpackgi_exports__Path as Path,
  __webpackgi_exports__PerspectiveCamera as PerspectiveCamera,
  __webpackgi_exports__PickingPlugin as PickingPlugin,
  __webpackgi_exports__Plane as Plane,
  __webpackgi_exports__PlaneBufferGeometry as PlaneBufferGeometry,
  __webpackgi_exports__PlaneGeometry as PlaneGeometry,
  __webpackgi_exports__PlaneHelper as PlaneHelper,
  __webpackgi_exports__PointLight as PointLight,
  __webpackgi_exports__PointLight2 as PointLight2,
  __webpackgi_exports__PointLightHelper as PointLightHelper,
  __webpackgi_exports__PointerLockControls2 as PointerLockControls2,
  __webpackgi_exports__PointerLockControlsPlugin as PointerLockControlsPlugin,
  __webpackgi_exports__Points as Points,
  __webpackgi_exports__PointsMaterial as PointsMaterial,
  __webpackgi_exports__PolarGridHelper as PolarGridHelper,
  __webpackgi_exports__PolyhedronBufferGeometry as PolyhedronBufferGeometry,
  __webpackgi_exports__PolyhedronGeometry as PolyhedronGeometry,
  __webpackgi_exports__PopmotionPlugin as PopmotionPlugin,
  __webpackgi_exports__PositionalAudio as PositionalAudio,
  __webpackgi_exports__PresetLibraryPlugin as PresetLibraryPlugin,
  __webpackgi_exports__ProgressivePlugin as ProgressivePlugin,
  __webpackgi_exports__PropertyBinding as PropertyBinding,
  __webpackgi_exports__PropertyMixer as PropertyMixer,
  __webpackgi_exports__QuadraticBezierCurve as QuadraticBezierCurve,
  __webpackgi_exports__QuadraticBezierCurve3 as QuadraticBezierCurve3,
  __webpackgi_exports__Quaternion as Quaternion,
  __webpackgi_exports__QuaternionKeyframeTrack as QuaternionKeyframeTrack,
  __webpackgi_exports__QuaternionLinearInterpolant as QuaternionLinearInterpolant,
  __webpackgi_exports__REVISION as REVISION,
  __webpackgi_exports__RGBADepthPacking as RGBADepthPacking,
  __webpackgi_exports__RGBAFormat as RGBAFormat,
  __webpackgi_exports__RGBAIntegerFormat as RGBAIntegerFormat,
  __webpackgi_exports__RGBA_ASTC_10x10_Format as RGBA_ASTC_10x10_Format,
  __webpackgi_exports__RGBA_ASTC_10x5_Format as RGBA_ASTC_10x5_Format,
  __webpackgi_exports__RGBA_ASTC_10x6_Format as RGBA_ASTC_10x6_Format,
  __webpackgi_exports__RGBA_ASTC_10x8_Format as RGBA_ASTC_10x8_Format,
  __webpackgi_exports__RGBA_ASTC_12x10_Format as RGBA_ASTC_12x10_Format,
  __webpackgi_exports__RGBA_ASTC_12x12_Format as RGBA_ASTC_12x12_Format,
  __webpackgi_exports__RGBA_ASTC_4x4_Format as RGBA_ASTC_4x4_Format,
  __webpackgi_exports__RGBA_ASTC_5x4_Format as RGBA_ASTC_5x4_Format,
  __webpackgi_exports__RGBA_ASTC_5x5_Format as RGBA_ASTC_5x5_Format,
  __webpackgi_exports__RGBA_ASTC_6x5_Format as RGBA_ASTC_6x5_Format,
  __webpackgi_exports__RGBA_ASTC_6x6_Format as RGBA_ASTC_6x6_Format,
  __webpackgi_exports__RGBA_ASTC_8x5_Format as RGBA_ASTC_8x5_Format,
  __webpackgi_exports__RGBA_ASTC_8x6_Format as RGBA_ASTC_8x6_Format,
  __webpackgi_exports__RGBA_ASTC_8x8_Format as RGBA_ASTC_8x8_Format,
  __webpackgi_exports__RGBA_BPTC_Format as RGBA_BPTC_Format,
  __webpackgi_exports__RGBA_ETC2_EAC_Format as RGBA_ETC2_EAC_Format,
  __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format as RGBA_PVRTC_2BPPV1_Format,
  __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format as RGBA_PVRTC_4BPPV1_Format,
  __webpackgi_exports__RGBA_S3TC_DXT1_Format as RGBA_S3TC_DXT1_Format,
  __webpackgi_exports__RGBA_S3TC_DXT3_Format as RGBA_S3TC_DXT3_Format,
  __webpackgi_exports__RGBA_S3TC_DXT5_Format as RGBA_S3TC_DXT5_Format,
  __webpackgi_exports__RGBFormat as RGBFormat,
  __webpackgi_exports__RGBM16Encoding as RGBM16Encoding,
  __webpackgi_exports__RGBM16Encoding_ as RGBM16Encoding_,
  __webpackgi_exports__RGBM7Encoding as RGBM7Encoding,
  __webpackgi_exports__RGB_ETC1_Format as RGB_ETC1_Format,
  __webpackgi_exports__RGB_ETC2_Format as RGB_ETC2_Format,
  __webpackgi_exports__RGB_PVRTC_2BPPV1_Format as RGB_PVRTC_2BPPV1_Format,
  __webpackgi_exports__RGB_PVRTC_4BPPV1_Format as RGB_PVRTC_4BPPV1_Format,
  __webpackgi_exports__RGB_S3TC_DXT1_Format as RGB_S3TC_DXT1_Format,
  __webpackgi_exports__RGFormat as RGFormat,
  __webpackgi_exports__RGIntegerFormat as RGIntegerFormat,
  __webpackgi_exports__RandomizedDirectionalLight as RandomizedDirectionalLight,
  __webpackgi_exports__RandomizedDirectionalLightPlugin as RandomizedDirectionalLightPlugin,
  __webpackgi_exports__RawShaderMaterial as RawShaderMaterial,
  __webpackgi_exports__Ray as Ray,
  __webpackgi_exports__Raycaster as Raycaster,
  __webpackgi_exports__RectAreaLight as RectAreaLight,
  __webpackgi_exports__RedFormat as RedFormat,
  __webpackgi_exports__RedIntegerFormat as RedIntegerFormat,
  __webpackgi_exports__Reflector2 as Reflector2,
  __webpackgi_exports__ReinhardToneMapping as ReinhardToneMapping,
  __webpackgi_exports__RendererUiPlugin as RendererUiPlugin,
  __webpackgi_exports__RepeatWrapping as RepeatWrapping,
  __webpackgi_exports__ReplaceStencilOp as ReplaceStencilOp,
  __webpackgi_exports__ReverseSubtractEquation as ReverseSubtractEquation,
  __webpackgi_exports__Rhino3dmLoadPlugin as Rhino3dmLoadPlugin,
  __webpackgi_exports__Rhino3dmLoader2 as Rhino3dmLoader2,
  __webpackgi_exports__RingBufferGeometry as RingBufferGeometry,
  __webpackgi_exports__RingGeometry as RingGeometry,
  __webpackgi_exports__RootScene as RootScene,
  __webpackgi_exports__SETTLING_TIME as SETTLING_TIME,
  __webpackgi_exports__SRGBColorSpace as SRGBColorSpace,
  __webpackgi_exports__SSAOPlugin as SSAOPlugin,
  __webpackgi_exports__SSContactShadows as SSContactShadows,
  __webpackgi_exports__SSGIPlugin as SSGIPlugin,
  __webpackgi_exports__SSRPlugin as SSRPlugin,
  __webpackgi_exports__STLLoadPlugin as STLLoadPlugin,
  __webpackgi_exports__Scene as Scene,
  __webpackgi_exports__SceneCamerasUiPlugin as SceneCamerasUiPlugin,
  __webpackgi_exports__SceneLoopPlugin as SceneLoopPlugin,
  __webpackgi_exports__SelectionWidget as SelectionWidget,
  __webpackgi_exports__ShaderChunk as ShaderChunk,
  __webpackgi_exports__ShaderLib as ShaderLib,
  __webpackgi_exports__ShaderMaterial as ShaderMaterial,
  __webpackgi_exports__ShaderMaterial2 as ShaderMaterial2,
  __webpackgi_exports__ShaderMaterialEncodingSupport as ShaderMaterialEncodingSupport,
  __webpackgi_exports__ShaderPass2 as ShaderPass2,
  __webpackgi_exports__ShadowMapBaker as ShadowMapBaker,
  __webpackgi_exports__ShadowMaterial as ShadowMaterial,
  __webpackgi_exports__Shape as Shape,
  __webpackgi_exports__ShapeBufferGeometry as ShapeBufferGeometry,
  __webpackgi_exports__ShapeGeometry as ShapeGeometry,
  __webpackgi_exports__ShapePath as ShapePath,
  __webpackgi_exports__ShapeTubeExtrudePlugin as ShapeTubeExtrudePlugin,
  __webpackgi_exports__ShapeUtils as ShapeUtils,
  __webpackgi_exports__ShortType as ShortType,
  __webpackgi_exports__SimpleAssetList as SimpleAssetList,
  __webpackgi_exports__SimpleBackgroundEnvUiPlugin as SimpleBackgroundEnvUiPlugin,
  __webpackgi_exports__SimpleDataSource as SimpleDataSource,
  __webpackgi_exports__SimpleEventDispatcher as SimpleEventDispatcher,
  __webpackgi_exports__SimpleJSONExporter as SimpleJSONExporter,
  __webpackgi_exports__SimpleJSONLoader as SimpleJSONLoader,
  __webpackgi_exports__SimpleTextExporter as SimpleTextExporter,
  __webpackgi_exports__SimpleTextPlugin as SimpleTextPlugin,
  __webpackgi_exports__SimpleViewerUi as SimpleViewerUi,
  __webpackgi_exports__Skeleton as Skeleton,
  __webpackgi_exports__SkeletonHelper as SkeletonHelper,
  __webpackgi_exports__SkinnedMesh as SkinnedMesh,
  __webpackgi_exports__Source as Source,
  __webpackgi_exports__Sphere as Sphere,
  __webpackgi_exports__SphereBufferGeometry as SphereBufferGeometry,
  __webpackgi_exports__SphereGeometry as SphereGeometry,
  __webpackgi_exports__SphereSelectionWidget as SphereSelectionWidget,
  __webpackgi_exports__Spherical as Spherical,
  __webpackgi_exports__SphericalHarmonics3 as SphericalHarmonics3,
  __webpackgi_exports__SplineCurve as SplineCurve,
  __webpackgi_exports__SpotLight as SpotLight,
  __webpackgi_exports__SpotLight2 as SpotLight2,
  __webpackgi_exports__SpotLightHelper as SpotLightHelper,
  __webpackgi_exports__Sprite as Sprite,
  __webpackgi_exports__SpriteMaterial as SpriteMaterial,
  __webpackgi_exports__SrcAlphaFactor as SrcAlphaFactor,
  __webpackgi_exports__SrcAlphaSaturateFactor as SrcAlphaSaturateFactor,
  __webpackgi_exports__SrcColorFactor as SrcColorFactor,
  __webpackgi_exports__StaticCopyUsage as StaticCopyUsage,
  __webpackgi_exports__StaticDrawUsage as StaticDrawUsage,
  __webpackgi_exports__StaticReadUsage as StaticReadUsage,
  __webpackgi_exports__StereoCamera as StereoCamera,
  __webpackgi_exports__StreamCopyUsage as StreamCopyUsage,
  __webpackgi_exports__StreamDrawUsage as StreamDrawUsage,
  __webpackgi_exports__StreamReadUsage as StreamReadUsage,
  __webpackgi_exports__StringKeyframeTrack as StringKeyframeTrack,
  __webpackgi_exports__SubtractEquation as SubtractEquation,
  __webpackgi_exports__SubtractiveBlending as SubtractiveBlending,
  __webpackgi_exports__SwitchNodePlugin as SwitchNodePlugin,
  __webpackgi_exports__TOUCH as TOUCH,
  __webpackgi_exports__TangentSpaceNormalMap as TangentSpaceNormalMap,
  __webpackgi_exports__TemporalAAPlugin as TemporalAAPlugin,
  __webpackgi_exports__TetrahedronBufferGeometry as TetrahedronBufferGeometry,
  __webpackgi_exports__TetrahedronGeometry as TetrahedronGeometry,
  __webpackgi_exports__TextSVGOptions as TextSVGOptions,
  __webpackgi_exports__Texture as Texture,
  __webpackgi_exports__TextureLoader as TextureLoader,
  __webpackgi_exports__ThinFilmLayerPlugin as ThinFilmLayerPlugin,
  __webpackgi_exports__ThreeMaterialLoader as ThreeMaterialLoader,
  __webpackgi_exports__TonemapPlugin as TonemapPlugin,
  __webpackgi_exports__TorusBufferGeometry as TorusBufferGeometry,
  __webpackgi_exports__TorusGeometry as TorusGeometry,
  __webpackgi_exports__TorusKnotBufferGeometry as TorusKnotBufferGeometry,
  __webpackgi_exports__TorusKnotGeometry as TorusKnotGeometry,
  __webpackgi_exports__TransformControls2 as TransformControls2,
  __webpackgi_exports__Triangle as Triangle,
  __webpackgi_exports__TriangleFanDrawMode as TriangleFanDrawMode,
  __webpackgi_exports__TriangleStripDrawMode as TriangleStripDrawMode,
  __webpackgi_exports__TrianglesDrawMode as TrianglesDrawMode,
  __webpackgi_exports__TubeBufferGeometry as TubeBufferGeometry,
  __webpackgi_exports__TubeGeometry as TubeGeometry,
  __webpackgi_exports__TubeShapeGeometry as TubeShapeGeometry,
  __webpackgi_exports__TweakpaneUiPlugin as TweakpaneUiPlugin,
  __webpackgi_exports__TweakpaneWrapper as TweakpaneWrapper,
  __webpackgi_exports__UVMapping as UVMapping,
  __webpackgi_exports__Uint16BufferAttribute as Uint16BufferAttribute,
  __webpackgi_exports__Uint32BufferAttribute as Uint32BufferAttribute,
  __webpackgi_exports__Uint8BufferAttribute as Uint8BufferAttribute,
  __webpackgi_exports__Uint8ClampedBufferAttribute as Uint8ClampedBufferAttribute,
  __webpackgi_exports__Uncharted2Tonemapping as Uncharted2Tonemapping,
  __webpackgi_exports__Uniform as Uniform,
  __webpackgi_exports__UniformsGroup as UniformsGroup,
  __webpackgi_exports__UniformsLib as UniformsLib,
  __webpackgi_exports__UniformsUtils as UniformsUtils,
  __webpackgi_exports__UnsignedByteType as UnsignedByteType,
  __webpackgi_exports__UnsignedInt248Type as UnsignedInt248Type,
  __webpackgi_exports__UnsignedIntType as UnsignedIntType,
  __webpackgi_exports__UnsignedShort4444Type as UnsignedShort4444Type,
  __webpackgi_exports__UnsignedShort5551Type as UnsignedShort5551Type,
  __webpackgi_exports__UnsignedShortType as UnsignedShortType,
  __webpackgi_exports__Unzip as Unzip,
  __webpackgi_exports__UnzipInflate as UnzipInflate,
  __webpackgi_exports__UnzipPassThrough as UnzipPassThrough,
  __webpackgi_exports__Unzlib as Unzlib,
  __webpackgi_exports__VSMShadowMap as VSMShadowMap,
  __webpackgi_exports__Vector2 as Vector2,
  __webpackgi_exports__Vector3 as Vector3,
  __webpackgi_exports__Vector4 as Vector4,
  __webpackgi_exports__VectorKeyframeTrack as VectorKeyframeTrack,
  __webpackgi_exports__VelocityBufferPlugin as VelocityBufferPlugin,
  __webpackgi_exports__VideoTexture as VideoTexture,
  __webpackgi_exports__ViewerApp as ViewerApp,
  __webpackgi_exports__ViewerState as ViewerState,
  __webpackgi_exports__VignettePlugin as VignettePlugin,
  __webpackgi_exports__WebGL1Renderer as WebGL1Renderer,
  __webpackgi_exports__WebGL3DRenderTarget as WebGL3DRenderTarget,
  __webpackgi_exports__WebGLArrayRenderTarget as WebGLArrayRenderTarget,
  __webpackgi_exports__WebGLCubeRenderTarget as WebGLCubeRenderTarget,
  __webpackgi_exports__WebGLMultipleRenderTargets as WebGLMultipleRenderTargets,
  __webpackgi_exports__WebGLMultisampleRenderTarget as WebGLMultisampleRenderTarget,
  __webpackgi_exports__WebGLRenderTarget as WebGLRenderTarget,
  __webpackgi_exports__WebGLRenderer as WebGLRenderer,
  __webpackgi_exports__WebGLUtils as WebGLUtils,
  __webpackgi_exports__WebGiViewerElement as WebGiViewerElement,
  __webpackgi_exports__WindowiseDialogPlugin as WindowiseDialogPlugin,
  __webpackgi_exports__WireframeGeometry as WireframeGeometry,
  __webpackgi_exports__WrapAroundEnding as WrapAroundEnding,
  __webpackgi_exports__ZeroCurvatureEnding as ZeroCurvatureEnding,
  __webpackgi_exports__ZeroFactor as ZeroFactor,
  __webpackgi_exports__ZeroSlopeEnding as ZeroSlopeEnding,
  __webpackgi_exports__ZeroStencilOp as ZeroStencilOp,
  __webpackgi_exports__Zip as Zip,
  __webpackgi_exports__ZipDeflate as ZipDeflate,
  __webpackgi_exports__ZipLoader as ZipLoader,
  __webpackgi_exports__ZipPassThrough as ZipPassThrough,
  __webpackgi_exports__Zlib as Zlib,
  __webpackgi_exports___SRGBAFormat as _SRGBAFormat,
  __webpackgi_exports__addBasePlugins as addBasePlugins,
  __webpackgi_exports__addDracoLoader as addDracoLoader,
  __webpackgi_exports__addGLTFExporter as addGLTFExporter,
  __webpackgi_exports__addGLTFLoader as addGLTFLoader,
  __webpackgi_exports__addRGBELoader as addRGBELoader,
  __webpackgi_exports__addZipLoader as addZipLoader,
  __webpackgi_exports__afterMain as afterMain,
  __webpackgi_exports__afterRead as afterRead,
  __webpackgi_exports__afterWrite as afterWrite,
  __webpackgi_exports__angle as angle,
  __webpackgi_exports__animate as animate,
  __webpackgi_exports__animateAsync as animateAsync,
  __webpackgi_exports__animateObject as animateObject,
  __webpackgi_exports__animatePromise as animatePromise,
  __webpackgi_exports__animateSet as animateSet,
  __webpackgi_exports__animateTarget as animateTarget,
  __webpackgi_exports__anticipate as anticipate,
  __webpackgi_exports__applyOffset as applyOffset,
  __webpackgi_exports__applyStyles as applyStyles,
  __webpackgi_exports__arrow as arrow,
  __webpackgi_exports__attract as attract,
  __webpackgi_exports__attractExpo as attractExpo,
  __webpackgi_exports__auto as auto,
  __webpackgi_exports__autoCenterObject3D as autoCenterObject3D,
  __webpackgi_exports__autoScaleObject3D as autoScaleObject3D,
  __webpackgi_exports__backIn as backIn,
  __webpackgi_exports__backInOut as backInOut,
  __webpackgi_exports__backOut as backOut,
  __webpackgi_exports__basePlacements as basePlacements,
  __webpackgi_exports__basicMaterialPropList as basicMaterialPropList,
  __webpackgi_exports__beforeMain as beforeMain,
  __webpackgi_exports__beforeRead as beforeRead,
  __webpackgi_exports__beforeWrite as beforeWrite,
  __webpackgi_exports__blobToDataURL as blobToDataURL,
  __webpackgi_exports__bottom as bottom,
  __webpackgi_exports__bounceIn as bounceIn,
  __webpackgi_exports__bounceInOut as bounceInOut,
  __webpackgi_exports__bounceOut as bounceOut,
  __webpackgi_exports__buildCSGMeshBSP as buildCSGMeshBSP,
  __webpackgi_exports__buildCSGMeshBVH as buildCSGMeshBVH,
  __webpackgi_exports__cLinearToRGBM as cLinearToRGBM,
  __webpackgi_exports__cRGBMToLinear as cRGBMToLinear,
  __webpackgi_exports__circIn as circIn,
  __webpackgi_exports__circInOut as circInOut,
  __webpackgi_exports__circOut as circOut,
  __webpackgi_exports__clamp as clamp,
  __webpackgi_exports__clippingParents as clippingParents,
  __webpackgi_exports__combineDofShader as combineDofShader,
  __webpackgi_exports__compress as compress,
  __webpackgi_exports__compressSync as compressSync,
  __webpackgi_exports__computeAverageGeometryNormal as computeAverageGeometryNormal,
  __webpackgi_exports__computeEigenVectors as computeEigenVectors,
  __webpackgi_exports__computeGeometryCenter as computeGeometryCenter,
  __webpackgi_exports__computeGeometrySize as computeGeometrySize,
  __webpackgi_exports__computeOffsetMatrix as computeOffsetMatrix,
  __webpackgi_exports__computeScreenSpaceBoundingBox as computeScreenSpaceBoundingBox,
  __webpackgi_exports__computeStyles as computeStyles,
  __webpackgi_exports__copyMaterialUserData as copyMaterialUserData,
  __webpackgi_exports__copyObject3DUserData as copyObject3DUserData,
  __webpackgi_exports__copyProps as copyProps,
  __webpackgi_exports__copyTextureUserData as copyTextureUserData,
  __webpackgi_exports__createAnticipate as createAnticipate,
  __webpackgi_exports__createAttractor as createAttractor,
  __webpackgi_exports__createBackIn as createBackIn,
  __webpackgi_exports__createCanvasElement as createCanvasElement,
  __webpackgi_exports__createDiv as createDiv,
  __webpackgi_exports__createExpoIn as createExpoIn,
  __webpackgi_exports__createIFrameCSS3DObject as createIFrameCSS3DObject,
  __webpackgi_exports__createImage as createImage,
  __webpackgi_exports__createPopper as createPopper,
  __webpackgi_exports__createPopperBase as createPopperBase,
  __webpackgi_exports__createPopperLite as createPopperLite,
  __webpackgi_exports__createRenderTargetKey as createRenderTargetKey,
  __webpackgi_exports__createScriptFromURL as createScriptFromURL,
  __webpackgi_exports__createStyles as createStyles,
  __webpackgi_exports__csgOperations as csgOperations,
  __webpackgi_exports__css as css,
  __webpackgi_exports__cubicBezier as cubicBezier,
  __webpackgi_exports__dataTextureFromColor as dataTextureFromColor,
  __webpackgi_exports__dataTextureFromVec4 as dataTextureFromVec4,
  __webpackgi_exports__decay as decay,
  __webpackgi_exports__decompress as decompress,
  __webpackgi_exports__decompressSync as decompressSync,
  __webpackgi_exports__deepAccessObject as deepAccessObject,
  __webpackgi_exports__deflate as deflate,
  __webpackgi_exports__deflateSync as deflateSync,
  __webpackgi_exports__degreesToRadians as degreesToRadians,
  __webpackgi_exports__deserializeObject as deserializeObject,
  __webpackgi_exports__deserializers as deserializers,
  __webpackgi_exports__detectOverflow as detectOverflow,
  __webpackgi_exports__diamondMaterialPropList as diamondMaterialPropList,
  __webpackgi_exports__distance as distance,
  __webpackgi_exports__downloadBlob as downloadBlob,
  __webpackgi_exports__downloadFile as downloadFile,
  __webpackgi_exports__easeIn as easeIn,
  __webpackgi_exports__easeInOut as easeInOut,
  __webpackgi_exports__easeOut as easeOut,
  __webpackgi_exports__embedUrlRefs as embedUrlRefs,
  __webpackgi_exports__end as end,
  __webpackgi_exports__envMapBackground as envMapBackground,
  __webpackgi_exports__escapeRegExp as escapeRegExp,
  __webpackgi_exports__eventListeners as eventListeners,
  __webpackgi_exports__extractAnimationKey as extractAnimationKey,
  __webpackgi_exports__flattenUiConfig as flattenUiConfig,
  __webpackgi_exports__flip as flip,
  __webpackgi_exports__fontFormatExtensionMap as fontFormatExtensionMap,
  __webpackgi_exports__generateUiConfig as generateUiConfig,
  __webpackgi_exports__generateUiFolder as generateUiFolder,
  __webpackgi_exports__getEncodingComponents as getEncodingComponents,
  __webpackgi_exports__getFilenameFromPath as getFilenameFromPath,
  __webpackgi_exports__getKeyByValue as getKeyByValue,
  __webpackgi_exports__getOrCall as getOrCall,
  __webpackgi_exports__getPropertyDescriptor as getPropertyDescriptor,
  __webpackgi_exports__getTexelDecoding as getTexelDecoding,
  __webpackgi_exports__getTexelDecoding2 as getTexelDecoding2,
  __webpackgi_exports__getTexelDecodingFunction as getTexelDecodingFunction,
  __webpackgi_exports__getTexelEncoding as getTexelEncoding,
  __webpackgi_exports__getTexelEncodingFunction as getTexelEncodingFunction,
  __webpackgi_exports__getTextureDataType as getTextureDataType,
  __webpackgi_exports__getTextureEncodingFromMap as getTextureEncodingFromMap,
  __webpackgi_exports__getUrlQueryParam as getUrlQueryParam,
  __webpackgi_exports__glsl as glsl,
  __webpackgi_exports__gunzip as gunzip,
  __webpackgi_exports__gunzipSync as gunzipSync,
  __webpackgi_exports__gzip as gzip,
  __webpackgi_exports__gzipSync as gzipSync,
  __webpackgi_exports__hide as hide,
  __webpackgi_exports__html as html,
  __webpackgi_exports__htmlToCanvas as htmlToCanvas,
  __webpackgi_exports__htmlToPng as htmlToPng,
  __webpackgi_exports__htmlToSvg as htmlToSvg,
  __webpackgi_exports__iGeometryIgnoredUserData as iGeometryIgnoredUserData,
  __webpackgi_exports__iMaterialIgnoredUserData as iMaterialIgnoredUserData,
  __webpackgi_exports__iModelIgnoredUserData as iModelIgnoredUserData,
  __webpackgi_exports__iTextureIgnoredUserData as iTextureIgnoredUserData,
  __webpackgi_exports__imageBitmapToBase64 as imageBitmapToBase64,
  __webpackgi_exports__imageToCanvas as imageToCanvas,
  __webpackgi_exports__imageUrlToImageData as imageUrlToImageData,
  __webpackgi_exports__includesAll as includesAll,
  __webpackgi_exports__inertia as inertia,
  __webpackgi_exports__inflate as inflate,
  __webpackgi_exports__inflateSync as inflateSync,
  __webpackgi_exports__interpolate as interpolate,
  __webpackgi_exports__isAnimatableType as isAnimatableType,
  __webpackgi_exports__isPoint as isPoint,
  __webpackgi_exports__isPoint3D as isPoint3D,
  __webpackgi_exports__isPropertyWritable as isPropertyWritable,
  __webpackgi_exports__keyframes as keyframes,
  __webpackgi_exports__left as left,
  __webpackgi_exports__lerpAngle as lerpAngle,
  __webpackgi_exports__lerpAngle2 as lerpAngle2,
  __webpackgi_exports__linear as linear,
  __webpackgi_exports__main as main,
  __webpackgi_exports__makeColorSvg as makeColorSvg,
  __webpackgi_exports__makeColorSvgCircle as makeColorSvgCircle,
  __webpackgi_exports__makeFilter as makeFilter,
  __webpackgi_exports__makeSamplerUi as makeSamplerUi,
  __webpackgi_exports__makeSetterFor as makeSetterFor,
  __webpackgi_exports__makeSetterForAnimObject as makeSetterForAnimObject,
  __webpackgi_exports__makeTextSvg as makeTextSvg,
  __webpackgi_exports__matDefine as matDefine,
  __webpackgi_exports__mirrorEasing as mirrorEasing,
  __webpackgi_exports__mix as mix,
  __webpackgi_exports__mixColor as mixColor,
  __webpackgi_exports__mixComplex as mixComplex,
  __webpackgi_exports__mobileAndTabletCheck as mobileAndTabletCheck,
  __webpackgi_exports__modifierPhases as modifierPhases,
  __webpackgi_exports__now as now,
  __webpackgi_exports__offset as offset,
  __webpackgi_exports__onChange as onChange,
  __webpackgi_exports__parseFileExtension as parseFileExtension,
  __webpackgi_exports__patchShaderEncodingSupport as patchShaderEncodingSupport,
  __webpackgi_exports__pathJoin as pathJoin,
  __webpackgi_exports__physicalMaterialPropList as physicalMaterialPropList,
  __webpackgi_exports__pipe as pipe,
  __webpackgi_exports__placements as placements,
  __webpackgi_exports__pointFromVector as pointFromVector,
  __webpackgi_exports__popper as popper,
  __webpackgi_exports__popperGenerator as popperGenerator,
  __webpackgi_exports__popperOffsets as popperOffsets,
  __webpackgi_exports__preventOverflow as preventOverflow,
  __webpackgi_exports__processViewer as processViewer,
  __webpackgi_exports__progress as progress,
  __webpackgi_exports__radiansToDegrees as radiansToDegrees,
  __webpackgi_exports__read as read,
  __webpackgi_exports__reference as reference,
  __webpackgi_exports__removeDuplicateGeometries as removeDuplicateGeometries,
  __webpackgi_exports__replaceAll as replaceAll,
  __webpackgi_exports__reverseEasing as reverseEasing,
  __webpackgi_exports__right as right,
  __webpackgi_exports__rotateDuplicatedMesh as rotateDuplicatedMesh,
  __webpackgi_exports__sRGBEncoding as sRGBEncoding,
  __webpackgi_exports__safeSetProperty as safeSetProperty,
  __webpackgi_exports__serializable as serializable,
  __webpackgi_exports__serialize as serialize,
  __webpackgi_exports__serializeObject as serializeObject,
  __webpackgi_exports__serializers as serializers,
  __webpackgi_exports__setMeshGeometry as setMeshGeometry,
  __webpackgi_exports__setMeshMaterial as setMeshMaterial,
  __webpackgi_exports__setThreeRendererMode as setThreeRendererMode,
  __webpackgi_exports__setUrlQueryParam as setUrlQueryParam,
  __webpackgi_exports__setupCoreWebGiViewer as setupCoreWebGiViewer,
  __webpackgi_exports__setupIModel as setupIModel,
  __webpackgi_exports__setupObject3dModel as setupObject3dModel,
  __webpackgi_exports__setupSandboxWebGiEditor as setupSandboxWebGiEditor,
  __webpackgi_exports__shaderReplaceString as shaderReplaceString,
  __webpackgi_exports__slerp as slerp,
  __webpackgi_exports__smooth as smooth,
  __webpackgi_exports__smoothFrame as smoothFrame,
  __webpackgi_exports__snap as snap,
  __webpackgi_exports__snapObject as snapObject,
  __webpackgi_exports__sphericalFromObject as sphericalFromObject,
  __webpackgi_exports__spring as spring,
  __webpackgi_exports__standardMaterialPropList as standardMaterialPropList,
  __webpackgi_exports__start as start,
  __webpackgi_exports__steps as steps,
  __webpackgi_exports__strFromU8 as strFromU8,
  __webpackgi_exports__strToU8 as strToU8,
  __webpackgi_exports__svgToCanvas as svgToCanvas,
  __webpackgi_exports__svgToPng as svgToPng,
  __webpackgi_exports__svgUrl as svgUrl,
  __webpackgi_exports__syncAnimSetUi as syncAnimSetUi,
  __webpackgi_exports__timeout as timeout,
  __webpackgi_exports__toDecimal as toDecimal,
  __webpackgi_exports__toIndexedGeometry as toIndexedGeometry,
  __webpackgi_exports__toTitleCase as toTitleCase,
  __webpackgi_exports__top as top,
  __webpackgi_exports__uiButton as uiButton,
  __webpackgi_exports__uiColor as uiColor,
  __webpackgi_exports__uiConfig as uiConfig,
  __webpackgi_exports__uiDropdown as uiDropdown,
  __webpackgi_exports__uiFolder as uiFolder,
  __webpackgi_exports__uiImage as uiImage,
  __webpackgi_exports__uiInput as uiInput,
  __webpackgi_exports__uiMonitor as uiMonitor,
  __webpackgi_exports__uiSlider as uiSlider,
  __webpackgi_exports__uiToggle as uiToggle,
  __webpackgi_exports__uiVector as uiVector,
  __webpackgi_exports__uniform as uniform,
  __webpackgi_exports__unzip as unzip,
  __webpackgi_exports__unzipSync as unzipSync,
  __webpackgi_exports__unzlib as unzlib,
  __webpackgi_exports__unzlibSync as unzlibSync,
  __webpackgi_exports__uploadFile as uploadFile,
  __webpackgi_exports__vLinearToRGBM as vLinearToRGBM,
  __webpackgi_exports__vRGBMToLinear as vRGBMToLinear,
  __webpackgi_exports__variationPlacements as variationPlacements,
  __webpackgi_exports__velocityPerFrame as velocityPerFrame,
  __webpackgi_exports__velocityPerSecond as velocityPerSecond,
  __webpackgi_exports__verifyPermission as verifyPermission,
  __webpackgi_exports__viewerGLTFExtension as viewerGLTFExtension,
  __webpackgi_exports__viewport as viewport,
  __webpackgi_exports__webgiLightExtrasExtension as webgiLightExtrasExtension,
  __webpackgi_exports__webgiMaterialExtrasExtension as webgiMaterialExtrasExtension,
  __webpackgi_exports__webgiObject3DExtrasExtension as webgiObject3DExtrasExtension,
  __webpackgi_exports__wrap as wrap,
  __webpackgi_exports__write as write,
  __webpackgi_exports__writeFile as writeFile,
  __webpackgi_exports__zip as zip,
  __webpackgi_exports__zipSync as zipSync,
  __webpackgi_exports__zlib as zlib,
  __webpackgi_exports__zlibSync as zlibSync
};
/*! Bundled license information:

webgi/dist/examples/runtime/bundle.m.js:
  (*! For license information please see bundle.m.js.LICENSE.txt *)
*/
//# sourceMappingURL=webgi.js.map
